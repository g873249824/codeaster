

-----------------------------------------------------------------------
--- AUTEUR cibhhlv L.VIVAN   DATE  le 30/08/2004 a 15:17:39

--------------------------------------------------------------------------
CORRECTION AL 2004-295
   INTERET_UTILISATEUR : NON
   NB_JOURS_TRAV  : 0.0
   POUR_LE_COMPTE_DE   : J.P.LEFEBVRE
   TITRE :   mot clé FICHIER dans sdnv102a.com0
   FONCTIONNALITE :
     mise à jour du cas test
   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION

--------------------------------------------------------------------------
REALISATION EL 2002-107
   NB_JOURS_TRAV  : 0.5
   POUR_LE_COMPTE_DE   : N.SELLALI
   INTERET_UTILISATEUR : NON
   TITRE  le cas test ssnv158 possede une solution de refrence
   FONCTIONNALITE
     Ce test est un test de non regression. Néanmoins, les résultats
     obtenus ont été post-traités avec Excel et comparés avec les
     résultats du logiciel FLAC-2D.

   RESU_FAUX_VERSION_EXPLOITATION    : NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   : NON
   RESTITUTION_VERSION_EXPLOITATION  : NON
   RESTITUTION_VERSION_DEVELOPPEMENT : OUI
   VALIDATION
   IMPACT_DOCUMENTAIRE : OUI
     DOC_V : V6.04.158
      EXPL_ : modif résultats de la modélisation D (voir AL2002-246)

--------------------------------------------------------------------------
CLASSEMENT SANS SUITE AL 2004-264
   INTERET_UTILISATEUR : OUI
   NB_JOURS_TRAV  : 1.5
   POUR_LE_COMPTE_DE   : A.ASSIRE
   TITRE :  POST_RELEVE_T ou IMPR_TABLE
   FONCTIONNALITE :
   Description de l'anomalie:
   --------------------------
     Il s'agit d'un dépouillement sur deux groupes de noeuds qui sont
     sensés avoir la meme taille
     MAILMEC=DEFI_GROUP(reuse =MAILMEC,
                   MAILLAGE=MAILMEC,
                   CREA_GROUP_NO=(_F( DIFFE=('SCB','PTCOMMUN',),
                                      NOM='SCBCONT',),
                                  _F( DIFFE=('SCP','PTCOMMUN',),
                                      NOM='SCPCONT',),),);
               --------------------------------------
               ! NOM DU GROUPE ! NBRE DE NOEUDS DU  !
               !    NOEUDS     !      GROUPE_NO     !
               --------------------------------------
               !  SCBCONT      !       773          !
               !  SCPCONT      !       773          !
               --------------------------------------
     or :
     1) on n'obtient pas le meme nombre de noeuds (ou lignes) dans les
        deux tables (elles devraient etre identiques)
     2) on n'obtient pas non plus le nombre de noeuds (ou lignes) indiqués
        en sortie du DEFI_GROUP qui cree ces deux groupes en début de fichier.

     JSCP=POST_RELEVE_T(ACTION=_F( INTITULE='jeuSCP',
                                   GROUP_NO='SCPCONT',
                                   RESULTAT=RESANN1,
                                   NOM_CHAM='VALE_CONT',
                                   NOM_CMP='JEU',
                                   OPERATION='EXTRACTION',),);
     dans la table JSCP, on a 247 noeuds

     JSCB=POST_RELEVE_T(ACTION=_F( INTITULE='jeuSCP',
                                   GROUP_NO='SCBCONT',
                                   RESULTAT=RESANN1,
                                   NOM_CHAM='VALE_CONT',
                                   NOM_CMP='JEU',
                                   OPERATION='EXTRACTION',),);
     dans la table JSCP, on a 77 noeuds

   Réponse:
   --------
   Le champ VALE_CONT s'appuie sur les noeuds sommets des mailles ESCLAVES.
   Dans le cas de l'étude :
      315 noeuds sommets (SCP) - 68 noeuds de bord (PTCOMMUN) = 247 noeuds

   L'IMPR_RESU du champ VALE_CONT imprime 247 noeuds.

   Le group_no SCPCONT conteint 773 noeuds dont 247 noeuds sommets.
   Le POST_RELEVE_T sur SCPCONT traite bien les 247 noeuds.

   Il y a 77 noeuds communs entre le group_no SCBCONT et les noeuds du
   champ VALE_CONT.
   Le POST_RELEVE_T sur SCBCONT traite bien les 77 noeuds.

   Il n'y a aucune anomalie due au code. Comme le signale la doc R5.03.51
   le champ VALE_CONT s'appuie sur les noeuds sommets des mailles esclaves.
   Peut-etre faut-il le préciser dans une autre doc.

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  NON
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION


-----------------------------------------------------------------------
--- AUTEUR jmbhh01 J.M.PROIX   DATE  le 31/08/2004 a 08:00:13

--------------------------------------------------------------------------
CORRECTION AL 2004-143
   INTERET_UTILISATEUR : OUI
   NB_JOURS_TRAV  : 6
   TITRE  Convergence trop lente des éléments GRILLE en non linéaire
   FONCTIONNALITE
   Problème constaté :
   -------------------
   En utilisant une modélisation GRILLE au lieu de GRILLE_MEMBRANE sur
   le test SSNS105A, Pierre s'est aperçu que meme en linéaire, il fallait
   plusieurs itérations pour converger. On convergeait toutefois vers la
   bonne solution.

   Effectivement, en essayant cette manip (STAT_NON_LINE avec comportement
   élastique) sur d'autres tests (SSNS100, SSLS109), je me suis convaincu
   qu'il y avait un problème de convergence. Cela pouvait provenir soit de
   la rigidité, soit du calcul des contraintes ou des forces nodales.

   Cela se produisait notamment quand le repère local n'était pas confondu
   avec le repère global (c'est tout l'intérêt du test de Pierre), et ne
   se produisait plus si on enlevait les termes de flexion propre.

   Les changements de repère étaient suspects : je les ai donc
   remplacées par des routines classiques, utilisées sur les DKT, qui, elles,
   fonctionnent.

   Au passage, j'ai suspecté un moment les DKT d'avoir les memes
   symptomes : non convergence dès la prédiction (itération 0) en linéaire.
   En regardant K.U et BtSIGMA, la seule différence vient de la rigidité
   fictive de rotation autour de la normale à l'élémet DKT. Il suffit donc
   de preciser COEF_RIGI_DRZ=0 dans AFFE_CARA_ELEM pour que la convergence
   soit parfaite. Les DKT sont donc OK.

   Corrections effectuées :
   ------------------------
   Retour aux grilles : le changement de repère utlisé pour la
   rigidité tangente, n'était pas le meme que pour les forces nodales.
   En faisant le ménage des routines de rotation, on obtient une convergence
   parfaite sur SSNS100 (thermoplasticité), et sur le test de Pierre (futur SSNS105C)

   Par contre sur le seul test de grille excentrée, SSLS109, ce n'était pas
   encore bon.  En effet, on ne calculait pas pour BtSigma les termes de moments
   dus a l'excentrement. En les ajoutant,  cela converge dès la prédiction en linéaire,
   et tous les tests de grille passent.

   Une autre modification des grilles : je supprime la rigidité dite de rotation propre,
   qui correspond à la rotation dans le plan de la grille. En effet, dans STAT_NON_LINE,
   on calcule les contraintes dans les grilles en une seule couche, et avec un seul pôint
   d'intégration dans l'épaisseur. Avec si peu de points, je ne vois pas (hors excentrement)
   comment intégrer les contraintes pour calculer des moments... En pratique, il faut vérifier
   que cette simplification est licite (la grille en participe pas à la rigidité de flexion
   de la plaque de béton armé si elle est sur la surface moyenne).

   Ceci peut toutefois conduire à bloquer systématiquement les ddl de rotation des
   grilles, pour des cas très simple où il n'y a que des grilles.

   De meme pour les GRILLES : FORC_NODA et SIEF_ELNO_ELGA utilisaient en entrée le champ de
   déplacements (!) pour calculer les moments de façon linéaire : faux en non linéaire ..
   Je corrige ce point, en intégrant les contraintes dans l'épaisseur de la meme façon que
   dans les options FULL_MECA, RAPH_MECA.

   Problèmes qui subsistent :
   --------------------------
   Au passage les DKT avec excentrement présentent des résultats faux pour les FORC_NODA :
   l'équilibre n'est pas vérifié (cf AL2002-047). J'émets donc une erreur fatale si on
   tente de calculer FORC_NODA ou SIEF_ELNO_ELGA et que l'excentrement n'est pas nul.
   De plus dans STAT_NON_LINE, on ne prenait pas en compte l'excentrement des DKT
   (et on continuait le calcul) : j'arrete le calcul dans ce cas.

   Validation :
   ------------
   Pour valider l'opération, je restitue la nouvelle modélisation C de
   SSNS105 qui teste un cube de béton avec une grille inclinée : les deux premières
   modélisations sont en grille_membrane.

   On restitue aussi une nouvelle modélisation (C) de SSLS109, qui permet de comparer
   les solutions obtenues d'une part en  grilles avec stat_non_line et meca_statique
   et d'autre part en modélisation DKT avec excentrement. Contrairement aux modélisations
   A et B, on sollicite la plaque en flexion. La plaque centrale (béton) engloble les deux
   nappes d'armatures. les résultats (déplacements) diffèrent de moins de 1% entre DKT+EXCENTREMENT
   et GRILLE (MECA_STATIQUE ou STAT_NON_LINE), car on a choisi des épaisseurs de grilles très petites
   afin que la rigidité de flexion propre soit négligeable.
   Sans surcharge, on obtient les memes valeurs, mais on converge en 2 itérations.

   Du fait de la suppression de la rigidité de flexion propre, les resultats du SSLS109B sont NOOK
   (comparaison avec SSNL109A : DEFI_COQU_MULT). Je modifie donc les valeurs de référence de la
   modelisations B, qui ne s'appuient plus sur celles de la modelisation A.
   (différences de l'ordre 20% en moyenne)

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : OUI
     DOC_V : V3.03.109
     DOC_V : V6.05.105
     DOC_R : R5.03.09
   VALIDATION
     SSNS105C, SSL109C
   DETAILS
   Modifications dans DKTNLI (qui gère aussi les grilles, mais avec plusieurs blocs
   if specifiques) : calcul spécifique de BTSIG et des moments en tenant compte de l'excentrement,
   cf la doc R de l'excentrement, R3.07.06.   Un jour on pourra inclure (et mutualiser) la
   programmation des DKT avec excentrement a cet endroit (réflexion théorique préalable !).

   Modifications dans DXMATE : on vire les coefficients 1.D-7 pour le calcul de
   la rigidité fictive de rotation autour de la normale, et on lit à la place la
   valeur fournie par l'utilisateur sous COEF_RIGI_DRZ. Au passage, il y a 4 routines
   de calcul des opérateurs d'élasticité pour les DKT et grilles : DXMATE, DXMATH,
   DMATEL, DMATHL. Un petit ménage à prévoir ? On vire la rigidite de flexion propre (mais on laisse
   bien sûr celle liée à l'excentrement).

   Modifications dans NMGRIL :utilisation des routines de changement de repère
   des DKT pour passer les déformations et contraintes initiales du repère
    intrinsèque de l'élément au repère matériau (défini par ANGL_REP),
    dont la première direction est la seule active : DXREPE,
   DXSIRO, puis après calcul du comportement uniaxial (NMCO1D), DXSIRO pour passer
   les contraintes du repère matériau au repère de l'élément, et UTBTAB pour
   l'opérateur tangent.

   Modifs de TE0341 : pour pouvoir utiliser les GRILLE_MEMBRANE en linéaire, avec
   MECA_STATIQUE, je ne l'oblige plus à lire le comportement.

   Au passage je réunis les routines DXEFFI et DXEFF2 qui font la meme chose : la seule différence
   vient du stockage des forces sur 6 ou 8 composantes. Je passe un argument qui correspond à ce
   choix. Je supprime donc DXEFF2. Je supprime aussi DXELAS qui n'est appelé par aucune routine.

--------------------------------------------------------------------------
REALISATION EL 2004-173
   INTERET_UTILISATEUR : NON
   NB_JOURS_TRAV  : 0.5
   TITRE   RESORPTION HSLP300 ET SSLP302
   FONCTIONNALITE
    Ces tests n'ont jamais été publiés.
    - HSLP300A arche circulaire épaisse sous chargement thermique : la solution de
    référence (NAFEMS) est obtenue avec un maillage particulier, en des points où
    les contraintes sont extrapolées. les résultats ne sont pas très proches de la
    référence,(6% d'écart) et on ne peut pas raffiner le maillage.
    De, plus la thermoélasticité plane est testée dans HPLP100, HPLP311 par exemple.
    - SSLP302A,B,C plaque en porte a faux sous poids propre, modélisé en D_PLAN :
    Les résultats sont éloignés de la solution de référence (9,2% pour les dépl)
    La pesanteur est testée dans SSLP100, SSLP102 par exemple.
    Les forces internes sont testées dans SSLP102, SSLP301 par exemple.
    D_PLAN_INCO st testé dans SSLP106B, SSLV130C.

    Je propose donc de les résorber ces deux tests.

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION

--------------------------------------------------------------------------
REALISATION EL 2003-074
   INTERET_UTILISATEUR : OUI
   NB_JOURS_TRAV  : 1.5
   TITRE   Verif de l'état initial de STAT_NON_LINE
   FONCTIONNALITE
    Plusieurs AL (2003-008 par exemple) ont montré que des utilisateur
    meme avertis pouvaient obtenir des résultats faux avec COMP_INCR
    à cause d'un état initial où les températures ne sont pas égales à
    la température de référence.
    Dans l'AL 2003-008 , cela entrainait une dépendance de G par
    rapport à la couronne, il n'était donc pas évident de remonter à
    la source du problème.

    Pour éviter ce risque,je propose une vérification de l'état initial
    donné par l'utilisateur de STAT_NON_LINE :
    on fait le calcul du second membre correspondant aux variables de
    commande à l'instant initial et on calcule sa norme.
    Si celle ci est différente de 0 (à RESI_GLOB_RELA près) on alarme.

    Après passage de la liste complète (sauf les YYYY), deux tests ont des
    alarmes :

    FORMA09B : c'est logique, puisque l'un des calculs consiste justement à
    montrer la différence entre un calcul incrémental avec un mauvais état
    initial et un calcul correct.

    TTNL03A : là par contre... Il y a  un calcul d'hydratation avec THER_NON_LINE
    puis deux calculs mécanique, l'un avec STAT_NON_LINE, l'autre avec
    MECA_STATIQUE. La température de référence valait 0 alors que la température
    initiale valait 20.9. On met donc cette valeur comme TEMP_REF pour le
    calcul non linéaire. De plus l'instant de calcul intial était 1, alors qu'à
    ce moment, l'hydratation est non nulle. On avait donc une alarme. En partant de
    l'instant 0, on n'a plus d'alarme et le test est OK.

   DETAILS
   On calcule simplement le second membre du aux var. commande à t=0
   par un appel à NMCVFO sur COMMOI dans OP0070. On passe ce CHAMNO (CNVCF1)
   a NMCONV. Dans NMCONV, si on est au premier increment, et si ETAT_INIT
   n'est pas fourni, alors on calcule la norme de CNVCF1 et on la divise par
   le meme denominateur que pour le calcul du critère relatif habituel.
   Si cette valeur est supérieure à RESI_GLOB_RELA, on émet une alarme.

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
     Tous les tests utilisant STAT_NON_LINE.

--------------------------------------------------------------------------
RESTITUTION HORS AREX
   POUR_LE_COMPTE_DE : Christophe Durand
   teminant la fiche AL 2004-254
   NB_JOURS_TRAV  : 0.5
   INTERET_UTILISATEUR : NON
   TITRE : sdns01 et nook avec python2.3
   FONCTIONNALITE : sdns01a
   DETAILS :
   De meme que pour sdns01b, sdns01a se comporte différemment entre
   python2.1 et 2.3.
   Le branchement dans les test_resu se passe bien, mais les tolérances
   sont vraiment trop serrées : on met 1.E-07
   RESU_FAUX_VERSION_EXPLOITATION    : NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   : NON
   RESTITUTION_VERSION_EXPLOITATION  : NON
   RESTITUTION_VERSION_DEVELOPPEMENT : OUI
   IMPACT_DOCUMENTAIRE:  NON
   VALIDATION : sdns01a

--------------------------------------------------------------------------
REALISATION EL 2004-050
   POUR_LE_COMPTE_DE : Sophie Lamarche
   INTERET_UTILISATEUR : OUI
   TITRE
   METHODE CONTINUE, FORMULATION EN VITESSE
   FONCTIONNALITE
   Developper une formulation en vitesse pour
   remedier aux carences des schemas classiques dans l'integration
   du contact en dynamique.
   RESU_FAUX_VERSION_EXPLOITATION  :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : OUI
    DOC_R : R5.03.52  Methode continue
    EXPL_ : ajout d'un paragraphe sur la formulation en vitesse en dynamique
    DOC_U : U4.53.01  DYNA_NON_LINE
    EXPL_ : explication de l'usage de la theta-methode
    DOC_V : V5.03.100  Cas test SDNV100
    EXPL_ :

   VALIDATION
    * ajouts des modelisations :
    sdnv100c :formulation en deplacement
    sdnv100d :formulation en vitesse
   DETAILS
   La formulation en vitesse consiste a ecrire les lois de contact
   en vitesse et integrer la dynamique avec un Theta_schema (d'ordre 1).

   Cette formulation permet de remedier aux carences du schema de Newmark
   qui engendre des oscillations (numeriques) importantes au moment des
   chocs. En effet l'ecriture proposee et developpee permet de controler
   les placements et les vitesses, a la fois, grace a l'utilisation de deux champs
   de signes.

   L'utilisateur a le choix entre une formulation CONTINUE en deplacement
   integree avec un schema de Newmark et une formulation CONTINUE en
   vitesse integree avec un Theta_schema.

   Les routines modifiees sont :
   Pour le contact : affe_char_meca.capy, affe_char_meca_f.capy, gener_cmcfz1.cata,
     gener_cmcfz2.cata, nmible.f, nmtble.f, calico.f, frapp2.f, conlig.f, mappar.f,
     mmmbca.f, te0364.f, te0365.f
   Pour la dynamique : dyna_non_line.capy, dinit.f, ndlect.f, accel0.f, op0069.f,
    op0070.f


   NB_JOURS_TRAV  : 20

----------------------------------------------------------------------------------------------
CORRECTION AL 2004-073
   POUR_LE_COMPTE_DE : Sophie Lamarche
   NB_JOURS_TRAV  : 3.0
   INTERET_UTILISATEUR : NON
   TITRE   méthode continue et tests ssnv128m ssnp121d
   FONCTIONNALITE
      Traitement du contact avec la méthode CONTINUE en statique.
   DETAILS
      Des cas tests utilisant la méthode de contact CONTINUE en statique plantaient par écrasement mémoire,
      suite à la restitution de l'EL 2004-032 qui permettait le traitement du contact avec la méthode CONTINUE
      en dynamique.
      L'instruction  CALL DETRSD('MATR_ASSE','&&MATASS') avait été incluse dans une boucle réservée au cas de la dynamique,               ,
      alors qu'elle concerne la dynamique ET la statique.
      Cette modification est prise en compte dans la restitution de l'EL 2004-50

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
      * le cas test SSNV501c (emboutissage d'une tole par un poincon hémisphérique) est ajouté,
     il fait parti de la liste proposée par DeltaCad.
      * le cas test SSNP121D est modifié, pour tenir compte du changement de syntaxe de IMPR_RESU

----------------------------------------------------------------------------------------------
CORRECTION AL 2004-188
   POUR_LE_COMPTE_DE : Sophie Lamarche
   NB_JOURS_TRAV  : 4
   INTERET_UTILISATEUR : OUI
   TITRE   Contact Méthode Continue SSNA102
   FONCTIONNALITE
     Cette modification permet d'utiliser la méthode CONTINUE en 2D quadratique (contact SEG3-SEG3)
   DETAILS
     Correction d'une anomalie liee au traitement du contact
     avec l'element SEG3-SEG3 dans le cadre de la methode CONTINUE.
     l'anomalie vient d'une erreur dans le calcul des derivees des fonctions
     de formes et de leurs derivees secondes (calffd.f et calffx.f).
   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : OUI
     DOC_V : V6.01.102
     EXPL_ : ajout de la modélisation c
   VALIDATION
     Le cas test SSNA102 (contact multicorps élastiques),
     issu des cas test DeltaCad

----------------------------------------------------------------------------------------------
REALISATION EL 2004-053
   POUR_LE_COMPTE_DE : Sophie Lamarche
   NB_JOURS_TRAV  : 2
   INTERET_UTILISATEUR : NON
   TITRE   Acceleration initiale et methode continue
   FONCTIONNALITE
     Tenir compte d'une acceleration intiale non nulle,
     dans le traitement du contact en dynamique avec la méthode CONTINUE
   DETAILS
     Cette modification etendra l'utilisation de la methode continue
     en dynamique (en deplacement ou en vitesse)
     avec une acceleration initiale non nulle.
     Il s'agit de rendre la matrice de masse globale (contenant les
     ddls de lagrange de contact) inversible, en remplacant les termes
     diagonaux nuls par des valeurs egales à 1.

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION


-----------------------------------------------------------------------
--- AUTEUR nicolas O.NICOLAS   DATE  le 30/08/2004 a 17:33:19

------------------------------------------------------------------------------
REALISATION EL 2004-172
   INTERET_UTILISATEUR : NON
   NB_JOURS_TRAV  : 5
   TITRE : DEFI_MODELE_GENE ET MODES D'INTERFACE
   FONCTIONNALITE : DEFI_MODELE_GENE
   DETAILS
      Il s'agit de pouvoir utiliser la sous-structuration dynamique
      par une méthode de modes d'interface afin de reduire la taille
      des modeles generalises.
      Le principe est de calculer les modes propres de l'operateur dynamique
      condense a l'interface et de les utiliser comme des modes statiques
      dans la sous structuration dynamique.
      ROUTINE : liared
   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : OUI
     DOC_R : R4.06.02
     DOC_U : U4.65.02
       EXPL_ : Explication de l'integration de l'option "REDUIT" pour
               prendre en compte les modes d'interface
   VALIDATION
     CAS TEST : SDLV402

------------------------------------------------------------------------------
REALISATION EL 2004-171
   INTERET_UTILISATEUR : OUI
   NB_JOURS_TRAV  : 20
   TITRE : INCOMPATIBILITE DE MAILLAGE EN SOUS-STRUCTURATION
   FONCTIONNALITE
   DETAILS
      Integration de l'incompatibilite de maillage en sous-structuration
      dynamique.
      Il s'agit d'integrer les appels aux routines de projection tel
      qu'effectue dans AFFE_CHAR_MECA (LIAISON_MAILLE) ou PROJ_CHAMP
      dans l'operateur DEFI_MODELE_GENE. Ceci permet de gerer des interfaces
      incompatibles entre deux sous structures a posteriori.
      ROUTINE : op0126, arg126, callis, geolis, inclis, prjlis, mgutdm
   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : OUI
     DOC_R : R4.06.02
     DOC_U : U4.65.02
       EXPL_ : Explication de l'integration de l'option "GROUP_MA..." pour
               prendre en compte les maillles maitres necessaires a la
               projection des noeuds esclaves
   VALIDATION
     CAS TEST : SDLV402

------------------------------------------------------------------------------
RESTITUTION HORS AREX
   INTERET_UTILISATEUR : NON
   NB_JOURS_TRAV  : 0.5
   FONCTIONNALITE : DEFI_BASE_MODALE
   DETAILS
      Il n'est pas possible d'utiliser la sous structuration dynamique
      avec l'option MCNEAL lorsque la sous structure presente des modes
      de corps rigide. Lors de la factorisation de la matrice de raideur
      pour le calcul des modes d'attache, il n'y a qu'une alarme pour
      prevenir de leur presence.
      Dans l'attente de la realisation de l'EL 2004-093, on convertit
      l'alarme en une erreur lorsque la factorisation mene a une perte
      de decimale trop important.
      ROUTINE : facmtr camoat
   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : OUI
     DOC_R : R4.06.02
     DOC_U : U4.64.01
       EXPL_ : dire que les modes d'attache ne sont calcules que si la
       structure n'est pas libre
   VALIDATION


-----------------------------------------------------------------------
--- AUTEUR smichel S.MICHEL-PONNELLE   DATE  le 30/08/2004 a 13:19:08

--------------------------------------------------------------------------
REALISATION ED 2004-013
   INTERET_UTILISATEUR : NON
   NB_JOURS_TRAV  : 0.1
   TITRE   relation de comportement de Granger
   FONCTIONNALITE
   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  NON
   IMPACT_DOCUMENTAIRE : OUI
     DOC_R : R7.01.01
       EXPL_ : correction des définitions du retrait de dessiccation et du
               retrait endogène
   VALIDATION

--------------------------------------------------------------------------
CLASSEMENT SANS SUITE AL 2003-261
   INTERET_UTILISATEUR : NON
   NB_JOURS_TRAV  : 3.5
   TITRE D_PLAN_INCO et SIMO_MIEHE
   IMPACT_DOCUMENTAIRE : NON
   FONCTIONNALITE
   Il s'agit d'une etude avec contact en déformation plane utilisant les éléments
   incompressibles. Le problème est que le calcul s'arrête sous la Compaq pour cause de
   matrice tangente non factorisable alors qu'il tourne sous Linux.
   Sur le cas test initial, j'ai fait plusieurs tests :
   - le calcul tourne avec la modélisation D_PLAN.
   - on a les mêmes problèmes que DEFORMATION=PETIT ou SIMO_MIEHE
   - comportement identique avec LDLT
   - si on impose NPPREC=5 sur Linux, le calcul passe toujours sans problème.
   - si on enlève le contact, on observe toujours les mêmes difficultés.

   J'ai ensuite travaillé en petites déformations sans le contact, pour lequel on observe
   également un plantage sous la Compaq dès RIGI_MECA_TANG alors que le calcul passe sous
   Linux. J'ai comparé les matrices tangentes élémentaires dans le te obtenues sur les deux
   machines, ainsi que les matrices assemblées (dans nmmatr) : elles sont "quasiment"
   identiques : on observe juste une petite différence sur les valeurs < 10^(-8)). Mais si
   on met à 0 dans la matrice élémentaire tous les termes < 10^-7, on observe le même écart
   de comportement sous Linux et Compaq. Signalons également que dans ce cas, LDLT plante
   également mais GCPC OK.

   Une étude encore plus simplifiée où on impose le déplacement de tous les noeuds a
   permis de mettre en avant le fait que selon les cas, on pouvait ou non avoir besoin
   d'itérer pour obtenir la solution :
   ex.- cela marche lorsqu'on impose  le déplacement uniquement sur les noeuds sommets.
   (Ce qui est également vrai pour l'étude originaire de cette fiche)
      - sous Linux une itération suffit pour une géométrie de 9*9 carrés, il faut itérer
      pour 10*10 carrés
      - sous Linux suivant le solveur, et la méthode de renumérotation utilisée, il faut ou
      non itérer
      etc...

   Je propose donc de classer cette fiche sans suite et d'en émettre une autre qui s'appuie
   sur un problème simplifié où il faudrait regarder s'il n'y a pas un pb au moment de l'
   assemblage ou de la résolution

--------------------------------------------------------------------------
CLASSEMENT SANS SUITE AL 2004-095
   INTERET_UTILISATEUR : NON
   NB_JOURS_TRAV  : 0.2
   TITRE loi de comportement BETON_UMLV_FP
   IMPACT_DOCUMENTAIRE : NON
   FONCTIONNALITE
     J'avais émis cette fiche parce que je pensais qu'il y avait un problème
     lors des poursuites avec le modèle BETON_UMLV_FP. En fait, je pense que
     c'est moi qui avais fait une erreur dans le chargement (je retendais
     les câbles une deuxième fois).

--------------------------------------------------------------------------
CLASSEMENT SANS SUITE EL 2002-151
   POUR LE COMPTE DE : V. CANO
   INTERET_UTILISATEUR : NON
   NB_JOURS_TRAV  : 0.5
   TITRE remplacement du mot-clé ROUSS_PR par ROUSSELIER
   IMPACT_DOCUMENTAIRE : NON
   FONCTIONNALITE
     Il s'agit d'une demande faite par R. Masson pour ne distinguer les deux versions du
     modèles de Rousselier (version PETIT_REAC développée à MMC et version SIMO_MIEHE
     développé à AMA) que par la commande DEFORMATION.
     Le problème est que les deux lois de comportement ne possèdent pas le même nombre de
     variables internes et qu'elles ne sont pas rigoureusement identiques. Par exemple,
     il est possible d'activer des paramètres dans ROUSS_PR non utilisables dans ROUSSELIER.
     Pour ne pas embrouiller l'utilisateur, on propose pour le moment de laisser coexister
     les 2 lois sous 2 noms distincts.


-----------------------------------------------------------------------
--- AUTEUR vabhhts J.PELLET   DATE  le 31/08/2004 a 11:52:41

------------------------------------------------------------------------------
CLASSEMENT SANS SUITE AL 2004-166
   NB_JOURS_TRAV : 0.4
   INTERET_UTILISATEUR : NON
   TITRE "CALC_MATR_AJOU ne crée pas correctement certains CHAM_NO"
   IMPACT_DOCUMENTAIRE : NON
   FONCTIONNALITE
   Lors du développement du solveur FETI, O. Boiteau avait remarqué que
   la commande CALC_MATR_AJOU créait incorrectement plusieurs cham_no (selon X et Y)
   en faisant une "économie de moyens". Le champ selon Y était incomplet : il
   ne possédait que l'objet .VALE (puisque le .DESC et .REFE étaient identiques à
   ceux selon X).

   Dans sa fiche, il ne donnait aucune précision sur les champs incorrects : quelles
   variables dans quelles routines ?

   Pour confirmer sa remarque, j'ai instrumenté la routine JECREO pour qu'elle imprime
   le nom des objets créés lors de la commande CALC_MATR_AJOU.
   Mais je n'ai rien remarqué de bizarre (sur le test fdlv102a) : on crée apparemment
   autant de cham_no (complets) selon X que selon Y.

   Je classe donc la fiche "sans suite" et Olivier la réemetra éventuellement en étant
   plus précis.
   De toutes façons, ce n'est pas bien grave car la commande fonctionne bien pour l'instant
   comme cela.

------------------------------------------------------------------------------
CORRECTION AL 2004-203
   NB_JOURS_TRAV : 0.8
   INTERET_UTILISATEUR : NON
   TITRE "ssla200b : alarmes supplémentaires"
   FONCTIONNALITE
   Effectivement, le test ssla200b utilisait abondamment le fait que les charges
   utilisées pour les post-traitement (CALC_ELEM, CALC_NO et POST_ELEM) n'étaient
   pas les mêmes que celles utilisées pour le calcul "principal" (MECA_STATIQUE).

   J'ai donc modifié ce test (de non-regression) pour qu'il soit "exemplaire" :
   - dans toutes les commandes CALC_ELEM/CALC_NO/POST_ELEM : suppression des
     mots clés MODELE, CHAM_MATER, CARA_ELEM et EXCIT (ou CHARGE)
     (Bien évidemment, pour POST_ELEM, il faut les conserver si l'on n'utilise pas le mot clé RESULTAT)
   - je suis tombé sur quelques problèmes :
      pb1 : dans CALC_NO lorque l'un des chargement réparti est de type CHAR_MECA_EPSI_INIT_F
            dépendant de la température, le calcul s'arretait en erreur car CALC_NO ne transmettait
            pas le champ de température à la routine CALCUL.
            J'ai donc corigé la routine OP0106 pour qu'elle transmette la température à la
            routine VECHME.
      pb2 : la logique consistant à ne plus préciser EXCIT/CHARGE dans la commande CALC_NO
            conduit parfois à s'arrêter en erreur fatale lorsque l'on fait le post-traitement sur
            un sous-ensemble du modèle (utilisation de GROUP_MA et MAILLE). Par exemple, si le modèle
            comporte des chargement des "bord" et que l'on fait CALC_NO sur des mailles "volumiques",
            le code s'arrêtera sur un message du type : "aucun élément du ligrel ne sait calculer
            l'option 'mon_chargement_de_bord' ".
            Je corrige donc la routine VECHME de la façon suivante :
              - si commande == CALC_NO et si ligrel de calcul /= ligrel du modele :
                 call CALCUL('C',...)
                 puis test de l'existence du champ résultat de CALCUL
     - suite à ces modifications (de test et de fortran), 3 résultats du test deviennent NOOK :
       (REAC_NODA pour le concept MSLI2). Cela n'a rien d'étonnant puisque les chargements répartis
       ne sont plus les mêmes. Je modifie donc les valeurs de référence pour ces 3 valeurs.
   DETAILS
     Liste des fichiers modifiés:
       op0106.f  vechme.f
       ssla200b.comm

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   OUI
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION

------------------------------------------------------------------------------
CORRECTION AL 2004-216
   NB_JOURS_TRAV : 0.5
   INTERET_UTILISATEUR : OUI
   TITRE "PROJ_CHAMP s'arrete brutalement sur les mailles dégénérées"
   FONCTIONNALITE
   Lorsque l'on utilise PROJ_CHAMP avec comme maillage initial un maillage contenant
   des mailles dégénérées, on peut s'arrêter avec le message lapidaire :
   "ERREUR NUMERIQUE : IL Y A SANS DOUTE UNE ERREUR DE PROGRAMMATION"
   En effet, dans l'algorithme d'appariement des noeuds du maillage_2 avec les
   mailles du maillage_1, on est amenés à diviser par le volume de la maille qui
   est nul pour certaines dégénérescences (routine pj3da1.f par exemple).
   On corrige ce problème.

   DETAILS
   On corrige les routines :
   pj2da1.f  pj2da2.f  pj2dap.f  pj3da1.f  pj3da3.f  pj3da4.f  pj3dap.f  pj4dap.f

   pour tenir compte du fait que :
     - le volume d'un élément 3D peut etre nul
     - la surface d'un élément 2D peut etre nulle
     - la longueur d'un élément 1D peut etre nulle

   Liste des fichiers modifiés:
  pj2da1.f  pj2da2.f  pj2dap.f  pj3da1.f  pj3da3.f  pj3da4.f
  pj3dap.f  pj4dap.f

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION : un petit essai sur un maillage volontairement dégénéré

------------------------------------------------------------------------------
CORRECTION AL 2004-221
   NB_JOURS_TRAV : 0.3
   INTERET_UTILISATEUR : NON
   TITRE "tpll101b s'arrete en ARRET_ANORMAL en 7.3.8"
   FONCTIONNALITE
   Le test était en réalité mal écrit :
      CREA_CHAMP(TYPE_CHAM='SOUR_R'
   au lieu de :
      CREA_CHAMP(TYPE_CHAM='ELGA_SOUR_R'

   Quelqu'un avait essayé de modifier le catalogue de CREA_CHAMP pour traiter
   la syntaxe 'SOUR_R', mais c'était mal fait.

   Correction faite :
   1) je retire la modif de catalogue de CREA_CHAMP
   2) je corrige le test TPLL101B (c'est le seul à utiliser TYPE_CHAM='SOUR_R')

   DETAILS
     Liste des fichiers modifiés:
       crea_champ.capy
       tpll101b.comm

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION

------------------------------------------------------------------------------
CORRECTION AL 2004-239
   NB_JOURS_TRAV : 0.3
   INTERET_UTILISATEUR : NON
   TITRE "Test forma01g NOOK en 7.3.10"
   FONCTIONNALITE
   Pour le champ EQUI_ELNO_SIGM, le test testait le "max" sur tout le champ.

   Jusqu'à 7.3.9, ce max était atteint sur TETRA4 (maille M4054).
   En 7.3.10, on a changé le schéma d'intégration pour les TETRA4 : 4 -> 1.
   A partir de la 7.3.10, le passage Gauss -> Noeuds pour les TETRA4 conduit
   donc à un champ ELNO constant par élément ; ce qui n'était pas vrai jusqu'à
   présent. La valeur max observée a donc assez logiquement changé.

   La valeur de référence étant une valeur de non régression, je n'ai pas trop
   de scrupules à la changer.

   => modification du test forma01g :
      <                    VALE=2.3689932489835E+08,
      ---
      >                    VALE=2.4340779378589E+08,

   DETAILS
   J'ai comparé les résultats obtenus entre la STA7 et la NEW7.

   remarque : j'ai été surpris de voir que le champ EQUI_ELNO_SIGM avait
   également "bougé" pour les autres éléments (PENTA6) alors que leur schéma
   d'intégration n'avait pas changé. La raison en est que la modification
   de l'intégration des TETRA4 change la rigidité globale du système et donc
   la solution en déplacement sur tout le modèle. Ce qui change les contraintes
   pour tous les éléments.

   Liste des fichiers modifiés:
     forma01g.comm

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION  : modification de forma01g.comm

------------------------------------------------------------------------------
CORRECTION AL 2004-277
   NB_JOURS_TRAV : 0.5
   INTERET_UTILISATEUR : NON
   TITRE  "écrasement mémoire dans AFFE_CARA_ELEM si plusieurs occurences de AFFE_SECT"
   FONCTIONNALITE
   Si l'utilisateur utilisait plusieurs fois le mot clé AFFE_SECT de la commande
   AFFE_CARA_ELEM, le programme n'écrivait pas au bon endroit et écrasait la mémoire
   JEVEUX provoquant une message du type "écrasement aval ..."

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  OUI
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION : Modification du test sdll122a pour qu'il teste le cas de plusieurs
                occurrences de AFFE_SECT.

   DETAILS
   Il y avait un bug dans la routine pmfd00.f : la variable II n'était pas remise
   à zéro pour chaque occurrence de AFFE_SECT.
   Au passage, on remplace la variable II par la variable NBFIB (plus parlante)

   Remarque :
   Le bug a été introduit en version 7.3.5 en corrigeant l'AL 2004-100.
   Comme ce bug n'avait pas été corrigée en NEW6, je le fais (comme en NEW7).

   Liste des fichiers modifiés:
  pmfd00.f  pmfd01.f  pmfd02.f
  sdll122a.comm

------------------------------------------------------------------------------
REALISATION EL 2003-059
   NB_JOURS_TRAV : 10  (temps passé sur X-FEM par J. Pellet jusqu'à présent)
   INTERET_UTILISATEUR : NON
   TITRE  "étude d'impact pour l'introduction de la méthode XFEM dans Code_Aster"
   FONCTIONNALITE
   Avant de commencer l'introduction de la méthode XFEM dans Code_Aster, une série
   de réunions entre EDF (P. Massin, C. Chavant, J. Pellet ...) ,N. Moes (ECN) et
   Samuel Géniaut a eu lieu en 2003 pour permettre de tracer les grandes lignes
   de ce développement dans Aster. Ces réunions ont donné lieu à CR-AMA-03.151

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION

------------------------------------------------------------------------------
RESTITUTION HORS AREX   (H2)
   NB_JOURS_TRAV : 0
   INTERET_UTILISATEUR : NON
   FONCTIONNALITE
   Je retire 5 lignes de la routines CALCUL qui étaient inaccessibles.
   C'est JPL qui l'avait remarqué avec Foresys.
   DETAILS
     Liste des fichiers modifiés:
        calcul.f

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION

------------------------------------------------------------------------------
RESTITUTION HORS AREX   (H3)
   NB_JOURS_TRAV : 0.5
   INTERET_UTILISATEUR : OUI
   FONCTIONNALITE
   Améliorations des vérifications de LIRE_MAILLAGE :
   --------------------------------------------------
   Suite à une plainte (à l'assistance Aster) sur la commande PROJ_CHAMP, je me
   suis aperçu que l'on pouvait améliorer les vérifications de maillage faites
   dans la commande LIRE_MAILLAGE :

   1) lorsqu'un noeud était connecté à plus de 200 mailles, on arrêtait toutes
      les vérifications. Maintenant :
        a) on imprime le nom de tous les noeuds connectés à plus de 200 mailles
           et on émet une alarme.
        b) lorsqu'une maille est connectée à un noeud connecté à plus de
           200 mailles, on ne vérifie pas cette maille

   2) Pour les messages concernant les mailles dégénérées ou trop applaties,j'imprime
      le type des mailles (en plus de leur nom).
   DETAILS
     Liste des fichiers modifiés:
        chckma.f

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION

------------------------------------------------------------------------------
CORRECTION AL 2004-243
(partielle)
   NB_JOURS_TRAV : 2
   INTERET_UTILISATEUR : OUI
   TITRE  "amélioration des performances CPU de la combinaison linéaire de matrices morses"
   FONCTIONNALITE
   Les méthodes de contact utilisent abondamment la combinaison de matrices
   assemblées. Mikael s'est aperçu que cette combinaison était très couteuse
   pour la méthode MULT_FRONT (stockage Morse).
   On améliore donc cette programmation : réduction de 60% du temps passé dans
   la combinaison des matrices pour le test SSNV128I.

   Dans la fiche 2004-243, C. Durand constate que pour une étude, le solveur MULT_FRONT
   est 15 fois plus couteux que LDLT. La correction apportée ici ne résoudra pas (je pense)
   complètement ce problème. Il faut donc que quelqu'un (Mickaël ? Christian ?) continue
   l'analyse. Il semble qu'il y ait également un problème du côté de Métis qui consommerait
   du temps "système".

   DETAILS
   améliorations de la routine PROSMO :
   1) on remplace les JEDETC par des JEDETR
   2) on déplace 1 couple WKVECT/JEDETR en dehors de la boucle sur les equations.
   3) on modifie radicalement l'usage de l'objet KLISTE : il n'y a plus maintenant
      d'appels à JEVEUX dans la boucle sur les équations.
   4) on utilise 2 fois moins la routine de tri UTTRII

   détails sur les détails :
   Après avoir fait une première version de la routine qui supposait que tous les objets
   .HCOL tenaient en mémoire centrale, je me suis remis au travail pour utiliser un objet
   KLISTE segmenté en blocs (de taille DEBUT/TAILLE_BLOC (800 000 par défaut)).

   Liste des fichiers modifiés:
  detrsd.f  prosmo.f

  Dernière minute (asrest) :
  --------------------------
  Suite à l'amélioration (CPU) de la routine prosmo.f
  Je dois augmenter la mémoire de 2 tests :
    - rccm02b  : 16 Mo -> 24 Mo
    - ssnv148a : 64 Mo -> 96 Mo

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION :  SSNV128I reste OK
     SSNV128I : le gain est important.
        pour la commande U3M=STAT_NON_LINE:
          avant : 260s -> après : 123s

------------------------------------------------------------------------------
REALISATION EL 2004-092
   NB_JOURS_TRAV : 4.5
   INTERET_UTILISATEUR : OUI
   TITRE   "rendre possible MULT_FRONT avec les macro-elements statiques"
   FONCTIONNALITE
   On complète la programmation des commandes NUME_DDL et ASSE_MATRICE pour
   qu'elles prennent en compte les macro-éléments avec un stockage "morse".
   Ce qui permet d'utiliser le solveur MULT_FRONT.

   DETAILS
   1) je supprime le calcul de NCOEF dans NUEFFE : ce majorant du nombre
      de termes stockés dans la matrice morse n'est plus utilisé : on
      agrandit les objets de travail au fur et à mesure des besoins.
      => on modifie la SD NUME_DDL :
         .NEQU(2) : ne contient plus rien

   2) Au passage, je modifie ASSMAT pour que Arlequin soit possible avec LDLT :
    prise en compte du poids des mailles lors de l'assemblage.

   3) je corrige un petit bug dans RELIEM qui ne pouvait pas etre appelée lorsque
      le maillage ne contenait que des sous-structures statiques.

   4) je ne fais pas l'évolution pour les matrices non-symétriques (morse ou
      ligne de ciel : routines assmmns et assmmn)

   Liste des fichiers modifiés:
      assmam.f  assmat.f  moinsr.f  nudeeq.f  nueffe.f  preml0.f
      promor.f  reliem.f  ssriu1.f
      sslp100c.comm  sslp100d.comm

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
     DOC_D : D4.06.07
     EXPL_: .NEQU(2) : inutilisé
   VALIDATION  : On modifie le test sslp100d pour le passer en MULT_FONT.
      Au passage, on modifie sslp100c (et d) pour ne calculer que quelques pas de temps (5)
      et non pas 200 comme avant.

------------------------------------------------------------------------------
CORRECTION AL 2004-157
   NB_JOURS_TRAV : 0.5
   INTERET_UTILISATEUR : NON
   TITRE  "TEST_RESU ne vérifie pas le numéro du point (ou du sous-point)"
   FONCTIONNALITE
      La commande TEST_RESU ne vérifiait pas que le numéro du POINT
      ou du SOUS_POINT était licite.
      Elle émet maintenant une alarme losrque ce n'est pas le cas.
   DETAILS
     Dans le test hsns100b, je supprime un TEST_RESU concernant un effort
     "caché" dans les contraintes (éléments DKT) qui aurait du etre supprimé en même
     temps que l'on supprimait les effort cachés. Ce problème ne s'était pas vu car
     le numéro du sous-point n'était pas testé dans TEST_RESU.

     Liste des fichiers modifiés:
       utchdl.f
       hsns100b.comm

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION : un petit essai pour voir le message

------------------------------------------------------------------------------
REALISATION EL 2001-190
   NB_JOURS_TRAV : 1.5  (dont 0.5 pour l'analyse des risques de résultats faux)
   INTERET_UTILISATEUR : NON
   TITRE "échange de champs aux points de Gauss"
   FONCTIONNALITE
   Cette vieille fiche (2001) voulait résoudre de façon définitive et générale
   le problème de l'échange (entre de 2 modèles) de champs aux points de Gauss (ELGA).

   Je propose d'être plus raisonable :
   1) On améliore la routine chligr.f pour empêcher tout échange illicite de champs ELGA.
      On peut le faire aujourd'hui grâce aux nouveaux ELREFE s'appuyant sur un catalogue
      de types de mailles plus riche. Cette amélioration nous protège de résultats
      potentiellement faux : par exemple, un élément mécanique ne pourra plus utiliser un
      champ ELGA thermique si l'élément thermique est "lumpé".
   2) On a émis 2 fiches spécifiques concernant les problèmes d'échange connus à ce jour :
      - la métallurgie (fiche 8022)
      - l'hydratation  (fiche 8026)
   3) On prie pour ne pas voir apparaitre de nouveaux problème d'échange de champs ELGA ...
   4) on solde cette vieille fiche

   RESU_FAUX_VERSION_DEVELOPPEMENT :   OUI  DEPUIS : 6.0.0
      Jusqu'à cette évolution un risque de résultats faux existait (pour la métallurgie et l'hydratation)
      lorsque les éléments thermiques et mécaniques utilisés successivement avaient le même nombre
      de point de Gauss mais disposés différemment.

      Après un examen approfondi des catalogues, ce problème concernait les études :
         - ayant un maillage 3D linéaire : HEXA8/PENTA6/TETRA4
         - faisant un calcul thermique avec la modélisation '3D_DIAG'
         - faisant en suite un calcul mécanique utilisant les phases métallurgiques
           (calculées par CALC_META) ou utilisant de l'hydratation (AFFE_CHAR_MECA/HYDR_CALCULEE)

      En effet, la modélisation thermique '3D_DIAG' utilise des familles de points de Gauss
      aux "noeuds sommets" et les éléments mécaniques utilisent (le plus souvent) une famille
      de points de Gauss ayant le même nombre de points (FPG8 pour l'HEXA8, FPG6 pour le PENTA6
      et FPG4 pour le TETRA4)

      Pour ne pas "accabler" de telles études, il faut aussi signaler que l'erreur (lorsqu'elle
      était faite) n'était sans doute pas énorme : au lieu d'utiliser la métallurgie (ou l'hydratation)
      sur un point de Gauss, on utilisait celle d'un noeud sommet du même élément (donc proche).


   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI

   RESU_FAUX_VERSION_EXPLOITATION  :   OUI  DEPUIS : 6.0.0
   RESTITUTION_VERSION_EXPLOITATION  :   NON   : on ne saurait pas corriger simplement
                   car le chantier ELREFA n'a pas été fait en version 6

   IMPACT_DOCUMENTAIRE : OUI
     DOC_D : D6.00.01
     EXPL_: ajout de la routine celfpg.f

   VALIDATION

   DETAILS
   1) on blinde la routine chligr.f:
      - pour les champs "ELGA", on vérifie que les familles de PG sont cohérentes.
        Jusqu'à présent, on se contentait de vérifier le nombre de Points de Gauss,
        sans savoir si les 2 familles étaient identiques.

        Remarque : cette vérification ne concerne que les éléments portés par les mailles du
        maillage. On ne vérifie rien sur les éléments affectés directement sur des
        noeuds (AFFE_MODELE/AFFE/GROUP_NO/NOEUD)

      Cette évolution permet d'améliorer le message d'erreur que l'on obtient lorsque
      l'on utilise en entrée de la routine CALCUL, des cham_elem_ELGA n'ayant pas la
      bonne famille de points de Gauss :

      avant :
        <F> <STAT_NON_LINE> <CESCEL> NOMBRES DE POINTS DIFFERENTS POUR LA MAILLE: M1
            CHAM_ELEM DE: VARI_R

      après :
        <F> <STAT_NON_LINE> <CHLIGR> INCOHERENCE DES FAMILLES DE POINTS DE GAUSS POUR
            LA MAILLE M1       (QU8     FPG9    /QU8     FPG4    )


   Liste des fichiers modifiés:
  celfpg.f  chligr.f




-----------------------------------------------------------------------
--- AUTEUR ylepape Y.LEPAPE   DATE  le 30/08/2004 a 15:47:50

------------------------------------------------------------------------------
REALISATION EL 2004-180
   INTERET_UTILISATEUR : OUI
   NB_JOURS_TRAV  : 2.5
   TITRE Fluage BETON_UMLV_FP, prise en compte du retrait
   FONCTIONNALITE
     La loi de comportement BETON_UMLV_FP modélise le fluage propre du béton.
     Jusqu'à présent, le retrait du béton n'était pas intégré à ce modèle.
     Or, suite à une étude sur PACE 1300, il a été constaté que les résultats
     semblaient peu physiques compte tenu des variations d'humidité imposées par
     le séchage naturel du matériau.
     Le retrait endogène et le retrait de dessiccation ont donc été ajoutés à la
     loi en question.
   DETAILS
   - modification de nmcomp.f et de nmcoup.f pour permettre l'appel de
     BETON_UMLV_FP avec les variables d'hydratation et la valeur de référence
     du séchage.
   - modification de lcumfp.f (routine principale de la loi de comportement)
     pour ajouter la récupération des paramètres du retrait et le calcul des
     déformations correspondantes..
   - modification de lcumef.f pour ajouter les déformations de retrait dans le
     calcul des contraintes à la fin du pas de temps

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : OUI
     DOC_V : V6.04.174 SSNV174 - Prise en compte du retrait dans le modèle BETON_ULMV_FP
     DOC_R : R7.01.07  BETON_UMLV_FP - Prise en compte du retrait
   VALIDATION
     nouveau cas-test : SSNV174 (solution numérique obtenue avec Scilab 2.7.2,
     1 modélisation : 3D)


========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST AJOUT sdlv402a                      nicolas O.NICOLAS          350    350      0
 CASTEST AJOUT sdnv100b                      jmbhh01 J.M.PROIX          287    287      0
 CASTEST AJOUT sdnv100c                      jmbhh01 J.M.PROIX          286    286      0
 CASTEST AJOUT sdnv100d                      jmbhh01 J.M.PROIX          378    378      0
 CASTEST AJOUT ssls109c                      jmbhh01 J.M.PROIX          836    836      0
 CASTEST AJOUT ssna102d                      jmbhh01 J.M.PROIX          314    314      0
 CASTEST AJOUT ssns105c                      jmbhh01 J.M.PROIX          614    614      0
 CASTEST AJOUT ssnv174a                      ylepape Y.LEPAPE           266    266      0
 CASTEST AJOUT ssnv501c                      jmbhh01 J.M.PROIX          322    322      0
 CASTEST MODIF forma01g                      vabhhts J.PELLET           341      3      3
 CASTEST MODIF hsns100b                      vabhhts J.PELLET           253      1      4
 CASTEST MODIF rccm02b                       vabhhts J.PELLET           354      1      1
 CASTEST MODIF sdll122a                      vabhhts J.PELLET           145      8      3
 CASTEST MODIF sdns01a                       jmbhh01 J.M.PROIX          420      6      6
 CASTEST MODIF sdnv100a                      jmbhh01 J.M.PROIX          369    136     10
 CASTEST MODIF sdnv102a                      cibhhlv L.VIVAN            656      1      1
 CASTEST MODIF ssla200b                      vabhhts J.PELLET          1338     21     60
 CASTEST MODIF sslp100c                      vabhhts J.PELLET           223      7      9
 CASTEST MODIF sslp100d                      vabhhts J.PELLET           426      8     10
 CASTEST MODIF ssls109b                      jmbhh01 J.M.PROIX          702     40     40
 CASTEST MODIF ssls113a                      jmbhh01 J.M.PROIX          483      2      2
 CASTEST MODIF ssnv148a                      vabhhts J.PELLET           201      1      1
 CASTEST MODIF ssnv158a                      cibhhlv L.VIVAN            442     43     24
 CASTEST MODIF ssnv158b                      cibhhlv L.VIVAN            440     22     22
 CASTEST MODIF ssnv158c                      cibhhlv L.VIVAN            424     21     21
 CASTEST MODIF ssnv158d                      cibhhlv L.VIVAN            409     20     20
 CASTEST MODIF tpll101b                      vabhhts J.PELLET           124      2      2
 CASTEST MODIF ttnl03a                       jmbhh01 J.M.PROIX          467     11      5
 CASTEST SUPPR hslp300a.comm                 jmbhh01 J.M.PROIX          237      0    237
 CASTEST SUPPR sslp302a.comm                 jmbhh01 J.M.PROIX          126      0    126
 CASTEST SUPPR sslp302b.comm                 jmbhh01 J.M.PROIX          128      0    128
 CASTEST SUPPR sslp302c.comm                 jmbhh01 J.M.PROIX          141      0    141
CATALOGU MODIF typelem/gener_cmcfz1          jmbhh01 J.M.PROIX           56      2      2
CATALOGU MODIF typelem/gener_cmcfz2          jmbhh01 J.M.PROIX          148      2      2
CATALOPY MODIF commande/affe_char_meca       jmbhh01 J.M.PROIX          760      2      1
CATALOPY MODIF commande/affe_char_meca_f     jmbhh01 J.M.PROIX          483      2      1
CATALOPY MODIF commande/crea_champ           vabhhts J.PELLET           146      1      3
CATALOPY MODIF commande/defi_modele_gene     nicolas O.NICOLAS           48      9      1
CATALOPY MODIF commande/dyna_non_line        jmbhh01 J.M.PROIX          303      6      2
 FORTRAN AJOUT algorith/geolis               nicolas O.NICOLAS          188    188      0
 FORTRAN AJOUT algorith/inclis               nicolas O.NICOLAS          175    175      0
 FORTRAN AJOUT algorith/liared               nicolas O.NICOLAS          116    116      0
 FORTRAN AJOUT algorith/prjlis               nicolas O.NICOLAS          295    295      0
 FORTRAN AJOUT calculel/celfpg               vabhhts J.PELLET           105    105      0
 FORTRAN MODIF algeline/preml0               vabhhts J.PELLET           189     67     64
 FORTRAN MODIF algorith/accel0               jmbhh01 J.M.PROIX          224     25     14
 FORTRAN MODIF algorith/arg126               nicolas O.NICOLAS          400      1      1
 FORTRAN MODIF algorith/callis               nicolas O.NICOLAS          304    148     46
 FORTRAN MODIF algorith/camoat               nicolas O.NICOLAS          210      8      1
 FORTRAN MODIF algorith/conlig               jmbhh01 J.M.PROIX           62      5      4
 FORTRAN MODIF algorith/dinit                jmbhh01 J.M.PROIX          211     52      9
 FORTRAN MODIF algorith/facmtr               nicolas O.NICOLAS          121      4      1
 FORTRAN MODIF algorith/frapp2               jmbhh01 J.M.PROIX          690      8      4
 FORTRAN MODIF algorith/grdmat               jmbhh01 J.M.PROIX           74      4      3
 FORTRAN MODIF algorith/lcumef               ylepape Y.LEPAPE           162     23      5
 FORTRAN MODIF algorith/lcumfp               ylepape Y.LEPAPE           493     39     27
 FORTRAN MODIF algorith/mappar               jmbhh01 J.M.PROIX          184      2      2
 FORTRAN MODIF algorith/mgutdm               nicolas O.NICOLAS          163     15      4
 FORTRAN MODIF algorith/mmmbca               jmbhh01 J.M.PROIX          224     43      6
 FORTRAN MODIF algorith/ndlect               jmbhh01 J.M.PROIX          189     28      7
 FORTRAN MODIF algorith/nmcomp               ylepape Y.LEPAPE           635      2      2
 FORTRAN MODIF algorith/nmconv               jmbhh01 J.M.PROIX          417     24      6
 FORTRAN MODIF algorith/nmcoup               ylepape Y.LEPAPE           185      3      3
 FORTRAN MODIF algorith/nmgril               jmbhh01 J.M.PROIX          252     24     41
 FORTRAN MODIF algorith/nmible               jmbhh01 J.M.PROIX          132      5      4
 FORTRAN MODIF algorith/nmtble               jmbhh01 J.M.PROIX          117      4      3
 FORTRAN MODIF algorith/op0069               jmbhh01 J.M.PROIX          674      7      6
 FORTRAN MODIF algorith/op0070               jmbhh01 J.M.PROIX          843     17     10
 FORTRAN MODIF algorith/op0126               nicolas O.NICOLAS          113     25      5
 FORTRAN MODIF algorith/vechme               vabhhts J.PELLET           438     27     12
 FORTRAN MODIF assembla/assmam               vabhhts J.PELLET           814    365    326
 FORTRAN MODIF assembla/assmat               vabhhts J.PELLET           691    301    404
 FORTRAN MODIF assembla/moinsr               vabhhts J.PELLET           198      9     14
 FORTRAN MODIF assembla/nudeeq               vabhhts J.PELLET           209     69     73
 FORTRAN MODIF assembla/nueffe               vabhhts J.PELLET          1036      4     59
 FORTRAN MODIF assembla/promor               vabhhts J.PELLET           416     99     72
 FORTRAN MODIF calculel/calcul               vabhhts J.PELLET           328      1     17
 FORTRAN MODIF calculel/chligr               vabhhts J.PELLET           145     39      3
 FORTRAN MODIF calculel/pj2da1               vabhhts J.PELLET            86      6      2
 FORTRAN MODIF calculel/pj2da2               vabhhts J.PELLET           144     20      5
 FORTRAN MODIF calculel/pj2dap               vabhhts J.PELLET           170     11      3
 FORTRAN MODIF calculel/pj3da1               vabhhts J.PELLET            95      6      2
 FORTRAN MODIF calculel/pj3da3               vabhhts J.PELLET            81      6      1
 FORTRAN MODIF calculel/pj3da4               vabhhts J.PELLET            65      7      1
 FORTRAN MODIF calculel/pj3dap               vabhhts J.PELLET           177     12      5
 FORTRAN MODIF calculel/pj4dap               vabhhts J.PELLET           139     11      3
 FORTRAN MODIF elements/calffd               jmbhh01 J.M.PROIX          329      3      3
 FORTRAN MODIF elements/calffx               jmbhh01 J.M.PROIX          114      4      3
 FORTRAN MODIF elements/dktnli               jmbhh01 J.M.PROIX          622     33     21
 FORTRAN MODIF elements/dmatel               jmbhh01 J.M.PROIX          580      7      4
 FORTRAN MODIF elements/dmathl               jmbhh01 J.M.PROIX          400      7      4
 FORTRAN MODIF elements/dxbsig               jmbhh01 J.M.PROIX          143      1      9
 FORTRAN MODIF elements/dxeffi               jmbhh01 J.M.PROIX          180     24     16
 FORTRAN MODIF elements/dxmate               jmbhh01 J.M.PROIX          566      9      4
 FORTRAN MODIF elements/dxmath               jmbhh01 J.M.PROIX          534      6      4
 FORTRAN MODIF elements/te0031               jmbhh01 J.M.PROIX          333      6      4
 FORTRAN MODIF elements/te0364               jmbhh01 J.M.PROIX          864     14      7
 FORTRAN MODIF elements/te0365               jmbhh01 J.M.PROIX          595     65      6
 FORTRAN MODIF elements/te0431               jmbhh01 J.M.PROIX          332      7      3
 FORTRAN MODIF modelisa/calico               jmbhh01 J.M.PROIX          813     20     13
 FORTRAN MODIF modelisa/chckma               vabhhts J.PELLET           305     41     20
 FORTRAN MODIF modelisa/pmfd00               vabhhts J.PELLET           431      4      6
 FORTRAN MODIF modelisa/prosmo               vabhhts J.PELLET           411    157    145
 FORTRAN MODIF modelisa/reliem               vabhhts J.PELLET           351     68     65
 FORTRAN MODIF prepost/op0106                vabhhts J.PELLET           819      2      2
 FORTRAN MODIF soustruc/ssriu1               vabhhts J.PELLET           353    166    163
 FORTRAN MODIF utilitai/detrsd               vabhhts J.PELLET           495     34      4
 FORTRAN MODIF utilitai/utchdl               vabhhts J.PELLET           309     30     21
 FORTRAN SUPPR elements/dxeff2               jmbhh01 J.M.PROIX          172      0    172


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :   14        4532      4532             +4532
 MODIF :   90       32540      2662    2063      +599
 SUPPR :    5         804               804      -804
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :  109       37876      7194    2867     +4327 
