

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR abbas        ABBAS Mickael          DATE 06/07/2010 - 08:49:43

--------------------------------------------------------------------------------
RESTITUTION FICHE 011011 DU 2007-06-22 12:50:59
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   sd_char_contact.py et sd_char_unilate.py  Doc D4.06.14
FONCTIONNALITE
   Objectifs :
      * compléter les catalogues sd_char_contact.py et sd_char_unilate.py :
         - ajouter des routines check_xxx de vérification de l'existence conditionnelle de
   certains objets, de cohérence de longueur, ...
   
      * mettre à jour D4.06.14
   
   Remarque JP :
     - je crois que dans D4.06.14, on décrit actuellement certains objets temporaires créés
   et utilisés dans STAT_NON_LINE. Il faudrait sans doute créer un (ou plusieurs ?) nouveau
   catalogue pour décrire ces objets : sd_mecanonline_contact.py 
   
   Les catalogues ont été ré-écrits (indispensable de toute façon à cause de SDVERI) lors du
   passage en DEFI_CONTACT.
   La doc D4.06.14 est à jour sur le WIKI. 
   Concernant les objets "internes" OP0070 (préfixés par &&RESOCO), je pense qu'il n'est pas
   nécessaire de le faire dans un catalogue, ces SD sont toujours sur la base volatile.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : D4.06.14
VALIDATION
   sans objet
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR caron        CARON Axelle           DATE 06/07/2010 - 14:12:30

--------------------------------------------------------------------------------
RESTITUTION FICHE 015201 DU 2010-06-14 16:02:18
TYPE evolution concernant Code_Aster (VERSION 10.4)
TITRE
   Visualisation X-FEM quadratique 2D
FONCTIONNALITE
   Visualisation des éléments XFEM quadratiques 2D avec contact et frottement pour le traitement
   des interfaces en petits glissements [Deuxième partie de la restitution du 16/06/2010
   (fiche 13731)]
   
   Dans la visu, on recalcule les level set des entites (NOEUD, POINT ou MILIEU) dans xpolsn
   en interpolant sur l'élément parent. Cela permet en effet de savoir si on considère
   l'entité en double ou pas. Pour les points milieux, cela concerne évidemment tout
   particulièrement le point milieu de la fissure calculé par xdecqu, xmilfi. Or lors de ce
   calcul, j'interpolais la level set normale sur le triangle issu du la phase de
   prédécoupage. L'interpolation ne pouvant pas être la même dans le calcul et la visu (pour
   un maillage quadrangle), j'obtenais des lsn différentes.
   Je rectifie donc l'interpolation dans la phase de calcul, qui est réalisée dorénavant sur
   l'élément parent.
   
   Impact fortran
   op0187 (post_cham_xfem), op0196 (post_mail_xfem), xpoajc, xpoajd, xpoajm, xpoajn, xpocmp,
   xpoco2, xpodim, xpomac, xpomax, xposep, xpolsn, te0514, xdecqu
   
   Tests de validation quadratique
   ssnv182k & ssnv182l (bloc avec interface en contact frottant avec X-FEM) : introduction du
   post traitement pour la visualisation X-FEM (les champs DEPL et SIEF_ELGA)
   
   ssnv209m (plaque en contact frottant sur bâti rigide avec X-FEM, interface qui coïncide
   avec les faces du maillage) : extraction du champ DEPL sur le résultat issu de post_cham_xfem
   
   ssnv209n (plaque en contact frottant sur bâti rigide avec X-FEM, interface qui passe au
   milieu des mailles) : extraction du champ DEPL sur le résultat issu de post_cham_xfem
   
   Ces 4 cas tests xfem quadratique 2D font intervenir des interfaces droites qui ne
   permettent pas encore de mettre complètement en évidence les spécificités du quadratique
   (il y aura prochainement un test sur une chaînette en contact/frottement et un test avec
   courbure d'interface en traction).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V6.04.209
VALIDATION
   ssnv209m ssnv209n ssnv182k ssnv182l
NB_JOURS_TRAV  : 20.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR corus        CORUS Mathieu          DATE 05/07/2010 - 12:43:18

--------------------------------------------------------------------------------
RESTITUTION FICHE 015005 DU 2010-04-28 12:42:54
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   Detection des modes de corps rigide avec un modxc3xa8le generalisxc3xa9
FONCTIONNALITE
   #-- Probleme --#
   on ne peut pas utiliser l'option "MODE_RIGIDE" de MODE_ITER_SIMULT quand on travaille avec
   un modèle généralisé. Dans le cas de pivots nuls, on passe par un appel a rgndas.f, qui
   cherche a recuperer le nom du modele associe. Dans le cas des modeles generalises, cette
   info est stockee dans le .REFN du NUME_DDL_GENE, alors qu'elle est stockee dans le .REFE
   dans le cas du NUME_DDL standard.
   
   #-- Solution --#
   
   On teste l'existence du .REFE pour recuperer cette info. S'il existe, on fait comme avant,
   sinon, on cherche dans un .REFN.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V2.03.106
VALIDATION
   sdls106c
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 05/07/2010 - 13:34:02

--------------------------------------------------------------------------------
RESTITUTION FICHE 015248 DU 2010-06-23 15:40:58
TYPE aide utilisation concernant Code_Aster (VERSION 7.0)
TITRE
   Evaluation d'un champ de fonctions
FONCTIONNALITE
   Un utilisateur ne peut pas évaluer son champ de formule.
   La raison est que les noms des paramètres de la formule 
   contiennent des espaces : ' SIXX' !
   
   On fait deux améliorations :
   
   1. dans l'affichage du message, on fait ressortir l'erreur :
   
   ...!--------------------------------------------------------
   ---------------------------------!
   ...!.<A>.<FONCT0_51>........................................
   .................................!
   ...!........................................................
   .................................!
   ...!.Erreur.lors.de.l'interprétation.de.la.formule.'Pression
   '................................!
   ...!........................................................
   .................................!
   ...!.Les.paramètres.de.la.formule.n'ont.pas.été.fournis.....
   .................................!
   ...!.Paramètres.manquants.:.'.SIXY',.'.SIYY',.'.X'..........
   .................................!
   ...!........................................................
   .................................!
   ...!.Conseils.:.............................................
   .................................!
   ...!...Si.le.problème.reporté.ci-
   dessus.ressemble.à.'NameError:.name.'XXX'.is.not.defined.',.
   !
   ...!...vérifiez.que.le.paramètre.'XXX'.fait.bien.partie.des.
   paramètres.de.définition.de......!
   ...!...la.formule.(mot.clé.FORMULE./.NOM_PARA)..............
   .................................!
   ...!........................................................
   .................................!
   ...!........................................................
   .................................!
   ...!.Ceci.est.une.alarme..Si.vous.ne.comprenez.pas.le.sens.d
   e.cette..........................!
   ...!.alarme,.vous.pouvez.obtenir.des.résultats.inattendus.!.
   .................................!
   ...!--------------------------------------------------------
   ---------------------------------!
   
   
   2. mais ce message ne devrait plus se produire, on interdit 
   la création de la formule avec ces paramètres :
   
    Etape  FORMULE ligne :  3 fichier :  fort.1 nom de 
   paramètre invalide (contient des blancs) : ' SIXX'
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test xc3xa9lxc3xa9mentaire + xc3xa9tude jointe
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desoza       DE SOZA Thomas         DATE 06/07/2010 - 11:34:38

--------------------------------------------------------------------------------
RESTITUTION FICHE 015296 DU 2010-07-02 12:53:00
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   Amxc3xa9lioration d'un message de VERI_NORM
FONCTIONNALITE
   Express
   =======
   
   Un utilisateur du forum réalisant un calcul de contact est tombé sur l'erreur fatale
   suivante :
   
   !------------------------------------------------------------------------------------------------------------------------------------!
   ! <EXCEPTION> <MODELISA5_99>                                                             
                                              !
   !                                                                                        
                                              !
   !                                                                                        
                                              !
   !  impossibilité de vérifier l'orientation des mailles de bord : on trouve des groupes de
   mailles disjoints dans la liste de mailles !
   ! de bords fournie.                                                                      
                                              !
   !  vérifier que les groupes de mailles de bord définis forment un ensemble connexe.      
                                              !
   !                                                                                        
                                              !
   !                                                                                        
                                              !
   !                                                                                        
                                              !
   !                                                                                        
                                              !
   !------------------------------------------------------------------------------------------------------------------------------------!
   
   Il s'agit d'un message émis lors de la vérification automatique de l'orientation des
   surfaces de contact. Ici une de ses surfaces n'est pas connexe et la vérification échoue.
   
   Lorsqu'une surface de contact n'est pas connexe cela peut venir d'une mauvaise définition
   des surfaces de contact. Cependant il peut y avoir certains cas où c'est licite : dans ce
   cas il faut utiliser VERI_NORM='NON' dans DEFI_CONTACT pour désactiver la vérification
   
   Je propose d'enrichir le message pour avertir l'utilisateur de cette possibilité.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   nxc3xa9ant
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 015245 DU 2010-06-23 13:04:23
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Incohxc3xa9rences en hyperxc3xa9lastique entre fortran/tests/doc
FONCTIONNALITE
   Anomalie
   ========
   
   On observe des incohérences entre la documentation et les cas-tests pour la loi ELAS_HYPER.
   
   Détails
   =======
   
   ** La définition d'un matériau Néo-Hookéen n'est pas la même selon que l'on lit
   DEFI_MATERIAU[U4.43.01] ou la doc R de ELAS_HYPER[R5.03.19]. La bonne définition est celle
   donnée dans la doc R : C10 non nul définit un matériau NH.
   ==> On corrige DEFI_MATERIAU. Il manquait aussi un signe - que l'on rajoute dans la
   définition du potentiel
   
   ** Les cas-tests SSNV187 et SSNV189 qui valident la loi ELAS_HYPER ont une doc V qui n'est
   pas cohérente avec les fichiers de commandes.
   - Pour SSNV189 il s'agit simplement d'une interversion entre C01 et C10 dans la doc V que
   l'on corrige.
   - Pour SSNV187, c'est plus embêtant : la doc cite des paramètres matériaux qui ne sont pas
   ceux utilisés dans le test. D'autre part on y définit un matériau NH de façon erronée (C01
   non nul alors que c'est C10 normalement). Le test reproduit la même erreur.
   ==> on corrige et la doc V et le test (en intervertissant C01 et C10). Les 3 modélisations
   sont alors NOOK sur des valeurs de non-régression que l'on ajuste. À noter que la solution
   de référence qui est analytique reste OK, elle semble d'ailleurs avoir été obtenue avec la
   bonne définition du NH (je sais c'est compliqué !).
   
   ** Pour finir on répare une dernière erreur qui consiste dans le catalogue de
   DEFI_MATERIAU/ELAS_HYPER à rendre obligatoire la donnée de C01 alors que c'est C10 qui
   devrait l'être (quelque soit le type de matériau modélisé, (NH, Signorini, MR), ce
   coefficient est obligatoire).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.43.01,V6.04.187,V6.04.189,R5.03.19
VALIDATION
   ssnv187abc,ssnv189abc
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 015148 DU 2010-06-03 12:53:58
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   initialisation dans mmnewd
FONCTIONNALITE
   Anomalie
   ========
   
   Martin G. (IFP) a trouvé un bug dans l'algorithme de projection avec direction de
   recherche imposée (l'algorithme n'est alors plus un Newton). Il est appelable pour toutes
   les méthodes de contact en spécifiant TYPE_APPA='FIXE'.
   
   Correction
   ==========
   
   En 3D, on initialisait une matrice de taille 2x2 comme si elle était de dimension 3x3 d'où
   un possible écrasement mémoire.
   On corrige dans MMNEWD.f
   
   Résultats faux
   ==============
   
   L'écrasement a pu produire de mauvais projetés et donc de mauvaises conditions de contact.
   Néanmoins ce type d'appariement est très peu utilisé.
   
   Correction à reporter en V9 (routine inchangée)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   astout tests avec TYPE_APPA='FIXE'
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 015037 DU 2010-05-05 16:35:23
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   Meilleure initialisation des noeuds contactants en formulation continue (CONTACT_INIT)
FONCTIONNALITE
   Contexte
   ========
   
   Dans le cadre du stage sur le benchmark NAFEMS, on étudie un emboutissage de tôle mince
   (Benchmark 3). La tôle n'est tenue que par le contact. On fait donc face au classique
   problème du mouvement de corps rigide.
   
   En formulation continue, l'utilisation de CONTACT_INIT permet en théorie de surmonter le
   problème : cela marche en élastique HPP mais conduit à un échec dans l'intégration de la
   LdC ou une divergence en grands déplacements.
   
   Analyse
   =======
   
   C'est normal : CONTACT_INIT='OUI' entraîne l'activation du statut de *tous* les points
   de contact. C'est mal car un point pour lequel le jeu initial n'est pas nul (ou
   interpénétré) n'a pas de raison d'être contactant.
   
   En jetant un oeil à l'image jointe, on comprend vite pourquoi en l'état actuel des choses
   on risque d'avoir des problèmes dans la LdC ou une divergence. Elle montre ce qu'entraîne
   l'utilisation de CONTACT_INIT suite à la prédiction. On voit que le jeu a été fermé
   partout (les points à l'extrémité de la plaque sont sur le prolongement de la tangente au
   poinçon).
   
   Proposition
   ===========
   
   On propose de n'activer le statut de contact d'un noeud que si le jeu en ce point est
   initialement nul ou interpénétré. Cela corrige la non-convergence.
   
   Validation
   ==========
   
   Astout contact continu.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   astout
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desroches    DESROCHES Xavier       DATE 05/07/2010 - 17:01:18

--------------------------------------------------------------------------------
RESTITUTION FICHE 015031 DU 2010-05-05 07:57:06
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   Dxc3xa9formations initiales dans l'xc3xa9lxc3xa9ment SHB8
FONCTIONNALITE
   Développement de l'option EPSI_INIT pour les éléments SHB 
   linéaires.
   
   Même te que pour les éléments 3D (te0049)
   Modification des catalogues 
   gener_meshb3.cata et phenmode.cata
   
   Test de la fonctionnalité dans SSLS101C en NON_REGRESSION.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   SSLS101C
NB_JOURS_TRAV  : 3.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR devesa       DEVESA Georges         DATE 05/07/2010 - 16:47:17

--------------------------------------------------------------------------------
RESTITUTION FICHE 015249 DU 2010-06-24 09:19:18
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Adapter le temps CPU du cas-test fdlv113a
FONCTIONNALITE
   Dans le test FDLV113A, on réduit le nombre de fréquences 
   calculées de 7 à 2 (1 et 21 Hz) en espérant passer cette fois-ci 
   sur clpaster en moins de 300 s. On garde donc un minimum de 
   tests de résultats significatifs.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test FDLV113A
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 015250 DU 2010-06-24 09:23:05
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW10.2.3, le cas-test miss05a s'arrete en erreur_<F> sur Bull et Calibre5
FONCTIONNALITE
   Le cas test MISS05a est cassé en effet à cause du traitement de 
   la fiche 14742 à la suite de la modification de la routine 
   COMP81 pour associer réduction des modes d'interface et sous-
   structuration statique.
   Dans le test MISS05A, on a bien réduction des modes d'interface 
   mais pas de sous-structuration statique et on n'a donc pas 
   besoin de préciser un concept d'interface dynamique dans la 
   définition de la base de Ritz qui assure la réduction modale à 
   l'interface. Dans ce cas, l'objet &&COMP81.NEUEXC nécessaire en 
   sous-structuration statique mais inactif ici n'est pas créé une 
   première fois d'où le message. Il suffit d'en tenir compte en 
   traitant l'absence d'interface dynamique associée à la réduction 
   modale à l'interface (3 lignes ajoutées), ce qui n'était pas 
   fait jusqu'à présent.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test MISS05a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR kazymyrenko  KAZYMYRENKO Kyrylo     DATE 05/07/2010 - 17:03:18

--------------------------------------------------------------------------------
RESTITUTION FICHE 014863 DU 2010-03-26 10:17:53
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Bornes sur le paramxc3xa8tre de pilotage mal gxc3xa9rxc3xa9es en cas de non-convergence
FONCTIONNALITE
   On a observé un comportement anormal de Code_Aster en cas de pilotage avec l'option 
   PROJ_BORNES= 'NON'
   
   Si, à un instant de calcul, les itérations successives ne parviennent pas à un état
   convergé, et qu'à l'état final (non convergé), le ETA_PILOTAGE est hors de l'intervalle
   [ETA_PILO_MIN , ETA_PILO_MAX], STAT_NON_LINE s'arrête en ENDED_OK.
   
   Un comportement cohérent devrait continuer le calcul en sous-découpant le pas de
   temps, la valeur finale de ETA_PILOTAGE n'ayant pas de sens si le pas de temps n'est pas
   convergé et juste ensuite s'arrêter si l'on est toujours hors intervalle [ETA_PILO_MIN ,
   ETA_PILO_MAX].
   ##############################################################################
   ####################### SOLUTION #############################################
   Impacte sources : nmconv.f
   ##########################
   Voici la modification, qui n'impacte que nmconv.f
   
   Au lieu de faire
   
      IF ((LICCVG(1) .EQ. -1)) THEN
          FINPAS = .TRUE.
      END IF      
   
   on fait
   
      IF ((LICCVG(1) .EQ. -1).AND.CONVER) THEN
          FINPAS = .TRUE.
      END IF   
   
   ce qui implique de faire ce test une fois que CONVER a été évalué. Ce n'est pas trop
   impactant, car FINPAS ne sert qu'au pilotage.
   
   ####################################################################################
   ############# REMARQUE SUR LA DOC ##################################################
   impacte doc : [U4.51.03]
   ########################
   Les explications consernantes le pilotage sont erronées dans la doc U4.51.03 de
   STAT_NON_LINE. Le sens de ETA_PILO_MAX/MIN est inversé avec celui de ETA_PILO_R_MAX/MIN.
   
   La signification de ETA_PILO_R_ et ETA_PILO_ est inversee dans la doc U4.51.03.
   ETA_PILO_MAX/MIN est couplé à l'option PROJ_BORNES. En resumant ceci donne:
   
   1) ETA_PILO_R_MAX/MIN sert a eliminer les solutions hors du domaine souhaite. C'est une
   condition stricte. A chaque iteration de Newton s'il y a pas de solutions dans cet
   intervalle on s'arrete en echeque de pilotage. (_R_ signifiant Recherche).
   2) ETA_PILO_MAX/MIN sert a aider la convergence en choisissant parmis toutes les solutions
   celles qui sont dans l'intervalle. S'il y en a pas de solution on retient toute et les
   filtre pas d'autre methode.
   PROJ_BORNE sert a preciser le comportement si l'on franchit les bornes ETA_PILO_MIN/MAX.  
   2a) ETA_PILO_MAX/MIN + PROJ_BORNES = 'OUI' sert a forcer la solution de rester dans le
   domaine souhaiter en projetant a chaque iteration de Newton sur le bord depasse. Arrete en
   non convergence est possible, car quand on projete sur les bornes c'est comme si on
   essayait de resoudre le probleme avec un chargement fix donne (ce qui converge pas toujours).
   2b) ETA_PILO_MAX/MIN + PROJ_BORNES = 'NON' laisse la solution evoluer meme si elle depaces
   les bornes ETA_PILO_MIN/MAX, mais si jamais ca converge toujours hors intervalle on s'arrete.
   En conclusion ETA_PILO_R_MIN/MAX controle la sortie en ECHEQUE_DE_POLITAGE via LICCVG(1)=1.
   La sortie lors de depacement de borne dans le cas ETA_PILO_MAX/MIN + PROJ_BORNES = 'NON'
   est controle via LICCVG(1)=-1. On doit arreter le calcul si a la fois on a depasse les
   bornes et on a converge. 
   Dans OP0070.f on utilise la variable FINPAS pour arrete le calcul, comme si on est au
   dernier pas de temps.
   C'est alors cette variable qui doit etre utilisee pour arreter le calcul ETA_PILO_MAX/MIN
   + PROJ_BORNES = 'NON' avec les bornes depasses. La solution proposee par Martin me semble
   le plus appropriee. La seule sortie/arret modifie est liee a un calcul explicite. Mais
   comme le pilotage n'a pas de sens dans ce cas, on n'affecte pas l'architecture de sorties
   possibles.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.51.03, R5.03.80
VALIDATION
   tous les cas tests avec du pilotage
NB_JOURS_TRAV  : 5.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 015017 DU 2010-04-30 11:45:49
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Pilotage
FONCTIONNALITE
   il y a une faute dans nmdoet qui faisait que 
   ZR(JDEPOL+I-1) était toujours mis à zéro:
   nmdoet fait un test sur ANGL_NORM_DEPL (l'option qui n'existe pas dans Aster) au lieu de 
   ANGL_INCR_DEPL pour initialiser ce vecteur.
   
   cette faute de frappe à été corrigé.
   
   impacte source: nmdoet.f
   
   Pour la modification du critère de pilotage (voir en bas) on propose de faire l'ensemble
   de modifs dans la fiche d'évolution 14731. Sinon avec un avantage limité pour
   l'utilisateur ca risque de l'embrouiller (passage automatique ANGL_INCR_DEPL vers
   NORM_INCR_DEPL). On peut choisir un autre nom pour le critère du choix des solutions
   AUTO_INCR_DEPL et faire tous ce que propose Patrick (fiche 14731) la dedans.
   
   #################################### PROPOSITION INITIALE ###########################
   La routine nmceai est clairement fausse pour le pilotage
   via ANGL_INCR_DEPL: 
   en effet on regarde le cosinus de l'angle entre la nouvelle 
   solution (au sens incrément) et celle du pas de temps précédent.
   Or dans la programmation actuelle, on oublie de renormaliser 
   par le déplacement du pas de temps précédent. 
   Certes, cela évite que ANGL_INCR_DEPL ne plante pas au premier 
   pas de temps du calcul, mais c'est faux.
   On préconise donc de renormaliser par le déplacement initial et 
   de remplacer la programmation 
   NODUP=NODUP+(ZR(JDEPDE+I-1)+RHO*ZR(JDU0+I-1)+ETA*ZR(JDU1+I-1))
   **2
   par 
   NODUP1= NODUP1 + (ZR(JDEPDE+I-1)+RHO*ZR(JDU0+I-1)+ETA*ZR(JDU1+I-
   1))**2
   NODUP2= NODUP2+ ZR(JDEP0L+I-1)**2
   NODUP = NODUP1*NODUP2
   En faisant cela, on observe bien des cosinus variant en -1 et 
   +1.
   Par ailleurs ANGL_INCR_DEPL ne peut pas fonctionner au premier 
   par de temps. Ce que l'on propose c'est que dans le cas où l'on 
   détecte NODUP=NODUP1*NODUP2=0 on repasse automatiquement en 
   NORM_INCR_DEPL (ce qui fait d'ailleurs du sens).
   Cette correction permet par ailleurs d'utiliser assez 
   astucieusement le pilotage à la fois en charge et en décharge 
   (au sens contrôle en déplacement qui n'est pas forcément 
   monotone croissant).
   
   ################## PRECISION ANGL_INCR_DEPL #########################
   
   La routine nmceai donne le critère de minimisation de l'angle entre la solution au pas de
   temps précédent et la prédiction actuelle. Bien qu'elle calcule le cosinus à un préfacteur
   constant près, elle n'est pas fausse. La renormalisation du critère proposée pour obtenir
   le cosinus exactement est à mon avis pas pertinante, car
   1) Justement cela évite que ANGL_INCR_DEPL ne plante pas au premier pas de temps du calcul
   2) Supposons qu'on accepte les modifs. Ca n'a pas de sens de basculer de ANGL_INCR_DEPL
   vers NORM_INCR_DEPL quand NODUP1 = 0, car NORM_INCR_DEPL utilise NODUP1 comme critère de
   choix. Donc il reste juste le basculement de ANGL_INCR_DEPL vers NORM_INCR_DEPL quand
   NODUP2 = 0, c'est à dire l'état initial qui n'a pas bougé. Dans ce cas on est soit au
   premier pas de temps, soit on est ramené pile poile vers l'état initial en pilotant. Ceci
   est réalisable numériquement seulement, à mon avis, si l'on pilote sur tous les noeuds en
   charge-décharge. Je pense que ce n'est pas une utilisation appropriée du pilotage.
   3) Les modifications rendront la lecture du code plus complexe, car l'option
   ANGL_INCR_DEPL  obtiendra une certaine intelligence à la WINDOWS et l'utilisateur ne sera
   pas ce que fait le pilotage exactement.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   liste cas tests avec le pilotage
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR proix        PROIX Jean-Michel      DATE 05/07/2010 - 15:17:30

--------------------------------------------------------------------------------
RESTITUTION FICHE 014958 DU 2010-04-16 10:50:26
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   MN06 - Interfaxc3xa7age aux subroutines Abaqus UMAT
FONCTIONNALITE
   Demande
   =======
   Le but de cette fiche est d'offrir à terme aux utilisateurs de Code_Aster la possibilité
   d'utiliser une subroutine UMAT (i.e. User MATerial, subroutine Abaqus permettant
   d'intégrer une loi de comportement particulière). On cherche à limiter au maximum les
   modifications à réaliser sur la UMAT existante et le nombre de fichiers Code_Aster à
   surcharger. On se base sur la nouvelle architecture des lois de comportement qui facilite
   grandement ce chantier.
   
   Solution partielle proposée
   ===========================
   
   Ce développement illustre une interface avec une routine de type Umat (celle décrite dans
   la doc de Umat).  On restitue cette routine, bien qu'elle ne corresponde pas vraiment aux
   normes Aster (voir dernière remarque).
   
   On définit pour cela le nouveau comportement "UMAT", qui a pour numéro de LC : 50. Dans
   LC0050, on lit la température, les paramètres matériau (définis de façon arbitraire dans
   DEFI_MATERIAU sous le mot-clé facteur UMAT, et les mots-clés C1, C2, ... C50), le nombre
   de variables internes (défini sous COMP_INCR par NB_VARI, comme pour Zmat). La routine
   lc0050 appelle alors la routine umat.f, restituée comme exemple.
   
   Ceci est conforme à une partie des conclusions de la RTA du 12/05/2010 :
   - Dans un premier temps au moins, on ne pourra avoir qu'un UMAT. OK
   - defi_materiau : mettre 50 paramètres. OK
   - sortie des énergies : pour le moment, vers /dev/null. Ce serait un champ de sortie
   supplémentaire dans merimo ou bien dans des variables internes + impact tous les
   catalogues d'éléments. De même pas de couplage thermomécanique pour le moment.
   - umat.py : nb_vari=0, nom_vari=vide et ajouter un mot-clé dans COMP_INCR (comme ZMAT) OK
   
   Ce qui reste à faire (fiche 15297)
   ====================
   
    - routines utilitaires : les rendre accessibles dans aster (faire des chapeaux vers les
   routines aster, vérifier les droits) : bibfor/umat (fiche EL 15299)
   - alarme si UMAT (faire aussi pour ZMAT)
   - les sources UMAT seront donnés dans astk/surcharge, nouveau type "lib" => l'utilisateur
   se débrouille pour fabriquer son .so (aide dans doc U).
   => on essaie de lui fabriquer : répertoire de sources fourni dans astk (type "srclib")
   (tester si on peut appeler un module objet aster depuis la .so)
   - cas-test : mettre le source fortran dans xxxx.44, dans le .comm, on compile 
   le fortran (avec gfortran), on fabrique la .so
   
   Cette restit est donc partielle. Une fiche est émise pour mettre en oeuvre ce dernier
   point (15297)
   
   Validation 
   ==========
   Le test umat001a correspond à un problème thermo-élastique AXIS (issu de SSNA106a). On
   compare la solution Aster (ELAS) et la solution UMAT. Cela permet de valider aussi la
   bonne prise en compte des températures.
   Remarque : le comportement viscoélastique linéaire intégré par umat.f n'existe pas dans
   Aster.  C'est pourquoi on se limite à l'élasticité en donnat des valeurs nulles aux
   coefficients  C3, C4, C5.
   
   Avec le même comportement (UMAT, et C3=C4=C5=0), on restitue le test UMAT002A qui
   s'inspire des tests COMPxxx : cela permet d'avoir un trajet de chargement
   multi-directionnel dans l'espace des déformations, de tester les rotations, le changement
   d'unités, la matrice tangente.
   
   Remarque importante 
   =================
   Au passage on se rend compte que les conventions utilisées dans les UMAT ne sont pas les
   mêmes que dans Aster : en particulier les termes 4,5,6 des déformations correspondent à
   Gamma_XY = 2 Eps_XY, etc..
   
   Cela peut donc poser problème si on n'y prend pas garde. Un pré traitement est effectué
   dans LC0050 pour faire la transposition, mais cela reste problématique, notamment avec
   GDEF_HYPO_ELAS, qui fait tourner le tenseur des déformations avant l'appel à NMCOMP. Il
   faudra retravailler cette question prochainement.
   
   Pour le moment, les seules déformations permises sont 'PETIT' et 'PETIT_REAC'.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.51.11, U4.43.01, V1.03.124, V1.03.125,
VALIDATION
   umat001a, umat002a
NB_JOURS_TRAV  : 5.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 015285 DU 2010-07-01 09:25:44
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW10.2.4, le cas-test ssnv171b est NOOK sur Bull.
FONCTIONNALITE
   En NEW10.2.4, le cas-test ssnv171b est NOOK sur Bull. Mais il était correct sur ma machine.
   
   Ceci était dû à un défaut d'initialisation du tableau contenant les angles d'Euler dans la
   routine PMINIT.
   
   Historique : Le test SSNV171b a été enrichi de SIMU_POINT_MAT + ANGL_EULER en 10.1.23 (5 mai)
   
   Depuis ce temps, ce défaut d'initialisation ne s'était pas manifesté. C'est maintenant réparé.
   
   Risque de résultat faux :
   ==========================
   
   Les résultats pouvaient être faux avec SIMU_POINT_MAT  / SUPPORT='POINT', et ANGL_EULER,
   dans le cas où on ne fournissait qu'un seul angle.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 10.1.23
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ssnv171b
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 015280 DU 2010-07-01 09:04:36
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW10.2.4, les cas-tests comp001b, comp002f, comp002g, comp003a et hsnv100j s'arretent anormalement sur Bull, Calibre5 et Rocks.
FONCTIONNALITE
   Probleme 
   ========
   
   En NEW10.2.4, les cas-tests comp001b, comp002f, comp002g, comp003a et hsnv100j s'arrêtent
   anormalement sur Bull, Calibre5 et Rocks. Le message d'erreur est le suivant:
   !  TypeError: simu_point_mat_ops() takes exactly 20 non-keyword arguments (14 given)    
   
   Ceci était dû à une erreur dans simu_point_mat_ops.py, et seulement dans le cas
   SUPPORT='ELEMENT'. En efeft j'ai ajouté la semaine dernière les mots-clés facultatifs
   MATR_C1, MATR_C2, VECT_IMPO, valables seulement dans la cas SUPPORT='POINT' (c'est à dire
   dans un bloc relatif à SUPPORT='POINT' dans simu_point_mat.CAPY. 
   
   Mais bêtement, je les ai mis en argument de SIMU_POINT_MAT_OPS.py. D'où le message
   d'erreur dans le cas où SUPPOR n'est pas égal à POINT. Je n'avais rien vu car tous les
   tests en liste restreinte ont SUPPORT='POINT'.
   
   Correction
   ==========
   
   Je corrige en enlevant des arguments de l'ops, et en interrogeant directement "args". Et
   je propose d'ajouter HSNV100J dans la liste restreinte (il n'est pas trop long :
    * TOTAL_JOB                :       7.79 :       0.53 :       8.32 :       8.46 )
   
   Validation
   ==========
   
   tous les tests comportant SIMU_POINT_mat SUR c5, bULL ET CLPASTER
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   comp001b, comp002f, comp002g, comp003a et hsnv100j
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 015283 DU 2010-07-01 09:18:24
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW10.2.4, le cas-test ssnd109a s'arrete en <F>_ERROR sur Rocks.
FONCTIONNALITE
   En NEW10.2.4, le cas-test ssnd109a s'arrete en <F>_ERROR sur Rocks.
   
   
   Ceci était dû à une mauvaise initialisation (encore une) dans op0033 sur la variable
   ACTION, introduite la semaine dernière, ce qui provoquait un arrêt prématuré de
   SIMU_POINT_MAT, d'où le message d'erreur, mais seulement sur Rocks !
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ssnd109a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 015281 DU 2010-07-01 09:09:14
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW10.2.4, les cas-tests forma03d et zzzz159a s'arretent en <F>_ERROR sur Rocks.
FONCTIONNALITE
   En NEW10.2.4, les cas-tests forma03d et zzzz159a s'arretent en <F>_ERROR sur Rocks.
   
   Le message d'erreur est le suivant:
   ! <F> <RECAL0_44>                                                                        
              !
   ! Problème de division par zéro dans la normalisation de la fonctionnelle.               
              !
   ! Une des valeurs de la fonctionnelle initiale est nulle ou inférieure à la précision
   machine : 0.00 !
   ! Cette erreur est fatale. Le code s'arrete.                                             
              !
   !----------------------------------------------------------------------------------------------------!
   
   Comme pour la fiche 15283, ce plantage était dû à une mauvaise initialisation dans op0033
   sur la variable
   ACTION, introduite la semaine dernière, ce qui provoquait un arrêt prématuré de
   SIMU_POINT_MAT, d'où le message d'erreur, mais seulement sur Rocks !
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   astout sur Rocks
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 015282 DU 2010-07-01 09:13:42
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW10.2.4, le cas-test ssna110a s'arrete en <F>_ERROR sur Rocks.
FONCTIONNALITE
   En NEW10.2.4, le cas-test ssna110a s'arrete en <F>_ERROR sur Rocks.
   
   Le message d'erreur est le suivant:
   
   "
      !-------------------------------------------------------!
      ! <F> <DVP_2>                                           !
      !                                                       !
      ! Erreur numérique (floating point exception).          !
      !                                                       !
      !                                                       !
      ! Cette erreur est fatale. Le code s'arrete.            !
      ! Il y a probablement une erreur dans la programmation. !
      ! Veuillez contacter votre assistance technique.        !
      !-------------------------------------------------------!
   
   Comme pour la fiche 15283, ce plantage était dû à une mauvaise initialisation dans op0033
   sur la variable
   ACTION, introduite la semaine dernière, ce qui provoquait un arrêt prématuré de
   SIMU_POINT_MAT, d'où le message d'erreur, mais seulement sur Rocks !
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   astout sur Rocks des tests SIMU_POINT_MAT
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR sellenet     SELLENET Nicolas       DATE 05/07/2010 - 16:28:13

--------------------------------------------------------------------------------
RESTITUTION FICHE 015265 DU 2010-06-29 06:11:25
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   perf011 : etude Epicure
FONCTIONNALITE
   Objet de la fiche :
   -------------------
   Ajout de l'étude Epicure comme nouveau cas test de performance : perf011.
   
   Nombre de noeuds  : 284 544
   Nombre de mailles : 158 400
   Nombre de ddl     : 864 574 dont 10 942 Lagrange
   
   Temps elapse sur Bull en séquentiel     : 2536,14 s
   Mémoire consomée sur Bull               : 2790,85 Mo
   
   On ajoute 2 modélisations perf011 a et b. la première sera séquentielle, la deuxième sera
   executée sur 4 procs.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   aucune
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 015291 DU 2010-07-02 08:28:26
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   Suppression, deplacement et couverture de code
FONCTIONNALITE
   Objet de la fiche :
   -------------------
   Nettoyage suite au passage de la couverture de code.
   
   
   Proposition :
   -------------
   Suppression de :
   agglom
   nmxma2
   jeinfb
   cnnoeu
   cnsoli
   nmdofu
   cofano
   coligr
   desagg
   nbnod2
   pjefpr
   pjefte
   
   Déplacement dans debug de :
   mmmtdb
   mmimp1
   dbgmpi
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   aucune
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST AJOUT perf011a                     sellenet N.SELLENET         586    586      0
 CASTEST AJOUT perf011b                     sellenet N.SELLENET         589    589      0
 CASTEST AJOUT sdls106c                        corus M.CORUS            327    327      0
 CASTEST AJOUT ssnv209m                        caron A.CARON            524    524      0
 CASTEST AJOUT ssnv209n                        caron A.CARON            525    525      0
 CASTEST AJOUT umat001a                        proix J-M.PROIX          193    193      0
 CASTEST AJOUT umat002a                        proix J-M.PROIX          271    271      0
 CASTEST MODIF comp001a                        proix J-M.PROIX          257      4      6
 CASTEST MODIF comp001b                        proix J-M.PROIX          383      2      2
 CASTEST MODIF fdlv113a                       devesa G.DEVESA           334     32     32
 CASTEST MODIF hsnv100j                        proix J-M.PROIX          122      3      3
 CASTEST MODIF ssls101c                    desroches X.DESROCHES        449     31      2
 CASTEST MODIF ssnp121j                       desoza T.DESOZA           247      2      2
 CASTEST MODIF ssnp121k                       desoza T.DESOZA           244      2      2
 CASTEST MODIF ssnv171b                        proix J-M.PROIX          187      2      2
 CASTEST MODIF ssnv182k                        caron A.CARON            224     19     22
 CASTEST MODIF ssnv182l                        caron A.CARON            215     17     18
 CASTEST MODIF ssnv187a                       desoza T.DESOZA           254      5      5
 CASTEST MODIF ssnv187b                       desoza T.DESOZA           270      5      5
 CASTEST MODIF ssnv187c                       desoza T.DESOZA           270      5      5
 CASTEST MODIF wtnv134b                        proix J-M.PROIX          515      2      2
CATALOGU MODIF compelem/phenomene_modelisation__  desroches X.DESROCHES       1591      2      2
CATALOGU MODIF typelem/gener_meshb3        desroches X.DESROCHES        326      9      5
CATALOPY MODIF commande/defi_materiau          proix J-M.PROIX         3113    134     23
CATALOPY MODIF commande/formule             courtois M.COURTOIS          50      6      3
CATALOPY MODIF commun/c_comp_incr              proix J-M.PROIX          146      4      1
CATALOPY MODIF commun/c_relation               proix J-M.PROIX          150      2      1
FORTRAN90 DEPLA utilitai/dbgmpi                debug/ sellenet        N.SELLENET         115      0      0
 FORTRAN AJOUT algorith/lc0050                 proix J-M.PROIX          272    272      0
 FORTRAN AJOUT algorith/umat                   proix J-M.PROIX          192    192      0
 FORTRAN AJOUT prepost/xpolsn                  caron A.CARON            135    135      0
 FORTRAN MODIF algorith/cfchoi                desoza T.DESOZA           155     10      2
 FORTRAN MODIF algorith/cfproj                desoza T.DESOZA           230     11      6
 FORTRAN MODIF algorith/chmano                desoza T.DESOZA           268      3      3
 FORTRAN MODIF algorith/comp81                devesa G.DEVESA           379      5      2
 FORTRAN MODIF algorith/mappar                desoza T.DESOZA           392     13      5
 FORTRAN MODIF algorith/mmjeux                desoza T.DESOZA            84      5      4
 FORTRAN MODIF algorith/mmnewd                desoza T.DESOZA           212      3      7
 FORTRAN MODIF algorith/mmrema                desoza T.DESOZA            99      5      4
 FORTRAN MODIF algorith/nmconv            kazymyrenko K.KAZYMYRENKO      515      9     10
 FORTRAN MODIF algorith/nmdocc                 proix J-M.PROIX          244      5      1
 FORTRAN MODIF algorith/nmdoet            kazymyrenko K.KAZYMYRENKO      493      3      3
 FORTRAN MODIF algorith/op0033                 proix J-M.PROIX          345      2      1
 FORTRAN MODIF algorith/pmdorc                 proix J-M.PROIX          187      3      1
 FORTRAN MODIF algorith/pminit                 proix J-M.PROIX          347      4      1
 FORTRAN MODIF algorith/xdecqu                 caron A.CARON            388      9      9
 FORTRAN MODIF algorith/xmrema                desoza T.DESOZA           370      2      2
 FORTRAN MODIF elements/te0514                 caron A.CARON            361      2      2
 FORTRAN MODIF prepost/op0187                  caron A.CARON            145      4      4
 FORTRAN MODIF prepost/op0196                  caron A.CARON            197      4      8
 FORTRAN MODIF prepost/xpoajc                  caron A.CARON            166     21     14
 FORTRAN MODIF prepost/xpoajd                  caron A.CARON            300     60     48
 FORTRAN MODIF prepost/xpoajm                  caron A.CARON            150     21     14
 FORTRAN MODIF prepost/xpoajn                  caron A.CARON            136     22     34
 FORTRAN MODIF prepost/xpocmp                  caron A.CARON            145     36     14
 FORTRAN MODIF prepost/xpoco2                  caron A.CARON            177      7      7
 FORTRAN MODIF prepost/xpodim                  caron A.CARON            314     12     13
 FORTRAN MODIF prepost/xpomac                  caron A.CARON            152      2      2
 FORTRAN MODIF prepost/xpomax                  caron A.CARON            532    105     29
 FORTRAN MODIF prepost/xposep                  caron A.CARON            226     15      4
 FORTRAN MODIF utilitai/rgndas                 corus M.CORUS            216      6      1
 FORTRAN SUPPR algorith/agglom              sellenet N.SELLENET          51      0     51
 FORTRAN SUPPR algorith/cofano              sellenet N.SELLENET         291      0    291
 FORTRAN SUPPR algorith/desagg              sellenet N.SELLENET          44      0     44
 FORTRAN SUPPR algorith/nmdofu              sellenet N.SELLENET          75      0     75
 FORTRAN SUPPR algorith/nmxma2              sellenet N.SELLENET         133      0    133
 FORTRAN SUPPR calculel/cnnoeu              sellenet N.SELLENET          61      0     61
 FORTRAN SUPPR calculel/cnsoli              sellenet N.SELLENET          58      0     58
 FORTRAN SUPPR calculel/pjefpr              sellenet N.SELLENET          23      0     23
 FORTRAN SUPPR calculel/pjefte              sellenet N.SELLENET          23      0     23
 FORTRAN SUPPR jeveux/jeinfb                sellenet N.SELLENET          54      0     54
 FORTRAN SUPPR modelisa/coligr              sellenet N.SELLENET         237      0    237
 FORTRAN SUPPR modelisa/nbnod2              sellenet N.SELLENET         139      0    139
  PYTHON AJOUT Comportement/umat               proix J-M.PROIX           38     38      0
  PYTHON MODIF Build/B_ETAPE                courtois M.COURTOIS         808      4      4
  PYTHON MODIF Macro/simu_point_mat_ops        proix J-M.PROIX          670     14     10
  PYTHON MODIF Messages/modelisa4           sellenet N.SELLENET         415      1      5
  PYTHON MODIF Messages/modelisa5           sellenet N.SELLENET         370      6      7


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :   11        3652      3652             +3652
 MODIF :   54       19535       722     424      +298
 SUPPR :   12        1189              1189     -1189
 DEPLA :    1         115 
         ----      ------     ------  ------   ------
 TOTAL :   78       24491      4374    1613     +2761 
