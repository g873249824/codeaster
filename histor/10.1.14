

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR abbas        ABBAS Mickael          DATE 09/03/2010 - 14:50:54

--------------------------------------------------------------------------------
RESTITUTION FICHE 014720 DU 2010-03-03 16:23:25
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   ELAS_HYPER
FONCTIONNALITE
   Vu sur le forum.
   
   
   La loi ELAS_HYPER s'arrête en erreur fatale lorsque l'élongation devient nulle.
   Ce n'est pas très sympathique pour l'utilisateur. On propose de retourner un code retour
   d'erreur type LdC pour forcer le redécoupage dans ce cas.
   
   On en profite pour faire trasniter les messages d'erreurs d'algorith3.py vers elashyper.py
   et pour les rendre plus compréhensibles (et en français !)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ssnv187,ssnv189
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 014545 DU 2010-02-02 10:26:06
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Alarme sur l'observation en NEW10
FONCTIONNALITE
   Le cas-test SSNV104E a une nouvelle alarme en NEW10 alors qu'elle n'y était pas en STA10 : 
   
   !----------------------------------------------------------------!
   !.<A>.<OBSERVATION_79>...........................................!
   !................................................................!
   !................................................................!
   !..DDL.inconnu.sur.le.noeud.ou.la.maille.specifiée.pour.le.suivi.!
   !................................................................!
   !................................................................!
   !................................................................!
   !.Ceci.est.une.alarme..Si.vous.ne.comprenez.pas.le.sens.de.cette.!
   !.alarme,.vous.pouvez.obtenir.des.résultats.inattendus.!.........!
   !----------------------------------------------------------------!
   
   Effectivement, la routine DYOBAR émet cette alarme alors qu'elle ne devrait pas.
   Si on suit un CHAM_NO, DYOEXT (appelé par DYOBAR) retourne le numero de noeud/de
   composante à extraire. Si c'est un CHAM_ELGA, on retourne directement la valeur du champ,
   INOEUD et ICMP restant indéfinis (non initialisés).
   Or le test émettait l'alarme qui ne faisiat pas la distinction CHAM_ELEM/CHAM_NO. Pas de
   chance, INOEUD/ICMP était non-initialisés à non-zéro jusque là. 
   Correction: dans DYOEXT, on met INOEUD=ICMP=1 (différent de zéro) pour le cas CHAM_ELGA.
   
   Autre bug: ce test vérifie l'affichage et til y a un problème pour la colonne INCR_TPS
   
   INSTANT DE CALCUL :  1.000000000E-01
    
   -----------------------------------
   |   ITERATIONS   |   INCREMENT    |
   |     NEWTON     |     TEMPS      |
   |                |                |
   -----------------------------------   
   | 0              |*****           |
   -----------------------------------    
   | 0            X |*****           |    
   | 1              |*****           |
   -----------------------------------    
   | 0            X |*****           |  
   | 1              |*****           |
   -----------------------------------   
   | 0            X |*****           |     
   | 1              |*****           |
   -----------------------------------
   
   Mauvais choix de la précision d'affichage. Je modifie le cas-test.
   
   
   A faire en 9.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   visuelle
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 014539 DU 2010-02-01 16:51:44
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   La fonctionnalitxc3xa9 COEF_MASS_SHIFT (shift de masse) n'est plus active dans DYNA_NON_LINE en NEW10
FONCTIONNALITE
   En NEW10, que l'on mette ou pas COEF_MASS_SHIFT non nul dans DYNA_NON_LINE ne change 
   absolument rien alors que cela joue toujours en STA10.
   
   Cette fonctionnalité sert à accélérer la convergence en dynamique ou même parfois lui est
   indispensable. Le problème c'est qu'elle est testée dans le cas test WDNP101B de calcul
   sismique d'une colonne de sol avec loi de Hujeux où elle accélérerait seulement la
   convergence et sans elle, on aurait quand même un résultat.
   
   L'erreur introduite dans DYNA_NON_LINE a été suivie de très près par des modifs dans les
   lois de Hujeux, on a donc accusé (à tort) ces dernières modifs d'être à l'origine du
   problème de convergence de wdnp101b.
   
   De plus, COEF_MASS_SHIFT a été mal reprogrammée:
   - elle doit marcher pour tous les schémas en temps (et non pas seulement pour l'explicite !)
   - le décalage ne doit être fait qu'au premier instant
   
   En dynamique, on a la matrice assemblée globale MATASS qui vaut une combinaison linéaire
   des matrices rigidité, masse et amortissement:
   
   MATASS = a . M + b . C + d . K
   
   COEF_MASS_SHIFT décale la matrice masse de la manière suivante
   M' = M + h.K1 (avec h = COEF_MASS_SHIFT)
   
   MATASS = a . M' + b . C + d . K
   
   Subtilité:
   - le K1 est la matrice tangente en prédiction, la matrice masse est donc modifiée au tout
   début, premier pas de temps, première itération (prédiction) et on utilise M' à la place
   de M tout au long du calcul
   
   Remarques:
   - ce décalage n'est pas fait pour le calcul de l'accélération initiale
   - la matrice masse utilisée dans le calcul de l'amortissement de Rayleigh est la matrice
   masse non-décalée au premier pas de temps, puis la matrice décalée ensuite !
   - en explicite, cette stratégie coûte l'évaluation de la matrice de rigidité (uniquement
   au premier pas de temps)
   
   Corrections dans:
   accel0.f  
   ndlect.f  
   nmcoma.f  
   nmmatr.f  
   nmprma.f
   dibcle.f  
   nmchoi.f  
   nminit.f  
   nmprac.f
   
   
   Validation dans wdnp101b: on remet INV_K_EAU = 1./K_EAU  à la place INV_K_EAU = 1.E-7
   (c'était une astuce pour que ça converge !) 
   Ce qui rend wdnp101a et b cohérents du point de vue des données.
   
   Impact doc. 
   R5.05.05: préciser les restrictions d'usage de COEF_MASS_SHIFT (la matrice masse est
   inchangée en accel. init.), on calcule la matrice masse à partir de la matrice de rigidité
   en PREDICTION, il faut l'écrire dans la doc !
   V7.34.101: doc V de wdnp101
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V7.34.101,R5.05.05
VALIDATION
   wdnp101
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 014512 DU 2010-01-27 15:19:02
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   RESI_COMP_RELA passage en RESI_GLOB_MAXI
FONCTIONNALITE
   Lors de la RTA sur l'introduction du nouveau critère RESI_COMP_RELA, on avait demandé à ce
   qu'Aster repasse automatiquement en RESI_GLOB_MAXI en cas de valeur nulle (comme
   RESI_GLOB_RELA).
   
   Le passage se fait bien mais on n'affiche pas de message.
   
   On modifie nmconv.f
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   visuelle
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 014374 DU 2010-01-06 09:13:06
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Affichage du tableau de convergence en REAC_GEOM='SANS' - episode 3
FONCTIONNALITE
   L'affichage en REAC_GEOM='SANS' pour le contact a un problème : la dernière ligne de
   convergence est affichée 2 fois.
   
   Corrigé
   
   
   On profite de l'occasion pour afficher le nombre de points de contact esclaves en méthode
   continue et pour supprimer "NOMBRE MAXIMUM D'ITERATIONS ATTEINT" quand on converge en
   exactement ITER_GLOB_MAXI itérations.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   visuelle
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 014705 DU 2010-03-01 14:28:32
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Bug recherche linéaire mixte
FONCTIONNALITE
   Ainsi que le soupçonnait Nicolas Tardieu, il y a bien un bug dans la recherche linéaire
   mixte.
   On teste RESI_INTE_RELA par rapport à la valeur absolue, ce qui empeche la recherche
   linéaire mixte de fonctionner correctement dans le cas où la fonctionnelle est négative.
   
   
   Dans NMREBO, il faut
   
   IF (ABS(FOPT) .LT. FCVG) THEN
   ...
   ENDIF
   
   Sinon, en cas de fonctionnelle négative, même si on a pas atteint un optimum on sort de la
   boucle !
   Dans ssna114a, c'est assez spectaculaire.
   Sans correction, la recherche linéaire ne fait AUCUNE itération, quelque soit la valeur de
   RESI_INTE_RELA.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   liste restreinte
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR berard       BERARD Alexandre       DATE 08/03/2010 - 11:42:14

--------------------------------------------------------------------------------
RESTITUTION FICHE 014577 DU 2010-02-08 10:08:06
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   Message <CALCULEL5_3> ambigu
FONCTIONNALITE
   Descriptif
   ==========
   
   Le message <CALCULEL5_3>, reproduit ci-dessous, peut prêter à confusion au niveau du deuxième paragraphe.
      
      !-----------------------------------------------------------------------------------------------!
      ! <EXCEPTION> <CALCULEL5_3>                                                                     !
      !                                                                                               !
      ! Erreur Utilisateur :                                                                          !
      !   On cherche à regrouper des éléments finis en "paquets" de façon à ce que la taille de leurs !
      !   matrices élémentaires ne puisse pas dépasser la taille des blocs définis dans :             !
      !   DEBUT / MEMOIRE / TAILLE_BLOC                                                               !
      !                                                                                               !
      !   Malheureusement, la taille indiquée ne permet pas de mettre 1 seul élément dans le paquet.  !
      !                                                                                               !
      ! Conseil :                                                                                     !
      !   Il faut augmenter la valeur du paramètre  DEBUT / MEMOIRE / TAILLE_BLOC                     !
      !                                                                                               !
      !-----------------------------------------------------------------------------------------------!
   
   J'avais interprété la phrase comme "il n'est pas possible de ne mettre qu'un élément", sous-entendu : il 
   en faut au moins deux.
   
   
   Proposition
   ===========
   
   Remplacer la phrase par "Malheureusement, la taille indiquée ne permet même pas de mettre un élément 
   dans le paquet."
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   Aucune
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR colombo      COLOMBO Daniele        DATE 08/03/2010 - 16:20:39

--------------------------------------------------------------------------------
RESTITUTION FICHE 014312 DU 2009-12-16 14:43:45
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
   X-FEM : distorsion des level sets aux bords du domaine par la mxc3xa9thode upwind (PROPA_FISS)
FONCTIONNALITE
   Dans le cadre de la simulation de la propagation de fissures X-FEM (opérateur PROPA_FISS),
   des problèmes de distorsion des level sets aux bordes du domaine de calcul (maillage de la
   structure ou grille auxiliaire) ont été détectés. Cela peut déterminer des erreurs sur la
   position calculée du fond de la fissure et des modifications de la surface de fissure
   existante.
   
   Seulement la méthode upwind est affectée par ce problème.
   
   
   ANALYSE DU PROBLEME
   -------------------
   
   Il s'agit d'un problème de conditions aux limites.
   
   En général la condition actuellement utilisée (gradient de la level set égal à zéro) ne
   pose pas des problèmes dans les cas où la géométrie des bordes du domaine est régulière
   (les bordes sont des droits en 2D ou des plans on 3D) et la fissure (lsn=0) n'est pas
   proche à les zones où ces droits et ces plans se croisent. Cela est vrai dans tous les cas
   test Aster et en général dans tous les cas où une grille auxiliaire est utilisée (à mon
   avis l'utilisateur n'a pas envie de créer une grille auxiliaire avec des bordes
   géométriquement compliqués et il utilise des rectangles en 2D et des parallélépipèdes
   rectangles en 3D).
   
   Par contre, cela n'est pas vrai si on utilise la localisation du domaine, disponible à
   partir de la version NEW10.1.2. Dans ce cas le domaine coïncide avec un tore construit
   autour du fond de la fissure.
   
   Si on utilise la condition aux limites grad(level set)=0, dans la mise à jour des level
   sets on ne tient pas en compte les composantes du gradient qui sortent du domaine de
   calcul. Cela coïncide avec l'affectation d'un gradient parallèle au bord du domaine, ce
   qui fait que la level set se déforme de façon tale d'être orthogonale au bord.
   
   
   
   SOLUTION
   --------
   
   La méthode upwind ne peut pas être utilisée pour les points du bord du domaine où le point
   duquel on a besoin pour calculer le gradient de la level set est inexistant, c'est-à-dire
   à l'exterieur du domaine de calcul. L'extrapolation de la valeur de la level set à ces
   points en utilisant la valeur aux points voisins rende la méthode très instable. En fait,
   par sa nature, cette méthode utilise seulement les informations en amont (c'est-à-dire
   «upwind») par rapport à la direction de propagation de l'information (gradient des level
   sets) et la sélection des bons points voisins n'est pas facile à faire.
   
   Pour ces points problématiques on impose donc directement la solution cherchée en
   utilisant la définition de level set: on calcule la distance normale ou tangentielle du
   point à la surface ou au fond de la fissure.
   
   Le calcul de cette distance est fait de la même façon de celle déjà utilisée par la
   routine xprls0.f (qui appelle xproj.f). Pour bien calculer la distance, les points qui ont
   la projection à l'extérieur de la surface de la fissure doivent être traités de façon
   différente des ceux qui ont la projection à l'intérieur de la surface. Pour ces points la
   distance à calculer est celle qui est obtenue en utilisant une prolongation de la surface
   de la fissure.
   
   
   PERFORMANCE
   -----------
   
   La performance de la méthode est un peu pénalisée par cette nouvelle condition aux
   limites. Pour les cas test la différence n'est pas grande chose. Par contre, pour des cas
   de propagation 3D hors plan en modèles de taille beaucoup plus élevée, j'ai constaté que
   le temps de calcul est environ 10% plus élevée que avant.
   Dans le cas où la restriction du domaine n'est pas utilisée, la performance est très
   pénalisée parce que on impose la bonne solution à des points qui sont loin du fond de la
   fissure et beaucoup d'itération d'intégration sont nécessaire pour faire propager
   l'information du fond à ces points. Dans ce cas on a choisi donc de conserver la condition
   grad=0 même si la level set n'est pas bien calculée aux bords du domaine parce que le fond
   de fissure est loin des bords, comme déjà expliqué. Si cela cause des mauvais résultats,
   l'utilisateur peut toujours activer la restriction du domaine, ce qui permet de gagner
   aussi en performance.
   
   
   CAS TEST
   --------
   
   Pour éviter les problèmes liés à la distorsion de la level set, les cas test pour lesquels
   la méthode upwind est utilisée avec restriction du domaine et sans une grille auxiliaire
   ont été interdits avec la restitution de la fiche 13983, c'est-à-dire que pour ces cas
   test la restriction du domaine à été désactivé en ajoutant ZONE_MAJ='TOUT'.
   Avec la restitution de cette fiche on réactive la restriction du domaine pour les cas test
   upwind suivantes: sslp318a, sslp319a, sslp321c, sslv314d, sslv315d, sslv316a, ssnv185q.
   
   On harmonise aussi la tolérance utilisée dans le cas test sslv321c (de 3% à 5%) à celle
   déjà utilisée dans la modélisation b du même cas test (changée en NEW10.0.23).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : R7.02.12, V3.02.321
VALIDATION
   tous les cas test X-FEM PROPA_FISS
NB_JOURS_TRAV  : 25.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR debonnieres  DE BONNIERES Philippe   DATE 09/03/2010 - 16:45:48

--------------------------------------------------------------------------------
RESTITUTION FICHE 014739 DU 2010-03-05 13:42:40
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   correction des tests ssnv214a et ssnv216a
FONCTIONNALITE
   Correction de 2 cas-tests de la loi RAG SSNV214A et SSNV216A
   
   1) Suite au changement de l'element sur lequel s'appuyait le test de traction simple 
   cyclique SSNV214A, le chargement (en deplacement impose) etait devenu trop faible par 
   rapport a la reference experimentale. Donc, pour que la validation soit aussi "poussee" 
   en terme de chargement que la STA8, on rectifie le chargement.
   
   2) Les coefficients de fluage du test SSNV216A n'etaient pas les bons. On modifie donc le 
   cas-test en introduisant les valeurs fournies par Etienne Grimal.
   
   Dans les deux cas, les valeurs de reference sont obtenues en faisant tourner le test en 
   STA8.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V6.04.214 V6.04.216
VALIDATION
   SSNV214A  SSNV216A
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desoza       DE SOZA Thomas         DATE 09/03/2010 - 14:00:08

--------------------------------------------------------------------------------
RESTITUTION FICHE 014709 DU 2010-03-02 12:59:26
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   Accélération de PERF009 avec MUMPS
FONCTIONNALITE
   Express
   =======
   
   Afin d'améliorer un petit peu les accélérations parallèles des modélisations D,E,F et G du
   cas-test utilisant MUMPS // PERF009, je désactive le raffinement de solution (qui ne sert
   ici qu'à donner une estimation de l'erreur et du conditionnement).
   Pour cela on renseigne RESI_RELA=-1.0 dans ces tests.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V1.01.262
VALIDATION
   perf009defg
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 014672 DU 2010-02-22 12:07:29
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   Nouveau cas-test de performances en parallxc3xa8le (PERF010)
FONCTIONNALITE
   Cas-tests de performances (suite)
   =================================
   
   On ajoute à la base des tests de perfs 5 modélisations d'un calcul thermo-mécanique
   linéaire sur le diabolo plein (sur la base de PERF008).
   
   Détails
   =======
   
   Les 4 modélisations (D,E,F,G,H) viennent en complément de celles restituées par N.
   Sellenet dans la fiche issue14738.
   Il s'agit ici d'utiliser le solveur linéaire MUMPS et d'activer les fonctionnalités :
   * partitionnement par sous-domaines (SD)
   * matrice distribuée
   * out-of-core (OOC)
   
   Ce qui différencie les 5 modélisations est le nombre de processeurs utilisés pour le
   calcul : de 1 à 16.
   Pour le cas à  8 et 16 processeurs, on désactive l'OOC car le gain en mémoire par
   processeur ne justifie alors plus la perte en temps (cf. CR-I23-2009-057 de O. Boiteau).
   
   Remarques
   =========
   
   Ce nouveau-test de performances utilisant MUMPS en parallèle permet de montrer que le gain
   apporté par le parallélisme peut énormément varier selon le type de problème étudié.
   Ainsi alors qu'avec PERF009 (pompe RIS), l'efficacité // ne dépasse pas 40% sur 8
   processeurs, elle atteint ici 60% (speed-up de 5 sur 8 procs).
   
   Pour pouvoir restituer les tests en INFO=2, je corrige un bug dans AMUMPT.F, qui empêche
   MUMPS de marcher dans ce mode d'affichage (cf issue14659).
   
   Documentation
   =============
   
   La documentation avec toutes les modélisations (OpenMP et MUMPS) sera restituée une fois
   les tests passés mercredi prochain.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V1.01.263
VALIDATION
   perf010*
NB_JOURS_TRAV  : 1.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 014565 DU 2010-02-04 17:03:57
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW10.1.9, le cas-test sdnv104a s'arrete par manque de temps CPU sur Bull
FONCTIONNALITE
   Anomalie
   ========
   
   Le cas-test SDNV104A s'arrête par manque de temps CPU sur Bull en 10.1.13. C'est un
   cas-test de contact et frottement avec résolution par Lagrangien en 2D.
   
   Correction
   ==========
   
   Le nombre d'itérations de Newton de ce test est beaucoup plus important depuis
   l'introduction de DEFI_CONTACT.
   Cela est dû à un petit "bug" dans CFJEIN : à chaque réappariement on rendait toutes les
   liaisons actives adhérentes. Auparavant en STA10.1, il y a avait mémorisation d'un
   appariement à un autre (ce qui n'était pas licite dans la mesure où le nombre de liaisons
   pouvait avoir changé). Depuis l'introduction de DEFI_CONTACT, on repart donc de "zéro" dès
   qu'il y a un nouvel appariement :
   - on détermine à nouveau les liaisons actives qui sont donc en contact
   - on ne fait rien de plus pour déterminer le statut adhérent/glissant, on laisse donc
   faire l'algorithme
   
   Cette façon de faire rend à nouveau les tests utilisant le Lagrangien en
   contact/frottement 2D rapides. Cependant elle casse les tests Lagrangien en
   contact/frottement 3D. On particularise donc pour l'instant : le problème restant sera
   traité dans la fiche issue14579.
   
   Validation
   ==========
   
   Astout contact discret. On observe : 
   * une amélioration des perfs sur les cas Lagrangien (contact frottement 2D)
   * le cas-test SSNV505H est NOOK : sur une valeur qui avait été modifiée à l'introduction
   de DEFI_CONTACT, on la rétablit comme elle était en STA10.1, le test est alors OK.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   astout contact discret
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 014516 DU 2010-01-28 10:03:58
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW10.1.3, le cas-test ssnv128u s'arrete anormalement sur Bull, Rocks, Calibre 4 et 5.
FONCTIONNALITE
   Anomalie
   ========
   
   Depuis l'introduction de DEFI_CONTACT, ssnv128u est cassé, il ne converge plus.
   
   Correction
   ==========
   
   Il y a un petit bug dans le calcul du jeu d'usure. Pour cela on récupère dans la carte
   d'usure la valeur à retirer au jeu observé.
   La carte d'usure est de type NEUT_R, c'est donc un champ à 90 composantes par éléments de
   contact (par point d'intégration donc). On en utilise cependant qu'une seule composante !
   
   Le décalage était mal fait et on lisait donc un mauvais jeu, ce qui finissait par faire
   diverger le calcul ... bien que les 2 autres tests d'usure fonctionnaient.
   
   Impact
   ======
   
   F : mmmbca.f, mmusur.f, mmusuc.f
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ssnv128u
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 012304 DU 2008-07-16 13:26:51
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   CTC3 - Cas-test de frettage sans température
FONCTIONNALITE
   Dans cette fiche on proposait l'introduction d'un cas-test de contact en illustrant
   comment prendre en compte l'assemblage par frettage (à ne pas confondre avec le "fretting").
   Pour cela la méthodologie consiste au lieu d'effectuer un chargement thermique (plus
   physique) :
   * à interpénétrer initialement les pièces mécaniques dans le maillage;
   * à faire un premier pas de charge sans forces extérieures;
   * et donc laisser le contact corriger cette interpénétration
   
   ==> C'est cette correction de l'interpénétration par le contact qui crée la précontrainte.
   
   Dans la mesure où :
   * un tel cas-test ne valide pas le contact de façon élémentaire (c'est plus une
   méthodologie) autrement que de vérifier qu'une interpénétration initiale ne pose aucun
   problème
   * cette méthodologie est déjà mise en oeuvre aussi bien dans des études EDF (T63, L. May)
   ou par la communauté Aster-libre (http://www.code-aster.org/forum2/viewtopic.php?id=13526)
   
   On choisit de solder sans suite sans restituer de nouveau cas-test. On mentionnera
   néanmoins la méthodologie dans la doc U2.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : U2.04.04
VALIDATION
   néant
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 011924 DU 2008-04-04 09:37:29
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   CTC2 - Amxc3xa9lioration algo projection
FONCTIONNALITE
   On abandonne l'idée de mieux initialiser l'algorithme de projection (un Newton) des
   formulations de contact car il s'est montré jusqu'à maintenant très robuste et peu coûteux
   en CPU.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   nxc3xa9ant
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR proix        PROIX Jean-Michel      DATE 09/03/2010 - 14:53:40

--------------------------------------------------------------------------------
RESTITUTION FICHE 014063 DU 2009-10-19 11:26:54
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
   Problxc3xa8mes grandes dxc3xa9formations ZMAT
FONCTIONNALITE
   Suite au travail de S.Quilici (ENSMP) le couplage Aster-Zmat en grandes transformations
   est maintenant réparé, et va être de nouveau accessible via le mot-clé GDEF_HYPO_ELAS.
   
   L'erreur était simplement due à des SQRT(2.) sur les termes de cisaillement, qui
   manquaient dans l'interface de grandes def., alors qu'elles étaient bien gérées en HPP.
   C'est pourquoi les tests restitués à l'époque, qui ne sollicitaient pas les cisaillemetns,
   ne permettaient pas de voir le problème.
   
   On restitue donc 2 tests supplémentaires : 
   - ZMAT008A, de même type que ssnd106 : barreau sousmis à de multiples tractions-rotations,
   et qui permet de vérifier le caractère onjectif du formalisme de grandes transformations
   de Zmat
   
   - ZMAT009A, cisaillement simple, dont la solution analytique en plasticité est connue
   
   La correction est à faire soit dans nmzmat.f, soit dans Zaster.c. J'ai une préférence pour
   Zaster.c,  car S.Quilici l'a amélioré. On aurait donc à EDF une version plus propre. Mais
   pour compiler Zaster.c et reconstruire la bbl zmat,  j'ai besoin de Mathieu...
   Je joins à la fiche le fichier Zaster.c
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V1.03.121, V1.03.122
VALIDATION
   zmat008a, zmat009a
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 014563 DU 2010-02-04 16:11:07
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   Elasticite cubique
FONCTIONNALITE
   L'évolution demandée consistait à développer l'élasticité cubique.
   
   C'est en fait un type particulier d'orthotropie, qui se traduit par une matrice 
   d'élasticité composée de 3 termes :
   
   C1111 (termes D(1,1), D(2,2) D(3,3)), 
   C1122 (termes D(i,j),i/=j, i=1,3, j=1,3) et 
   C1212 (termes D(4,4),D(5,5),D(6,6)). 
   
   la définition de l'élasticité cubique (cf doc Zmat page 14.8) est donc une restriction de
   l'élasticité orthotrope (cf doc R4.01.02 page 6).
   
   En fait il est facile de définir les coefficients de ELAS_ORTH pour répondre à ce besoin : 
   
   Il suffit de chercher E_T=E_L=E_N et NU_LT=NU_LN=NU_TN, et aussi G_LT tels que :
   
   y1111=E*(1-Nu**2)/(1-3*Nu**2-2*Nu**3)
   y1212=G_LT
   y1122=E*Nu*(1+Nu)/(1-3*Nu**2-2*Nu**3)
   
   y1111 et y1212 étant donnés,on obtient donc  E et Nu par :
   
   Nu=1.0/(1.0+y1111/y1122)
   E =y1111*(1.0-3.0*Nu**2-2.0*Nu**3)/(1.0-Nu**2)
               
   MAT1=DEFI_MATERIAU(  ELAS_ORTH =_F( E_L  =E,
                                       E_T  =E,
                                       E_N  =E,
                                       NU_LT=Nu,
                                       NU_LN=Nu,
                                       NU_TN=Nu,
                                       G_LT =y1212,
                                       G_LN =y1212,
                                       G_TN =y1212,
                                    ),
   
   Cela convient aux demandeur, mais comme Nicolas Rupin l'a fait remarquer , il faut se
   prémunir du cas où le dénominateur est nul (ce qui correspond à l'incompressibilité, Nu=0.5).
   
   Tout ceci est testé dans ZMAT010, par comparaison avec ce logiciel.
   L'impact doc, outre celle du test (V.01.123), concerne la doc R de l'orthotropie : on
   ajoute un paragraphe sur l'élasticité cubique.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : v1.03.123, R4.01.02
VALIDATION
   zmat010
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 013674 DU 2009-08-03 12:26:04
TYPE aide utilisation concernant Code_Aster (VERSION 7.0)
TITRE
   Problxc3xa8me raccord 3d-poutre en non linxc3xa9aire
FONCTIONNALITE
   Problème rencontré :
   ====================
   Nous avons tenté de réaliser des calculs de plasticité cristalline avec raccord 3D-poutre.
   Un premier test en élasticité semble donner de bons résultats, mais lors du passage en non
   linéaire la première itération de Newton du premier pas de temps prend 3 heures... Il est
   impossible d'envisager la réalisation d'un calcul mécanique dans ces conditions. Que
   peut-on faire ?
   
   Travail réalisé (par N.Rupin et JMP)
   ====================================
   Le document joint, écrit par Nicolas, détaille toutes les observations. Principalement :
   
   - Sur les faces de l'agrégat, qui comportent beaucoup de noeuds, le remplacement de
   conditions de Dirichlet (DDL_IMPO) par LIAISON_ELEM / 3D_POU conduit à moins de noeuds de
   Lagrange, mais un couplage entre tous les DDL de la face concernée. Ceci se traduit par
   une taille de matrice plus importante et un temps CPU pour la résolution 2 à 3 fois  plus
   grand (suivant la taille de l'agrégat) avec liaison_elem + MULT_FRONT. Mais avec MUMPS, on
   n'observe pas la même chose : le temps CPU de résolution avec liaison_unif + mumps est à
   peine supérieur au temps avec DDL_IMPO+MUMPS. De plus en parallèle, 4 proc, avec MUMPS,
   LAISON_ELEM devient plus rapide.
   
   un petit tableau : sur un agrégat à 172 grains, 40364 noeuds, 28434 Tetra10, les temps CPU
   en secondes, pour un transitoire conduisant à une déformation totale imposée de 1% :
   
   =================================
   .............DDL_IMPO......3D_POU
   ---------------------------------
   MULT_FRONT...10414.........19934
   MUMPS SEQ....9198..........11048
   MUMPS PAR....11690.........4580
   =================================
   
   Enfin, du point de vue mécanique, les liaisons 3D_POU sont importantes pour ce type de
   calcul car elles évitent des concentrations de contraintes et de déformations pres des bords.
   Grâce à MUMPS, on a donc le moyen de les employer. (voir doc joint)
   
   Remarquons aussi que GCPC avec préconditionneur MUMPS (LDLT_SP, proposé par Nicolas
   Tardieu) fournit aussi de très bons résultats, non altérés par la condition de raccord (je
   l'ai testé uniquement sur un petit agrégat à 6400 mailles, 1000 noeuds). Voici les résultats :
   
   ********************************************************************************
   Avec LIAISON_ELEM + MULT_FRONT    
      TEMPS POUR FACTORISATION MATRICE        :  2 m 22 s               
      TEMPS POUR INTEGRATION COMPORTEMENT     : 57 m 15 s               
   ********************************************************************************
   Avec LIAISON_ELEM + GCPC PRECOND LDLT_SP    
      TEMPS POUR FACTORISATION MATRICE        : 23 s                    
      TEMPS POUR INTEGRATION COMPORTEMENT     : 56 m  0 s               
   ********************************************************************************
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   aucune
NB_JOURS_TRAV  : 5.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR sellenet     SELLENET Nicolas       DATE 08/03/2010 - 13:44:39

--------------------------------------------------------------------------------
RESTITUTION FICHE 014636 DU 2010-02-16 08:31:09
TYPE evolution concernant Code_Aster (VERSION )
TMA : DeltaCad
TITRE
   Impression d'une sd_resu de type 'MODE_FLAMB'
FONCTIONNALITE
   Objectif
   ========
   L'impression au format MED d'un resultat de type 'MODE_FLAMB' est indexe par la valeur en
   dure "999.999" alors qu'on aurait prefere une indexation par la charge critique.
   
   Réalisation
   ============
   Le fichier irchme.f a ete enrichi pour prendre en compte l'acces "CHAR_CRIT" de la SD
   Resultat de type mode_flamb.
   
   Validation
   ==========
   - passage du cas-test fourni + verification de l'indexation avec l'utilitaire  xmdump +
   visualisation du champ avec SalomeMeca
   - liste restreinte
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   liste restreinte + cas test fourni
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR sellenet     SELLENET Nicolas       DATE 08/03/2010 - 12:57:14

--------------------------------------------------------------------------------
RESTITUTION FICHE 014738 DU 2010-03-05 12:58:09
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   perf010 a, b et c
FONCTIONNALITE
   Ajout de cas Tests de performance :
   -----------------------------------
   
   On ajoute à la base des tests de perfs 5 modélisations d'un calcul thermo-mécanique
   linéaire sur le diabolo plein (sur la base de PERF008).
   
   Le solveur utilisé est MULT_FRONT sur 1, 2 et 4 procs.
   
   J'en profite pour supprimer perf008e qui n'a plus de raison d'être.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   unitaire
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR tardieu      TARDIEU Nicolas        DATE 08/03/2010 - 18:22:03

--------------------------------------------------------------------------------
RESTITUTION FICHE 014711 DU 2010-03-02 15:59:46
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   MACR_LIGN_COUPE + CHAM_GD : pas de variables internes
FONCTIONNALITE
   Il s'agit d'un oubli dans le coeur de la macro lors de la détermination du type de
   résultat à créer quand on utilise un CHAM_GD (on fait alors un CREA_RESU pour se ramener
   au cas où l'on fournit une SD résultat). 
   On examine différents cas : température, déplacement, déformation, contrainte mais il n'y
   a pas de type variables internes.
   Je l'ajoute.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test zzzz162b
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST AJOUT perf010a                     sellenet N.SELLENET         117    117      0
 CASTEST AJOUT perf010b                     sellenet N.SELLENET         117    117      0
 CASTEST AJOUT perf010c                     sellenet N.SELLENET         117    117      0
 CASTEST AJOUT perf010d                       desoza T.DESOZA           121    121      0
 CASTEST AJOUT perf010e                       desoza T.DESOZA           138    138      0
 CASTEST AJOUT perf010f                       desoza T.DESOZA           138    138      0
 CASTEST AJOUT perf010g                       desoza T.DESOZA           138    138      0
 CASTEST AJOUT perf010h                       desoza T.DESOZA           138    138      0
 CASTEST AJOUT zmat008a                        proix J-M.PROIX          219    219      0
 CASTEST AJOUT zmat009a                        proix J-M.PROIX          177    177      0
 CASTEST AJOUT zmat010a                        proix J-M.PROIX          243    243      0
 CASTEST MODIF perf009d                       desoza T.DESOZA           121      2      1
 CASTEST MODIF perf009e                       desoza T.DESOZA           121      2      1
 CASTEST MODIF perf009f                       desoza T.DESOZA           121      2      1
 CASTEST MODIF perf009g                       desoza T.DESOZA           121      3      2
 CASTEST MODIF sslp318a                      colombo D.COLOMBO          264      1      2
 CASTEST MODIF sslp319a                      colombo D.COLOMBO          281      1      2
 CASTEST MODIF sslp321c                      colombo D.COLOMBO          226      4      4
 CASTEST MODIF sslv314d                      colombo D.COLOMBO          275      1      2
 CASTEST MODIF sslv315d                      colombo D.COLOMBO          293      1      2
 CASTEST MODIF sslv316a                      colombo D.COLOMBO          311      1      2
 CASTEST MODIF ssnd106a                        proix J-M.PROIX          227      1      1
 CASTEST MODIF ssnv104e                        abbas M.ABBAS            467      3      9
 CASTEST MODIF ssnv128u                       desoza T.DESOZA           249    179    156
 CASTEST MODIF ssnv129e                        abbas M.ABBAS            227     15      2
 CASTEST MODIF ssnv185q                      colombo D.COLOMBO          259      1      2
 CASTEST MODIF ssnv187a                        abbas M.ABBAS            254      1      1
 CASTEST MODIF ssnv187b                        abbas M.ABBAS            270      1      1
 CASTEST MODIF ssnv187c                        abbas M.ABBAS            270      1      1
 CASTEST MODIF ssnv189a                        abbas M.ABBAS            136      1      1
 CASTEST MODIF ssnv189b                        abbas M.ABBAS            136      1      1
 CASTEST MODIF ssnv189c                        abbas M.ABBAS            146      1      1
 CASTEST MODIF ssnv214a                   debonnieres P.DE-BONNIERES     279     49     16
 CASTEST MODIF ssnv216a                   debonnieres P.DE-BONNIERES     327     55     13
 CASTEST MODIF wdnp101b                        abbas M.ABBAS            765     16     12
 CASTEST MODIF zmat005a                        proix J-M.PROIX          178      5      5
 CASTEST MODIF zmat005b                        proix J-M.PROIX          173      5      5
 CASTEST MODIF zzzz162b                      tardieu N.TARDIEU          260    151    119
 CASTEST SUPPR perf008e.comm                sellenet N.SELLENET         130      0    130
FORTRAN90 MODIF mumps/amumpt                   desoza T.DESOZA           424      6      6
 FORTRAN AJOUT algorith/nmgz2d                 proix J-M.PROIX          322    322      0
 FORTRAN AJOUT algorith/nmgz3d                 proix J-M.PROIX          311    311      0
 FORTRAN AJOUT algorith/xprali               colombo D.COLOMBO          214    214      0
 FORTRAN AJOUT algorith/xprpfi               colombo D.COLOMBO          590    590      0
 FORTRAN MODIF algorith/accel0                 abbas M.ABBAS            161      8      6
 FORTRAN MODIF algorith/cfcrsd                 abbas M.ABBAS            421      1      5
 FORTRAN MODIF algorith/cfjein                desoza T.DESOZA           475     21     10
 FORTRAN MODIF algorith/dibcle                 abbas M.ABBAS            105      8      6
 FORTRAN MODIF algorith/dyoext                 abbas M.ABBAS            150      7      1
 FORTRAN MODIF algorith/frolgd                desoza T.DESOZA           946      4      4
 FORTRAN MODIF algorith/hyp3ci                 abbas M.ABBAS            122     32     27
 FORTRAN MODIF algorith/hyp3cv                 abbas M.ABBAS             88     31     20
 FORTRAN MODIF algorith/hyp3di                 abbas M.ABBAS            387     28     21
 FORTRAN MODIF algorith/hyp3dv                 abbas M.ABBAS            240     24     16
 FORTRAN MODIF algorith/hypcpc                 abbas M.ABBAS            198     36     23
 FORTRAN MODIF algorith/hypcpd                 abbas M.ABBAS            529     52     33
 FORTRAN MODIF algorith/hypdpc                 abbas M.ABBAS            113     30     21
 FORTRAN MODIF algorith/hypdpd                 abbas M.ABBAS            236     23     18
 FORTRAN MODIF algorith/hypela                 abbas M.ABBAS            223    115     50
 FORTRAN MODIF algorith/hypinc                 abbas M.ABBAS            217    110     58
 FORTRAN MODIF algorith/hypmat                 abbas M.ABBAS            119     52     42
 FORTRAN MODIF algorith/mmmbca                desoza T.DESOZA           406      3      3
 FORTRAN MODIF algorith/mmusuc                desoza T.DESOZA           200     10     10
 FORTRAN MODIF algorith/ndlect                 abbas M.ABBAS            471      1      5
 FORTRAN MODIF algorith/nmchoi                 abbas M.ABBAS            164     17     10
 FORTRAN MODIF algorith/nmcoma                 abbas M.ABBAS            273      6      4
 FORTRAN MODIF algorith/nmconv                 abbas M.ABBAS            536     12     10
 FORTRAN MODIF algorith/nmgc2d                 proix J-M.PROIX          327      2      7
 FORTRAN MODIF algorith/nmgc3d                 proix J-M.PROIX          332      3     58
 FORTRAN MODIF algorith/nminit                 abbas M.ABBAS            265      3      3
 FORTRAN MODIF algorith/nmmatr                 abbas M.ABBAS            237     38     17
 FORTRAN MODIF algorith/nmprac                 abbas M.ABBAS            185      7      5
 FORTRAN MODIF algorith/nmprma                 abbas M.ABBAS            260      6      4
 FORTRAN MODIF algorith/nmrebo                 abbas M.ABBAS             91      2      2
 FORTRAN MODIF algorith/nmtble                 abbas M.ABBAS            220      1      1
 FORTRAN MODIF algorith/nmzmat                 proix J-M.PROIX          192      9      3
 FORTRAN MODIF algorith/op0010               colombo D.COLOMBO          993      4      9
 FORTRAN MODIF algorith/xprls0               colombo D.COLOMBO          772    109     14
 FORTRAN MODIF algorith/xproj                colombo D.COLOMBO          128     12      5
 FORTRAN MODIF algorith/xprrei               colombo D.COLOMBO          579      4      4
 FORTRAN MODIF algorith/xprupw               colombo D.COLOMBO          629    116     15
 FORTRAN MODIF elements/rcangm                 proix J-M.PROIX          110      2      1
 FORTRAN MODIF elements/te0100                 proix J-M.PROIX          320     31     13
 FORTRAN MODIF elements/te0139                 proix J-M.PROIX          292     23      6
 FORTRAN MODIF modelisa/cfmxsd                 abbas M.ABBAS            178      9      2
 FORTRAN MODIF modelisa/mmusur                desoza T.DESOZA            82      6      9
 FORTRAN MODIF prepost/irchme                rezette C.REZETTE          273      9      1
  PYTHON AJOUT Messages/elashyper              abbas M.ABBAS             38     38      0
  PYTHON MODIF Comportement/zmat               proix J-M.PROIX           38      2      2
  PYTHON MODIF Macro/macr_lign_coupe_ops     tardieu N.TARDIEU          960      3      1
  PYTHON MODIF Messages/algorith3              abbas M.ABBAS            272      2     19
  PYTHON MODIF Messages/algorith9              abbas M.ABBAS            282      1      1
  PYTHON MODIF Messages/calculel5             berard A.BERARD           341      2      2
  PYTHON MODIF Messages/xfem2                colombo D.COLOMBO          594      9     11


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :   16        3138      3138             +3138
 MODIF :   77       22913      1556     989      +567
 SUPPR :    1         130               130      -130
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :   94       26181      4694    1119     +3575 
