

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR corus        CORUS Mathieu          DATE 10/05/2010 - 13:56:02

--------------------------------------------------------------------------------
RESTITUTION FICHE 014497 DU 2010-01-25 13:46:40
TYPE anomalie concernant Code_Aster (VERSION 10.2)
TITRE
   Probleme avec MACR_ELEM_DYNA
FONCTIONNALITE
   On rencontre un probleme dans l'utilisation de MACR_ELEM_DYNA quand on lui donne :
   - directement un concept issu de MODES_ITER_SIMULT,
   - un concept issu de DEFI_BASE_MODALE, construit avec une seule occurrence du mot clef 'RITZ'.
   
   Et, dans les deux cas, avec ou sans specification des matrices de rigidite ou de masse. Le
   probleme arrive dans la routine refe81.f quand on cherche les concepts de matrices
   assembles associes aux modes. 
   
   Quand on rentre directement un concept issu de MODES_ITER_SIMULT, les variables devant
   contenir les noms des matrices
   sont toujours une chaine de caracteres blanc, donc on n'a aucune chance de sortir quoi que ce
   soit, que l'on renseigne ou non les mots clefs MATR_RIGI et MATR_MASS dans MACR_ELEM_DYNA.
   
   Si on rentre un concept issu de DEFI_BASE_MODALE avec une seule occurrence du mot clef
   'RITZ', sans donner les matrices, comme ce concept provient de MODES_ITER_SIMULT, il
   encapsule les concepts de masse et de raideur, mais on a toujours le meme probleme. 
   Pour contourner cette difficulte, il suffit de ne plus assigner par defaut la valeur BLANC
   dans le cas 'RITZ', 
   et de proposer de ressortir soit les matrices associees au concept issu de
   MODE_ITER_SIMULT, soit les matrices utilisateur
   quand TYPBAS vaut sa valeur initiale. La modification a ete realisee et teste dans
   plusieurs cas. Cependant, aucun cas test de la base ne teste l'operateur dans les deux cas
   incrimines.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test perso
NB_JOURS_TRAV  : 0.25
--------------------------------------------------------------------------------
RESTITUTION FICHE 014668 DU 2010-02-19 13:01:19
TYPE anomalie concernant Code_Aster (VERSION 10.2)
TITRE
   Liaisonnement des sous-structures dans DEFI_MODELE_GENE
FONCTIONNALITE
   Dans le cas de calcul par sous structuration avec une methode de Craig & Bampton, il est
   necessaire que les interface servant au couplage soient bloquées, ou que, a tout le monde,
   6 DDL bloquant les modes de corps rigides soient definies. Dans le cas contraire,
   l'absence de multiplicateurs de Lagranges pour ces interfaces interdit le calcul. Or, en
   l'etat actuel, on ne teste pas la presence de DDL actifs pourles interfaces.
   
   Dans un cas particulier, on a voulu tester le couplage de sous structure en considerant
   des modes a interface libre, donc sans multiplicateurs de lagranges definis a l'interface.
   Le probleme, initie par l'absence de tests dans la routine ddlatc.f (operateur
   DEFI_INTERF_DYNA), se repercute jusqu'a ce que l'operateur DEFI_MODELE_GENE plante salement.
   
   On teste donc maintenant la presence de DDL actifs dans la routine ddlact.f, et on arrete
   le calcul si on n'en trouve aucun, avec le message suivant :
   
      !----------------------------------------------------------------------------------------!
      ! <EXCEPTION> <ALGORITH15_84>                                                            !
      !                                                                                        !
      ! On n''a pas trouve de DDL actifs pour les interfaces donnees                           !
      !    => On ne pourra pas calculer les modes d'attaches, de contrainte ou de couplage.    !
      !                                                                                        !
      !   CONSEIL : Verifiez la coherence de la definition des interfaces (conditions limites) !
      !             avec la methode retenue :                                                  !
      !              - CRAIGB   : le modele doit etre defini avec des interfaces encastrees,   !
      !              - CB_HARMO : le modele doit etre defini avec des interfaces encastrees,   !
      !              - MNEAL    : le modele doit etre defini avec des interfaces libres.       !
      !----------------------------------------------------------------------------------------!
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test perso
NB_JOURS_TRAV  : 0.25
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 11/05/2010 - 11:45:34

--------------------------------------------------------------------------------
RESTITUTION FICHE 011630 DU 2008-01-11 17:28:43
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   Basculement Numpy
FONCTIONNALITE
   Cette fiche trace le basculement de Numeric à numpy.
   
   Il y a une 60aine de modules python qui font appel à des fonctions de Numeric.
   La plupart du temps, il suffit de modifier les imports. On voit à cette occasion que "from
   xxx import *" est vraiment à proscrire. De même que l'import de plusieurs modules sur une
   seule ligne.
   
   La conversion se fait en deux temps que la couche de compatibilité fournie dans numpy
   (numpy.oldnumeric) :
    1. modif des imports, quelques fonctions (presque entièrement automatique)
    2. suppression de la couche de comptabilité (moins automatique)
   
   Pas mal de surprise lors de la phase 2 :
   - typage implicite en entier/réel/complexe des tableaux
   - concatenate retourne apparemment toujours un tableau de réel (cf. PROPA_FISS)
   - fonctions renommées : matrixmultiply, eigenvalues, eigenvectors, solve_linear_equations
   - comportement modifié : nonzero retourne systématiquemet une liste de tableaux d'indices
   - take : besoin de préciser axis=1
   - linalg.svd : ajouter full_matrices=False (visiblement le défaut à changer)
   
   Attention : différence entre LinearAlgebra.eigenvectors et numpy.linalg.eig : le premier
   retourne une séquence de vecteurs propres (vecteurs en ligne), le second retourne les
   vecteurs propres en colonnes !
   
   
   
   Validation sur la liste complète (sauf les longs).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   liste complète
NB_JOURS_TRAV  : 8.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 014920 DU 2010-04-08 11:04:27
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Probleme d'import du catalogue de la v10 dans eficas
FONCTIONNALITE
   Problème
   --------
   Il y a des imports mal placés dans l'ops des macros IMPR_DIAG_CAMPBELL et
   CALC_MODE_ROTATION qui empêchent l'import du catalogue dans Eficas.
   
   
   Correction
   ----------
   "import aster" dans CALC_MODE_ROTATION ne sert à rien.
   
   impr_diag_campbell_ops.py fait 2000 lignes...
   Il y a quand même quelques fonctions. On les déplace dans un nouveau module
   impr_diag_campbell_utils.py (800 lignes).
   Le corps de la macro fait tout de même 1200 lignes, ce qui est beaucoup trop pour la
   lisibilité.
   
   Il faut absolument avancer sur la mise en service d'une vérification du source python
   (pychecker/pylint...).
   
   Une règle pour les macros pourrait être :
   1. le corps de la macro est dans le module xxxx_ops.py
   2. dans xxxx_ops.py, il ne doit pas y avoir d'import autres que les modules standards
   3. les imports des modules auxilaires à la macro doivent être faits dans le corps même de
   la macro (sous le def)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sdll124a, sdll125a, sdll125b
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 014414 DU 2010-01-13 10:04:45
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   AR03 - Test de l'existence d'un concept
FONCTIONNALITE
   Problème
   --------
   Comment savoir dans le fortran si un concept existe ?
   
   
   Solution
   --------
   On utilise souvent JEEXIN pour savoir si une partie de la 
   structure de données du concept est présente.
   
   En fait, l'api n'est pas forcément géniale mais gcucon 
   répond au besoin :
   
   CALL GCUCON('RESU', 'EVOL_NOLI', IRET)
   => IRET =  0 : RESU est un evol_noli
   => IRET =  1 : RESU est un concept d'un autre type
   => IRET = -1 : RESU n'existe pas
   
   Si on ne connait pas le type :
   CALL GCUCON('RESU', ' ', IRET)
   => IRET >= 0 si RESU existe
   
   
   On peut aussi utiliser GETTCO :
   
   CALL GETTCO('RESU', TYPCO)
   => TYPCO = 'EVOL_NOLI' si RESU est un evol_noli
   => TYPCO = ' ' si RESU n'existe pas
   
   
   
   Vérification du coût des appels :
   1. un appel depuis le fortran à une fonction python est 10 
   fois plus coûteux qu'un call fortran (de l'ordre de 10s 
   contre 1s pour 10^7 appels)
   2. un appel à gettco coûte encore 20 fois plus cher (190s 
   pour 10^7 appels).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ras
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 014665 DU 2010-02-19 08:40:23
TYPE evolution concernant astk (VERSION )
TITRE
   creation de dossier par ASTK
FONCTIONNALITE
   Problème
   --------
   Si dans un profil d'étude, on met un fichier en résultat 
   dans, par exemple, /dd/ff/gg/result et que le répertoire 
   /dd/ff/gg n'existe pas, le fichier n'est pas recopié.
   
   
   Solution
   --------
   Pour les bases, ce n'était pas le cas, on créait 
   automatiquement le répertoire de destination.
   On fait maintenant la même chose pour tous les fichiers 
   résultats.
   
   De même, lorsque la copie d'un fichier résultat ou des bases 
   échoue, les fichiers sont copiés dans un répertoire de /tmp 
   (autre que le répertoire de travail et qui n'est donc pas 
   effacé) où l'utilisateur pourra aller les chercher (ce 
   mécanisme était déjà en place pour les bases).
   
   Exemple :
   
    Copie des résultats
   
   <E>_MKDIR_ERROR    impossible de créer le répertoire 
   /root/tmp/myresults
   
   
   <A>_COPY_RESULTS   Sauvegarde des résultats dans un 
   répertoire temporaire (/tmp/courtois@cli70cx-
   save_results.20755).
   
   copying .../fort.6            [  OK  ]
   copying .../glob.1            [  OK  ]
   copying .../pick.1            [  OK  ]
   
   <A>_ALARM          Exécution de Code_Aster terminée
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test elementaire
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 014544 DU 2010-02-02 10:17:50
TYPE aide utilisation concernant Code_Aster (VERSION 7.0)
TITRE
   Projet FUITE_GV : lancer des calculs distribuxes
FONCTIONNALITE
   Il s'agit d'une étude paramétrique pour le projet Fuite_GV.
   
   Il y a 5 paramètres variables (3 paramètres matériau, 2 
   paramètres géométriques).
   Un des cas d'étude est un scénario avec 3 valeurs pour 
   chaque paramètres (min/moy/max), soit 243 calculs.
   
   Le lancement de ces calculs indépendants est géré 
   directement dans astk (cf. doc u1.04.00, fonctionnalité 
   disponible depuis la version 1.7.0, janvier 2009).
   
   Pour cela, on part de l'étude nominale standard à laquelle 
   on ajoute :
   - un fichier (syntaxe python) qui détermine les valeurs des 
   paramètres pour les 243 exécutions.
   Les valeurs des paramètres peuvent avoir été déterminées 
   auparavant ou bien calculées en python dans le fichier (type 
   distr). Au final, ce fichier doit définir une liste de 
   dictionnaire de nom VALE (chaque dictionnaire correspondant 
   à un calcul).
   
   - un fichier définissant les ressources calculs disponibles.
   Dans le cas du lancement en batch, il suffit d'indiquer le 
   nom du noeud où seront soumis les jobs et un nombre maximum  
   de jobs à soumettre en même temps.
   Sur le serveur Bull, le noeud de soumission est aster2. La 
   classe dédiée à ce type d'étude autorise au maximum 12 
   calculs simultanés de 4 Go au maximum. Le fichier est :
   [aster2]
   cpu=16
   mem=48000
   
   C'est le fichier qui est utilisé par défaut (tel que défini 
   dans etc/codeaster/asrun : batch_distrib_hostfile).
   En mettant 16, il y aura toujours quelques calculs en 
   attente prêts à être démarrés.
   
   - le nom du groupe de classes de jobs dans laquelle les jobs 
   seront exécutés (option classe : distr). Les classes LSF 
   accessibles par ce groupe sont définies dans 
   etc/codeaster/asrun.
   
   
   Dans ces conditions (12 jobs au maximum selon la charge de 
   la machine), le gain en temps de retour est d'environ d'un 
   facteur 8.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   satisfaction client
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 014991 DU 2010-04-26 05:28:01
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW10.1.21, le cas-test ssnv195a est NOOK sur Calibre 4.
FONCTIONNALITE
   On teste à 0. à 1.e-16 et on trouve 1.026478E-16.
   
   On teste maintenant ces zéros à 1e-15.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ssnv195a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR geniaut      GENIAUT Samuel         DATE 11/05/2010 - 11:45:36

--------------------------------------------------------------------------------
RESTITUTION FICHE 015039 DU 2010-05-06 10:53:01
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
   X-FEM : bug dans PROPA_FISS, méthode MAILLAGE
FONCTIONNALITE
   Problème:
   --------
   
   Lorsque l'on choisi un coefficient C de la loi de paris différent de 1, l'avancée maximale
   DM_AMX n'est pas respectée.
   Dans le cas où C est très petit, les nouvelles mailles surfaciques de la fissure sont
   tellement petites que les nouveaux noeuds du fond sont confondus avec les anciens.
   
   
   
   Solution:
   ---------
   
   En effet, une coquille s'est introduite dans la macro python PROPA_FISS/ méthode
   'Maillage', datant 
   vraisemblablement de l'époque où DA_MAX n'était pas renseigné par l'utilisateur.
   
   Les 'Coef_C' des lignes 599 à 601 de propa_fiss_ops.py sont donc à supprimer.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ras
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR flejou       FLEJOU Jean Luc        DATE 11/05/2010 - 11:45:37

--------------------------------------------------------------------------------
RESTITUTION FICHE 015041 DU 2010-05-06 14:09:52
TYPE anomalie concernant Code_Aster (VERSION 10.2)
TITRE
   Plantage de la fonction ToAster(transfert=True) de la classe MAIL_PY
FONCTIONNALITE
   Utilisation de "class MAIL_PY" :
   --------------------------------
   
   Correction de la fonction ToAster(unite)
   * unite : argument facultatif
   
   Pour récupérer le maillage modifié dans l'espace Aster et le sauver au format MED
   ..unit2=maillage_python.ToAster()        # ToAster fait l'association entre unit2 et le
   fichier sur disque
   ou
   ..unit3=maillage_python.ToAster(unit2)   # dans ce cas unit3==unit2
   ou
   ..maillage_python.ToAster(unit2)
   et 
   ..Mail =LIRE_MAILLAGE(UNITE=unit2)
   ..IMPR_RESU(FORMAT='MED',MAILLAGE=Mail)
   
   
   Avant ToAster avait 2 arguments facultatifs ToAster(unite=[entier],transfert=[False|True])
   avec par défaut unite=None,transfert=False. Dans le cas où transfert=True, il y avait un
   toujours un plantage (pas de résultat faux).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   cas test perso
NB_JOURS_TRAV  : 0.05
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR nistor       NISTOR Ionel           DATE 11/05/2010 - 11:45:37

--------------------------------------------------------------------------------
RESTITUTION FICHE 015002 DU 2010-04-28 06:18:54
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   suppresion de l'objet .NOEU de la sd_mode_meca
FONCTIONNALITE
   Problème:
   --------------------------------------
   L'objet .NOEU appartenant à la sd_mode_meca n'existait plus que pour une utilisation 
   particulière dans les sources python de CALC_ESSAI et cela grâce à des glutes dans op0093 
   (MODE_STATIQUE) et op0099 (DEFI_BASE_MODALE). Depuis la résolution de la fiche 12583 par 
   Mathieu, il existe une méthode pour récupérer l'information que cet objet contient (en 
   double d'ailleurs dans la sd_mode_meca) à partir d'un autre objet (.RS16) mais les glutes 
   existent toujours dans les sources indiquées (on crée toujours cet objet .NOEU) et dans les 
   sources python de CALC_ESSAI (leidee_cata.py) on l'utilise toujours.
   
   Solution:
   -------------------------------------
   Les sources python de CALC_ESSAI ont été mises à jour par Charles en intégrant l'evolution de la fiche 12583. 
   Je supprime donc les glutes dans Fortran (l'objet .NOEU n'existe plus de tout), et je mets à jour le 
   catalogue de la sd_resultat.
   
   Impact dans les sources:
   -------------------------------------
   op0093.f
   op0099.f
   meidee_calcul_modifstruct.py
   meidee_correlation.py
   modes.py
   meidee_cata.py
   meidee_modifstruct.py
   sd_resultat.py
   
   Validation:
   -------------------------------------
   tous les cas-tests appelant CALC_ESSAI
   
   Temps de travail: 0.5 Charles + 0.5 Ionel
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   liste de cas-tests appelant CALC_ESSAI
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 014506 DU 2010-01-26 14:57:05
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   sdll136a est trop souvent casse !
FONCTIONNALITE
   Problème:
   ------------------------------
   Le cas-test sdll136a était, du nouveau, NOOK sur clpaster. Il s'agit d'un cas-test très capricieux, qui 
   plante de façon très aléatoire suivant la date de lancement, la machine etc.
   Particularité: il met en jeu un calcul fluide-structure et l'intégration se fait sur base modale 
   (DYNA_TRAN_MODAL) avec la méthode ITMI (en voie de refonte dans le cadre du projet QUAL-IFS-GV)
   
   Solution:
   -------------------------------
   La solution trouvée cette fois ne concerne plus la diminution du pas de temps (comme on avait l'habitude)! 
   J'augmente dans DTM le nombre d'itération par pas de temps: NMAX_ITER_PAS=25 en lieu de la valeur par défaut 
   qui était 16.
   Le cas-test passe maintenant sur toutes les machines.
   
   Validation:
   ------------------------------
   sdll136a
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sdll136a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 014597 DU 2010-02-10 13:58:59
TYPE evolution concernant Documentation (VERSION )
TMA : DeltaCad
TITRE
   doc absente pour les cas-test sdll133 et sdnl301
FONCTIONNALITE
   L'objectif de cette fiche est de restituer dans la base GED la documentation pour deux cas-tests: sdll133 et 
   sdnl301.
   Suite au travail effectué on deux nouveau manuels:
   - V2.02.133
     SDLL133 => TITRE : CALCUL DES MODES PROPRES D'UNE ROUE AUBAGEE
     ==============================================================
     => Modelisation A :
      - TITRE "CALCUL DES MODES PROPRES PRECONTRAINTS D'UNE ROUE AUBAGEE
               METHODE PAR MODELISATION COMPLETE DE LA ROUE"
      - MODELISATION : 3D (HEXA8)
      - Type d'analyse : 
        . calcul non lineaire en grandes deformations
        . calcul des modes propres précontraints
      - Résolution de référence: Non-regression
   
      => Modélisation B : 
      - TITRE "CALCUL DES MODES PROPRES D'UNE ROUE AUBAGEE
               METHODE PAR SYMETRIE CYCLIQUE DYNAMIQUE"
      - MODELISATION : 3D (HEXA8)
       - Types d'analyse : 
        . calcul non lineaire en grandes deformations,
        . calcul des modes propres précontraints
      - Résolution de référence: Non-regression
   
   - V5.02.301
      SDNL301A =>  TITRE : VIBRATION D'UNE POUTRE AVEC IMPACT MULTI-POINTS
      ====================================================================
      => Modelisation A :
      - TITRE : VIBRATION D'UNE POUTRE AVEC IMPACT MULTI-POINTS
      - MODELISATION : POU_D_T (SEG2)
      - Type d'analyse : 
        . calcul des modes propres 
        . calcul de la réponse dynamique linéaire sur base modale
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V5.02.301, V2.02.133
VALIDATION
   neant
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR delmas       DELMAS Josselin        DATE 10/05/2010 - 13:32:06

--------------------------------------------------------------------------------
RESTITUTION FICHE 014847 DU 2010-03-25 08:34:01
TYPE evolution concernant Documentation (VERSION )
TITRE
   Renseignement de DEFI_TRC
FONCTIONNALITE
   Problème :
   ========
   Suite à une sollicitation du forum, nous nous sommes aperçu que la doc R4.04.01 faisait
   référence à un logiciel (sans dire quoi ni où le trouver) permettant de saisir les
   diagrammes TRC.
   
   Après enquête et investigation le logiciel a été retrouvé. Il s'agit d'un fichier fortran
   qui écrit dans un fichier la commande DEFI_TRC, utilisable par exemple avec INCLUDE_FICHIER.
   
   Evolution :
   =========
   Bien qu'il n'y ait pas de demande interne, on propose de mettre cet objet "au chaud" en
   ajoutant le fichier à un test de métallurgie existant (mtlp100a.66 + copie dans le .comm).
   On met la doc R à jour en faisant référence au test et en mettant à jour la syntaxe de la
   commande produite.
   
   Impacts :
   =======
   mtlp100a
   r4.04.01
   v4.61.100
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : R4.04.01, V4.61.100
VALIDATION
   Nxc3xa9ant
NB_JOURS_TRAV  : 1.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 014837 DU 2010-03-23 14:31:32
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Calcul d'erreur impossible
FONCTIONNALITE
   Problème :
   ========
   Au cours de la formation on a vu que dans CALC_ELEM, dans le cas où le concept resultat
   n'est pas réentrant et que l'on a une liste d'options dépendant les unes des autres (par
   exemple on a besoin de SIGM_ELNO_DEPL pour calculer ERRE_ELEM_SIGM), on s'arrête avec le
   message suivant :
   
   ...!----------------------------------------------------------------!
   ...!.<A>.<UTILITAI8_14>.............................................!
   ...!................................................................!
   ...!.Champ..inexistant..SIGM_ELNO_DEPL..............................!
   ...!................................................................!
   ...!...ou..SIEF_ELNO_ELGA...........................................!
   ...!................................................................!
   ...!...ou..SIRE_ELNO_DEPL...........................................!
   ...!................................................................!
   ...!...NUME_ORDRE..1..on.ne.calcule.pas.l'option..ERRE_ELEM_SIGM....!
   ...!................................................................!
   ...!................................................................!
   ...!.Ceci.est.une.alarme..Si.vous.ne.comprenez.pas.le.sens.de.cette.!
   ...!.alarme,.vous.pouvez.obtenir.des.résultats.inattendus.!.........!
   ...!----------------------------------------------------------------!
   
   Analyse :
   =======
   C'est normal, pour calculer l'option ERRE_ELEM_SIGM, on a besoin de SIGM_ELNO_DEPL que
   l'on cherche dans la SD initiale et non la nouvelle.
   
   Correction :
   ==========
   On améliore le message pour dire où on cherche le champ en question et on ajoute un conseil :
   
   ...!.<A>.<UTILITAI8_13>..................................................................!
   ...!.....................................................................................!
   ...!.Dans.la.structure.de.données.resultat.meca,.........................................!
   ...!...le.champ.SIGM_ELNO_DEPL...........................................................!
   ...!.....................................................................................!
   ...!...ou.le.champ.SIEF_ELNO_ELGA........................................................!
   ...!.....................................................................................!
   ...!...ou.le.champ.SIRE_ELNO_DEPL........................................................!
   ...!.....................................................................................!
   ...!...n'existe.pas......................................................................!
   ...!.....................................................................................!
   ...!...Pour.le.numéro.d'ordre.NUME_ORDRE.1,..............................................!
   ...!...l'option.ERRE_ELEM_SIGM.n'est.pas.calculée........................................!
   ...!.....................................................................................!
   ...!...Conseil.:.........................................................................!
   ...!.....Vérifiez.le.nom.de.la.structure.de.donnée.et.vérifiez.que.les.champs.existent...!
   ...!.....Si.le.concept.n'est.pas.réentrant.les.champs.ne.sont.pas.cherchés.dans.meca.....!
   ...!.....................................................................................!
   ...!.....................................................................................!
   ...!.Ceci.est.une.alarme..Si.vous.ne.comprenez.pas.le.sens.de.cette......................!
   ...!.alarme,.vous.pouvez.obtenir.des.résultats.inattendus.!..............................!
   ...!-------------------------------------------------------------------------------------!
   
   Impacts:
   =======
   rsexc2.f
   utilitai8.py
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   affichage message
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 014627 DU 2010-02-15 12:10:19
TYPE aide utilisation concernant Code_Aster (VERSION 7.0)
TITRE
   Raffinement maillage xc3xa0 partir d'indicateur erreur sur Von Mises
FONCTIONNALITE
   Pour rappel, l'estimation d'erreur en quantité d'intérêt se fait en 3 étapes :
   1. Estimation d'erreur en norme de l'énergie sur le problème primal ;
   2. Estimation d'erreur en norme de l'énergie sur le problème dual (même rigidité mais
   second membre différent) ;
   3. Combinaison des deux erreurs.
   
   Le calcul d'erreur en quantité d'intérêt pour les contraintes de Von Mises nécessite la
   prise en compte (au niveau de la programmation de l'estimateur en résidu) d'un chargement
   de type SIGM_INTERNE. Ceci n'est pas encore disponible dans la version officielle de
   Code_Aster mais sous forme de surcharge.
   
   Mais le problème le plus important pour cette étude est la présence d'un chargement
   prépondérant de type thermique. Celui-ci n'est pas du tout prévu pour le moment dans la
   programmation de l'estimateur en résidu. Il y a une évolution à réaliser.
   
   Une alternative peut être l'utilisation des estimateurs basés sur le lissage de champ. Ils
   ne nécessitent pas la prise en compte du chargement, seul le champ de contrainte compte.
   Mais dans le cas ou il peut y avoir un fort gradient de température et/ou un fort gradient
   de contrainte, ces méthodes peuvent se révéler inefficaces : un lissage est effectué sur
   la structure complète pour la méthode dite ZZ1. Dans le cas de la méthode ZZ2 les
   contraintes de maillage sont trop fortes pour que l'on puisse espérer que cela fonctionne
   sur une structure aussi complexe que celle-ci.
   
   En conclusion, il faudrait :
   - faire évoluer l'estimateur en résidu pour prendre en compte les chargements de type
   SIGM_INTERNE ;
   - faire évoluer l'estimateur en résidu pour prendre en compte les chargements de type
   thermique ;
   - éventuellement tester avec les estimateurs en lissage (en comparaison de ce qui aura été
   développé).
   
   Cette étude pourra faire partie d'une série d'études cibles, sur lesquelles il FAUT que
   les estimateurs d'erreur de Code_Aster fonctionnent.
   
   Je propose de fermer cette AOM et d'ouvrir une fiche d'évolution.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   *
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 014370 DU 2010-01-05 16:09:51
TYPE anomalie concernant Documentation (VERSION *)
TITRE
   La doc de DEFI_LIST_INST n'existe pas
FONCTIONNALITE
   Problème :
   ========
   La doc de DEFI_LIST_INST n'existe pas.
   
   Correction :
   ==========
   Suite à des problèmes de l'appli, la doc n'avait pas été soumise. La doc est maintenant
   dans l'appli.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   *
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------
RESTITUTION FICHE 014311 DU 2009-12-16 14:09:20
TYPE anomalie concernant Documentation (VERSION *)
TITRE
   Docaster - v7.31.132 bloquxc3xa9
FONCTIONNALITE
   Problème :
   ========
   Le document v7.31.132 est bloqué dans l'appli (on peut faire des transitions mais pas le
   récupérer). Cela semble être dû au fait qu'il n'y avait pas de métadonnées, ni d'entête
   dans le document de base.
   
   Correction :
   ==========
   La version 0.9.2 de docaster + un hotfix a permis de résoudre le problème (ticket 27858).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   *
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 014117 DU 2009-10-28 17:39:28
TYPE anomalie concernant Documentation (VERSION *)
TITRE
   Docaster - v2.03.120 signalxc3xa9 en brouillon
FONCTIONNALITE
   Problème :
   ========
   v2.03.120 est signalé en brouillon alors que son état est différent.
   De plus il est signalé pour plusieurs utilisateurs.
   
   Correction :
   ==========
   Il y avait une révision qui n'avait pas été dépréciée et qui était donc restée en brouillon.
   Grâce à "modifier", on déprécie la révision qui posait problème.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   *
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 013865 DU 2009-09-11 14:52:42
TYPE evolution concernant Documentation (VERSION )
TMA : DeltaCad
TITRE
   Solutions analytiques de tests
FONCTIONNALITE
   Problème :
   ========
   Je me suis aperçu qu'il existait des docs "solution de référence".
   Je pensais que les solutions de références étaient toutes incluses dans les docs des tests.
   
   Cela pose 2 problèmes :
   - il n'y a pas 1 test == 1 doc,
   - le responsable de la doc de référence n'est pas le responsable du test.
   
   Correction :
   ==========
   On fait mourir ces docs en incluant la référence dans la doc du test en annexe.
   
   [V3.90.001] SSLL14  - Calcul d'un portique plan hyperstatique élastique
   [V7.90.02]  HSNV100 - Elasto-plasticité sous charge thermique
   [V7.90.03]  HPLA100 - Une solution analytique pour le cylindre creux thermoélastique
   
   pour le mettre en annexe de docs correspondant aux tests.
   
   On en profite pour rafraichir les docs obtenus par correction des styles :
     --> reprise des équations :
     --> reprise des figures.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   *
--------------------------------------------------------------------------------
RESTITUTION FICHE 013864 DU 2009-09-11 14:37:45
TYPE anomalie concernant Documentation (VERSION *)
TITRE
   Docaster - Traquer les clxc3xa9s doc non conforme
FONCTIONNALITE
   Problème :
   ========
   Il existe dans l'appli des clés doc qui ne répondent pas au format Vx.xx.xxx .
   
   Correction :
   ==========
   Mathieu a ajouté dans le script de publication des documents (qui tourne chaque nuit) un
   contrôle.
   
   Il existe trois documents dans ce cas :
   ./9.5/fr/man_v/v7/v7.90.03.pdf
   ./9.5/fr/man_v/v7/v7.90.02.pdf
   ./9.5/fr/man_v/v0/v0.00.00.pdf
   ./default/fr/man_v/v7/v7.90.03.pdf
   ./default/fr/man_v/v7/v7.90.02.pdf
   ./default/fr/man_v/v0/v0.00.00.pdf
   
   Les deux premiers vont être supprimés, le troisième va être corrigé.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   *
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 013780 DU 2009-08-26 16:04:22
TYPE evolution concernant Site web (VERSION )
TITRE
   Mise en ligne des CR de CTA et de CODIR sur le site web / intranet
FONCTIONNALITE
   Le SEPTEN souhaite voir apparaître sur le site web / intranet les compte-rendus de CTA et
   de CODIR Aster.
   
   Pour répondre à la demande, on a créé une page
   (http://www.code-aster.org/V2/spip.php?article228) accessible en intranet sur laquelle on
   retrouve les compte-rendus de Comité Technique Aster, de Comité Aster et de Comité
   Directeur Aster.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   *
NB_JOURS_TRAV  : 3.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR geniaut      GENIAUT Samuel         DATE 10/05/2010 - 14:39:47

--------------------------------------------------------------------------------
RESTITUTION FICHE 015036 DU 2010-05-05 14:26:41
TYPE express concernant Code_Aster (VERSION 10.1)
TITRE
   X-FEM : nb de mailles enrichies limitées
FONCTIONNALITE
   Problème :
   Dans xenrch.f, on limite le nb de mailles enichies à NBMA/10
   
   c'est trop peu pour certaines études.
   
   
   Solution:
   On dimensionne le tableau en question à NBMA, nb de mailles du maillage
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test perso
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR granet       GRANET Sylvie          DATE 10/05/2010 - 13:16:36

--------------------------------------------------------------------------------
RESTITUTION FICHE 015035 DU 2010-05-05 13:02:44
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   THM - kitdec.f - variable nvith
FONCTIONNALITE
   La variable nvith utilisée dans comthm n'était utile que 
   lorsqu'il y avait les lois de type "Gatmari" resorbées depusi 
   longtemps. Cette variable inutile existe toujours et n'est 
   renseignée nulle part.Elle n'est donc pas initialisée à 0. Or 
   la routine kitdec l'utilise inutilement pour déclarer la 
   longueur du vecteur des variables internes en THM.
   Bref il y a un risque ed tableau mal dimensionné.
   Je résorbee nvith de kitdec.f, comthm.f, coeithm.f et calcme.f.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   passage de tests THM
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 014992 DU 2010-04-26 05:32:53
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW10.1.21, les cas-tests wtna106a,b,c,d , wtnp102a,b,c,d et wtnv102a,b s'arretent en erreur_<F> sur Rocks.
FONCTIONNALITE
   Il y avait une variable non initialisée dans la routine hmlvag. 
   La variable CP22 n'était en effet pas mise à 0.
   Cette routine concerne les lois de comportement liqu_vape_gaz 
   (d'où les cas tests qui plantaient sur rocks).
   On fait l'initialisation et les tests passent sur les différentes 
   machines.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   passage des tests sous rocks
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 10/05/2010 - 13:56:08

--------------------------------------------------------------------------------
RESTITUTION FICHE 014971 DU 2010-04-19 15:44:19
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TMA : DeltaCad
TITRE
   RECU_TABLE - message d'erreur développeur
FONCTIONNALITE
   Problème
   --------
   Lorsque l'utilisateur souhaite récupérer une table qui 
   n'existe pas, en l'occurence la table ESTI_GLOB. Cette table 
   contient les estimateurs d'erreur globaux. Aster emet un 
   message d'erreur développeur peu explicite.
   
   Modification
   -------------
   => Ajout d'un message plus explicite dans table0.py
   "La table 'ESTI_GLOB' n'existe pas dans le résultat RESU_1."
   
   Modif de la routine ltnotb.f pour prendre en compte le 
   nouveau message
   
   Validation
   ----------
    - Etude fournie
    - Ajout dans le cas-test zzzz257a de 
        RECU_TABLE(CO=RESU,NOM_TABLE='ESTI_GLOB')
   
   4) Documentation
   ----------------
   Modification de la doc U4.71.02 "RECU_TABLE": description de 
   la table ESTI_GLOB
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   zzzz257a
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR nistor       NISTOR Ionel           DATE 10/05/2010 - 13:56:08

--------------------------------------------------------------------------------
RESTITUTION FICHE 014597 DU 2010-02-10 13:58:59
TYPE evolution concernant Documentation (VERSION )
TMA : DeltaCad
TITRE
   doc absente pour les cas-test sdll133 et sdnl301
FONCTIONNALITE
   L'objectif de cette fiche est de restituer dans la base GED la documentation pour deux cas-tests: sdll133 et 
   sdnl301.
   Suite au travail effectué on deux nouveau manuels:
   - V2.02.133
     SDLL133 => TITRE : CALCUL DES MODES PROPRES D'UNE ROUE AUBAGEE
     ==============================================================
     => Modelisation A :
      - TITRE "CALCUL DES MODES PROPRES PRECONTRAINTS D'UNE ROUE AUBAGEE
               METHODE PAR MODELISATION COMPLETE DE LA ROUE"
      - MODELISATION : 3D (HEXA8)
      - Type d'analyse : 
        . calcul non lineaire en grandes deformations
        . calcul des modes propres précontraints
      - Résolution de référence: Non-regression
   
      => Modélisation B : 
      - TITRE "CALCUL DES MODES PROPRES D'UNE ROUE AUBAGEE
               METHODE PAR SYMETRIE CYCLIQUE DYNAMIQUE"
      - MODELISATION : 3D (HEXA8)
       - Types d'analyse : 
        . calcul non lineaire en grandes deformations,
        . calcul des modes propres précontraints
      - Résolution de référence: Non-regression
   
   - V5.02.301
      SDNL301A =>  TITRE : VIBRATION D'UNE POUTRE AVEC IMPACT MULTI-POINTS
      ====================================================================
      => Modelisation A :
      - TITRE : VIBRATION D'UNE POUTRE AVEC IMPACT MULTI-POINTS
      - MODELISATION : POU_D_T (SEG2)
      - Type d'analyse : 
        . calcul des modes propres 
        . calcul de la réponse dynamique linéaire sur base modale
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V5.02.301, V2.02.133
VALIDATION
   neant
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR pellet       PELLET Jacques         DATE 10/05/2010 - 13:57:52

--------------------------------------------------------------------------------
RESTITUTION FICHE 014845 DU 2010-03-24 17:31:53
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Calcul THM - plantage obscur STAT_NON_LINE
FONCTIONNALITE
   Problème :
   ----------
   Sébastien est tombé sur un message obscur (ASSERT) en voulant utiliser un chargement de
   type EVOL_CHAR sur un modèle THM.
                                                                                            
           
   Analyse :
   ---------
   L'assert correspond à un "trou" dans la programmation de la routine exchno.f (utilitaire
   de calcul.f) si un champ "in" est un champ aux "noeuds" et que l'élément fini attend un
   champ "ELGA".
                                                                                            
           
   En théorie, rien n'empecherait de boucher ce "trou", mais encore faudrait-il pouvoir
   tester la nouvelle programmation. Hors pour l'instant, ce besoin n'est pas utilisé dans le
   code.
                                                                                            
           
   Le problème de Sébastien vient du fait que (par erreur) les éléments de THM ont prévu que
   les chargements de type "EVOL_CHAR" sont des champs ELGA alors que tous les autres
   éléments les attendent aux noeuds. Sébastien a donc émis une fiche (14783) pour corriger
   les éléments de THM.
                                                                                            
           
   Correction / Impact documentaire :
   ----------------------------------
   On ne modifie pas les sources dans le cadre de cette fiche mais on en profite pour
   améliorer un peu la doc U :
   U4.44.01 (AFFE_CHAR_MECA) :
     paragraphe 4.4 (EVOL_CHAR) :
     Dire que pour l'instant, la structure de données evol_char doit contenir des chargements
   qui sont des champs 'NOEU' / 'ELNO' / 'ELEM' / 'CART'  mais pas des champs 'ELGA'.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : U4.44.01
VALIDATION
   sans objet
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 014949 DU 2010-04-15 09:21:28
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW10.1.19, le cas-test zzzz255c s'arrete en Error_<F> sur Bull, Rocks, Calibre4 et Calibre5
FONCTIONNALITE
   Problème :
   ----------
   En version 10.1.19, le test zzzz255c s'arrete en erreur fatale sur bull, Rocks, ... avec
   le message :
                                                                                            
                           
   !---------------------------------------------------------!
   !.<F>.<MODELISA2_20>......................................!
   !.les.2.maillages.doivent.être.du.même.type.:.2d.(ou.3d)..!
   !---------------------------------------------------------!
                                                                                            
                           
   Analyse :
   ----------
   A. Jaubert a analysé le problème. Il vient de la modification de la routine asmasu.f que
   j'a faite en 10.1.19 pour corriger la fiche 14191.
                                                                                            
                           
   Avant ma modif, la routine asmasu émettait l' erreur MODELISA2_20 si .DIME(MA1)(6) !=
   .DIME(MA2)(6) c'est à dire si les 2 maillages à fusionner sont COOR_2D et COOR_3D.
   Après ma modif, la routine asmasu émet l'erreur MODELISA2_20 si l'un des maillage est à
   Z=0 et l'autre non.
                                                                                            
                           
   En réalité, la commande ASSE_MAILLAGE n'a pas de (bonne) raison d'interdire l'assemblage
   d'un maillage 2D et d'un maillage 3D.
                                                                                            
                           
   Correction :
   ------------
   Dans asmasu.f, on retire la vérification de cohérence des 2 maillages à fusionner.
   On fait la meme chose dans la routine asmaco.f utilisée également dans ASSE_MAILLAGE.
                                                                                            
                           
    
    
   Liste des fichiers impactés par la correction de la fiche:  14949
     asmaco.f  asmasu.f
     modelisa2.py
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   zzzz255c
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 014980 DU 2010-04-20 16:47:13
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Resultats bizarres LIAISON_SOLIDE + maillage 2D
FONCTIONNALITE
   Problème:
   ---------
   Un utilisateur du Web s'est aperçu que le mot clé LIAISON_SOLIDE (pour un modèle de coques
   ou de poutres) ne faisait pas ce qu'il devait faire si le maillage était dans un plan Z=Cste.
                                                                                            
                         
   Analyse :
   ---------
   Dans la routine caliso.f (LIAISON_SOLIDE), pour savoir le nombre de mouvements de corps
   solide du groupe, il faut savoir si on est en 2D ou en 3D.
                                                                                            
                         
   Jusqu'à présent, on obtenait la réponse à cette question par :
           CALL DISMOI('F','Z_CST',MOD,'MODELE',NDIMMO,K8BID,IER)
                                                                                            
                         
   Ce qui répond mal à la question si le modèle (de coques ou de poutres) est situé dans un
   plan Z=Cste.
                                                                                            
                         
   Correction :
   ------------
   Je modifie caliso.f pour utiliser maintenant :
           CALL DISMOI('F','DIM_GEOM',MOD,'MODELE',NDIMMO,K8BID,IER)
   Cette question DISMOI est plus pertinente car elle regarde dans les catalogues des
   éléments finis du modèle si leur géométrie est 2D ou 3D.
                                                                                            
                         
                                                                                            
                         
   Détails :
   ---------
   1) J'ai retrouvé le meme problème dans les routines suivantes :
     * caliob.f : LIAISON_OBLIQUE
     * calyrc.f : LIAISON_CYCL
     * caprec.f : RELA_CINE_BP
     * calicp.f : LIAISON_COQUE
     * cafaci.f : FACE_IMPO
     Dans toutes ces routines, j'ai modifié le DISMOI : 'Z_CST' -> 'DIM_GEOM'
                                                                                            
                         
   2) La question 'DIM_GEOM' peut répondre :
     2 : tous les éléments du modèle sont 2D
     3 : tous les éléments du modèle sont 3D
     23: il y a un mélange d'éléments 2D et 3D (par exemple dans le test zzzz120b (GOUJ_2ECH))
     1002 : éléments 2D + macro-élements statiques
     1003 : éléments 3D + macro-élements statiques
     ...
                                                                                            
                         
     Dans toutes les routines modifiées :
       - j'oublie les macro-éléments en faisant : NDIM = MOD(NDIM,1000)
       - j'émets une erreur fatale si NDIM est différent de 2 ou 3
                                                                                            
                         
   Validation :
   ------------
     * passage de l'etude jointe à la fiche
     * passage de certains cas tests utilisant les mots clés d'AFFE_CHAR_MECA impactés par
   cette correction
                                                                                            
                         
                                                                                            
                         
   Résultats faux :
   ----------------
   Dans l'étude fournie par l'utilisateur, la conséquence de ce bug est que l'on n'écrivait
   que 3 relations linéaires (pour DX, DY et DRZ) au lieu d'en écrire 6. Ce qui conduit à des
   résultats faux.
                                                                                            
                         
   Les conséquences du bug ne sont pas les memes selon les mots clés impactés :
                                                                                            
                         
     * LIAISON_SOLIDE : Résultats faux si :
       - le modèle contient des éléments de coque ou de poutre
       - tous les noeuds du maillage ont la meme coordonnée "Z".
       - on veut "soldifier" un groupe de noeuds
                                                                                            
                         
     * LIAISON_OBLIQUE : Résultats faux si :
       - le modèle contient des éléments de coque ou de poutre
       - tous les noeuds du maillage ont la meme coordonnée "Z".
       - on veut imposer sur un groupe de noeuds un déplacement "oblique" qui n'est pas dans
   le plan du maillage.
                                                                                            
                         
   En revanche, il n'y a PAS de résultats FAUX pour les mots clés :
     * RELA_CINE_BP : car ce mot clé est destiné à des modèles de béton précontraint et que
   ces modèles ne peuvent pas etre definis sur un maillage plan Z=cste.
     * LIAISON_CYCL : Ce mot clé est destiné à écrire une condition de répétitivité cyclique.
   Il ne traite que les ddls de translation et ne doit pas etre utilisé pour des modèles de
   coque et/ou poutre.
     * LIAISON_COQUE : Ce mot clé est destiné à écrire une condition de raccord entre 2
   coques incidentes (1 mur et 1 plancher par exemple). Ce genre de modèle ne peut pas etre
   décrit par un maillage Z=cste.
     * FACE_IMPO : Le problème ne concerne que les utilisateurs voulant imposer DNOR ou DTAN
   sur un modèle de type coque dans un plan Z=Cste. Il y aura alors une confusion sur le sens
   du mot "normale" :
        - l'utilisateur doit s'attendre à ce que le normale soit celle de la coque (OZ)
        - le code estimant (à tort) qu'il s'agit d'un modèle 2D ne s'intéresera qu'à la
   normale au "bord" du domaine (les segments). Le code s'arretera alors en erreur fatale car
   il ne saura pas calculer la normale des éléments surfaciques (TRA et QUAD).
                                                                                            
                         
                                                                                            
                         
   NEW9 :
   ------
   Reporter en NEW9 les corrections suivantes :
   caliso.f :
   <       CALL DISMOI('F','Z_CST',MOD,'MODELE',NDIMMO,K8BID,IER)
   <       NDIMMO = 3
   <       IF (K8BID.EQ.'OUI') NDIMMO = 2
   ---
   >       CALL DISMOI('F','DIM_GEOM',MOD,'MODELE',NDIMMO,K8BID,IER)
   >       IF (NDIMMO.GT.1000) NDIMMO=NDIMMO-1000
   >       IF (.NOT.(NDIMMO.EQ.2.OR.NDIMMO.EQ.3))
   >      &    CALL U2MESS('F','MODELISA2_6')
                                                                                            
                         
   caliob.f :
   <       CALL DISMOI('F','Z_CST',MOD,'MODELE',NDIMMO,K8BID,IER)
   <       NDIMMO = 3
   <       IF (K8BID.EQ.'OUI') NDIMMO = 2
   ---
   >       CALL DISMOI('F','DIM_GEOM',MOD,'MODELE',NDIMMO,K8BID,IER)
   >       IF (NDIMMO.GT.1000) NDIMMO=NDIMMO-1000
   >       IF (.NOT.(NDIMMO.EQ.2.OR.NDIMMO.EQ.3))
   >      &    CALL U2MESS('F','MODELISA2_6')
                                                                                            
                         
                                                                                            
                         
    
    
   Liste des fichiers impactés par la correction de la fiche:  14980
     cafaci.f  calicp.f  caliob.f  caliso.f  calyrc.f  caprec.f
     modelisa2.py
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 6.0
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 6.0
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   xc3xa9tude jointe
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 015044 DU 2010-05-07 09:24:46
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   Un bug dans jevech si VF (vu par valgrind)
FONCTIONNALITE
   Problème :
   ----------
   En voulant résoudre la fiche 14968, S. Granet s'est aperçu avec valgrind qu'il y avait un
   problème dans la routine jevech.f lorsqu'on est en "volumes finis".
                                                                                            
                  
   Correction :
   ------------
   Effectivement, dans cette routine, on lit une information pour tous les champs paramètres,
   alors qu'on a le droit de la lire que pour les champs "out".
   Il faut inverser 2 lignes de "IF".
                                                                                            
                  
   Remarque : Le meme bug existe dans tecac2.f Je le corrige également.
                                                                                            
                  
   Validation :
   ------------
   Le message de valgrind disparait.
    
    
   Liste des fichiers impactés par la correction de la fiche:  15044
     jevech.f  tecac2.f 
   
   Je joins les 2 fichiers corrigés (fortran.gz) pour que Sylvie puisse corriger ce problème
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   essai perso
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 015046 DU 2010-05-07 11:08:28
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW10.1.23 le cas test forma12b s'arrete par manque de temps CPU sur la Bull
FONCTIONNALITE
   Le test consomme environ 60 secondes de temps système avec 60 Mo de RAM.
   
   On augmentant la limite mémoire à 180 Mo, le temps chute à moins de 10 secondes et le
   nombre de libération automatique est divisé par 10.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   forma12b
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR proix        PROIX Jean-Michel      DATE 10/05/2010 - 18:38:24

--------------------------------------------------------------------------------
RESTITUTION FICHE 014707 DU 2010-03-02 10:39:53
TYPE aide utilisation concernant Code_Aster (VERSION 7.0)
TITRE
   Comparaison entre ASTER-Zmat et ASTER-ASTER
FONCTIONNALITE
   Problème rencontré : 
   --------------------
   
   Lors du transfert des résultats d'une thèse effectuée avec Zebulon (ENSMP) dans
   Code_Aster, des calculs d'agrégats semblables ont été réalisés sur Code_ASTER en utilisant
   les options de modèles de
   comportement propres à ASTER et ceux de Zmat. Les performances des 2 options sont très
   différentes :	
   	- les temps CPU sont en faveur d'ASTER-Zmat
   	- les convergences sont très difficiles en utilisant les modèles ASTER.
   
   
   Analyse :
   ---------
   
   Une première analyse montre que la convergence difficile pour le comportement Aster est
   due à l'un des paramètres matériau :
     *flow norton         => pas d'influence notable sur la convergence
      K         11.0
      n          7.0
     *isotropic nonlinear  => pas d'influence notable sur la convergence
      R0        40.0
      Q         10.0
      b          3.0
     *kinematic nonlinear
      C       40000.0  => beaucoup plus grand que dans les tests Aster
      D        1500.0
     *interaction slip  => pas d'influence notable sur la convergence
      h1          1.0
      h2          1.0
      h3          0.6
      h4         12.3
      h5          1.6
      h6          1.8
   
   Cette convergence difficile cache une anomalie : tous les tests d'agrégat Aster ont été
   effectués jusqu'à présent pour des comportements quasi isotrope, avec de faibles valeurs
   de C. En effet
   c'est la première fois que l'on cherche à applique un chargement cyclique sur le
   comportement MONOCRISTAL.
   Par contre, si on convergeait (!) les résultats étaient corrects (en implicite, mais pas
   avec Runge-Kutta, cf fiche 15023).
   
   Ici C=40000. Quand on prend C=400 par exemple, la convergence est sans souci (aussi rapide
   que Zmat).
   
   Correction :
   ------------
   
   Elle a consisté à reprendre le calcul et la programmation de la matrice jacobienne des
   comportements monocristallins. Les expressions dans la doc R5.03.11 sont correctes (il
   manque juste une formule page 13), mais la programmation était trop compliquée et pouvait
   cacher des bugs. Je l'ai donc reprise, en simplifiant.
   
   Cette fois la convergence est bonne : on le vérifie sur le nouveau test SSND109A.
   
   D'autre part, en ce qui concerne l'étude jointe et la comparaison Zmat - Aster, les temps
   sont maintenant du même ordre de grandeur :
   
   Zmat :
   =====
   ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   STATISTIQUES SUR LE TRANSITOIRE 
   ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
      NOMBRE DE PAS DE TEMPS                  :    100
      NOMBRE D'ITERATIONS DE NEWTON           :    100
      NOMBRE DE CREATION DE NUMEROTATION      :      1
      NOMBRE DE FACTORISATION DE MATRICE      :    100
      NOMBRE D'INTEGRATION DE COMPORTEMENT    :    200
      NOMBRE DE RESOLUTION K.U = F            :    100
      TEMPS POUR CREATION NUMEROTATION        :  3 s                    
      TEMPS POUR FACTORISATION MATRICE        :        2 h  0 m  0 s    
      TEMPS POUR INTEGRATION COMPORTEMENT     :        2 h  3 m 17 s    
      TEMPS POUR RESOLUTION K.U = F           :  1 m 31 s               
   ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   
   Aster (après correction) (car avant on n'aboutissait pas par non convergence)
   =============================================================================
   
   ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   STATISTIQUES SUR LE TRANSITOIRE 
   ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
      NOMBRE DE PAS DE TEMPS                  :    146
      NOMBRE D'ITERATIONS DE NEWTON           :    163
      NOMBRE DE CREATION DE NUMEROTATION      :      1
      NOMBRE DE FACTORISATION DE MATRICE      :    163
      NOMBRE D'INTEGRATION DE COMPORTEMENT    :    326
      NOMBRE DE RESOLUTION K.U = F            :    163
      TEMPS POUR CREATION NUMEROTATION        :  1 s                    
      TEMPS POUR FACTORISATION MATRICE        :        3 h 26 m 10 s    
      TEMPS POUR INTEGRATION COMPORTEMENT     :        2 h 29 m 52 s    
      TEMPS POUR RESOLUTION K.U = F           :  1 m  7 s               
   ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   
   Le temps supplémentaire dans Aster vient des plus nombreux pas de temps : le nombre de
   re-découpages reste supérieur à celui de Zmat.
   
   Pour cela une amélioration est dans les cartons sur l'initialisation de l'algorithme de
   Newton local. Mais c'est une évolution, donc restituable après le 9 juin. Quoi qu'il en
   soit, la correction permet maintenant de travailler. 
   
   De plus, en utilisant la recherche linéaire locale (RESO_INTE='IMPLICITE_RELI', le temps
   CPU est encore amélioré :
   
   ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   STATISTIQUES SUR LE TRANSITOIRE 
   ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
      NOMBRE DE PAS DE TEMPS                  :     84
      NOMBRE D'ITERATIONS DE NEWTON           :    102
      NOMBRE DE CREATION DE NUMEROTATION      :      1
      NOMBRE DE FACTORISATION DE MATRICE      :    102
      NOMBRE D'INTEGRATION DE COMPORTEMENT    :    204
      NOMBRE DE RESOLUTION K.U = F            :    102
      TEMPS POUR CREATION NUMEROTATION        :  1 s                    
      TEMPS POUR FACTORISATION MATRICE        :        2 h  9 m 32 s    
      TEMPS POUR INTEGRATION COMPORTEMENT     :        1 h 22 m 22 s    
      TEMPS POUR RESOLUTION K.U = F           : 43 s                    
   ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   
   
   
   Détails :
   _________
   
   la correction consiste à dupliquer la routine qui calcule la matrice jacobienne (LCMMJA).
   Celle -ci fait maintenant appel à LCMMJ1 pour les comportements de type ECOUL_VISC*, et
   LCMMJ2 pour KOCKS_RAUCH.
   
   En effet les inconnues cherchées ne sont pas les mêmes dans les deux cas : pour chaque
   système de glissement, ce sont les glissements viscoplastiques pour le premier cas et la
   densité de dislocation pour le deuxième. La programmation est maintenant plus simple et
   plus évolutive, et semble meilleure qu'avant, en ce qui concerne la convergence.
   
   Validation :
   ___________
   les test SSDN109A, avec C=100000.
   Toues les tests appelant MONOCRISTAL
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : v6.08.109, R5.03.11
VALIDATION
   ssnd109a
NB_JOURS_TRAV  : 5.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 015023 DU 2010-05-04 08:24:32
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   comportement mono-cristal avec chargement cyclique en RUNGE_KUTTA
FONCTIONNALITE
   Problème rencontré :
   --------------------
   
   La comparaison des résultats ASTER-ASTER et ASTER-Zmat sur la simulation du comportement
   MONOCRISTAL pour un chargement cyclique monte que le comportement Aster est faux. Le
   résultat de Zmat est semblable à celui obtenu avec Zébulon.
   
   Correction :
   ------------
   
   Il y a effectivement un problème avec les fortes valeurs du paramètre C (cela n'avait pas
   été constaté jusqu'à maintenant puisque l'on n'utilisait pas ces comportements pour ces
   calculs cyclique). C'est un problème voisin de la fiche 14707. Celle-ci met en évidence
   des difficultés de convergence en implicite. 
   
   Tous ces problèmes disparaissent si C devient plus petit (tous les tests de validation
   utilisent des valeurs de C nulles ou petites, de l'ordre de 10 MPa. Ici C=100000 MPa).
   
   Au passage on ajoute une vérification dans DEFI_COMPOR / POLYCRISTAL : il faut que la
   somme des fractions volumiques soit égale à 1 (à 1.E-3 près) pour que la calcul soit
   licite. Sinon un message d'erreur est émis.
   
   
   Possibilité de résultats faux :
   -------------------------------
   
   On avait des résultats faux pour le MONOCRISTAL et le POLYCRISTAL, seulement en
   RUNGE_KUTTA,et avec de fortes valeurs de C.
   
   Détail de correction :
   ----------------------
   
   C'était dû à une mauvaise utilisation de la routine réalisant la partie cinématique du
   comportement (LCMMFC) : on avait voulu utiliser la routine formulée en implicite (qui est
   correcte dans ce cas) pour l'intégration explicite  (ce qui n'est pas bon). La correction
   consiste à distinguer les deux cas. Une nouvelle routine, LCMMEC, spécifique à
   l'intégration explicite a été introduite. Elle est appelée uniquement par LCMMON
   (Monocristal explicite) et LCMMOP (polycristal), à la place de LCMMFC (réservée au
   monocristal implicite).
   
   Validation :
   -------------
   
   un nouveau test, SSDN109A, inspiré de l'étude ayant exhibé l'anomalie, permet de valider
   l'intégration explicite (et l'intégration implicite en V10) pour C=100000MPa. La solution
   de référence est fournie par Zmat (cf. courbe jointe).
   
   Impact documentaire :
   ---------------------
   
   ajout dans la doc R de la signification de H=0 pour la matrice d'interaction et doc du
   test : V6.08.109.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 9.0.0
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 10.0.0
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V6.08.109, R5.03.11
VALIDATION
   ssnd109a
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR tardieu      TARDIEU Nicolas        DATE 10/05/2010 - 13:02:26

--------------------------------------------------------------------------------
RESTITUTION FICHE 013204 DU 2009-03-11 17:53:35
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   Autoriser TOU_INI_EL* en thermique
FONCTIONNALITE
   Les éléments 2D de thermique ne savent pas calculer TOU_INI_ELGA. Il n'y a pas de raison à
   cela.
   
   J'ajoute donc les lignes suivantes dans le catalogue gener_thpl_2.cata:
   ----------------------------------------------------------------------------------------
   PNEUT_R
   TOU_INI_ELGA        99    IN__   NGEOMER  PGEOMER
   .                         OUT__  ESOURCR  PSOUR_R  EGNEUT_R PNEUT_R  EGGEOM_R PGEOM_R 
   EGNEUT_F PNEUT_F 
   ----------------------------------------------------------------------------------------
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test perso
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 015045 DU 2010-05-07 09:37:00
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   Modif dans MATIMP
FONCTIONNALITE
   Suite à la réalisation de la fiche issue14941, dans MATIMP format Matlab, on ajoute
   "-ascii" à la fonction "load" dans le commentaire.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   Perso
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST AJOUT ssnd109a                        proix J-M.PROIX          266    266      0
 CASTEST MODIF demo002a                     courtois M.COURTOIS         516     11     11
 CASTEST MODIF forma03d                     courtois M.COURTOIS         331      3      3
 CASTEST MODIF forma04a                     courtois M.COURTOIS         358     10     14
 CASTEST MODIF forma04b                     courtois M.COURTOIS         357     10     14
 CASTEST MODIF forma04c                     courtois M.COURTOIS         308      6     10
 CASTEST MODIF forma05a                     courtois M.COURTOIS         330      9     13
 CASTEST MODIF forma05b                     courtois M.COURTOIS         363      4      8
 CASTEST MODIF forma12b                       pellet J.PELLET           114      2      2
 CASTEST MODIF hsna120a                     courtois M.COURTOIS         762     17     17
 CASTEST MODIF mac3c01a                     courtois M.COURTOIS         434      1      1
 CASTEST MODIF mtlp100a                       delmas J.DELMAS          1348    570      4
 CASTEST MODIF perfe01a                     courtois M.COURTOIS         318      1     48
 CASTEST MODIF perfe03a                     courtois M.COURTOIS         332      1      4
 CASTEST MODIF sdll123a                     courtois M.COURTOIS         324     12     12
 CASTEST MODIF sdll123b                     courtois M.COURTOIS         487     21     20
 CASTEST MODIF sdll123c                     courtois M.COURTOIS         687     19     19
 CASTEST MODIF sdll124a                     courtois M.COURTOIS         248      3      2
 CASTEST MODIF sdll125a                     courtois M.COURTOIS         268      3      2
 CASTEST MODIF sdll125b                     courtois M.COURTOIS         268      3      2
 CASTEST MODIF sdll128a                     courtois M.COURTOIS         821     21     25
 CASTEST MODIF sdll133b                     courtois M.COURTOIS         366      1      3
 CASTEST MODIF sdll136a                     courtois M.COURTOIS         653      3      1
 CASTEST MODIF sdls113a                     courtois M.COURTOIS         419      6      6
 CASTEST MODIF sdls121a                     courtois M.COURTOIS         121      5      5
 CASTEST MODIF sdls121b                     courtois M.COURTOIS         110      5      5
 CASTEST MODIF sdls121c                     courtois M.COURTOIS         114      5      4
 CASTEST MODIF sdls139a                     courtois M.COURTOIS         606      2      2
 CASTEST MODIF sdlv124a                     courtois M.COURTOIS         565      5      6
 CASTEST MODIF sdlv125a                     courtois M.COURTOIS         592      1      2
 CASTEST MODIF sdlv131a                     courtois M.COURTOIS         259      6      5
 CASTEST MODIF sdlv131b                     courtois M.COURTOIS         263      7      6
 CASTEST MODIF sdlv131c                     courtois M.COURTOIS         266      8      7
 CASTEST MODIF sdlv131d                     courtois M.COURTOIS         241      6      5
 CASTEST MODIF sdnd105a                     courtois M.COURTOIS         217      3      3
 CASTEST MODIF sdnd105b                     courtois M.COURTOIS         215      3      3
 CASTEST MODIF sdnd106a                     courtois M.COURTOIS         256      1      1
 CASTEST MODIF sdnd121a                     courtois M.COURTOIS         248      1      1
 CASTEST MODIF sdnl105d                     courtois M.COURTOIS         559      1      3
 CASTEST MODIF sdns01a                      courtois M.COURTOIS         693      1      2
 CASTEST MODIF sdns01b                      courtois M.COURTOIS         371      1      2
 CASTEST MODIF sdns107a                     courtois M.COURTOIS         424      4      4
 CASTEST MODIF sdns107b                     courtois M.COURTOIS         424      4      4
 CASTEST MODIF shll102a                     courtois M.COURTOIS         414     21     23
 CASTEST MODIF sslp107a                     courtois M.COURTOIS         388     25     25
 CASTEST MODIF sslp315a                     courtois M.COURTOIS         167      1      2
 CASTEST MODIF sslv316c                     courtois M.COURTOIS         316      1      2
 CASTEST MODIF sslv316g                     courtois M.COURTOIS         316      1      2
 CASTEST MODIF ssna110a                     courtois M.COURTOIS        2117      6     10
 CASTEST MODIF ssnd101a                     courtois M.COURTOIS         364      9     10
 CASTEST MODIF ssnd101b                     courtois M.COURTOIS         309     10     10
 CASTEST MODIF ssnd106a                     courtois M.COURTOIS         227      1      1
 CASTEST MODIF ssnd106b                     courtois M.COURTOIS         215      1      1
 CASTEST MODIF ssnd107a                     courtois M.COURTOIS         241      1      1
 CASTEST MODIF ssnd108a                     courtois M.COURTOIS         257      1      1
 CASTEST MODIF ssnp15a                      courtois M.COURTOIS         887      1      1
 CASTEST MODIF ssns107a                     courtois M.COURTOIS         191     11     11
 CASTEST MODIF ssns107b                     courtois M.COURTOIS         195     11     11
 CASTEST MODIF ssns107c                     courtois M.COURTOIS         190     11     11
 CASTEST MODIF ssns107d                     courtois M.COURTOIS         194     11     11
 CASTEST MODIF ssnv171c                        proix J-M.PROIX          396    115    140
 CASTEST MODIF ssnv177a                     courtois M.COURTOIS         258     19     12
 CASTEST MODIF ssnv195a                     courtois M.COURTOIS         367      9      9
 CASTEST MODIF ssnv199e                     courtois M.COURTOIS         363      1      3
 CASTEST MODIF ssnv199f                     courtois M.COURTOIS         372      1      3
 CASTEST MODIF ssnv199g                     courtois M.COURTOIS         403      1      3
 CASTEST MODIF ssnv206a                     courtois M.COURTOIS         330      1      1
 CASTEST MODIF wdnp101a                     courtois M.COURTOIS         959      1      3
 CASTEST MODIF wtna110a                     courtois M.COURTOIS         436      3      4
 CASTEST MODIF wtna110b                     courtois M.COURTOIS         426      3      3
 CASTEST MODIF wtna110c                     courtois M.COURTOIS         454      3      3
 CASTEST MODIF wtna110d                     courtois M.COURTOIS         444      3      3
 CASTEST MODIF wtnp119a                     courtois M.COURTOIS         447      3      3
 CASTEST MODIF wtnp119b                     courtois M.COURTOIS         435      3      3
 CASTEST MODIF wtnp119c                     courtois M.COURTOIS         444      3      3
 CASTEST MODIF wtnp119d                     courtois M.COURTOIS         432      3      3
 CASTEST MODIF wtnp124a                     courtois M.COURTOIS         545      1      2
 CASTEST MODIF wtnp124b                     courtois M.COURTOIS         550      1      2
 CASTEST MODIF wtnp124c                     courtois M.COURTOIS         541      1      2
 CASTEST MODIF wtnp124d                     courtois M.COURTOIS         528      1      2
 CASTEST MODIF wtnv102a                       granet S.GRANET           341      6      6
 CASTEST MODIF wtnv132a                     courtois M.COURTOIS         676      1      2
 CASTEST MODIF wtnv133a                     courtois M.COURTOIS         623      1      2
 CASTEST MODIF wtnv133b                     courtois M.COURTOIS         607      1      2
 CASTEST MODIF wtnv134a                     courtois M.COURTOIS         874      1      2
 CASTEST MODIF wtnv135a                     courtois M.COURTOIS         349      1      1
 CASTEST MODIF wtnv136a                     courtois M.COURTOIS         441      1      2
 CASTEST MODIF wtnv136b                     courtois M.COURTOIS         426      1      2
 CASTEST MODIF wtnv136c                     courtois M.COURTOIS         457      1      2
 CASTEST MODIF wtnv136d                     courtois M.COURTOIS         447      1      2
 CASTEST MODIF zmat004a                     courtois M.COURTOIS         518     41     39
 CASTEST MODIF zmat008a                     courtois M.COURTOIS         219      1      1
 CASTEST MODIF zzzz110a                     courtois M.COURTOIS         307      7      6
 CASTEST MODIF zzzz159a                     courtois M.COURTOIS         116      5      3
 CASTEST MODIF zzzz159b                     courtois M.COURTOIS         118      4      3
 CASTEST MODIF zzzz159c                     courtois M.COURTOIS         127      5      4
 CASTEST MODIF zzzz159d                     courtois M.COURTOIS         123      5      4
 CASTEST MODIF zzzz159e                     courtois M.COURTOIS         105      5      4
 CASTEST MODIF zzzz159f                     courtois M.COURTOIS         156      1      1
 CASTEST MODIF zzzz180a                     courtois M.COURTOIS         826      8     70
 CASTEST MODIF zzzz189a                     courtois M.COURTOIS         297     15     14
 CASTEST MODIF zzzz208a                     courtois M.COURTOIS         534     26     26
 CASTEST MODIF zzzz208b                     courtois M.COURTOIS         464     16     20
 CASTEST MODIF zzzz241a                     courtois M.COURTOIS         308      1      1
 CASTEST MODIF zzzz257a                    lebouvier F.LEBOUVIER        330      6      1
CATALOGU MODIF typelem/gener_thpl_2          tardieu N.TARDIEU          345      6      1
CATALOPY MODIF entete/accas                 courtois M.COURTOIS         223      5      5
       C MODIF supervis/astermodule         courtois M.COURTOIS        4122      1     11
       C MODIF supervis/fonctions_module    courtois M.COURTOIS         158      2      2
 FORTRAN AJOUT algorith/lcmmec                 proix J-M.PROIX           82     82      0
 FORTRAN AJOUT algorith/lcmmj1                 proix J-M.PROIX          230    230      0
 FORTRAN AJOUT algorith/lcmmj2                 proix J-M.PROIX          189    189      0
 FORTRAN MODIF algeline/op0093              courtois M.COURTOIS         523      1      7
 FORTRAN MODIF algorith/calcme                granet S.GRANET           559      4      4
 FORTRAN MODIF algorith/coeihm                granet S.GRANET           390      4      5
 FORTRAN MODIF algorith/comthm                granet S.GRANET           289      4      4
 FORTRAN MODIF algorith/ddlact                 corus M.CORUS            186     13      1
 FORTRAN MODIF algorith/hmlvag                granet S.GRANET           377      3      2
 FORTRAN MODIF algorith/kitdec                granet S.GRANET            72      3      3
 FORTRAN MODIF algorith/lcmmja                 proix J-M.PROIX          101     23    206
 FORTRAN MODIF algorith/lcmmon                 proix J-M.PROIX          171      2      4
 FORTRAN MODIF algorith/lcmmop                 proix J-M.PROIX          342      2      2
 FORTRAN MODIF algorith/op0099              courtois M.COURTOIS         121      1     10
 FORTRAN MODIF algorith/refe81                 corus M.CORUS            235      5      2
 FORTRAN MODIF algorith/xenrch               geniaut S.GENIAUT          428      2      2
 FORTRAN MODIF calculel/jevech                pellet J.PELLET           197      2      2
 FORTRAN MODIF calculel/tecac2                pellet J.PELLET           364      2      2
 FORTRAN MODIF debug/matimp                  tardieu N.TARDIEU          240      2      2
 FORTRAN MODIF modelisa/asmaco                pellet J.PELLET           641      4      6
 FORTRAN MODIF modelisa/asmasu                pellet J.PELLET           333      2      5
 FORTRAN MODIF modelisa/cafaci                pellet J.PELLET           461     13      8
 FORTRAN MODIF modelisa/calicp                pellet J.PELLET           367      5      4
 FORTRAN MODIF modelisa/caliob                pellet J.PELLET           297      5      5
 FORTRAN MODIF modelisa/caliso                pellet J.PELLET           264     13     10
 FORTRAN MODIF modelisa/calyrc                pellet J.PELLET           614      5      4
 FORTRAN MODIF modelisa/caprec                pellet J.PELLET           516      5      4
 FORTRAN MODIF modelisa/op0059                 proix J-M.PROIX          381      7      2
 FORTRAN MODIF utilitai/ltnotb             lebouvier F.LEBOUVIER        103      7      2
 FORTRAN MODIF utilitai/rsexc2                delmas J.DELMAS            96     11      8
  PYTHON AJOUT Macro/impr_diag_campbell_utils   courtois M.COURTOIS         823    823      0
  PYTHON AJOUT Noyau/N_types                courtois M.COURTOIS          61     61      0
  PYTHON MODIF Build/B_ETAPE                courtois M.COURTOIS         806     22     20
  PYTHON MODIF Build/B_SENSIBILITE_DERIVATION   courtois M.COURTOIS         485      7      5
  PYTHON MODIF Cata_Utils/t_fonction        courtois M.COURTOIS         737     75     87
  PYTHON MODIF Execution/genpy              courtois M.COURTOIS         316     11      9
  PYTHON MODIF Intranet/calc_eolienne       courtois M.COURTOIS        1723      3      3
  PYTHON MODIF Macro/calc_europlexus_ops    courtois M.COURTOIS        2546      9      9
  PYTHON MODIF Macro/calc_fonction_ops      courtois M.COURTOIS         418      4     13
  PYTHON MODIF Macro/calc_mode_rotation_ops   courtois M.COURTOIS          98      1      2
  PYTHON MODIF Macro/calc_spec_ops          courtois M.COURTOIS         436     38     38
  PYTHON MODIF Macro/defi_fonc_elec_ops     courtois M.COURTOIS         192      4      4
  PYTHON MODIF Macro/defi_inte_spec_ops     courtois M.COURTOIS         153     11      8
  PYTHON MODIF Macro/dyna_iss_vari_ops      courtois M.COURTOIS         355     42     50
  PYTHON MODIF Macro/fiabilite_mefisto      courtois M.COURTOIS         460     10     11
  PYTHON MODIF Macro/impr_diag_campbell_ops   courtois M.COURTOIS        1212     18    834
  PYTHON MODIF Macro/lire_fonction_ops      courtois M.COURTOIS         262      6      5
  PYTHON MODIF Macro/macr_fiabilite_ops     courtois M.COURTOIS         358     13     14
  PYTHON MODIF Macro/macr_recal_ops         courtois M.COURTOIS         674     13      8
  PYTHON MODIF Macro/observation_ops        courtois M.COURTOIS        1172     56     80
  PYTHON MODIF Macro/post_dyna_alea_ops     courtois M.COURTOIS         431     12     12
  PYTHON MODIF Macro/post_k1_k2_k3_ops      courtois M.COURTOIS        1294    175    175
  PYTHON MODIF Macro/propa_fiss_ops         courtois M.COURTOIS         975     82     91
  PYTHON MODIF Macro/raff_xfem_ops          courtois M.COURTOIS         198      1      2
  PYTHON MODIF Macro/reca_algo              courtois M.COURTOIS         295     67     62
  PYTHON MODIF Macro/reca_calcul_aster      courtois M.COURTOIS         521     17      8
  PYTHON MODIF Macro/reca_controles         courtois M.COURTOIS         242     11      5
  PYTHON MODIF Macro/reca_evol              courtois M.COURTOIS         165      3      3
  PYTHON MODIF Macro/reca_interp            courtois M.COURTOIS         186     14     91
  PYTHON MODIF Macro/recal                  courtois M.COURTOIS        1590     36     24
  PYTHON MODIF Macro/reca_mac               courtois M.COURTOIS         129      5      6
  PYTHON MODIF Macro/reca_message           courtois M.COURTOIS         149      5      4
  PYTHON MODIF Macro/reca_utilitaires       courtois M.COURTOIS         245     13      7
  PYTHON MODIF Macro/simu_point_mat_ops     courtois M.COURTOIS         654      8      8
  PYTHON MODIF Macro/test_fonction_ops      courtois M.COURTOIS         945     22     20
  PYTHON MODIF Meidee/meidee_calc_spec      courtois M.COURTOIS         960      7     10
  PYTHON MODIF Meidee/meidee_calcul_correlation   courtois M.COURTOIS         209      6      6
  PYTHON MODIF Meidee/meidee_calcul_modifstruct   courtois M.COURTOIS        1211      5      6
  PYTHON MODIF Meidee/meidee_calcul_turbulent   courtois M.COURTOIS         450     42     42
  PYTHON MODIF Meidee/meidee_cata           courtois M.COURTOIS        1259     22     26
  PYTHON MODIF Meidee/meidee_correlation    courtois M.COURTOIS         491     10     10
  PYTHON MODIF Meidee/meidee_iface          courtois M.COURTOIS         780      4      4
  PYTHON MODIF Meidee/meidee_modifstruct    courtois M.COURTOIS         896     49      9
  PYTHON MODIF Meidee/meidee_parametres     courtois M.COURTOIS         776      1      2
  PYTHON MODIF Meidee/meidee_test           courtois M.COURTOIS         353      2      2
  PYTHON MODIF Meidee/meidee_turbulent      courtois M.COURTOIS         841      3      3
  PYTHON MODIF Meidee/modes                 courtois M.COURTOIS        1422      7      9
  PYTHON MODIF Messages/compor2                proix J-M.PROIX           63      9      4
  PYTHON MODIF Messages/modelisa2             pellet J.PELLET           339     13      4
  PYTHON MODIF Messages/soustruc2              corus M.CORUS             74     12      1
  PYTHON MODIF Messages/table0             lebouvier F.LEBOUVIER        134      4      1
  PYTHON MODIF Messages/utilitai8             delmas J.DELMAS           270     14      4
  PYTHON MODIF Noyau/N_CONVERT              courtois M.COURTOIS         105     15     13
  PYTHON MODIF Noyau/N_utils                courtois M.COURTOIS         153     12      9
  PYTHON MODIF Noyau/N_VALIDATOR            courtois M.COURTOIS        1224     40     37
  PYTHON MODIF SD/co_cham_elem              courtois M.COURTOIS          74      4      4
  PYTHON MODIF SD/co_cham_no                courtois M.COURTOIS         102      4      4
  PYTHON MODIF SD/co_fonction               courtois M.COURTOIS         351      4      4
  PYTHON MODIF SD/co_macr_elem_dyna         courtois M.COURTOIS         120     17     17
  PYTHON MODIF SD/co_matr_asse_gene         courtois M.COURTOIS         210     38     38
  PYTHON MODIF SD/co_vect_asse_gene         courtois M.COURTOIS         101     16     16
  PYTHON MODIF SD/sd_resultat               courtois M.COURTOIS         179      1      3
  PYTHON MODIF Stanley/as_courbes           courtois M.COURTOIS         301     25     22
  PYTHON MODIF Utilitai/Graph               courtois M.COURTOIS        1200      8      8
  PYTHON MODIF Utilitai/optimize            courtois M.COURTOIS         591     13     15
  PYTHON MODIF Utilitai/partition           courtois M.COURTOIS        1324     70     72
  PYTHON MODIF Utilitai/stats               courtois M.COURTOIS          61      3      3
  PYTHON MODIF Utilitai/sup_gmsh            courtois M.COURTOIS        1415      1      2
  PYTHON MODIF Utilitai/Table               courtois M.COURTOIS        1049     30     29
  PYTHON MODIF Utilitai/transpose           courtois M.COURTOIS          41     15      9
  PYTHON MODIF Utilitai/veri_matr_tang      courtois M.COURTOIS         267     30     32


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :    6        1651      1651             +1651
 MODIF :  204       96197      2800    3404      -604
 SUPPR :    0           0                 0        +0
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :  210       97848      4451    3404     +1047 
