========================================================================
Version 11.3.14 du : 14/03/2013
========================================================================


-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR hamon        HAMON François        DATE 03/13/2013 - 09:13:26

--------------------------------------------------------------------------------
RESTITUTION FICHE 020470 DU 2013-02-27 12:49:27
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    Defi_MATER_GC
FONCTIONNALITE
   Lors de l'utilisation de la loi Mazars, il est nécessaire de renseigner 6 paramètres
   matériaux: Ac,Bc,At,Bc,k et le seuil de déformation. 
   At définit le comportement post-endommagement en traction simple. Sa valeur est
   obligatoirement comprise entre 0 (comportement proche d'un comportement plastique parfait)
   et 1 ( aucune contrainte résiduelle à la ruine du béton). 
   
   Toutefois, en compression, le béton a un comportement adoucissant. De ce fait, le
   paramètre Ac ( similaire à At en compression) est généralement supérieur à 1. Il n'existe
   aucune borne supérieur à ce paramètre. Une limite inférieur à 1 est introduite (min =0)
   pour permettre de représenter le comportement en compression comme celui de la traction
   c'est à dire quasi-fragile. De nombreux modèles de béton font cette hypothèse et certains
   utilisateurs imposent un tel comportement à Mazars pour comparer les modèles même si cela
   n'est pas physique.
   
   Modification de la DEFI_MATER_GC.capy : 
   
         AC =SIMP(statut='f',typ='R',     val_min=0.E+0,
                  fr="Paramètre de décroissance post-pic en compression"),
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    aucune
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR idoux        IDOUX Ludovic          DATE 03/11/2013 - 04:04:01

--------------------------------------------------------------------------------
RESTITUTION FICHE 019548 DU 2012-09-20 15:17:22
TYPE evolution concernant Code_Aster (VERSION )
TMA : DeltaCad
TITRE
    AR01 Les xc3xa9lxc3xa9ments Q4GG et DKTG doivent exprimer les efforts dans le repxc3xa8re utilisateur
FONCTIONNALITE
   Histor
   
   1- Objectif
   -----------
   Actuellement les éléments à couches (DKT, DST, Q4G, COQUE_3D) expriment les contraintes
   dans le repère utilisateur alors que les éléments globaux (DKTG, Q4GG) expriment les
   efforts dans le repère intrinsèque. On uniformise cet état en faisant en sorte que les
   éléments globaux (DKTG,Q4GG) expriment les efforts dans le repère utilisateur défini par
   AFFE_CARA_ELEM.
   
   2- Modifications
   ----------------
   => Routine dxglrc(SIEF_ELGA): comme les contraintes stockées, sont exprimées dans le
   repère utilisateur, et que la vérification de la loi de comportement est faite dans le
   repère intrinsèque, on modifie dxglrc de la manière suivante:
   1 -> Passage des contraintes a l'instant T "-" du repère utilisateur au repère intrinsèque
   2 -> Calcul de la loi de comportement : accroissement de contrainte, variables internes,...
   3 -> Passage des contraintes a l'instant T "+" du repère intrinsèque au repère utilisateur
   4 -> Stockage des contraintes
   => Les routines te0409 et te0412 sont modifiées pour tenir compte du fait que SIEF_ELGA
   n'est plus exprimée dans le repère intrinsèque (option FORC_NODA, ENEL_xxx,...)
   
   3- Vérifications
   ----------------
     - passage des cas-tests utilisant les modélisations DKT, DST, Q4G, DKTG et Q4GG
     - ajout dans les cas-tests ssls126(a,b,c,d) et ssls127(a,b,c,d) de TEST_RESU sur 
       SIEF_ELGA, EFGE_ELGA, EFGE_ELNO et DEGE_ELGA, EFGE_ELNO pour les deux repères
   utilisateur suivant (0.,0.) et (33.,12.)
     - passage de l'étude industrielle citée dans la fiche 19405.
     - passage liste restreinte
   
   4- Documentation
   ----------------
     - Ajout dans la docs des cas-tests ssls126 et ssls127 des vérifications sur les options
   nouvellement testées
   
   5- Définition des repères intrinsèques des éléments de structure
   ----------------------------------------------------------------
     Il nest mentionné dans aucune documentation la manière dont sont définis les repères
   intrinsèques des éléments de structure, qui s'appuie sur la connectivité. On ouvre la
   fiche issue20532 à cet effet.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V3.03.126 V3.03.127
VALIDATION
    ssls126 ssls127 cas-test industriel
--------------------------------------------------------------------------------
RESTITUTION FICHE 019550 DU 2012-09-20 15:52:57
TYPE evolution concernant Code_Aster (VERSION )
TMA : DeltaCad
TITRE
    AR01 Ajouter dans MODI_REPERE le passage dans le repxc3xa8re intrinsxc3xa8que
FONCTIONNALITE
   histor (Proposition)
   
   1 - Objectif
   ------------
   On ajoute dans MODI_REPERE les mots-clés suivants :
   - REPERE='COQUE_UTIL_INTR' : permet le passage du repère utilisateur défini dans
   AFFE_CARA_ELEM au repère intrinsèque
   - REPERE='COQUE_INTR_UTIL' : permet le passage du repère intrinsèque au repère utilisateur
   défini dans AFFE_CARA_ELEM 
   
   2 - Exemple de Syntaxe
   ----------------------
      Exemple n°1 : DKT
          MOD = AFFE_MODELE(MAILLAGE=mail,
                            AFFE=_F(MODELISATION='DKT',TOUT='OUI',
                                    PHENOMENE='MECANIQUE'))
          ...
          RESU = MODI_REPERE(RESULTAT=RES,
                             MODI_CHAM =( _F(NOM_CHAM  = 'EFGE_ELNO',
                                            NOM_CMP   = ('NXX','NYY','NXY',
                                                         'MXX','MYY','MXY',
                                                         'QX','QY'),
                                            TYPE_CHAM = 'COQUE_GENE')
                                          _F(NOM_CHAM  = 'SIGM_ELNO',
                                             NOM_CMP   = ('SIXX','SIYY','SIXY',
                                                          'SIXY','SIXZ','SIYZ'),
                                             TYPE_CHAM = 'TENS_3D'),
                             REPERE    =    'COQUE_INTR_UTIL',
                             AFFE      = _F(GROUP_MA ='ENGREN'))
   
      Exemple n°2 : Q4GG
          MOD = AFFE_MODELE(MAILLAGE=mail,
                            AFFE=_F(MODELISATION='Q4GG',TOUT='OUI', 
                                   PHENOMENE='MECANIQUE'))
          ...
          RESU = MODI_REPERE(RESULTAT=RES,
                             MODI_CHAM = _F(NOM_CHAM  = 'SIEF_ELGA',
                                            NOM_CMP   = ('NXX','NYY','NXY',
                                                         'MXX','MYY','MXY',
                                                         'QX','QY'),
                                            TYPE_CHAM = 'COQUE_GENE',),
                             REPERE    =    'COQUE_UTIL_INTR',
                             AFFE      = _F(MAILLE ='M12'))
   3 - Analyse
   -----------
   Les fonctionnalités actuelles pour les coques, REPERE='COQUE' sont les suivantes:
   - Modélisations : DKT, DST, Q4G, COQUE_3D :  on ne traite que les types de champs
   suivants:
      . TYPE_CHAM='COQUE_GENE'  : EFGE_ELNO, EFGE_ELGA, DEGE_ELNO et EFGE_ELGA
      . TYPE_CHAM='TENS_3D'     : SIGM_ELNO, SIGM_ELGA, DEGE_ELNO et EFGE_ELGA
   - Modélisations DKTG, Q4GG: éléments non supportées
   
   Comme pour REPERE='COQUE', COQUE_UTIL_INTR/COQUE_INTR_UTIL est compatible avec :
      - Les cham_elem,
      - Les mots-clés GROUP_MA et MAILLE,
      - Les modélisations coques et plaques.
   
   Pour les modélisations DKTG et Q4GG :
     - Le mot-clé TYPE_CHAM = 'TENS_3D' n'est pas utilisé, puisque ces éléments sont
   formulés en termes d'efforts généralisés.
   
   
   3 Modifications
   ---------------
   - Routine chrpel : ajout à la carte CARIOE d'une nouvelle composante "REP"
   qui prend comme valeur :
      . REP = 1 si COQUE_INTR_UTIL est présent dans MODI_REPERE
      . REP = 2 si COQUE_UTIL_INTR est présent dans MODI_REPERE
   - Routine te0442 : modification de la routine pour traiter les deux nouveaux changement de
   repère. 
   - Catalogue grandeurs_simples___: ajout de la nouvelle composante REP a la grandeur CAROIE
   
   
   4 - Validations
   ---------------
   - ssls126c (Q4GG: TRIA3), ssls127d (Q4GG: QUA4)
   Dans ces deux modélisations, on vérifie pour l'option SIEF_ELGA, qu'après avoir effectué
   deux changements de repère successifs Utilisateur => Intrinsèque et Intrinsèque =>
   Utilisateur on retrouve bien les valeurs calculées par l’option EGFE_ELGA. 
   
   - Ajout d'un nouveau cas-test ZZZZ333 permettant vérifier les changements de repère du
   type COQUE_INTR_UTIL et COQUE_UTIL_INTR. Ce cas-test représente une plaque définie dans le
   plan XOY, orientée autour de l'axe Z d'un angle de 35°et soumise a un chargement de
   traction et de flexion. On teste les changements de repère suivant INTRINSEQUE =>
   UTILISATEUR et  UTILISATEUR => INTRINSEQUE pour les éléments de coque DKT avec les options
   REPE_TENS et REPE_GENE d'une part et pour les éléments de coque Q4GG avec l'option
   REPE_GENE d'autre part. Le maillage comporte des QUAD4 et des TRIA3. Les résultats sont
   comparés avec une solution analytique
   
   - Passage des cas-tests de coque
   - Passage des cas-test contenant MODI_REPERE
   - passage de la liste restreinte
   
   5 - Documentation
   ------------------
    - Ajout dans la Doc U MODI_REPERE des nouveaux changement de repères
    - Ajout dans la Doc V des cas-tests ssls126 et ssls127 des grandeurs testées
    - Rédaction de la Doc V du nouveau cas-test zzzz333
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V1.01.333 V3.03.126 V3.03.127 U4.74.01
VALIDATION
    ssls126c ssls127d zzzz333
--------------------------------------------------------------------------------
RESTITUTION FICHE 019338 DU 2012-08-21 08:17:04
TYPE evolution concernant Code_Aster (VERSION )
TMA : DeltaCad
TITRE
    AR01 MODI_REPERE pour les elements Q4GG, T3GG, DKTG, DKQG
FONCTIONNALITE
   1 - Objectif
   ------------
   L'objectif de cette fiche est d'étendre l'utilisation de MODI_REPERE aux modélisations
   DKTG (éléments DKTG, DKQG) et Q4GG (éléments Q4GG, T3GG) utilisant des lois de
   comportement globales.
   
   Les options disponibles a prendre en compte dans ces développements sont :
     - Contraintes généralisées  : EFGE_ELNO, EFGE_ELGA, SIEF_ELGA
     - Déformations généralisées : DEGE_ELGA, DEGE_ELNO
   
   2 - Modifications
   -----------------
   Par rapport aux modélisations DKT, DST, Q4G et COQUE_3D l'option SIEF_ELGA des
   modélisations DKTG et Q4GG ne contiennent pas les contraintes locales mais les efforts
   généralisées (SIEF_ELGA <=> EFGE_ELGA). 
   
   Les modifications effectuées sont les suivantes : 
   - Catalogue d'élément : ajout dans le catalogue gener_medkg1(modélisations Q4GG et DKTG)
   de l'option REPE_GENE.
   - Dans les routines te0442(changement de repère pour les plaques) et chrpel (changement de
   repère dans le cas d'un cham_elem), on ajoute la possibilité, dans le cas ou le type de
   champ modifier est du type COQUE_GENE, de pouvoir traiter le champ SIEF_ELGA.
   - Cas-test : Ajout de la commande MODI_REPERE, dans les cas-tests ssls127a (DKTG avec des
   TRIA3) et ssls127d (Q4GG avec des QUA4).Dans MODI_REPERE on utilise pour ANGL_REP les
   angles (35,0) et on calcule les options :
     . EFGE_ELNO dans le nouveau repère et on compare les valeurs de MXX, MYY et MXY au
   centre de la plaque avec la solution analytique
     . SIEF_ELGA dans le nouveau repère et on compare en NON_REGRESSION, les valeurs de MXX,
   MYY et MXY au point de gauss, situé à proximité du centre de la plaque. On doit trouver
   des valeurs proches de la solution analytique déterminée au centre de la plaque. 
   
   3. Validation
   -------------
     - passage des cas-tests ssls126 et ssls127
     - Passage des cas-tests utilisant la commande MODI_REPERE
     - Passage de la liste restreinte
   
   4. Documentation
   ----------------
    - Ajout dans la documentation de Validation des cas-tests ssls127 et ssls127 des
   grandeurs testées.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V3.03.127
VALIDATION
    ssls127a ssls127d
--------------------------------------------------------------------------------
RESTITUTION FICHE 020157 DU 2013-01-08 13:04:57
TYPE evolution concernant Code_Aster (VERSION )
TMA : DeltaCad
TITRE
    MN18 MODI_REPERE : recopie des champs pour les xc3xa9lxc3xa9ments non concernxc3xa9s par la modification de repxc3xa8re.
FONCTIONNALITE
   Remarque
   --------
   Pour que cette fiche soit restituée il est impératif de restituer en même temps les 
   fiches 19550, 19548, et 19338.
   
   
   1) Objectif
   -----------
   L'objectif de cette fiche est de rendre MODI_REPERE réentrant uniquement dans le cas des
   actions REPERE='COQUE_INTR_UTIL' et REPERE='COQUE_UTIL_INTR'.
   
   
   3) Modifications
   ----------------
    > modi_repere.capy : 
      - on remplace reentrant = 'n' par reentrant = 'f'
      - on vérifie que si le concept est reentrant les seuls actions possibles sont 
        REPERE='COQUE_INTR_UTIL' ou REPERE='COQUE_UTIL_INTR'.  
    > Routine op0191 : 
   
   4) Vérifications
   ----------------
     - Tous les cas-tests de coque DKT, DST, Q4G, DKTG et Q4GG
     - Tous les cas-tests utilisant MODI_REPERE
     - Liste restreinte
     - Passage des cas-tests ssls126(a-b) et ssls127(a-b) modifiés dans le cadre des fiches
   19550, 19548, et 19338.
     - ssls137d : validation de la réentrance de MODI_REPERE
     - zzzz333 : ce cas-test a été créer dans le cadre des fiches 19550 19548 et 19338. Son
   objectif est de vérifier SIEF_ELGA dans le repère intrinsèque et utilisateur a partir de
   la nouvelle SD_RESULTAT produite par MODI_REPERE
       Dans le cadre de cette fiche, on modifie le cas-test afin d'utiliser les SD_RESULTAT
   modifiée par MODI_REPERE avec reentrance. On ajoute un TEST_RESU sur le déplacement afin
   de vérifier que la reentrance ne modifie pas les déplacements.
     - plexu03b : Avec la version de référence d'Aster, dans CALC_EUROPLEXUX on reprend la
   SD_RESULTAT créée par MODI_REPERE sans la reentrace Aster plante 
      avec le message suivant:
      !--------------------------------------------------------------------------------!
      ! <EXCEPTION> <PLEXUS_1>                                                         !
      !                                                                                !
      ! Pour que CALC_EUROPLEXUS fonctionne il faut ajouter DEBUG=_F(HIST_ETAPE='OUI') !
      ! dans la commande DEBUT.                                                        !
      ! Remarque : CALC_EUROPLEXUS ne fonctionne pas en POURSUITE                      !
      !--------------------------------------------------------------------------------!
       En utilisant la reentrance, le message n'existe plus.
   
   5) Documentation
   ----------------
    > MODI_REPERE [U4.71.01] : mise a jour de la doc
   
   
   Rq la nouvelle doc est jointe a ce message
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V3.03.137, U4.74.01
VALIDATION
    tout cas-test utilisant des coques ou modi_repere
--------------------------------------------------------------------------------
RESTITUTION FICHE 019746 DU 2012-10-16 11:14:57
TYPE evolution concernant Code_Aster (VERSION )
TMA : Necs
TITRE
    Gestion des reperes des coques entre Code_Aster et EPX avec CALC_EUROPLEXUS
FONCTIONNALITE
   Contexte :
   
   Les champs de contraintes pour les coques dans Code_Aster ne vont plus être exprimés dans
   le repère intrinsèque mais dans le repère utilisateur. Ceci impacte la macro
   CALC_EUROPLEXUS car elle envoie des champs de contraintes à EUROPLEXUS qui les attend dans
   le repère intrinsèque.
   
   Travail effectué :
   ===================
   
   1- Modification de calc_europlexus_ops.py pour envoyer des contraintes dans le repère
   intrinsèque à EUROPLEXUS. Pour cela on utilise MODI_REPERE et la possibilité de réentrance
   avec les mot-clés REPERE=COQUE_UTIL_INTR et COQUE_INTR_UTIL.
   MODI_REPERE est appelé 3 fois :
   - pour passer les contraintes sur les Q4GG dans le repère intrinsèque avant l'appel à
   IMPR_RESU qui crée le fichier MED de maillage + état initial pour EPX.
   - après le IMPR_RESU pour qu'en sortie de CALC_EUROPLEXUS le résultat donné en entrée ait
   toujours ses contraintes dans le repère utilisateur
   
   - après récupération du résultat issu de EPX et construction d'un concept evol_noli, pour
   avoir en sortie le champ de contraintes dans le repère utilisateur.
   
   2- reprise des tests plexu* devenus NOOK à cause des contraintes exprimées dans le
   repère utilisateur
   
   plexu02a et b : ajout d'un appel à MODI_REPERE/COQUE_UTIL_INTR pour être en accord avec
   les références SOURCE_EXTERNE.
   plexu03b,c et plexu04a : modifications des valeurs des TEST_RESU sur les contraintes ainsi
   que sur les FORC_NODA qui sont légèrement modifiées (plexu02b).
   
   plexu05a : issue20495 est ouverte car ce cas-test s'arrête par manque de temps CPU. On
   vérifie qu'avec un temps CPU plus grand (200 contre 150), le cas-test est OK. Cependant,
   on laisse en l'état et le cas-test sera par conséquent en erreur lors de la restitution.  
   
   
   3- pour plexu03b : on a vu que les valeurs du résultat issu de CALC_PRECONT sont
   légèrement modifiées, notamment des valeurs de FORC_NODA. Or ces valeurs sont testées avec
   une référence SOURCE_EXTERNE fourni par le test bm_str_ini_med_cont. On a donc
   reconstruire bm_str_ini_med_cont.msh pour récupérer les valeurs de forces internes (de
   référence) à partir de ce nouvel état initial.
   
   Voici les nouvelles sources :
   
   /home/cheignon/19746_CALC_EPX_repere_coque/test_EPX/bm_str_ini_med_cont.epx
   /home/cheignon/19746_CALC_EPX_repere_coque/test_EPX/bm_str_ini_med_cont.msh
   
   4- Reporter les changements de valeurs de références dans les différentes doc.
   V1.01.312, V5.06.109
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V1.01.312, V5.06.109
VALIDATION
    plexu0*
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desroche     DESROCHES Xavier       DATE 03/11/2013 - 04:04:06

--------------------------------------------------------------------------------
RESTITUTION FICHE 020441 DU 2013-02-22 08:09:12
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    objet jeveux inexistant modi_repere
FONCTIONNALITE
   PROBLEME:
   --------
   
   modi_repere plante sur un champ epsp_elno avec le message :
   
   Objet JEVEUX inexistant dans  les bases ouvertes: >&&MANOPG.CELMOD.CELD<
   l'objet n'a pas été créé ou il a été détruit.
   
   Dans le job, le modi_repere précédent marche sur un champ sief_elno.
   
   ANALYSE:
   --------
   
   Dans modi_repere, pour les options _elno, on a besoin de créer un champ qui contient
   la matrice de passage gauss => noeuds . Pour allouer ce champ, on a besoin du nom de 
   paramètre (in ou out) servant à décrire le cham_elem.
   Suite au chantier CALC_CHAM, ces noms ont changé dans les catalogues d'éléments pour
   les options EPXX_ELNO. Ils n'ont pas été changés dans le fortran, ce qui provoque un
   code retour de ALCHML en erreur qui n'est pas testé, d'où le plantage. 
   
   CORRECTION:
   -----------
   1. On actualise dans la routine CHRPEL appelante de MANOPG les noms de paramètres
   (PDEFOPG pour les calculs de déformations)
   2. Dans MANOPG on teste le code retour de ALCHML. S'il est non nul, on arrête en <F>.
   
   VALIDATION:
   -----------
   - passage de l'étude jointe
   - ajout d'un changement de repère sur un champ EPSI_ELNO et un champ EPSP_ELNO dans le 
   test ssnv113a.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssnv113a
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST AJOUT zzzz333a                        idoux L.IDOUX           1441   1441      0
 CASTEST MODIF plexu02a                        idoux L.IDOUX            592     18      2
 CASTEST MODIF plexu02b                        idoux L.IDOUX            472     11      2
 CASTEST MODIF plexu03b                        idoux L.IDOUX            305     34     26
 CASTEST MODIF plexu03c                        idoux L.IDOUX            436     15     15
 CASTEST MODIF plexu04a                        idoux L.IDOUX            690     33     33
 CASTEST MODIF plexu05a                        idoux L.IDOUX            286      4      4
 CASTEST MODIF ssls118u                        idoux L.IDOUX            540     10     10
 CASTEST MODIF ssls118v                        idoux L.IDOUX            536     13     13
 CASTEST MODIF ssls126a                        idoux L.IDOUX            561    259      4
 CASTEST MODIF ssls126b                        idoux L.IDOUX            527    255      3
 CASTEST MODIF ssls126c                        idoux L.IDOUX            494    280      4
 CASTEST MODIF ssls126d                        idoux L.IDOUX            522    254      3
 CASTEST MODIF ssls127a                        idoux L.IDOUX            506    262      4
 CASTEST MODIF ssls127b                        idoux L.IDOUX            491    249      4
 CASTEST MODIF ssls127c                        idoux L.IDOUX            486    246      6
 CASTEST MODIF ssls127d                        idoux L.IDOUX            537    300      7
 CASTEST MODIF ssls137d                        idoux L.IDOUX            243     28      2
 CASTEST MODIF ssnv113a                        idoux L.IDOUX            241     21      3
CATALOGU MODIF compelem/grandeur_simple__      idoux L.IDOUX           2160      7      2
CATALOGU MODIF typelem/gener_mecq32            idoux L.IDOUX            313      2      2
CATALOGU MODIF typelem/gener_medkg1            idoux L.IDOUX            284     13      1
CATALOGU MODIF typelem/gener_medkt2            idoux L.IDOUX            374      3      3
CATALOPY MODIF commande/defi_mater_gc          hamon F.HAMON             81      3      3
CATALOPY MODIF commande/modi_repere            idoux L.IDOUX            101     17      4
 FORTRAN MODIF algorith/chrpel                 idoux L.IDOUX           1036     24     18
 FORTRAN MODIF algorith/chrpno                 idoux L.IDOUX            610      4      4
 FORTRAN MODIF algorith/op0191                 idoux L.IDOUX            237     70      6
 FORTRAN MODIF calculel/chrpan                 idoux L.IDOUX            135      2      2
 FORTRAN MODIF calculel/manopg                 idoux L.IDOUX            366      8      3
 FORTRAN MODIF elements/dxglrc                 idoux L.IDOUX            655     62     17
 FORTRAN MODIF elements/ef0409                 idoux L.IDOUX             59      4     21
 FORTRAN MODIF elements/te0409                 idoux L.IDOUX            382     43     18
 FORTRAN MODIF elements/te0412                 idoux L.IDOUX            300     23      4
 FORTRAN MODIF elements/te0422                 idoux L.IDOUX             80      3      4
 FORTRAN MODIF elements/te0442                 idoux L.IDOUX            192     29      2
 FORTRAN MODIF elements/te0443                 idoux L.IDOUX            275     69      1
  PYTHON MODIF Macro/calc_europlexus_ops       idoux L.IDOUX           2664     35      3
  PYTHON MODIF Messages/calculel7              idoux L.IDOUX             55      7      2


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :    1        1441      1441             +1441
 MODIF :   38       18824      2720     265     +2455
 SUPPR :    0           0                 0        +0
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :   39       20265      4161     265     +3896 
