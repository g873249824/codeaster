

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR abbas        ABBAS Mickael          DATE 06/11/2009 - 11:06:35

--------------------------------------------------------------------------------
RESTITUTION FICHE 014142 DU 2009-11-05 16:06:08
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   ssnv204a en 9.5.9
FONCTIONNALITE
   Oubli de report de la correction sur ssnv204a en V9 (fiche 14089)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ssnv104a
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 014080 DU 2009-10-22 07:33:02
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   sdls108a en accord avec sa doc
FONCTIONNALITE
   Dans la doc v du test sdls108a, on fait état de 15 (3*5) valeurs testés. On ne trouve que
   8 test_resu dans le fichier de commandes.
   
   Verification faite, tout se passe bien si on ajoute les test_resu manquants. Ouf !
   
   Il suffit donc juste de restituer le fichier de commandes joint à cette fiche.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sdls108a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desroches    DESROCHES Xavier       DATE 09/11/2009 - 14:42:35

--------------------------------------------------------------------------------
RESTITUTION FICHE 013609 DU 2009-07-10 11:25:05
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TMA : DeltaCad
TITRE
   CRIT_ELNO_RUPT - bug dans le changement de base
FONCTIONNALITE
   1) Problème
   -----------
   Sur le forum un utilisateur a constaté, lors du calcul 
   des contraintes dans le repère local , une erreur dans 
   la matrice de rotation pour le changement de base: 
   repère global => repère local.
   Les calculs sont :
    - corrects lorsque l'angle d'orientation des couches 
   est 0 ou 90, 
    - faux lorsque l'angle d'orientation des couches est 
   différent de 0 ou 90.
   
   L'étude fournie avec la fiche montre que les résultats 
   fournis avec le logiciel LAMINATOR
   (www.thelaminator.net) sont différents de ceux obtenus 
   avec Code_Aster lorsque l'angle est de 45°.
   
   2 Correction
   --------------------
   a) te0040 ligne 144
      Avant : PGL(1,1) = COS(ORIENR)
              PGL(2,1) =-SIN(ORIENR)
              PGL(1,2) = SIN(ORIENR)
              PGL(2,2) = COS(ORIENR)
   
      Après : PGL(1,1) = COS(ORIENR)
              PGL(2,1) = SIN(ORIENR)
              PGL(1,2) =-SIN(ORIENR)
              PGL(2,2) = COS(ORIENR)
   
   b) cas-test ssls128a
      correction du signe de valeur de référence de SIGLT 
   de la deuxième couche
   
   3 Vérification
   --------------
   3.1) test ssns128a avec une seule couche, sollicitation 
   en compression. La contrainte analytique dans le repère 
   local de la fibre est de SIGL=-175. on doit trouver les 
   mêmes valeurs dans le repère local.
        a) maillage de référence
           - Repère global :  SIXX= -175. ; SIYY= 0. ; 
   SIXY=  0.
   	- Repère local  :  SIGL= -175. ; SIGT= 0. ; 
   SIGLT= 0. 
        b) maillage "tourne" de 45° autour de Z
           - Repère global :  SIXX= -87.49; SIYY= -87.49; 
   SIXY= -87.49
   	- Repère local  :  SIGL= -175. ; SIGT=   0.  ; 
   SIGLT=  0.
   3.1) cas-test avec maillage identique au cas-test 
   ssls128a sauf qu'il a "tourné" de 45 autour de Z. On 
   doit trouver les mêmes valeurs dans le repère local avec 
   et sans surcharge pour la deuxième couche.
    a) contraintes dans la deuxième couche (sans surcharge)
           SIGL = -8.7499999977130D+01
           SIGT = -8.7499999976932D+01
           SIGLT=  2.0877119650568D+01
    b) contraintes dans la deuxième couche (avec surcharge)
           SIXX = -8.7499999976932D+01
           SIYY = -8.7499999977130D+01
           SIXY = -2.0877119650568D+01
   
   3.3) étude
   on a repasse l'étude fournie, avec la surcharge. On 
   retrouve bien les valeurs calculées par le logiciel 
   LAMINATOR
   
   3.4) passage des cas-tests contenant DEFI_COQU_MULT
   
   4 Documentation
   ---------------
   Correction de la doc V3.03.128 du cas-test ssls128
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 3.1.1
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 3.1.1
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V3.03.128
VALIDATION
   SSLS128A
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR pellet       PELLET Jacques         DATE 09/11/2009 - 14:42:35

--------------------------------------------------------------------------------
RESTITUTION FICHE 013562 DU 2009-06-25 07:19:06
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TMA : DeltaCad
TITRE
   objet JEVEUX inexistant
FONCTIONNALITE
   Problème:
   ---------
   L'uilisation de POST_ELEM / INTEGRALE est impossible si le champ à intégrer a été calculé
   sur un sous-ensemble du modèle.
   
   Analyse :
   ---------
   Le problème vient du fait que l'intégrale est calculée sur un cham_elem calculé par
   CALC_ELEM avec usage du mot clé GROUP_MA pour restreindre les calculs élémentaires sur un
   sous-ensemble des mailles.
   Dans ce cas, le DISMOI de la ligne 75 de chpond.f n'a pas de sens car le ligrel n'est pas
   un ligrel de modèle.
   
   Correction: 
   -> suppression du DISMOI de la ligne 72 de chpond 
   -> ajout d'un nouvel argument MODELE pour la routine chpond.f
   
   Remarque: Le modèle est stocké dans la SD_RESULTAT (EVOL_ELAS) lors du MECA_STATIQUE. Il
   est extrait de la SD résultat dans la routine op0107(POST_ELEM), routine medome et
   transféré à PEEINT puis à PEECAL puis à chpond.
   
   Validation
   ----------
   -> Passage de l'étude
   -> Passage des 11 cas-tests contenant POST_ELEM(INTEGRALE)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   xc3xa9tude jointe
--------------------------------------------------------------------------------
RESTITUTION FICHE 013445 DU 2009-05-20 15:42:15
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TMA : DeltaCad
TITRE
   CALC_ELEM - charge de type contact
FONCTIONNALITE
   Problèmes constatés
   -------------------
   Si dans CALC_ELEM on laisse :
    a) dans EXCIT une charge de type contact, on a un message d'alarme surprenant :
          <A> <CALCULEL6_65>                                                   
            !  Le nombre de charges fourni par l'utilisateur 3 est différent du    !
            !  nombre de charges trouvées dans la SD_resultat -6456360408816457140 !
   	   
    b) des charges cinématiques, on a un plantage. 
   	
   Analyse et Correction
   --------------------- 
   a) CALC_ELEM(EXCIT=CONTACT)
   Le problème n'a rien a voir avec les charges de contact, c'est avant tout un problème
   d'affichage. L'anomalie est apparue avec la charge de contact c'est un hasard. Si on
   remplace dans la poursuite la charge de contact par une autre charge, on a le même
   problème. Le message CALCULEL6_65 est déclenché par la routine rslesd.f. Le problème se
   produit lors du remplissage du tableau VALI avant l'impression du message, VALI était mal
   rempli.
   on a ligne 314 ...
         IF(NCHALU.NE.NCHASD) THEN
            VALI(1)=NCHALU
            VALI(1)=NCHASD
            CALL U2MESI('A','CALCULEL6_65',2,VALI)
         ENDIF
         
          correction : 
         IF(NCHALU.NE.NCHASD) THEN
            VALI(1)=NCHALU
            VALI(2)=NCHASD   <-- correction
            CALL U2MESI('A','CALCULEL6_65',2,VALI)
         ENDIF
   
   Remarque : cette correction a déjà été restituée par Mathieu Courtois en 10.0.12.
   
   b) charges cinématiques
   Le plantage est du au fait que la commande CALC_ELEM n'accepte pas des concepts de
   char_meca_cine. 
   On modifie les catalogues calc_elem.capy et de calc_no.capy pour prendre en compte les
   charges de type cinématique.
   La vérification a été effectuée sur la base du cas-test ssnv134.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.81.01 U4.81.02
VALIDATION
   ssnv134, ssnv104b
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR durand       DURAND Christophe      DATE 12/11/2009 - 14:20:49

--------------------------------------------------------------------------------
RESTITUTION FICHE 012752 DU 2008-10-30 15:18:12
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   ASSE_MAILLAGE : permettre les noeuds confondus dans les zones xc3xa0 coller
FONCTIONNALITE
   Quand on a des noeuds géométriquement confondus dans un des groupes à coller pour
   ASSE_MAILLAGE, il y a confusion. En effet, l'appariement entre les groupes en vis à vis se
   fait par identité géométrique (distance nulle de noeud à noeud). Si dans l'une et l'autre
   des zones à apparier, on a déjà des noeuds topologiquement disjoints, mais géométriquement
   confondus, l'algorithme se plante fatalement.
   
   Je corrige donc en blindant : émission d'une erreur fatale quand on a des noeuds confondus
   dans la zone group_ma_1 du premier maillage. Comme par la suite on vérifie que la zone
   group_ma_2 lui est géométriquement superposée, pas besoin de faire la mm vérification sur
   le deuxième maillage.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test fourni par Samuel dans la fiche
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR sellenet     SELLENET Nicolas       DATE 12/11/2009 - 14:20:50

--------------------------------------------------------------------------------
RESTITUTION FICHE 014101 DU 2009-10-26 13:03:55
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   ssla200 a et b NOOK_TEST_RESU
FONCTIONNALITE
   Problème :
   ----------
   """
   ssla200a et ssla200b NOOK_TEST_RESU en debug JEVEUX.
   """
   
   
   Analyse :
   ---------
   Un test réalisé sur un résultat issu d'un MECA_STATIQUE devient NOOK lorsqu'on passe en
   debug JEVEUX. En imprimant le second membre calculé au début du MECA_STATIQUE, je me suis
   rendu compte qu'il n'était pas similaire en debug JEVEUX et en mode normal.
   
   Après analyse, j'ai constaté que la partie du second membre qui était fausse est due à un
   LIAISON_GROUP d'un AFFE_CHAR_MECA_F.
   
   Dans AFFE_CHAR_MECA_F pour construire la sd_char_meca correspondante au fichier de
   données, on commence par construire une liste des noeuds impliqués dans le LIAISON_GROUP.
   Cette liste et toutes les listes dépendantes sont triées dans la routine ORDLRL.
   Malheureusement, ces listes sont appelées avec un JEVEUO en lecture, de ce fait, en debug
   JEVEUX, le tri n'est pas sauvegardé. On se retrouve donc avec des inversions de valeurs
   dans la charge calculée.
   
   Cela peut engendrer des résultats faux depuis la 3.3.24 puisque ces tableaux n'ont jamais
   été sollicité en écriture dans cette routine.
   
   
   Solution :
   ----------
   Dans ORDLRL, on fait le JEVEUO en écriture sur les tableaux à trier.
   
   
   Validation :
   ------------
   ssla200a en debug JEVEUX.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 3.3.24
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 3.3.24
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ssla200a en debug JEVEUX
NB_JOURS_TRAV  : 2.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR audebert     AUDEBERT Sylvie        DATE 12/11/2009 - 14:20:50

--------------------------------------------------------------------------------
RESTITUTION FICHE 013770 DU 2009-08-25 14:04:21
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   comb_sism_modal et concept fonction dans SPEC_OSCI
FONCTIONNALITE
   bug signalÃ© sur le forum :
   le mot clÃ© spec_osci admet des nappes comme des fonctions simples. Or dans (au 
   moins) asexc1.f,
   on manipule l'objet .VALE de cet objet comme s'il s'agissait d'une collection 
   (JEXNUM) et non d'un
   vecteur simple.
   
   Autrement dit, on suppose qu'on a toujours affaire Ã  une nappe, et non une fonction 
   simple.
   
   On modifie le catalogue de telle sorte que les fonctions soient interdites pour le 
   mot-clé SPEC_OSCI de COMB_SISM_MODAL (en cohérence avec CALC_FONCTION, qui produit 
   bien des nappes). En effet, une nappe est absolument nécessaire (même d'une seule 
   fonction) pour le calcul.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   astout de COMB_SISM_MODAL
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR corus        CORUS Mathieu          DATE 12/11/2009 - 14:20:50

--------------------------------------------------------------------------------
RESTITUTION FICHE 013553 DU 2009-06-23 09:59:53
TYPE anomalie concernant Code_Aster (VERSION 10.2)
TITRE
   Mauvaise prise en compte de l'amortissement hysteretique heterogene
FONCTIONNALITE
   -- PROBLEME ORIGINAL --
   
   Je signale ici une petite anomalie sur la prise en compte de l'amortissement hystérétique.
   Dans le cas d'un modèle presentant simultanement des materiaux dissipatifs et non
   dissipatifs, pour obtenir un resultat correct, il faut pour l'instant preciser
   AMOR_HYST=0. dans les DEFI_MATERIAU associes aux materiaux non dissipatifs, faute de quoi
   un amortissement leur est assigne. Par exemple, dans le cas d'une plaque sandwich acier /
   visco / acier, si on ne precise pas AMOR_HYST=0.0 pour l'acier, voici les resultats que
   l'on obtient (calcul modal) :
   
       NUMERO    FREQUENCE (HZ)    AMORTISSEMENT    NORME D'ERREUR
            1      6.13318E+01       4.98790E-01       3.04393E-09
            2      1.35097E+02       4.98923E-01       6.36164E-10
            3      3.44878E+02       4.99163E-01       1.21238E-10
            4      4.36279E+02       4.99547E-01       9.22955E-11
            5      4.64861E+02       4.98940E-01       6.80782E-11
   
   Dans le cas test (joins), j'ai fixé eta=1, ce qui conduit, dans le cas eta=1 pour tout le
   modele, a un amortissement modal de eta/2, soit le 0,5 retrouve par calcul.
   
   Et voici ce qu'il faut obtenir (obtenu en precisant AMOR_HYST = 0.0 pour le materiau
   associe a l'acier)
   
       NUMERO    FREQUENCE (HZ)    AMORTISSEMENT    NORME D'ERREUR
            1      6.18367E+01       1.40127E-02       4.30809E-09
            2      1.38709E+02       3.77744E-02       8.61579E-10
            3      3.57371E+02       4.94749E-02       1.64133E-10
            4      4.49336E+02       4.30415E-02       1.20468E-10
            5      4.85451E+02       6.54859E-02       8.89606E-11
   
   
   Je propose donc que, par defaut, on assigne la valeur 0.0 à AMOR_HYST, ce qui me semble
   etre la facon la plus simple de contourner le probleme.
   
   -- RESOLUTION --
   
   La valeur assignee a AMOR_HYST n'est pas initialisee dans te0050.f. Par analogie avec les
   autres modelisations d'amortissement, on initialise a 0 cette valeur dans te0050f. Le fait
   de ne pas renseigner explicitement le mot clef dans DEFI_MATERIAU revient donc a ne pas
   considerer d'amortissement hysteretique.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 7.0
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 7.0
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   cas test personnel
NB_JOURS_TRAV  : 0.125
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desroches    DESROCHES Xavier       DATE 12/11/2009 - 14:20:50

--------------------------------------------------------------------------------
RESTITUTION FICHE 014025 DU 2009-10-12 13:19:27
TYPE anomalie concernant Code_Aster (VERSION 10.2)
TITRE
   Quelques corrections pour POST_ELEM
FONCTIONNALITE
   POST_ELEM calcul du centre de gravité : plusieurs problèmes
   
   1) si les mots-clé RESULTAT et CHAM_GD sont absents, alors 
   les mots-clé MODELE et CHAM_MATER sont obligatoires. 
   C'est dit dans la doc U mais pas intégré dans la commande.
   On rajoute un bloc dans POST_ELEM imposant cette condition.
   
   2) Le calcul du centre de gravité fait intervenir la masse 
   de la structure et donc, sauf pour les éléments discrets, 
   la masse volumique. En fait rho apparait au numérateur et 
   au dénominateur de la formule et on a simplifié, sans 
   prendre garde au fait que rho peut être nul.
   Dans le cas où rho=0., la masse est nulle et le centre de 
   gravité n'a pas de sens. Il vaut donc mieux arrêter en 
   erreur fatale et demander à l'utilisateur de rentrer un 
   rho non nul si il veut utiliser MASS_INER.
   
   Réalisé pour tous les éléments 2D et 3D.
   Impact : tous les te calculant MASS_INER sur ces éléments.
   
   Doc: on prévient les utilisateurs dans POST_ELEM MASS_INER.
   
   3) Dans le cas où un maillage 2D a un z constant non nul, 
   ce qui est autorisé par Aster, les calculs du centre de 
   gravité et des moments d'inertie ne tiennent pas compte de 
   ce z non nul, ce qui a priori n'est pas normal.
   Néanmoins, les champs de géométrie étant 2D (à 2 
   composantes), on a perdu cette information au niveau te et 
   il est normal que les calculs aient lieu en z=0.
   Les modifications à faire sont trop importantes (il 
   faudrait un champ de géométrie à 3 cmp en 2D et modifier 
   tous les te) pour prendre en compte ce cas particulier.
   
   On ne fait donc rien, sinon prévenir les utilisateurs dans 
   la doc de POST_ELEM MASS_INER.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 3.2
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 3.2
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.81.22
VALIDATION
   fichiers associxc3xa9s a la fiche
NB_JOURS_TRAV  : 3.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 013949 DU 2009-09-28 15:13:16
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Charge thermique s'appuyant sur un mod? m?nique + THER_LINEAIRE
FONCTIONNALITE
   Dans le cadre du TP thermo-mécanique de la formation de 
   base, on s'est rendu compte qu'un calcul THER_LINEAIRE 
   mené avec une charge de température imposée
   (AFFE_CHAR_THER/TEMP_IMPO) qui a été définie sur le 
   modèle mécanique, conduit à un calcul "ENDED OK" mais 
   que celui-ci est complètement faux.
   Ceci est du au fait qu'il n'y a pas de vérification dans 
   AFFE_CHAR_THER que le modéle est bien thermique.
   
   On vérifie dans AFFE_CHAR_XXXX (THER ou MECA) que la 
   charge est définie sur un modèle de même type.
   Routine impactée : cagene.f
   
   Pour AFFE_CHAR_CINE, la vérification est bien effectuée.
   De même, si on se trompe de modèle dans THER_LINEAIRE ou 
   MECA_STATIQUE, on a un message clair.
   
   Le test FORMA01C permet de vérifier facilement.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 3.2
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 3.2
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sans
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR greffet      GREFFET Nicolas        DATE 12/11/2009 - 14:20:51

--------------------------------------------------------------------------------
RESTITUTION FICHE 013773 DU 2009-08-26 12:12:16
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Doc ZZZZ102 et cas test associxc3xa9
FONCTIONNALITE
   Contexte
   Le cas-test zzzz102a présentait trois tests sur des valeurs de spectres 
   d'oscillateurs avec des tolérances importantes : de 5 à 10 %. Les solutions 
   de références sont analytiques.
   
   Analyse et solution
   En pratique, si l'on analyse le contenu fréquentiel des signaux utilisés 
   (unités logiques 18 et 19), on remarque que la fréquence de coupure se 
   situe vers 50 - 60 Hz, pas moins.
   
   On cherche à tester des valeurs asymptotiques (type accélération 
   d'entraînement), qui sont donc à ne pas mesurer fortement en dessous de la 
   fréquence de coupure du signal d'entrée.
   
   Le cas-test d'origine testait à 35,5 Hz (c'est la fréquence de coupure par 
   défaut pour SPEC_OSCI) et comme on le voit sur les figures ci-jointes le 
   spectre est encore assez "chahuté" à cette fréquence et il faudrait se 
   placer plus loin : a minima vers 50 Hz pour bien approcher la valeur 
   asymptotique.
   La valeur par défaut de LIST_FREQ pour le calcul SPEC_OSCI reste pertinente 
   pour des accéléros "classiques", dont la fréquence de coupure est 
   inférieure à 30 - 40 Hz (cas des spectres réglementaires français 
   habituels).
   
   Je propose donc de modifier le cas-test afin de bien tenir compte de tout 
   le contenu fréquentiel des signaux employés. Je définis donc une liste de 
   fréquence plus large : jusqu'à FMAX = 100 Hz (qui sera aussi la fréquence 
   pour mesurer les valeurs asymptotiques).
   
   En faisant cela, les écarts aux solutions de références deviennent 
   inférieures à 0.03%. On redéfinit donc la tolérance à 0.1 % (au lieu de 5 
   et 10 %).
   
   Le temps de calcul passe d'environ 10 s à 14 s (sur Calibre 5).
   
   Impact documentaire
   Au niveau de la doc U2, on donnera le conseil de toujours commencer par 
   vérifier le contenu fréquentiel du signal d'entrée, afin de pouvoir définir 
   la liste de fréquence pour le calcul de spectre d'oscillateur en 
   conséquence, surtout si on cherche l'accélération d'entrainement.
   Pour la doc U4, on pourra clarifier la définition de la liste de fréquence 
   par défaut.
   
   Qualité des résultats
   En termes d'imprécision des résultats avec la liste de fréquence par 
   défaut, il faut modérer les conclusions : en effet, l'information 
   pertinente est souvent la valeur maximale du spectre, qui est 
   habituellement obtenue pour des fréquences bien plus basses que 30 Hz.
   
   Version 9
   le report en version 9 sera simple : seul zzzz102a.comm est (légèrement) 
   impacté par cette restitution.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V1.01.102, U4.32.04, U2.06.10
VALIDATION
   zzzz102a
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 014139 DU 2009-11-05 12:07:47
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Depassement de tableau sdls119 a
FONCTIONNALITE
   Effectivement, le vecteur de réels 'FON_PROV' qui contient le champ 
   d'entrée pour la FFT
   (ou la FFT inverse) est de dimension 2*NBORDR pour la FFT et 3*NBORDR en 
   FFT inverse.
   Les données sont rangées ainsi :
   - de 1 à NBORDR ce sont les instants ou les fréquences suivant le sens de 
   FFT,
   - ensuite de sont les valeurs (réelles pour la FFT) ou complexes pour la 
   FFT-1.
   Pour stocker les nombres complexes on stocke séparement partie réelle et 
   imaginaire voilà
   pourquoi le vecteur et 1/3 plus long pour la FFT-1.
   Ce vecteur est construit dans PREFFT qui fait ensuite appel à SPDFFT.
   Dans SPDFFT, on va lire ces valeurs et pour le sens FFT-1, la boucle va 
   trop loin : 
   l'indice va en fait jusqu'au plus petit entier puissance de 2 supérieur à 
   NBORDR.
   
   En fait il faut récupérer les valeurs jusqu'à NBORDR puis éventuellement 
   compléter de 0.
   
   Si on fait cette modification, cela ne change pas les valeurs du test 
   sdls119a (qui est le
   seul à passer par ces routines : via op0181 : REST_SPEC_TEMP). Tous les 
   autres calculs de
   FFT se font avec CALC_FONCTION et se basent maintenant sur la FFT python.
   
   Routine impactée : SPDFFT
   
   Validation : on complète le test sdls119a en comparant les solutions avec 
   celles obtenues
   avec la FFT python (on passe alors par un CALC_FONCTION).
   
   Report en version 9 : facile car SPDFFT est alors quasiment identique.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V2.03.119
VALIDATION
   sdls119a
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desroches    DESROCHES Xavier       DATE 12/11/2009 - 14:20:52

--------------------------------------------------------------------------------
RESTITUTION FICHE 013851 DU 2009-09-10 15:55:59
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TMA : CS
TITRE
   Erreur JEVEUX avec MODI_REPERE
FONCTIONNALITE
   Anomalie:
   --------
   Lors de l'execution d'une etude ne contenant pas de groupe de 
   noeud, une erreur JEVEUX apparait lors de l'appel a la commande 
   MODI_REPERE. Quand on rajoute un GROUP_NO quelconque dans le 
   fichier de maillage, cette erreur n'apparait plus.
   
   Modification:
   ------------
   La routine chrpel est modifiée afin de tester la presence de 
   groupes
   
   Validation:
   ----------
   sdls01b modifie pour reproduire l'anomalie mais non restitue
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sans
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 12/11/2009 - 14:20:52

--------------------------------------------------------------------------------
RESTITUTION FICHE 014088 DU 2009-10-23 10:38:13
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Erreur lors de la recuperation des erreurs fatales dans STAT_NON_LINE
FONCTIONNALITE
   Problème
   ========
   
   resu=STAT_NON_LINE(...)
   => exception aster.error levée et récupérée par le superviseur qui écrit <S> (via impers)
      dans le fichier ERREUR (fort.9)
   => diagnostic <S>_ERROR : la base est fermée et recopiée.
   
   try:
      resu=STAT_NON_LINE(...)
   except aster.error:
      xxx
   => exception aster.error levée mais récupérée par le jdc et non le superviseur, donc
      pas de <S>.
   => diagnostic <F>_ERROR : la base a été fermée correctement (par FIN) mais n'est pas
   recopiée en raison du diagnostic.
   
   
   Solution
   ========
   
   Rappel sur le mécanisme d'erreurs/exceptions :
   ----------------------------------------------
   Dans les études (mot-clé CODE absent de DEBUT/POURSUITE), en cas d'erreur fatale :
    - on imprime le message avec le code <EXCEPTION> (au lieu de <F>),
    - on invalide le concept courant,
    - on ferme la base correctement en passant par FIN,
    - on lève une exception,
    - le diagnostic est <S>_ERROR, la base est recopiée.
   
   Si CODE (ou ERREUR_F='ABORT') est présent dans DEBUT/POURSUITE, en cas d'erreur fatale :
    - on imprime le message avec le code <F>,
    - on ne passe pas par FIN,
    - on appelle abort,
    - le diagnostic est <F>_ERROR, la base n'est pas recopiée.
   
   
   Dans STAT_NON_LINE, on souhaite récupérer les instants déjà calculé.
   Pour cela, on active le comportement en cas d'erreur fatale appelé EXCEPTION+VALID (via
   onerrf).
   
   Mais dans ce cas, l'impression du message ne remplaçait pas <F> (ou <E>) par <EXCEPTION>
   car le test était "== 'EXCEPTION'" et donc non vérifié avec EXCEPTION+VALID.
   
   Après correction, si on récupère l'exception dans le jdc, le diagnostic est <A>_ALARM (à
   cause du PAR_LOT='NON').
   
   
   On ajoute le test erreu05a pour vérifier ce comportement :
    - On fait un calcul thermo-mécanique.
    - La température varie de 0 à 10°C entre 0 et 10s.
    - Les propriétés matériaux ne sont définies qu'entre 0 et 5°C.
    - On demande le calcul aux instants 3 et 6s.
    - On récupère l'exception.
   En poursuite :
    - On vérifie que le concept evol_noli ne contient qu'un pas de temps calculé.
    - On calcule un instant supplémentaire (t=4s) pour vérifier l'intégrité du concept
   sauvegardé dans la base.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : u1.03.01
VALIDATION
   erreu05a
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desoza       DE SOZA Thomas         DATE 12/11/2009 - 14:20:52

--------------------------------------------------------------------------------
RESTITUTION FICHE 014059 DU 2009-10-16 16:29:41
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   TOLE_APPA provoque un depassement de tableau
FONCTIONNALITE
   Anomalie
   ========
   
   Lorsque le mot-clé TOLE_APPA est utilisé et qu'il provoque l'élimination d'un noeud du
   contact (par que **tous** les noeuds maîtres sont situés à une distance > TOLE_APPA) alors
   on a une seg_fault dans le contact discret uniquement.
   
   Correction
   ==========
   
   Lorsque que l'on se trouve dans un tel cas, on saute l'ajout du noeud (CFADDM) et on met à
   jour le pointeur (APPOIN).
   Impact : chmano.f
   
   Validation
   ==========
   
   Dans ZZZZ237A, mettre TOLE_APPA à 1.0 élimine bien tous les noeuds du contact et on se
   retrouve donc dans le cas sans contact (avant ça plantait).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   zzzz237a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR devesa       DEVESA Georges         DATE 12/11/2009 - 14:20:53

--------------------------------------------------------------------------------
RESTITUTION FICHE 013820 DU 2009-09-04 07:59:31
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Certains tests Miss emettent trop d'alarmes
FONCTIONNALITE
   On effectue des actions correctrices sur les fichiers de 
   commandes ou maillage de certains cas tests MISS pour diminuer le 
   nombre d'alarmes:
   Cas tests MISS01A et MISS05A: 
             -------    -------
   - on élimine les alarmes MODELISA5_8 :
    la maille :  %(k1)s  est en double dans le group_ma:  %(k2)s . 
   on elimine les doublons
   Pour cela , on supprime dans les fichiers .mail des groupes de 
   mailles inutiles.
   
   - pour le cas test MISS05A, on élimine aussi les alarmes 
   MODELISA_39 :
    la maille  %(k1)s  n'a pas ete afféctée par une matrice 
   (DISCRET).
   Pour cela, on affecte des masses ponctuelles nulles au groupe de 
   mailles RADIER dans miss05a.13
   
   Cas tests MISS04A et MISS04B: 
             -------    -------
   - on élimine les alarmes ELEMENTS_40 :
     -> L'axe de référence pour le calcul du repère local est normal 
   à au moins un élément de plaque.
   Pour cela, on suit le conseil en modifiant l'axe de référence 
   (axe X par défaut) par ANGL_REP dans AFFE_CARA_ELEM en donnant 
   une direction oblique.
   
   Toutefois pour les fichiers de commandes de MISS05a et MISS01A, 
   on n'a pu éliminer les alarmes ELEMENTS4_80 :
     L'élément de plaque QUAD4 défini sur la maille : %(k1)s
     n'est pas plan et peut conduire a des résultats faux
     Distance au plan :  %(r1)f
   Le maillage commun à ces 2 tests d'EPR a été transmis par le 7N 
   avec un maillage manuel par GIBI des éléments du dôme à la 
   planéité imparfaite.
   On n'a pu non plus éliminer les messages ALGELINE5_23 sur le 
   calcul modal par bandes où la vérification a posteriori sur un 
   intervalle légèrement élargi peut générer un message sur un 
   nombre de modes estimé différent de celui calculé.
   
   Il y avait aussi un certain nombre de messages MODELISA4_8 ou 
   MODELISA4_9 sur la présence de mailles doubles ou aplaties dans 
   les tests MISS051A, MISS05A, MISS03A, MISS08A.
   Pour le test MISS03A, on a pu les éliminer en supprimant des 
   mailles inutiles et les groupes qui les contiennent.
   Mais pour les autres tests, ces messages étaient soit inévitables 
   (MISS08A avec des mailles SEG2 de taille nulle) soit trop 
   compliqués à éliminer (MISS01A et MISS05A). Dans ce cas, on a 
   rajouté un VERI_MAIL=_F(VERIF='NON')qui s'il ajoute lui-même une 
   alarme permet de diminuer de beaucoup la taille des messages 
   d'alarmes précédents.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   tests MISS
NB_JOURS_TRAV  : 1.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR angles       ANGLES Jean            DATE 12/11/2009 - 14:20:53

--------------------------------------------------------------------------------
RESTITUTION FICHE 013536 DU 2009-06-17 15:44:07
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
   CALC_FATIGUE : incoherence OPTION / EQUI_GD
FONCTIONNALITE
   catalogue modifié : 
   
   calc_fatigue.capy
   
   ajout de 2 blocs :
   
                b_sigm   =BLOC(condition = "OPTION == 'DOMA_ELNO_SIGM' or OPTION ==
   'DOMA_ELGA_SIGM'",
                                  fr="Calcul a partir d un champ de contraintes.",
                  HISTOIRE        =FACT(statut='o',
                  RESULTAT        =SIMP(statut='o',typ=(evol_elas,dyna_trans,
                                                      evol_noli) ),
                  EQUI_GD         =SIMP(statut='f',typ='TXM',defaut="VMIS_SG",
                                    into=("VMIS_SG",) ),
                                      ),
                              ),
                b_epsi   =BLOC(condition = "OPTION != 'DOMA_ELNO_SIGM' and OPTION !=
   'DOMA_ELGA_SIGM'",
                                  fr="Calcul a partir d un champ de déformations.",
                  HISTOIRE        =FACT(statut='o',
                  RESULTAT        =SIMP(statut='o',typ=(evol_elas,dyna_trans,
                                                      evol_noli) ),
                  EQUI_GD         =SIMP(statut='o',typ='TXM',defaut="INVA_2_SG",
                                    into=("INVA_2_SG",) ),
                                       ),
   
   
   IMPACT DOCUMENTAIRE :
   -------------------
   Préciser dans le paragraphe 3.3.2 de la doc U4.83.02 (CALC_FATIGUE) que VMIS_SG et
   INVA_2_SG sont calculés à partir du déviateur des contraintes pour le premier et du
   déviateur des déformations pour le second.
   
   3.3.2 Opérande EQUI_GD
         ? EQUI_GD      =     /    'VMIS_SG',
                              /    'INVA_2_SG'
           Pour pouvoir calculer le dommage subi par une structure, par une méthode de Wöhler, de
           Manson-Coffin ou une méthode de Taheri, il faut disposer d'une histoire de
   chargement en
           contraintes ou en déformations "uniaxiale". Pour ce faire il faut transformer le
   tenseur de
           contraintes ou le tenseur de déformations en un champ uniaxial (scalaire)
   "équivalent".
                              pour calculer le dommage à partir d'une histoire de chargement
   de type
           'VMIS_SG'
                              contrainte de von Mises signée,
                              pour calculer le dommage à partir d'une histoire de chargement
   de type
           'INVA_2_SG'
                              invariant d'ordre 2 signé de la déformation.
   
   
   Préciser dans le paragraphe 2.6.5 (Options de calcul de critères) de la doc U4.81.01
   (CALC_ELEM) que INVA_2_SG est calculé à partir du déviateur des déformations.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.83.02  U4.81.01
VALIDATION
   SZLZ105A
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 12/11/2009 - 14:20:53

--------------------------------------------------------------------------------
RESTITUTION FICHE 013121 DU 2009-02-04 16:47:17
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TMA : DeltaCad
TITRE
   IMPR_RESU GMSH  TENS_3D plante dans irgmce.f
FONCTIONNALITE
   Anomalie
   --------
   IMPR_RESU/GMSH: Une verification etait faite dans irgmce (ligne 335) sur le nombre de
   composantes lorsque le type de champ est un tenseur (au sens gmsh).
   Il fallait que le nombre de composantes contenu dans le champ soit egal au nombre de
   composantes  specifiees par l'utilisateur.
   Cette verification etait redhibitoire dans la mesure ou on ne pouvait pas considerer des
   champs contenant plus de 6 composantes pour l'impression d'un
   champ de 6 composantes.
   
   Correction
   ----------
   Nous avons supprime cette verification en otant de irgmce l'appel à ASSERT (ligne 335).
   
   Validation
   ----------
   - passage de l'etude fournie par l'utilisateur: on a verifie que le fichier de
   post-taitement etait correctement cree et on a visualise avec gmsh le champ en question.
   - passage d'une liste restreinte a IMPR_RESU/GMSH (170 cas-tests)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test utilisant IMPR_RESU/GMSH
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR lefebvre     LEFEBVRE Jean-Pierre   DATE 12/11/2009 - 14:20:53

--------------------------------------------------------------------------------
RESTITUTION FICHE 013423 DU 2009-05-15 11:21:52
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   Type LOGICAL dans les structures fortran90 de MUMPS
FONCTIONNALITE
   La structure Fortran90 manipulée par MUMPS contients des éléments de type LOGICAL. Il est
   nécessaire de les modifier en LOGICAL*4 quand ils sont embarqués dans aster et compilés
   avec l'option -i8 sur le serveur Bull pour assurer la cohérence avec les librairies MUMPS
   compilées elles sans cette option.
   On modifie les fichiers d'include dmumps_root.h,dmumps_struc.h, zmumps_root.h et
   zmumps_struc.h et on restitue les routines : amumpc.F, amumpi.F, amumpm.F,  amumpp.F,
   amumpr.F, amumps.F et amumpt.F sans modifications pour qu'elles soient recompilées avec
   les fichiers d'include modifiés.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   les tests mumpsXX
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR tardieu      TARDIEU Nicolas        DATE 09/11/2009 - 13:23:51

--------------------------------------------------------------------------------
RESTITUTION FICHE 014135 DU 2009-11-04 17:25:44
TYPE anomalie concernant Code_Aster (VERSION 10.2)
TITRE
   En NEW10.0.24, le cas-test ssna102e est NOOK sur Calibre5.
FONCTIONNALITE
   J'ai regardé le problème : il s'agit d'une variation qui apparait au fur et à mesure que
   le calcul avance. On accumule des petites erreurs liées au calcul en virgule flottante et
   au final, on obtient une petite différence sur le résultat.
   Je mets donc les tolérances pour que ça marche.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   Passage du test
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 014130 DU 2009-11-03 16:18:26
TYPE express concernant Code_Aster (VERSION 10.2)
TITRE
   Encore un problxc3xa8me dans le GCP
FONCTIONNALITE
   Comme dans la fiche 14081, il s'agit d'une erreur au sein de l'algorithme de Gradient
   Conjugué Projeté. Il y avait une autre confusion entre la direction de recherche et le
   gradient de la fonctionnelle. Précédemment, il s'agissait de la conjugaison, là il s'agit
   de la phase de projection.
   Heureusement, ceci ne pouvait produire de résultats faux.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   astout tests avec GCP
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST AJOUT erreu05a                      macocco K.MACOCCO          102    102      0
 CASTEST MODIF miss01a                       macocco K.MACOCCO          487      2      2
 CASTEST MODIF miss04a                       macocco K.MACOCCO          321      2      1
 CASTEST MODIF miss04b                       macocco K.MACOCCO          472      2      1
 CASTEST MODIF miss05a                       macocco K.MACOCCO          443      3      2
 CASTEST MODIF miss08a                       macocco K.MACOCCO          372      2      2
 CASTEST MODIF sdls108a                        abbas M.ABBAS           2468     45      1
 CASTEST MODIF sdls119a                      macocco K.MACOCCO          496     80      7
 CASTEST MODIF ssls128a                    lebouvier F.LEBOUVIER        305      3      2
 CASTEST MODIF ssna102e                      tardieu N.TARDIEU          248      5      8
 CASTEST MODIF ssnv204a                        abbas M.ABBAS            622     15     38
 CASTEST MODIF zzzz102a                      macocco K.MACOCCO         1504     24     14
CATALOPY MODIF commande/calc_elem          lebouvier F.LEBOUVIER        545      6      6
CATALOPY MODIF commande/calc_fatigue         macocco K.MACOCCO           99     15      2
CATALOPY MODIF commande/calc_no            lebouvier F.LEBOUVIER        110      2      2
CATALOPY MODIF commande/comb_sism_modal      macocco K.MACOCCO          119      4      4
 FORTRAN MODIF algorith/algocg               tardieu N.TARDIEU          683      4      4
 FORTRAN MODIF algorith/chmano               macocco K.MACOCCO          266      9      6
 FORTRAN MODIF algorith/chrpel               macocco K.MACOCCO          722      9      3
 FORTRAN MODIF elements/te0040             lebouvier F.LEBOUVIER        205      3      3
 FORTRAN MODIF elements/te0050               macocco K.MACOCCO          149      2     10
 FORTRAN MODIF elements/te0065               macocco K.MACOCCO          189      5      2
 FORTRAN MODIF elements/te0152               macocco K.MACOCCO          132      5      2
 FORTRAN MODIF elements/te0157               macocco K.MACOCCO          157      5      2
 FORTRAN MODIF elements/te0227               macocco K.MACOCCO          159      5      2
 FORTRAN MODIF elements/te0245               macocco K.MACOCCO          124      5      2
 FORTRAN MODIF elements/te0285               macocco K.MACOCCO          212      5      2
 FORTRAN MODIF elements/te0409               macocco K.MACOCCO          366      4      1
 FORTRAN MODIF elements/te0417               macocco K.MACOCCO          153      5      2
 FORTRAN MODIF elements/te0431               macocco K.MACOCCO          493      5      2
 FORTRAN MODIF modelisa/asmaco               macocco K.MACOCCO          643     23      2
 FORTRAN MODIF modelisa/cagene               macocco K.MACOCCO           95     13      2
 FORTRAN MODIF modelisa/charme               macocco K.MACOCCO          377      1      6
 FORTRAN MODIF modelisa/ordlrl               macocco K.MACOCCO          375      7      7
 FORTRAN MODIF prepost/irgmce                macocco K.MACOCCO          393      1      4
 FORTRAN MODIF utilitai/chpond             lebouvier F.LEBOUVIER        213      4      4
 FORTRAN MODIF utilitai/peecal             lebouvier F.LEBOUVIER        239      2      2
 FORTRAN MODIF utilitai/spdfft               macocco K.MACOCCO          166      6      4
  PYTHON MODIF Messages/elements5            macocco K.MACOCCO          206      4      1
  PYTHON MODIF Messages/modelisa2            macocco K.MACOCCO          388      5      1
  PYTHON MODIF Messages/modelisa9            macocco K.MACOCCO          411      1      5
  PYTHON MODIF Messages/utilitai8            macocco K.MACOCCO          260     11      1
  PYTHON MODIF Utilitai/Utmess               macocco K.MACOCCO          629      2      2


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :    1         102       102              +102
 MODIF :   42       17016       361     176      +185
 SUPPR :    0           0                 0        +0
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :   43       17118       463     176      +287 
