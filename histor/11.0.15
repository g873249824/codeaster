

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR abbas        ABBAS Mickael          DATE 07/12/2011 - 11:00:17

--------------------------------------------------------------------------------
RESTITUTION FICHE 015966 DU 2010-11-25 10:05:02
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    DEF2 - Evolution de DEFI_LIST_INST pour l'event-driven
FONCTIONNALITE
   Problématique
   =============
   
   Dans le cadre de la réalisation de la fiche issue9332, on propose plusieurs modifications
   de DEFI_LIST_INST. Ces modifications se répartissent en deux lots:
   - on acte l'idée de la séparation EVENEMENT/ACTION
   - on simplifie (beaucoup) et on résorbe des fonctionnalités 
   
   PRINCIPE GÉNÉRAUX
   =================
   
   Il s'agit de découpler deux choses: un événement et son action associée. 
   
   Evol 1: Nouveaux événements
   ===========================
   
   Il existe désormais quatre types d'événements :
   EVENEMENT         = SIMP(into            =
   ("ERREUR","DELTA_GRANDEUR","COLLISION","INTERPENETRATION"),),    
   
   - ERREUR: une erreur de type intégration LdC, pilotage, matrice singulière ou contact
   survient lors du calcul ou le nombre maxi d'itérations de Newton est atteint
   - DELTA_GRANDEUR: une grandeur a atteint une valeur donnée
   - COLLISION: on détecte une collision( contact discret) voir issue9332
   - INTERPENETRATION: on détecte une interpénétration des deux surfaces (contact discret
   pénalisé) voir issue9332
   
   Il ne peut y avoir qu'un événement de type ERREUR, COLLISION, INTERPENETRATION et
   COMP_NCVG mais plusieurs de
   types DELTA_GRANDEUR.
   
   Evol 2: Nouvelles actions
   =========================
   
   ACTION          = SIMP(into=
   ("ARRET","DECOUPE","ITER_SUPPL","AUTRE_PILOTAGE","ADAPT_COEF_PENA"),),
   - ARRET: arrêt du calcul
   - DECOUPE: on découpe le pas de temps
   - ITER_SUPPL: on fait quelques itérations de Newton en plus
   - AUTRE_PILOTAGE: on choisit l'autre ETA du pilotage
   - ADAPT_COEF_PENA: voir issue9332
   
   Fonctionnement: la lecture des données
   --------------------------------------
   
   L'opérateur OP0028 (DEFI_LIST_INST) est coupé en trois morceaux pour faciliter la maintenance:
   - gestion de la liste d'instants DFLLTY
   - gestion des événements DFLLEC
   - gestion de l'adaptation DFLLAD
   NB1: l'événement ERREUR est obligatoire. Soit l'utilisateur le définit dans
   DEFI_LIST_INST, soit on le crée
   automatiquement.
   NB2: il y a nécessairement un ordre de priorité ERREUR >> DELTA_GRANDEUR. Cet ordre est
   géré dans DEFI_LIST_INST (on classe les événements
   dans l'ordre)
   NB3: en théorie, on pourrait imaginer plusieurs ERREUR (DIVE_ERRE_FACT, DIVE_ERRE_PILO,
   etc) suivant les événements. En pratique, il est impossible d'avoir une action différente
   par erreur puisqu'une seule erreur suffit à rendre le calcul impossible.
   Par contre, en soutterain, trois événements son sous-jacents à ERREUR: DIVE_ERRE,
   DIVE_ITER et COMP_NCVG
   
   
   OP0070 lit les données issues de DEFI_LIST_INST et en fait des copies locales (base
   volatile). On enrichit la routine d'interrogation UTDIDT qui ne peut interroger que les SD
   créées dans OP0070 (SDDISC) et non manipuler les SD de DEFI_LIST_INST.
   Si l'utilisateur utilise un DEFI_LIST_REEL au lieu d'un DEFI_LIST_INST, on active
   néanmoins l'événement important (ERREUR) avec l'ACTION='ARRET'
   
   Fonctionnement: Enregistrement des événements
   ---------------------------------------------
   
   On évalue la convergence (routine NMCONV) qui traite également les codes retours
   (intégration, factorisation pilotage, contact discret) et qui calcule les résidus.
   A la sortie, on vérifie le déclenchement des événements. C'est la routine NMEVDR. Si un
   événement est déclenché, on l'enregistre mais on ne le traite pas tout de suite.
   
   NB1: SIMU_POINT_MAT (op0033) utilise PMEVDR au lieu de NMEVDR du fait d'une légère
   différence dans le traitement des code-retours, mais la routine principale
   d'enregistrement des événements NMEVEV est commune aux deux cas.
   
   
   Fonctionnement: Actions des événements
   --------------------------------------
   
   La routine principale NMACTN s'occupe de gérer les actions à réaliser suite à un événement.
   1/ Recherche du premier événement activé: NMACTO
   2/ Action suite à l'action: NMEVAC
     * ARRET - S'arrêter
     * DECOUPE - Découper le pas de temps: NMDECO
     * ITER_SUPPL - Extrapoler résidu pour faire quelques itérations de Newton en plus: NMACEX
     * AUTRE_PILOTAGE - Changer le ETA du pilotage
   
   
   * ARRET: aucune option (!) 
   * DECOUPE: reprise du pas de temps en découpant
    Choix de la méthode de découpe SUBD_METHODE=('MANUEL','AUTO')
       1/ On peut découper de manière MANUEL: l'intervalle est découpé en tronçons de
   longueur égale (géré par les mots-clefs SUBD_PAS, SUBD_NIVEAU, SUBD_PAS_MINI).
       2/ On peut découper de manière AUTOMATIQUE: l'intervalle est découpé en tronçons
   inégaux, il y a deux options automatiques (pour l'instant), non choisie par l'utilisateur
        a/ La méthode EXTRAPOLE le premier incrément est évalué grâce à une savante
   formule issue de l'extrapolation linéaire des résidus.
        b/ Une méthode basée sur la collision (voir issue9332)
   * ITER_SUPPL: faire quelques itérations de Newton en plus
   PCENT_ITER_PLUS remplace SUBD_ITER_PLUS
   On résorbe tous les mots-clefs liés à l'extrapolation: 
   SUBD_OPTION , SUBD_ITER_IGNO , SUBD_ITER_FIN 
   
   NB1: si l'action EXTRAPOLE échoue, on essaie le découpage manuel (4 subdivisions)
   NB2: si l'action AUTRE_PILOTAGE échoue, on découpe
   NB3: l'action AUTRE_PILOTAGE n'est déclenchée que par ITER_MAXI. Une autre erreur provoque
   la découpe du pas de temps.
   
   Validation: les 195 cas-test de DEFI_LIST_INST
   
   Imapcts: 
   defi_list_inst.capy
   diadap.f  ndxdec.f  nmconv.f  nmdcei.f  nmdecp.f  nmevev.f  ntcrli.f  pmevdr.f
   dideco.f  nmacex.f  nmcret.f  nmdcen.f  nmdifi.f  nmevr0.f  op0033.f  pminit.f
   dierre.f  nmactn.f  nmcrld.f  nmdcex.f  nmdini.f  nmfpas.f  op0070.f  tiinit.f
   dieven.f  nmacto.f  nmcrli.f  nmdcin.f  nmerge.f  nminit.f  pascom.f  w039ca.f
   diinit.f  nmadat.f  nmcrlm.f  nmdcrg.f  nmevac.f  nmitsp.f  pascou.f
   eneven.f  nmadev.f  nmcrls.f  nmdeca.f  nmevdg.f  nmlere.f  pmactn.f
   ndexpl.f  nmcadt.f  nmcrsu.f  nmdecm.f  nmevdp.f  nmlerr.f  pmconv.f
   ndxcvg.f  nmcerr.f  nmdcea.f  nmdeco.f  nmevdr.f  nmnewt.f  pmdeco.f
   dfdevn.f  dfllad.f  dflldb.f  dfllec.f  dfllli.f  dfllpe.f  dfllty.f  op0028.f
   dfllac.f  dfllae.f  dflldc.f  dfllin.f  dfllne.f  dfllsv.f  dfllvd.f  utdidt.f
   adaptation.py      extrapolation.py  sd_list_inst.py
   algorith11.py      itersupp.py       subdivise.py
   discretisation.py  mecanonline6.py   test_compor_ops.py
   
   comp002i.comm  ssnp117a.comm  ssnv138d.comm  wtna109a.comm  wtnp122b.comm
   comp002j.comm  ssnp118j.comm  ssnv138e.comm  wtna109b.comm  wtnp122c.comm
   forma03b.comm  ssnp118k.comm  ssnv139b.comm  wtna111a.comm  wtnp122d.comm
   forma03c.comm  ssnp118l.comm  ssnv147f.comm  wtnp102a.comm  wtnp122e.comm
   hsll100a.comm  ssnp118v.comm  ssnv157c.comm  wtnp102b.comm  wtnp122f.comm
   hsnv101d.comm  ssnp118w.comm  ssnv157k.comm  wtnp102c.comm  wtnp122g.comm
   hsnv120b.comm  ssnp118x.comm  ssnv169d.comm  wtnp102d.comm  wtnp122h.comm
   perfe02a.comm  ssnp123a.comm  ssnv169e.comm  wtnp102e.comm  wtnp122i.comm
   sdnd100c.comm  ssnp123b.comm  ssnv169f.comm  wtnp102f.comm  wtnp123a.comm
   sdnl113a.comm  ssnp125a.comm  ssnv169g.comm  wtnp107a.comm  wtnp123b.comm
   sdnv103b.comm  ssnp125b.comm  ssnv169h.comm  wtnp112e.comm  wtnp123c.comm
   sdnv104a.comm  ssnp132a.comm  ssnv169i.comm  wtnp112f.comm  wtnp123d.comm
   sdnv104b.comm  ssnp133a.comm  ssnv171b.comm  wtnp112g.comm  wtnp124a.comm
   sdnv104e.comm  ssnp133b.comm  ssnv176e.comm  wtnp112h.comm  wtnp124b.comm
   ssep001a.comm  ssnp133c.comm  ssnv189b.comm  wtnp120a.comm  wtnp124c.comm
   ssep002a.comm  ssnp133d.comm  ssnv190a.comm  wtnp120b.comm  wtnp124d.comm
   ssna111a.comm  ssnp133e.comm  ssnv190b.comm  wtnp120c.comm  wtnp125a.comm
   ssna111b.comm  ssnp133f.comm  ssnv194c.comm  wtnp120d.comm  wtnp125b.comm
   ssna115b.comm  ssnp133g.comm  ssnv197c.comm  wtnp120e.comm  wtnp126a.comm
   ssna117b.comm  ssnp133h.comm  ssnv197d.comm  wtnp120f.comm  wtnp126b.comm
   ssna118a.comm  ssnp139a.comm  ssnv204a.comm  wtnp120g.comm  wtnp127a.comm
   ssna119a.comm  ssnp139b.comm  ssnv204c.comm  wtnp120h.comm  wtnp127b.comm
   ssna120a.comm  ssnp145a.comm  ssnv205a.comm  wtnp120i.comm  wtnp127c.comm
   ssna121a.comm  ssnp145b.comm  ssnv206a.comm  wtnp120j.comm  wtnp127d.comm
   ssnl111a.comm  ssnp145c.comm  ssnv207a.comm  wtnp121a.comm  wtnp128a.comm
   ssnl119a.comm  ssnp147a.comm  ssnv208a.comm  wtnp121b.comm  wtnp128b.comm
   ssnl127a.comm  ssnp147b.comm  ssnv221a.comm  wtnp121c.comm  wtnp128c.comm
   ssnl127e.comm  ssnp148a.comm  ssnv221b.comm  wtnp121d.comm  wtnp128d.comm
   ssnl133a.comm  ssnp151a.comm  ssnv501c.comm  wtnp121e.comm  wtnv122b.comm
   ssnl134a.comm  ssnp151b.comm  ssnv506b.comm  wtnp121f.comm  wtnv123f.comm
   ssnl135a.comm  ssns106a.comm  ssnv506c.comm  wtnp121g.comm  wtnv132a.comm
   ssnl135b.comm  ssns106b.comm  ssnv506d.comm  wtnp121h.comm  wtnv132b.comm
   ssnl135c.comm  ssns106c.comm  ssnv506e.comm  wtnp121i.comm  wtnv132c.comm
   ssnl136a.comm  ssns106d.comm  wdnp101a.comm  wtnp121j.comm  wtnv134a.comm
   ssnl136b.comm  ssns106e.comm  wdnp101b.comm  wtnp121k.comm  wtnv134b.comm
   ssnl502b.comm  ssns106h.comm  wtna106a.comm  wtnp121l.comm  wtnv135a.comm
   ssnl502c.comm  ssns106i.comm  wtna106b.comm  wtnp121m.comm  zzzz175a.comm
   ssnp102a.comm  ssns106j.comm  wtna106c.comm  wtnp121n.comm  zzzz268a.comm
   ssnp102b.comm  ssnv138b.comm  wtna106d.comm  wtnp122a.comm  zzzz268b.comm
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.34.03 D4.06.17
VALIDATION
    liste des cas-test DEFI_LIST_INST
NB_JOURS_TRAV  : 20.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 015226 DU 2010-06-17 07:11:50
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    DEF2 - Matrice singuliere et subdivision du pas de temps
FONCTIONNALITE
   Problématique
   =============
   
   Pour activer le découpage du pas de temps quand la matrice est singulière, il est
   nécessaire de le préciser dans le mot-clef SOLVEUR.
   Lorsque la matrice devient singulière et qu'on autorise la subdivision
   (STOP_SINGULIER='DECOUPE') alors le message d'erreur 'F' pivot nul... devient une simple
   alarme 'A'.
   
   Il serait plus logique que cela devienne une simple information 'I', au même titre que
   lorsqu'on subdivise à cause d'un échec de l'intégration de la LDC ou d'une non convergence
   des itérations de Newton...
   
   Solution
   ========
   
   On supprime STOP_SINGULIER='DECOUPE'. Désormais, c'est *_NON_LINE, qui, à partir de la
   donnée provenant de la gestion des événements (ACTION='DECOUPE', voir issue15966), modifie
   la SD solveur.
   Au niveau de l'affichage, ce n'est plus une alarme mais une information simple.
   
   Impact: CRESOL.f, c_solveur.capy
   
   NB: la détection n'étant possible que pour les solveurs directs, une alarme est émise en
   cas de demande de découpe de pas de temps et d'utilisation d'un solveur itératif.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.50.01 D4.06.11
VALIDATION
    liste restreinte
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 017259 DU 2011-07-06 14:11:56
TYPE express concernant Code_Aster (VERSION 9.1)
TITRE
    Bug dans pminit.f (CALC_POINT_MAT)
FONCTIONNALITE
   La variable ANGEUL est mal initialisée dans pminit, provoquant un débordement de tableau.
   
   Il faut
   CALL R8INIR ( 3, 0.D0, ANGEUL ,1 )
   Et non
   CALL R8INIR ( 7, 0.D0, ANGEUL ,1 )
   
   La variable XYZGAU est de mauvaise dimension
   REAL*8 XYZGAU(3)
   et non
   REAL*8 XYZGAU
   
   Je corrige
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    rien de particulier
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 017258 DU 2011-07-06 08:00:34
TYPE express concernant Code_Aster (VERSION 9.1)
TITRE
    Bug dans w039ca.f
FONCTIONNALITE
   La routine w039ca.f est bugguée.
   
   La chaine LIGREL n'est pas initialisée et on cherche à la détruire.
   Ca fait planter IMPR_RESU.
   
   Je corrige.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    liste restreinte
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 017087 DU 2011-06-09 07:33:17
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW11.0.10, le cas-test ssnp133g s'arrête en erreur fatale sur Aster4, Rocks et Calibre 5.
FONCTIONNALITE
   Problème:
   =========
   
   En NEW11.0.10, le cas-test ssnp133g s'arrête en erreur fatale sur Aster4, Rocks et Calibre 5.
   
   
   Solution:
   =========
   
   Le problème vient de la (non)-gestion des priorités entre événements.
   
   Ce test vérifie la bascule DIVE_ITER_PILO. En cas d'erreur (LDC, pilotage ou
   ITER_GLOB_MAXI), on est censé refaire le même pas de temps mais avec l'autre solution de
   pilotage.
   
   Le problème actuel est que l'évenement DIVE_ITER_PILOT se déclenche bien, mais seulement
   parce que l'evenement ERREUR se déclenche.
   
   Or, dans le traitement, l'évenement ERROR prend le dessus (devient prioritaire) et
   provoque la découpe du pas de temps.
   Résultat: on découpe le pas de temps, tout en changeant la solution de pilotage, ce qui
   n'a aucun sens.
   
   L'évolution issue15966 corrige le test. En effet DIVE_ITER_PILO passe d'EVENEMENT à ACTION
   et la gestion des priorité est faite.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssnp133g
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desoza       DE SOZA Thomas         DATE 07/12/2011 - 11:00:18

--------------------------------------------------------------------------------
RESTITUTION FICHE 017250 DU 2011-07-04 17:04:42
TYPE express concernant Code_Aster (VERSION 9.1)
TITRE
    Défaut d'affichage en contact discret avec réactualisation géométrique
FONCTIONNALITE
   Express
   =======
   
   Un petit bug dans nmconv.f conduisait à un affichage erroné en contact discret avec
   réactualisation géométrique : au passage d'une itération géométrique à une autre on
   affichait d'abord la ligne de séparation de pointillés puis on affichait la ligne de
   l'itération courante.
   On corrige cette interversion.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    visuelle
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desoza       DE SOZA Thomas         DATE 07/12/2011 - 04:56:40

--------------------------------------------------------------------------------
RESTITUTION FICHE 017213 DU 2011-06-28 11:17:41
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    [FORUM] Formulation continue : cas oubliés
FONCTIONNALITE
   Anomalie
   ========
   
   Dans le calcul ci-joint issu du forum, le contact en formulation discrète fonctionne alors
   qu'une erreur de programmation survient en formulation continue.
   En effet il y a contact entre une arête et un solide (cf. image jointe), ce qui n'est pas
   prévu, les éléments de contact Segment-facette ayant été oubliés.
   
   Développement
   =============
   
   On ajoute les éléments de contact tardif nécessaires au traitement arête-facette, il
   s'agit des 10 cas :
   - segment à 2 noeuds contre les triangles et quadrangles linéaires/quadratiques
   (TR3,TR6,QU4,QU8,QU9)
   - segment à 3 noeuds contre les triangles et quadrangles linéaires/quadratiques
   (TR3,TR6,QU4,QU8,QU9)
   
   On ajoute donc 10 types de maille (spécifiques au contact continu) et les éléments
   (ELREFE) ad-hoc en contact et en frottement (dans les catalogues de CC).
   Remarque : l'augmentation du nombre de types de maille oblige à modifier les routines de
   lecture/impression.
   
   On profite de l'occasion pour émettre un message plus clair si à l'avenir on rencontre un
   nouveau cas non prévu.
   
   96 : _("""
   Contact méthode continue. La prise en compte d'un contact entre une maille '%(k1)s' et une
   maille '%(k2)s' n'est pas prévu.
   
   Conseils :
   - utilisez une formulation 'DISCRETE'
   - émettez une fiche d'évolution
   """),
   
   Validation
   ==========
   
   On ajoute une modélisation au cas-test de contact entre poutres SSNV505, modélisation J.
   Le cas étant déjà traitable en formulation discrète, on fait un premier calcul en méthode
   des contraintes actives qui sert de référence au calcul contact continu.
   
   La modélisation consiste à mailler une des 2 poutres en 3D (maître), l'autre en poutre
   (esclave).
   
   Les résultats sont très proches entre les 2 formulations, les légères différences peuvent
   s'expliquer plutôt par la modélisation (POU_D_TGM) qui est un peu sensible au nombre
   d'itérations (formulation approchée des grands déplacements).
   
   On remarquera que les résultats obtenus ne sont ni les mêmes que le contact 3D-3D
   (modélisation B), ni que le contact poutre-poutre (modélisation H) mais là encore c'est un
   phénomène géométrique qui explique cela.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V6.04.505
VALIDATION
    ssnv505j
NB_JOURS_TRAV  : 1.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 017113 DU 2011-06-10 09:28:54
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Nettoyage des tests de SSNV104 et ajout de non-régression
FONCTIONNALITE
   Anomalie
   ========
   
   En écrivant la doc du test SSNV104, on a constaté quelques incohérences qu'il faut corriger :
   
   - des TEST_RESU ont des tolérances très élevées (12%) alors que l'erreur est beaucoup plus
   faible (6%) ==> conséquence ces tests ne servent à rien.
   
   - certains tests avec solution analytique ne sont pas doublés de non-régression alors que
   l'erreur est supérieure à 5%.
   
   Réalisation
   ===========
   
   Le premier point est corrigé : on réduit les tolérances dans plusieurs modélisations à des
   valeurs plus raisonnables.
   
   Le second point n'est finalement pas traité (sans suite) : il y a trop de tests de
   non-régression à rajouter dans ce test et d'autres, je préfère attendre un évolution plus
   globale de TEST_*.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssnv104
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 017230 DU 2011-07-01 09:23:10
TYPE aide utilisation concernant Code_Aster (VERSION 9.1)
TITRE
    mise en donnée de calculs de polycristaux en parallèle
FONCTIONNALITE
   AOM
   ===
   
   Demande initiale MMC :
   '''
   Nous souhaitons réaliser 30 calculs polycristallins 3D à environ 
   500000 ddl en parallèle (méthode MUMPS).
   Nous souhaiterions savoir s'il est possible d'obtenir une aide en 
   matière d'optimisation de la mise en donnée des calculs ?
   En effet, un calcul tourne  actuellement avec 20000Mb sur 16 CPU et 4 
   noeuds. Il s'arrête au bout de 4h. Nous devons lancer 2 poursuites 
   ensuite pour aboutir aux résultats du calcul complet. Les 4h semblent 
   être la limite max du temps de calcul autorisé sur la machine compte 
   tenu de la mémoire spécifiée.
   Je joins un exemple de mise en donnée (.comm, .export, .astk, .med)
   
   Par ailleurs est-il possible de nous allouer une queue spécifique pour 
   cette campagne de calculs sur Aster 4 ?
   '''
   
   Analyse de l'étude fournie
   ==========================
   
   Un premier calcul sur 2 pas de temps et 2 processeurs est effectué avec MUMPS pour se
   rendre compte des ordres de grandeur (taille du modèle, temps CPU). On constate que le
   modèle est de taille importante (550 000 ddls) et qu'une factorisation de matrice prend
   déjà 15min sur 2 processeurs.
   On sait par ailleurs que les calculs d'agrégats ont tendance à produire des matrices bien
   conditionnées. Ces points militent donc pour le remplacement du solveur direct MUMPS par
   un solveur itératif (PETSc aussi utilisable en parallèle)
   
   Voici les premières modifications effectuées directement dans le fichier de commandes :
   
   - passage en conditions cinématiques pour réduire le nombre d'inconnues (ici les CL
   s'appliquent à 2 noeuds, c'est donc complètement négligeable mais comme on vise
   l'utilisation d'un solveur linéaire itératif, il vaut mieux rendre la matrice la plus
   définie positive possible)
   
   - suppression de la partition en sous-domaines (c'est en général une bonne idée d'utiliser
   une telle partition pour MUMPS mais pour PETSc c'est moins le cas, le partitionnement par
   défaut devrait suffire étant donné la taille du problème)
   
   - utilisation d'un solveur itératif. On choisit les paramètres par défaut de PETSc :
   algorithme GMRES et préconditionneur LDLT_SP basé sur une factorisation MUMPS simple
   précision (donc aussi effectuée en parallèle). On a essayé d'autres préconditionneurs mais
   ils ne permettent pas d'obtenir la convergence, de plus on montre par la suite que LDLT_SP
   est un très bon choix.
   
   Avant de passer à l'analyse des perfs, voici quelques remarques importantes : 
   
   - pour la liste d'instants, dans les commentaires il est dit qu'un critère de déformation
   max doit être respecté, sachez que il est possible d'imposer une liste d'instants qui fait
   respecter un critère sur les incréments de variables internes par exemple
   (DEFI_LIST_INST/DELTA_GRANDEUR), cela peut vous servir.
   
   - j'ai remarqué que le calcul lancé 2 fois de suite ne mettait pas le même nombre
   d'itérations de Newton, en particulier le second membre change entre 2 runs (on le voit en
   consultant le RESI_GLOB_MAXI), c'est troublant. J'en ai discuté avec Jean-Michel et j'ai
   fait passer quelques runs du cas-test SSNV194A sans arriver à reproduire la chose, nous
   creusons la chose.
   
   Tests de différents paramétrages de PETSc
   =========================================
   
   Une fois le choix PETSc GMRES/LDLT_SP entériné, les paramètres (importants) à disposition
   sont :
   
   - RESI_RELA : c'est le critère de convergence de l'algo GMRES (la précision sur Ku-f=0)
   - PCENT_PIVOT : c'est le même paramètre que pour MUMPS
   - REAC_PRECOND : cela donne un critère pour la reconstruction du préconditionneur simple
   précision
   
   * PCENT_PIVOT=10 la valeur par défaut ne suffit pas. Une valeur de 50 a permis de passer
   le calcul dans toutes les configurations testées (de 2 à 16 procs).
   
   * Dans la mesure où le résidu et le nombre d'itérations semble assez variables (cf.
   remarque plus haut), j'ai fait des tests entre une valeur par défaut de RESI_RELA à 1.0E-6
   et une valeur plus dure de 1.0E-12.
   On constate que la valeur de 1.0E-12 permet parfois de réduire le nombre d'itérations de
   Newton sans trop pénaliser le temps de résolution de Ku=f. On propose donc
   RESI_RELA=1.0E-12, il faut environ 40 itérations de GMRES pour atteindre cette précision
   (contre environ 10 pour 1.0E-6). Ce choix est renforcé par la remarque suivante.
   
   * REAC_PRECOND vaut 30 par défaut, cela signifie que si GMRES met plus de 30 itérations à
   converger pour une résolution de Ku=f, à la suivante on réactualisera la facto simple
   précision de K qui sert de préconditionneur (il faut environ 6 minutes sur 2 procs pour la
   réaliser alors que le temps passé à résoudre Ku=f par pas de temps dépasse rarement 2
   minutes). Comme on constate de plus que le nombre d'itérations de GMRES semble constant
   tout au long du chargement, on force REAC_PRECOND à 100 ce qui a pour conséquence de ne
   (presque) jamais réactualiser le préconditionneur.
   
   Performances
   ============
   
   Tous ses paramètres fixés, on a fait des runs sur plusieurs processeurs : 2, 4, 8 et 16
   processeurs. Des calculs sur 32 et 64 processeurs ont été lancés mais ils risquent de ne
   pas pouvoir tourner (charge machine).
   
   On constate en général une très bonne scalabilité des calculs élémentaires (le temps
   "Intégration LdC" décroît quasi-linéairement jusqu'à 8 et un peu moins jusqu'à 16)
   Le préconditionneur n'est jamais reconstruit, on ne consomme donc du temps que dans les
   résolutions.
   Le temps des résolutions lui ne décroît pas bien pour 4 et 8 processeurs, par contre
   pour 16 processeurs, on retrouve un temps correct par rapport à 2. Cette disparité peut
   s'expliquer par la répartition des processeurs qui n'a pas été étudiée (paramètre
   mpi_nbnoeud). Il semblerait néanmoins qu'il est préférable d'avoir 4 procs/noeud.
   
   Tous les calculs lancés sur la file mpi_8G se sont arrêtés en atteignant la limite
   mémoire. Il semblerait en effet y avoir une fuite mémoire dans l'interface PETSc qui sera
   corrigé prochainement (issue17274).
   
   (Rappel : l'objectif est de faire 204 pas de temps jusqu'à T=20)
   
   2p  |  1 noeud  utilisé  (2p/N)
   4h10| 61 pas de temps
   
   4p  |  2 noeuds utilisés (2p/N)
   5h10| 93 pas de temps
   
   8p  |  4 noeuds utilisés (2p/N)
   3h50| 88 pas de temps
   
   16p |  4 noeuds utilisés (4p/N)
   2h15| 93 pas de temps
   
   32p |  4 noeuds utilisés (4p/N)
   30m | 17 pas de temps
   
   On constate donc que le calcul sur 16 processeurs présente un bon compromis. On pourra
   aussi privilégier une calcul sur 8 processeurs mais avec 4p/N.
   
   Le fichier de commandes modifié est joint à la fiche.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    étude
NB_JOURS_TRAV  : 1.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR tardieu      TARDIEU Nicolas        DATE 07/12/2011 - 04:56:40

--------------------------------------------------------------------------------
RESTITUTION FICHE 017137 DU 2011-06-16 07:12:39
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW11.0.11, le cas-test sslp201b est NOOK sur Rocks et Calibre5.
FONCTIONNALITE
   Problème :
   ---------
   En NEW11.0.11, le cas-test sslp201b est NOOK sur Rocks et Calibre5.
   TITRE TEST DE NON-REGRESSION ASTER : MECANIQUE LINEAIRE 2D C_PLAN_SI
   La fiche 16944 restituée par N. Tardieu pourrait être à l'origine de cet échec.
   Le test NOOK est le suivant:
   
    ---- RESULTAT         NUME_ORDRE       NOM_CHAM         TYPE_TEST
         MSLIN            1                SIEQ_ELGA        SOMM_ABS
         REFERENCE        LEGENDE          VALE_REF                 VALE_CAL                
   ERREUR           TOLE            
   NOOK  NON_REGRESSION   XXXX             9.04758968545E+08        9.0475896785271E+08     
   7.7E-08%         1.0E-08%        
   
   Solution :
   ---------
   Cela est lié à la fiche issue15774 où on prend en compte les conditions de Dirichlet dans
   les corrections de Newton. Je modifie la tolérance.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    Passage du test
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 017139 DU 2011-06-16 07:21:48
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW11.0.11, le cas-test ssnv128b s'arrete en erreur fatale sur Rocks et Calibre 5.
FONCTIONNALITE
   Problème :
   ---------
   En NEW11.0.11, le cas-test ssnv128b s'arrête en erreur fatale sur Rocks et Calibre 5.
   
   Solution :
   ---------
   Cela est lié à la fiche issue15774 où on prend en compte les conditions de Dirichlet dans
   les corrections de Newton. Il apparait une sensibilité à un nœud (N39) non activé
   auparavant (jeu=1.e-21) ici activé  (jeu=-1.e-21) qui cause une matrice très mal
   conditionnée (cond~1.e30).
   Passer au solveur MUMPS résout le problème sur toutes les plateformes.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    Passage des tests
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR fernandes    FERNANDES Roméo       DATE 07/12/2011 - 07:29:17

--------------------------------------------------------------------------------
RESTITUTION FICHE 017275 DU 2011-07-08 15:42:15
TYPE express concernant Code_Aster (VERSION 9.1)
TITRE
    Evolution des lois DIS_GRICRA, GRAN_IRRA_LOG et VISC_IRRA_LOG
FONCTIONNALITE
   Pour le calcul des déformations des assemblages combustibles on souhaite mémoriser
   l'historique du champ d'irradiation vécu par chaque assemblage.
   
   Pour cela on ajoute une variable interne dans les lois de comportements DIS_GRICRA (6ème
   variable) et (VISC/GRAN)_IRRA_LOG (2nde variable).
   
   Dorénavant, le calcul du champ de fluence au pas courant est obtenu par la relation :
   IRRA(propre à l'assemblage) = VI(t-) + (IRRA(t+) - IRRA(t-)),
   
   tandis qu'auparavant on écrivait :
   IRRA(propre à l'assemblage) = IRRA(t+).
   
   Dans le cas des simulations avec des conceptions d'assemblages ayant subi un nombre de
   cycles différents, les caractéristiques matériaux étaient fausses (correspondant à un
   matériau ayant subi plus d'irradiation).
   
   Impact dans la base des cas-tests:
   - Modification du test comp010a. Dans celui-ci la commande SIMU_POINT_MAT prend en entrée
   une initialisation du champ de variables internes qui vient de changer de dimension. On
   modifie cette entrée uniquement, les TEST_RESU restent inchangés.
   
   - Modification du test ssnl131d pour lequel le champ d'irradiation initial n'était pas
   nul. Pour ne pas impacter les TEST_RESU, j'ajoute une initialisation du champ de variable
   interne pour que le materiau prenne en compte un champ d'irradiation initial non nul.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 9.0.0
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 9.0.0
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : R5.03.17, R5.03.09, U4.51.11
VALIDATION
    tests de la base aster
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR flejou       FLEJOU Jean Luc        DATE 07/11/2011 - 07:43:29

--------------------------------------------------------------------------------
RESTITUTION FICHE 017242 DU 2011-07-01 15:10:08
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Couverture de code: AFFE_CARA_ELEM
FONCTIONNALITE
   Dans les cas test déjà existant modification de :
     M_T_L en M_T_D_L   : fdlv100a fdlv102c sdld02e
     M_TR_L en M_TR_D_L : sdld02f (il n'y avait qu'un cas test avec des M_TR_L)
   
   Restitution des cas tests, pas de doc V à modifier, doc AFFE_CARA_ELEM en version 11.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.42.01
VALIDATION
    passage cas tests
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 017233 DU 2011-07-01 12:30:23
TYPE anomalie concernant Code_Aster (VERSION 11.1)
TITRE
    En NEW11.00.13, le cas-test ssnl106k est NOOK sur Rocks.
FONCTIONNALITE
   C'est un test sur la valeur de la contrainte en élasto-plasticité parfaite.
   Or pour que cela fonctionne (pas de pivot nul) il faut donner un D_SIGM_EPSI faible. La
   valeur de référence est de 3.0E+06, avec une TOLE de 0.1%.
   
   Dans le cas test on avait D_SIGM_EPSI=2.0E+08 ce qui donnait SIGM_ELNO=3.003E+06, donc NOOK
   On met D_SIGM_EPSI=2.0E+06 ce qui donne SIGM_ELNO=3.00003E+06, donc OK
   
   Restitution du cas test, pas d'impact doc.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    passage cas test
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR geniaut      GENIAUT Samuel         DATE 07/11/2011 - 06:01:18

--------------------------------------------------------------------------------
RESTITUTION FICHE 017257 DU 2011-07-06 07:32:19
TYPE express concernant Code_Aster (VERSION 11.1)
TITRE
    RUPT : cas test 3D en mode mixte, K non constant le long du fond de fissure
FONCTIONNALITE
   Contexte :
   ----------
   
   La base de cas test en mecanique de la rupture classique pr?sente 2 manques :
   - cas test 3D en mode mixte, K non constant le long du fond de fissure
   - cas test 3D fissure non plane.
   
   
   Solution :
   ----------
   
   On propose dans cette fiche un nouveau cas test, r?pondant au 1er point.
   
   sslv154 : Fissure circulaire (penny-shaped crack) en mode mixte
   mod?lisation a : FEM
   mod?lisation b : X-FEM
   
   Ce test pr?sente des similitudes avec le sslv134, mais dans le sslv134, on impose les
   modes de chargements I et III dans des calculs s?par?s, ce qui fait qu'? chaque calcul, on
   est en mode pur. L'interet du sslv154 est d'imposer une traction + cisaillement en m?me
   temps (mode mixte). Une solution analytique est disponible.
   On teste ? chaque fois les K1, K2, et K3 le long du fond pour les commandes POST_K1_K2_K3
   et CALC_G.
   Ce test a permis notamment de d?couvrir des bugs (cf. fiches 16985 et 17185) dans CALC_G.
   
   Un 2eme cas test r?pondant au 2eme point (fissure non-plane) fera l'objet d'une autre fiche.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V3.04.154
VALIDATION
    sslv154a et b
NB_JOURS_TRAV  : 5.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 017185 DU 2011-06-22 14:19:57
TYPE anomalie concernant Code_Aster (VERSION 11.1)
TITRE
    RUPT : bug dans CALC_G si NB_POINT_FOND
FONCTIONNALITE
   Probl?me :
   ----------
   
   Dans la commande CALC_G, on obtient un G (et/ou des K) faux si toutes les conditions
   suivantes sont r?unies :
   + mod?lisation de la fissure par level sets (mot-cl? FISSURE) 
   + r?partition uniforme des points le long du fond (mot-cl? NB_POINT_FOND)
   + imposition de la direction tangente au point extremit? du fond (mot-cl? DTAN_EXTR).
   
   Plus pr?cis?ment, le Gelem (ou Kelem) correspondant ? l'avant-dernier champ theta est faux.
   
   Cela implique donc des G (ou K) faux :
   - sur tout le fond de fissure si LISSAGE = 'LEGENDRE'
   - sur les 3 points extr?mit?s du fond si LISSAGE = 'LAGRANGE'
   
   
   Correction :
   ------------
   
   Le probl?me vient de l'introduction du mot-cl? NB_POINT_FOND.
   En effet, si ce mot-cl? est renseign?, alors on va calculer G uniquement sur des nouveaux
   points r?partis uniform?ment le long du fond. La routine xrecff.f permet de recalcule les
   position de ces nouveaux points.
   Par contre, la base locale en fond de fissure (FISS.BASLOC) n'est pas recalcul?e !
   Or on se sert de cette base dans le cas o? on impose les direction tangentes du champ
   theta (routine gcour3.f).
   Pour la correction li?e ? DTAN_ORIG, on ne commet pas d'erreur en exploitant la "fausse"
   base locale, car le 1er point reste le 1er point.
   Par contre, pour la correction li?e ? DTAN_EXTR, l'exploitation de la fausse base locale
   conduit ? une correction de la direction erron?e.
   
   La solution consiste ? recalculer la bonne base locale dans xrecff.f, ? l'instar du
   recalcul du bon fond de fissure.
   
   impact : gcour3.f, xrecff.f, op0100.f
   
   
   Validation :
   ------------
   
   Le cas test sslv154b valide le dvt.
   Par ex sur le K1 (K1reference = 7.9788456080287E+05)
   Avant : max(K1) = 1.0879031894322E+06 (36.0%) et min(K1) = -2.128314872035E+05  (136%) 
   Apres : max(K1) = 8.3907374213329E+05 ( 5.2%) et min(K1) =  7.9432995131184E+05 (0.45%)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    SSLV154B
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 016985 DU 2011-05-24 08:16:01
TYPE anomalie concernant Code_Aster (VERSION 11.1)
TITRE
    RUPT : calcul de G aux bords
FONCTIONNALITE
   Origine du probl?me :
   ---------------------
   
   Un calcul sur fond courbe a montr? des K3 assez faux aux bords (sslv154a), ces erreurs
   empirant en
   raffinant suivant la direction du fond (fissure maill?e 3D, avec utilisation de Level
   sets, op?rateur CALC_G, option CALC_K_G).
   L'utilisation des tangentes exactes (DTAN_ORIG, DTAN_EXTR) n'y faisait rien.
   
   
   Investigation :
   ---------------
   
   1) Compr?hension des m?canismes
   -------------------------------
   
   Il est apparu qu'un traitement particulier ?tait r?alis? sur les quantit?s (G, K)
   ?l?mentaires (au sens THETA) dans la routine gkmet3.f, en lissage de LAGRANGE et ses
   variantes, et en pr?sence de level sets (mot-cl? FISSURE).
   
   Ces traitements ne sont pas r?alis?s dans les autres cas : lissage LEGENDRE, ou fissure
   sans level sets (FOND_FISS)
   
   Ces traitements consistent ? modifier avant inversion du syst?me les Qelem (ou Q = G ou K)
   pour les champs THETA correspondant aux 2 points extr?mit?s (THETA=1 et THETA=NNOFF) :
   - pour un lissage LAGRANGE : de telle sorte que l'on puisse retrouver exactement une
   solution constante le long du front.
   - pour un lissage LAGRANGE_NO_NO : par une extrapolation lin?aire des 2 points d'? cot?.
   
   La justification d'un tel traitement n'est pas tr?s claire. Il ?tait dit que sinon "les
   r?sultats ?taient peu pr?cis aux bords". On peut aussi se poser la question de la validit?
   du traitement en lissage LAGRANGE si les valeurs ne sont pas constantes le long du front
   (c'est d'ailleurs le cas qui est ? l'origine du probl?me !).
   
   
   2) Calcul de G
   --------------
   
   Pour comprendre les fondements, des ?tudes ont ?t? lanc?es sans traitement particulier.
   Il appara?t que les r?sultats sur Gelem et G sont identiques entre :
   - fissure repr?sent?e par level set (FISSURE) et option = CALC_G ou CALC_K_G
   - fissure repr?sent?e par le maillage (FOND_FISS) et option = CALC_G
   Il sont effectivement peu pr?cis sur les bords. L'ajout des directions tangentes
   (DTAN_ORIG et DTAN_EXTR) permet justement d'am?liorer ces valeurs.
   Attention :
   pour les fissures repr?sent?es par le maillage, les DTAN sont sp?cifi?es dans DEFI_FOND_FISS.
   pour les fissures repr?sent?es par les level sets, les DTAN sont sp?cifi?es dans CALC_G.
   Dans tous les cas, les DTAN et ne servent qu'? corriger la direction du champ THETA.
   
   En activant les DTAN, on retrouve pour tous les cas des bons r?sultats sur Gelem et G.
   Il n'y a donc pas de raisons de faire des traitements particuliers pour obtenir des
   valeurs de G correctes, si on donne les DTAN.
   
   Proposition :
   On pourrait ne r?aliser le traitement particulier que si les DTAN ne sont pas donn?es.
   
   
   3) Calcul des K
   ---------------
   
   Les K ne sont calcul?es que dans le cas de fissure repr?sent?e par level sets + option =
   CALC_K_G.
   D'apr?s ce que l'on a vu pr?c?demment, les r?sultats sont peu pr?cis aux bords, sans
   traitement et sans DTAN.
   Si on rajoute DTAN, sans traitement, on am?liore les K aux bords, sans toutefois atteindre
   la m?me pr?cision que sur les autres points. Ceci peut sembler en contradiction avec le
   point 2). La raison est que le calcul de K n?cessite que le directions du champ THETA
   soient bonnes, mais aussi que la base locale (d?finie par les gradients level sets) soit
   bonne en tout point de Gauss de la structure. L'ajout de DTAN n'influe que sur la
   direction du champ THETA, et pas sur les gradients de level sets. Il est donc normal que
   l'on ne retrouve pas les bonnes valeurs de K aux bords.
   
   C'est pour cette raison que les traitements sp?cifiques aux bords ont ?t? rajout?s.
   Cependant, leur validit? laisse ? d?sirer. Il faudrait une solution qui traite le probl?me
   ? sa base : la base locale li?e au gradient des level sets pour les points de Gauss qui
   sont en vis-?-vis des points des bords du fond !
   
   Trois solutions sont possibles :
   
   - Modifier la base locale li?e au gradient des level sets pour les points de Gauss qui
   sont en vis-?-vis des points des bords du fond. Cette solution consiste ? introduire DTAN
   directement dans DEFI_FISS_XFEM et modifier la base locale "sur les bords". Ce n'est pas
   difficile ? faire (routine xbaslo.f).
   
   - Pour diminuer l'erreur, sur les K aux bords, sans traitement sp?cifique, il suffit de
   raffiner le long du fond.
   C'est d'ailleurs souvent le cas pour un calcul X-FEM (on a beaucoup de points le long du
   fond, donc la base locale aux bords est correcte).
   
   - Une autre solution est de ne pas se servir de la base locale en chaque point de Gauss,
   mais plut?t d'utiliser la base locale du point du fond en question, qui elle, est corrig?e
   via les DTAN. Cette strat?gie est moins pr?cise pour les fissures non-planes car elle ne
   prend pas en compte la courbure de la surface de la fissure (alors que cette courbure est
   prise en compte via les level sets). Cependant, avec la r?forme de DEFI_FOND_FISS, c'est
   ce m?canisme qui sera mis en place pour toutes les fissures maill?es. Ainsi, pour les
   fissures maill?es, on n'utilisera plus les level sets. Ce sera plus simple : 
   fissure maill?e -> DEFI_FOND_FISS : pas de level sets
   fissure non maill?e -> DEFI_FISS_XFEM : utilisation de level sets
   
   
   Bilan :
   -------
   
   En attendant la r?forme de DEFI_FOND_FISS, on laisse le traitement sp?cifique tel quel,
   activ? m?me si on renseigne DTAN dans CALC_G (on a v?cu avec pendant 8 ans, on peut tenir
   encore quelques mois).
   
   Apr?s r?forme de DEFI_FOND_FISS, les fissure maill?es b?n?ficieront toutes de la donn?es
   de DTAN (via DEFI_FOND_FISS) pour la direction du champ THETA et pour la base locale ->
   les G et les K seront donc corrects, sans traitement sp?cifique aux bords.
   Pour les fissures X-FEM, on supprimera aussi le traitement sp?cifique aux bords, et on
   rajoutera DTAN dans DEFI_FISS_XFEM (1ere solution propos?e ci-dessous)
   
   Dans le futur, on automatisera le calcul de DTAN, afin de g?rer la propagation automatique
   (pour laquelle l'utilisateur ne sait pas d?finir DTAN au cours du temps)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : U2.05.01
VALIDATION
    sslv154a et b
NB_JOURS_TRAV  : 3.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR proix        PROIX Jean-Michel      DATE 07/11/2011 - 06:57:56

--------------------------------------------------------------------------------
RESTITUTION FICHE 017268 DU 2011-07-08 08:25:55
TYPE express concernant Code_Aster (VERSION 9.1)
TITRE
    Amélioration de l'architecture des matrices jacobiennes pour le monocristal
FONCTIONNALITE
   Pour faciliter l'introduction de nouveaux comportements monocristallins (par exemple fiche
   14586), et pour que les calculs en grandes déformations puissent bénéficier d'une matrice
   jacobienne, l'architecture du calcul des matrices jacobiennes des comportements
   monocristallins est modifiée : elle est ainsi commune à tous ces comportements, à la fois
   en HPP et en grandes déformations.
   
   L'expression des matrices jacobiennes a été généralisée, en séparant les termes génériques
   (en petites et en grandes déformations) des termes spécifiques à chaque comportement
   cristallin. Ce travail avait déjà été effectué pour le calcul du résidu.
   
   Un passage de la liste complète des tests MONOCRISTAL montre que les performances se sont
   dégradées. L'architecture générale est en place, mais il reste à optimiser le temps CPU.
   Une fiche spécifique sera émise pour cela.
   
   Le point de branchement est la routine LCMMJA. Elle construit la matrice jacobienne à
   partir d'une routine unique, LCMMJB, qui est une routine d'aiguillage permettant à chaque
   comportement de calculer les dérivées souhaitées.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : R5.03.11
VALIDATION
    tests monocristal
NB_JOURS_TRAV  : 5.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 017158 DU 2011-06-20 11:26:08
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Dégradation des temps du cas-test comp002k en 11.0.9 dans TEST_COMPOR
FONCTIONNALITE
   Le cas tests comp002k a vu son temps CPU se dégrader suite à la version 11.0.9. Lors de
   l'EDA du 20/06/2011, il a été décidé d'émettre une fiche pour comprendre la raison. La
   commande TEST_COMPOR a augmenté de 21%.
   
   En fait il s'agit du comportement VMIS_JOHN_COOK, mais aucune modification de ce
   comportement n'a été effectuée en version 11.0.9.
   
   L'augmentation est en fait due au calcul et à l'assemblage d'un nouveau vecteur second
   membre à chaque itération de Newton  (voir issue17157).
   
   Cette fiche est donc sans suite.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    comp002k
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------

