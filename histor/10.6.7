

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR brie         BRIE Nicolas           DATE 04/30/2012 - 02:33:23

--------------------------------------------------------------------------------
RESTITUTION FICHE 018378 DU 2012-02-10 09:21:01
TYPE anomalie concernant Code_Aster (VERSION 10.6)
TITRE
    En NEW10.6.3, le cas-test sdll136a s'arrête en erreur fatale sur Rocks.
FONCTIONNALITE
   Probleme:
   En NEW10.6.3, le cas-test sdll136a s’arrête en erreur fatale sur Rocks.
   -----------------------
   
   Diagnostic:
   le plantage a lieu quand on lance ce cas-test sur Rocks depuis une machine distante. Le
   plantage est "pseudo aleatoire" : des fois, ça marche bien, des fois ça plante (dans
   DYNA_VIBRA, avec 2 instants possibles). Cela semble lie a la norme d'erreur des modes
   propres calcules dans MODE_ITER_SIMULT : celle-ci varie selon les runs, avec 3 sets de
   valeurs correspondants aux 3 cas de resultat du cas-test.
   -----------------------
   
   Solution:
   Il semble que la norme des modes propres soit invariantes quand on utilise la méthode
   'TRI_DIAG'. Le cas-test tourne alors normalement. J'en profite pour diminuer le nombre de
   modes calcules : 5 seulement au lieu de 41 car on en utilise seulement 5 dans le calcul
   transitoire. J'augmente aussi le pas de temps, a une valeur plus raisonnable de 10^(-4)s
   (le tout sans toucher aux tolerances des TEST_RESU).
   ----------------------
   
   Impact:
   sdll136a.comm
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    aucune
NB_JOURS_TRAV  : 0.6
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR lefebvre     LEFEBVRE Jean-Pierre   DATE 05/10/2012 - 07:00:06

--------------------------------------------------------------------------------
RESTITUTION FICHE 018521 DU 2012-03-08 08:14:23
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Passage en med 3.0.5 et hdf 5.1.8.x
FONCTIONNALITE
   La dernière version med-3.0.5rc2 fonctionne correctement sur les plates-formes 64 bits, une version 
   rc3 est attendue pour corriger un problème de passage de tests à l'installation. On ajoute l'option 
   --enable-check23 à la construction pour optimiser les performances.
   
   La version HDF est maintenant la version 5-1.8.8. Deux fonctions bibc/hdf/hdfwat et bibc/hdf/hdfwsv 
   sont modifiées pour utiliser l'interface par défaut 1.8. 
   
   Le fichier de configuration est modifié pour pointer sur les nouvelles librairies et les 
   différentes fonctions s'appuyant sur les includes (med.h et hdf.h) sont recompilées.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    liste complxc3xa8te
DEJA RESTITUE DANS : 10.6.6, 11.1.17
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR laverne      LAVERNE Jérôme       DATE 05/10/2012 - 07:00:06

--------------------------------------------------------------------------------
RESTITUTION FICHE 018268 DU 2012-01-23 14:30:38
TYPE anomalie concernant Code_Aster (VERSION 11.1)
TITRE
    Elements de joints et variables de sortie
FONCTIONNALITE
   J'ajoute un code retour d'intégration de la LDC (CODRET) dans les modélisations de joint
   2D : PLAN_JOINT et AXIS_JOINT qui en étaient dépourvues. Le code retour est initialisé à
   zéro dans 'nmfi2d.f' car les lois CZM_xxx_REG sont intégrées explicitement et sans itérations.
    
   modif de te0201.f et nmfi2d.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    tests des joints 2D
DEJA RESTITUE DANS : 11.1.20
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR bodel        BODEL Charles          DATE 05/10/2012 - 07:00:06

--------------------------------------------------------------------------------
RESTITUTION FICHE 017900 DU 2011-11-14 14:00:51
TYPE anomalie concernant Code_Aster (VERSION 11.1)
TITRE
    Message d'erreur en cas de mauvaise utilisation de MACR_ELEM_DYNA
FONCTIONNALITE
   PROBLEME :
   ----------
   La base modale associee a un macro-element dynamique doit avoir ete creee par 
   DEFI_BASE_MODALE, meme si elle ne comporte qu'une base (c'est-a-dire lorsqu'elle n'est 
   pas un assemblage de differents modes, par exemple), et ce de maniere a la lier avec 
   une interface issue de DEFI_INTER_DYNA. 
   Si on ne le fait pas, le code plante dans DEFI_MODELE_GENE, dans arg126.f (l.261) avec 
   un message obscur : 
   
    !  Nom de Collection ou de Répertoire de noms inexistant :  .IDC_NOMS       $$XNOM !
   
   Il convient donc d'ajouter une verif dans arg126.f avec un message d'erreur un peu 
   plus explicite
   
   SOLUTION : 
   ----------
   On ajoute un message d'erreur plus explicite en amont de la commande qui plante dans 
   arg126.f. Le message est ajoute dans ALGORITH12 (mumero 3) : 
   
    On ne trouve pas le nom de l'interface associée à la sous-structure
    %(k1)s. La base modale utilisée pour définir le macro-élément associé
    à la sous-structure doit avoir été définie avec DEFI_BASE_MODALE, en
    mentionnant obligatoirement l'interface sous le mot-clé INTERF_DYNA.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    pas de validation
DEJA RESTITUE DANS : 11.1.21
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR abbas        ABBAS Mickael          DATE 05/10/2012 - 07:00:07

--------------------------------------------------------------------------------
RESTITUTION FICHE 018789 DU 2012-04-26 15:36:26
TYPE express concernant Code_Aster (VERSION 10.5)
TITRE
    Interdire MASS_DIAG en implicite
FONCTIONNALITE
   Problème
   ========
   
   L'usage d'une matrice masse diagonale n'est pas interdit avec les schémas implicites de
   DYNA_NON_LINE au niveau du catalogue dyna_non_line.capy (impossible à faire au vu de la
   situation des mots-clefs respectifs).
   
   Par contre, dans le fortran, on ne lit cette info du catalogue que si on est en explicite.
   L'utilisateur pourrait donc croire, à tort, qu'il utilise une matrice masse diagonale en
   implicite (il a mis MASS_DIAG='OUI') alors que ce n'est pas le cas.
   L'option de calcul utilisée dans DYNA_NON_LINE s'appelle d'ailleurs MASS_MECA_EXPLI (et
   non MASS_MECA_DIAG) et la doc précise qu'il faut l'utiliser en explicite et que la masse
   consistante est fortement recommandée en implicite tout en n'interdisant pas la matrice
   lumpée.
   
   Fiche à rapprocher de l'issue10296, toujours ouverte.
   
   Solution
   ========
   
   Vu qu'on est en phase de stabilisation, on propose l'erreur fatale si on est en implicite
   et que l'utilisateur a renseigné MASS_DIAG= 'OUI'.
   
   Impact: ndlect.f et la doc U4 de DYNA_NON_LINE
   
   A reporter en V10
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.53.01
VALIDATION
    liste restreinte
DEJA RESTITUE DANS : 11.1.20
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 018324 DU 2012-02-02 10:51:07
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    En NEW11.01.07, sdnv103b est NOOK et sdnv103i s'arrete en erreur fatale sur Aster4, Rocks, Calibre5 et Calibre7.
FONCTIONNALITE
   Problème
   ========
   
   En NEW11.01.07, sdnv103b est NOOK sur Aster4, Rocks, Calibre5 et Calibre7 et sdnv103i
   s’arrête en erreur fatale sur Aster4, Rocks, Calibre5 et Calibre7. 
   
   Solution
   ========
   
   Pour le sdnv103b: modif du cas-test à cause de la correction sur les prédicteurs dans la
   fiche issue18049.
   Pour le sdnv103i: idem, à cause de la fiche 18049 + boucle infinie non-trappée et corrigée
   par la fiche issue18271
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V5.03.103
VALIDATION
    sdnv103i,sdnv103b
DEJA RESTITUE DANS : 11.1.16
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desoza       DE SOZA Thomas         DATE 05/10/2012 - 07:00:07

--------------------------------------------------------------------------------
RESTITUTION FICHE 018581 DU 2012-03-19 14:04:56
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    ABNORMAL_ABORT sur Aster4 et MACR_CARA_POUTRE.
FONCTIONNALITE
   Anomalie
   ========
   
   '''
   Un calcul avec MACR_CARA_POUTRE et une géométrie de type disque troué, s'arrête en
   ABNORMAL_ABORT sur Aster4. 
   
   Ce même calcul se termine correctement avec un maillage plus "grossier". 
   
   Le maillage fin comporte 100 000 triangles alors que le grossier en comporte 1 500.
   '''
   
   Analyse
   =======
   
   Un run valgrind localise le plantage :
   
   ==13355== Invalid write of size 8
   ==13355==    at 0x14FEE29: afrela_ (afrela.f:371)
   ==13355==    by 0x1B02F91: calich_ (calich.f:278)
   ==13355==    by 0x15376A8: charth_ (charth.f:128)
   ==13355==    by 0xC71590: op0034_ (op0034.f:58)
   ==13355==    by 0x60AD6C: ex0000_ (ex0000.f:149)
   ==13355==    by 0x5A9557: execop_ (execop.f:64)
   ==13355==    by 0x54DD04: expass_ (expass.f:64)
   ==13355==    by 0x52D0A8: aster_oper (astermodule.c:2062)
   ==13355==    by 0x1F4E12F: PyEval_EvalFrameEx (ceval.c:3750)
   ==13355==    by 0x1F4EC6A: PyEval_EvalFrameEx (ceval.c:3836)
   ==13355==    by 0x1F4EC6A: PyEval_EvalFrameEx (ceval.c:3836)
   ==13355==    by 0x1F4EC6A: PyEval_EvalFrameEx (ceval.c:3836)
   ==13355==  Address 0xa6383b0 is 0 bytes after a block of size 160,064 alloc'd
   ==13355==    at 0x4CBEAFB: malloc (vg_replace_malloc.c:263)
   ==13355==    by 0x570DDF: hpalloc_ (hpalloc.c:30)
   ==13355==    by 0x53BFB6: jjalls_ (jjalls.f:145)
   ==13355==    by 0x547E1F: jxveuo_ (jxveuo.f:221)
   ==13355==    by 0x53C50B: jjalty_ (jjalty.f:63)
   ==13355==    by 0x53A6CA: jeveuo_ (jeveuo.f:139)
   ==13355==    by 0x570836: wkvect_ (wkvect.f:38)
   ==13355==    by 0x565016: juveca_ (juveca.f:129)
   ==13355==    by 0x14FD27C: afrela_ (afrela.f:264)
   ==13355==    by 0x1B02F91: calich_ (calich.f:278)
   ==13355==    by 0x15376A8: charth_ (charth.f:128)
   ==13355==    by 0xC71590: op0034_ (op0034.f:58)
   
   Il s'agit d'un agrandissement d'objet JEVEUX (par JUVECA) qui n'est pas bien protégé dans
   AFRELA : 
   
         IF (LONUTI+NBTERR.GE.LVECLR) THEN
           CALL JUVECA(LISREL//'.RLCO',2*LVECLR)
   
   Si LONUTI+NBTERR est encore plus grand que 2*LVECLR alors on va écraser le vecteur JEVEUX.
   C'est ce qui se passe ici : le rapport est de 20 !
   
   Correction
   ==========
   
   On multiplie désormais la taille du vecteur original par le plus petit entier qui permet
   de stocker le nouveau vecteur.
   Remarque : il y a de nombreux appels à JUVECA dont certains pourraient être dans le même cas.
   
   Impact (pour V10, routine quasi identique) : afrela.f
   
   Validation
   ==========
   
   L'étude jointe ne plante plus et finit par s'arrêter en erreur dans une résolution faute
   de base volatile assez grande (il s'agit d'une résolution LDLT).
   
   Résultats faux
   ==============
   
   Peu de chances de résultats faux, un plantage survenant assez souvent en cas de
   dépassement de tableau.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    xc3xa9tude jointe
DEJA RESTITUE DANS : 11.1.20
NB_JOURS_TRAV  : 0.25
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR delmas       DELMAS Josselin        DATE 05/10/2012 - 07:00:07

--------------------------------------------------------------------------------
RESTITUTION FICHE 018283 DU 2012-01-24 15:27:19
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    ssnp130 a sensible au format de son maillage
FONCTIONNALITE
   Problème :
   ========
   Le test ssnp130a devient NOOK (faiblement) lorsqu'on convertit son maillage au format MED.
   
   Correction :
   ==========
   Le NOOK provient du calcul de l'option ERME_ELEM. Pour cette option, on calcule pour
   chaque maille et pour chacune des faces un voisin (et un seul).
   
   Or dans le maillage il y a des mailles qui ont deux voisins : ce sont des mailles bordées
   à la fois par une maille de bord (noyée au milieux d'éléments volumiques) et une maille
   volumique.
   
   Et comme lors du passage au format MED, l'ordre de déclaration des types de mailles n'est
   plus le même ; on ne trouve pas toujours le même voisin (car on s'arrête de chercher dès
   qu'on a trouvé un voisin).
   
   Il peut être fréquent de rencontrer ce genre de situation mais le calcul de l'estimateur
   d'erreur n'est pas prévu pour gérer plusieurs voisins.
   On compte le nombre de voisin et dès qu'il est supérieur à 1, on s'arrête avec une erreur
   fatale et un message du type :
      !------------------------------------------------------------------------------!
      ! <F> <INDICATEUR_12> . . . . . . . . . . . . . . . . . . . . . . . . . . . .  !
      ! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  !
      !  La face numéro 1 de la maille M2 possède 2 voisins. . . . . . . . . . . . . !
      !  Or, ceci n'est pas prévu : un seul voisin par face est autorisé. . . . . . .!
      !  Cela signifie que la maillage comporte des mailles doubles ou qu'une maille !
      !  de bord est intercalée entre deux mailles volumiques. . . . . . . . . . .   !
      ! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  !
      !  Conseils : . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  !
      ! . .Vérifiez votre maillage. . . . . . . . . . . . . . . . . . . . . . . . .  !
      ! . .Il se peut que ces mailles doubles ou intercalées ne soient pas . . . . . !
      ! . .nécessaire au calcul. Dans ce cas ne les affectez pas avec le modèle ! . .!
      ! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  !
      ! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  !
      ! Cette erreur est fatale. Le code s'arrête. . . . . . . . . . . . . . . . .   !
      !------------------------------------------------------------------------------!
   
   La gestion de plusieurs voisins sera programmée lorsqu'il y aura un vrai besoin.
   
   Cette correction oblige à modifier des tests pour lesquels on faisait TOUT='OUI' dans
   AFFE_MODELE. On n'affecte que les mailles nécessaires au calcul.
   
   Au passage, on restitue le maillage MED pour ssnp130a.
   
   Impacts :
   =======
   F:
   resvoi.f
   
   PY:
   indicateur.py
   
   TESTS:
   ssls09b.comm  ssls09c.comm  ssnp123a.comm  ssnp123b.comm  ssnp130a.comm  ssnp130a.mmed
   ssnp130d.comm
   
   UNIGEST:
   ssnp130a.mail
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    passage des tests ERME_ELEM et ERTH_ELEM
DEJA RESTITUE DANS : 11.1.21
NB_JOURS_TRAV  : 3.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 018282 DU 2012-01-24 15:25:50
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    sslv134 d sensible au format de son maillage
FONCTIONNALITE
   Problème :
   ========
   Le test sslv134d devient NOOK (faiblement) lorsqu'on convertit son maillage au format MED.
   
   Correction :
   ==========
   Le NOOK provient du calcul de l'option ERME_ELEM. Pour cette option, on calcule pour
   chaque maille et pour chacune des faces un voisin (et un seul).
   
   Or dans le maillage il y a des mailles qui ont deux voisins : ce sont des mailles bordées
   à la fois par une maille de bord (noyée au milieux d'éléments volumiques) et une maille
   volumique.
   
   Et comme lors du passage au format MED, l'ordre de déclaration des types de mailles n'est
   plus le même ; on ne trouve pas toujours le même voisin (car on s'arrête de chercher dès
   qu'on a trouvé un voisin).
   
   Il peut être fréquent de rencontrer ce genre de situation mais le calcul de l'estimateur
   d'erreur n'est pas prévu pour gérer plusieurs voisins.
   On compte le nombre de voisin et dès qu'il est supérieur à 1, on s'arrête avec une erreur
   fatale et un message du type :
      !------------------------------------------------------------------------------!
      ! <F> <INDICATEUR_12> . . . . . . . . . . . . . . . . . . . . . . . . . . . .  !
      ! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  !
      !  La face numéro 1 de la maille M2 possède 2 voisins. . . . . . . . . . . . . !
      !  Or, ceci n'est pas prévu : un seul voisin par face est autorisé. . . . . . .!
      !  Cela signifie que la maillage comporte des mailles doubles ou qu'une maille !
      !  de bord est intercalée entre deux mailles volumiques. . . . . . . . . . .   !
      ! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  !
      !  Conseils : . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  !
      ! . .Vérifiez votre maillage. . . . . . . . . . . . . . . . . . . . . . . . .  !
      ! . .Il se peut que ces mailles doubles ou intercalées ne soient pas . . . . . !
      ! . .nécessaire au calcul. Dans ce cas ne les affectez pas avec le modèle ! . .!
      ! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  !
      ! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  !
      ! Cette erreur est fatale. Le code s'arrête. . . . . . . . . . . . . . . . .   !
      !------------------------------------------------------------------------------!
   
   La gestion de plusieurs voisins sera programmée lorsqu'il y aura un vrai besoin.
   
   Cette correction oblige à modifier des tests pour lesquels on faisait TOUT='OUI' dans
   AFFE_MODELE. On n'affecte que les mailles nécessaires au calcul.
   
   Au passage, on restitue le maillage MED pour sslv134d.
   
   Impacts :
   =======
   F:
   resvoi.f
   
   PY:
   indicateur.py
   
   TESTS:
   sslv07a.comm  sslv07d.comm  sslv134d.comm
   
   UNIGEST:
   sslv134d.mail
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    passage des tests ERME_ELEM et ERTH_ELEM
DEJA RESTITUE DANS : 11.1.21
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR assire       ASSIRE Aimery          DATE 05/10/2012 - 07:00:08

--------------------------------------------------------------------------------
RESTITUTION FICHE 018455 DU 2012-02-23 10:33:17
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    CALC_EUROPLEXUS : absence de messages pour les fonctionnalitxc3xa9s non-prxc3xa9vues
FONCTIONNALITE
   Problème :
   ========
   
   CALC_EUROPLEXUS n'émet aucun message quand une des modélisations présentes dans le modèle
   n'est pas prise en compte dans CALC_EUROPLEXUS et donc dans le calcul EPX qui suit.
   
   Correction :
   ==========
   
   On émet une erreur fatale quand le modèle contient des modélisations non traités par
   CALC_EUROPLEXUS.
   
      !---------------------------------------------------------------!
      ! <EXCEPTION> <PLEXUS_6>                                        !
      !                                                               !
      ! La modélisation POU_D_T n'est pas disponible dans CALC_EUROPLEXUS !
      !---------------------------------------------------------------!
   
   Pas d'impact doc
   
   Remarque :
   Nous n'avons fait le travail que pour le modèle car c'est le plus grave.
   Une fiche d'évolution (issue18797) a été émise pour gérer les autres concepts (caraelem,
   materiau, etc.).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    plexu*
DEJA RESTITUE DANS : 11.1.20
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 018454 DU 2012-02-23 10:16:45
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TMA : Necs
TITRE
    CALC_EUROPLEXUS : mauvaise traduction de M_T_D_N
FONCTIONNALITE
   Problème :
   ========
   Pour traduire les masses ponctuelles, CALC_EUROPLEXUS crée pour Europlexus les masses
   ajoutées ('MASSE') à partir des M_T_D_N du CARA_ELEM. 
   
   Cette traduction est erronées car on traduit la valeur M_T_D_N (masses sans inerties)
   comme "epx[MODULE].append('MASSE  123456 %s' %vale)" (calc_europlexus_ops.py, ligne 618),
   c'est-à-dire qu'on affecte la masse destinée aux ddl de translation (123) aussi aux ddl
   d'inertie (456).
   
   
   
   Correction :
   ===========
   On remplace :
   epx[MODULE].append('MASSE  123456 %s' %vale)
   par
   epx[MODULE].append('MASSE  123 %s' %vale)
   
   dans calc_europlexus_ops.py
   
   plexu02a utilise cette fonctionnalité, il n'est pas cassé avec ce changement.
   
   Pas d'impact doc
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 9.3.17
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 9.3.17
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    plexu*
DEJA RESTITUE DANS : 11.1.20
--------------------------------------------------------------------------------
RESTITUTION FICHE 018288 DU 2012-01-25 10:46:12
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    Probleme de lecture des variables internes dans CALC_EUROPLEXUS
FONCTIONNALITE
   Problème :
   =========
   
   Suivant les lois de comportement utilisées le nombre de variables internes dans EPX n'est
   pas le même. Lors de la lecture du fichier de résultats med issu d'EPX, on cherche à lire
   des composantes de V1 à V18. Ca marche avec GLRC mais pas en ELAS par exemple. Voilà
   pourquoi une alarme est émise.
   
   Proposition :
   ===========
   
   Dans calc_europlexus_ops.py, il y a un mécanisme de try/except pour lire à l'aveugle le
   contenu du fichier MED, associé à des MasquerAlarme. En première approche, on poursuit le
   "MasquerAlarme('MED_98')" jusqu'à la fin de la lecture des variables internes.
   Ainsi l'alarme n'est plus émise. Le champ VARI_ELGA reste cependant vide.
   
   Une fiche d'évolution (issue18798) a été émise pour réécrire la partie lecture du fichier
   MED à l'aide de l'API Python de MED.
   
   On supprime dans plexu01a.comm et plexu03a.comm les IGNORE_ALARM('MED_98') car ils ne sont
   plus utiles.
   
   Sources impactées : calc_europlexus_ops.py, plexu01a.comm et plexu03a.comm
   
   Pas d'impact doc.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    cas test plexu01a, plexu03a
DEJA RESTITUE DANS : 11.1.20
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 018643 DU 2012-04-02 13:27:21
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    CALC_EUROPLEXUS : message erron?
FONCTIONNALITE
   Probleme :
   ----------
   Le message suivant de CALC_EUROPLEXUS n'est pas bon  :
   
      !------------------------------------------------------!
      ! <EXCEPTION> <PLEXUS_16>                              !
      !                                                      !
      ! En prÃ©sence du mot-clÃ© K_TR_D_N dans CALC_EUROPLEXUS !
      ! le mot-clÃ© NFAT est obligatoire dans AFFE_CARA_ELEM. !
      !------------------------------------------------------!
   
   NFAT est obligatoire en présence de A_TR_D_N et non pas de K_TR_D_N.
   
   Solution :
   ----------
   On corrige le message
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    plexu*
DEJA RESTITUE DANS : 11.1.21
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 018453 DU 2012-02-23 10:07:45
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TMA : Necs
TITRE
    CALC_EUROPLEXUS : absence de message sur GROUP_NO_POI1
FONCTIONNALITE
   L'anomalie initiale n'a pas pu être reproduite en NEW11 et il apparaît qu'un message
   d'erreur est lancé quand GROUP_MA_POI1 est absent du concept cara_elem.
   Cependant les développements restitués la semaine dernière n'avaient pas pris en compte le
   cas des discrets dans CALC_EUROPLEXUS. 
   C'est d'ailleurs pour cette raison que plexu02a est cassé en NEW11.
   
   Proposition :
   ===========
   
   Pour corriger ce problème :
   
   Le message <plexu_6> n'est plus émis pour les modélisations commençant par "DIS_".
   Ce message passe en ALARME et non plus erreur fatale.
   
   Sources impactées :
   =================
   calc_europlexus_ops.py
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    plexu*
DEJA RESTITUE DANS : 11.1.21
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR durand       DURAND Christophe      DATE 05/10/2012 - 07:00:09

--------------------------------------------------------------------------------
RESTITUTION FICHE 018375 DU 2012-02-09 18:10:29
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    Problème arrondi coordonnées segment MACR_LIGN_COUPE
FONCTIONNALITE
   Problème dans le formatage des nombres réels pour le maillage de ligne généré par
   MACR_LIGN_COUPE, dans le cas de très petits nombres.
   
   Je revois le mécanisme de génération du maillage de ligne (méthode crea_mail_lig_coup dans
   macr_lign_coupe_ops.py) et en particulier le formatage des réels.
   
   A faire en versions 11 et 10.
   Je me charge de l'asrest v10.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    étude fournie  + tests de la base
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR debonnieres  DE BONNIERES Philippe   DATE 05/10/2012 - 07:00:10

--------------------------------------------------------------------------------
RESTITUTION FICHE 018528 DU 2012-03-09 12:20:45
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    plantage non explicite lors d'un calcul avec META_LEMA_ANI
FONCTIONNALITE
   A cause d'erreurs liees Ã  la precision machine, on tombait dans la 
   routine EDGEQU sur une valeur de la variable EQUI tres legerement 
   negative (de l'ordre de 1.E-47) dont on essayait de prendre la racine 
   carree.
   On ajoute donc un test sur la valeur de EQUI:
   si - R8PREM < EQUI < 0 , alors EQUI = 0
   si EQUI < - R8PREM , on emet un message d'erreur
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    perso (sur l'?tude li?e ? la fiche)
DEJA RESTITUE DANS : 11.1.21
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desroche     DESROCHES Xavier       DATE 05/10/2012 - 07:00:10

--------------------------------------------------------------------------------
RESTITUTION FICHE 018269 DU 2012-01-23 14:31:29
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    Elements SHB et variables de sortie
FONCTIONNALITE
   Problème : Pour les éléments SHB le calcul des options RAPH_MECA ET FULL_MECA ne gère 
   pas le code retour de NMCOMP.
   
   Correction : dans le te0477 on rajoute en fin de routine le stockage du code retour 
   dans le champ paramètre PCODRET.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    liste restreinte
DEJA RESTITUE DANS : 11.1.20
NB_JOURS_TRAV  : 0.25
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR pellet       PELLET Jacques         DATE 05/10/2012 - 07:00:10

--------------------------------------------------------------------------------
RESTITUTION FICHE 018472 DU 2012-02-28 09:02:26
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    affichage NAN pour TRAV_EXT
FONCTIONNALITE
   Problème :
   ----------
   Quand on ajoute à la fin du test ssnv217a :
                                                                                            
                                                                             
   U=CALC_CHAMP(reuse = U, FORCE='FORC_NODA', RESULTAT=U, )
   TRAV = POST_ELEM( RESULTAT = U, TRAV_EXT = _F(),)
   IMPR_TABLE(TABLE=TRAV)
                                                                                            
                                                                             
   On s'aperçoit qu'à partir du pas de temps 21 TRAV_REEL est NAN.
   On peut aussi trouver "louche" qu'au pas de temps 11, TRAV_REEL passe brutalement à
   -1.53722E+10
                                                                                            
                                                                             
   #ASTER 11.01.19 CONCEPT TRAV CALCULE LE 26/04/2012 A 12:35:23 DE TYPE
   #TABLE_SDASTER
    NUME_ORDRE   INST         TRAV_ELAS    TRAV_REEL
               0  0.00000E+00  0.00000E+00  0.00000E+00
               1  1.00000E-01  1.85400E+02  1.85400E+02
               2  2.00000E-01  7.87380E+01  4.10168E+02
               3  3.00000E-01  3.92847E+01  4.62632E+02
               4  4.00000E-01  2.30480E+01  4.81489E+02
               5  5.00000E-01  1.50456E+01  4.90260E+02
               6  6.00000E-01  1.05621E+01  4.95029E+02
               7  7.00000E-01  7.81103E+00  4.97906E+02
               8  8.00000E-01  7.11111E+00  4.99910E+02
               9  9.00000E-01  9.00000E+00  5.01799E+02
              10  1.00000E+00  1.11111E+01  5.03910E+02
              11  1.10000E+00  1.89824E+02 -1.53722E+10
              12  1.20000E+00  8.28672E+01 -1.53722E+10
              13  1.30000E+00  4.16395E+01 -1.53722E+10
              14  1.40000E+00  2.44954E+01 -1.53722E+10
              15  1.50000E+00  1.60111E+01 -1.53722E+10
              16  1.60000E+00  1.12479E+01 -1.53722E+10
              17  1.70000E+00  8.32179E+00 -1.53722E+10
              18  1.80000E+00  6.66657E+00 -1.53722E+10
              19  1.90000E+00  8.43737E+00 -1.53722E+10
              20  2.00000E+00  1.04165E+01 -1.53722E+10
              21  2.10000E+00  1.85400E+02          NAN
              22  2.20000E+00  7.87380E+01          NAN
              23  2.30000E+00  3.92847E+01          NAN
                                                                                            
                                                                             
                                                                                            
                                                                             
   Analyse :
   ---------
   La programmation de la routine pewext.f (POST_ELEM / TRAV_EXT) suppose implicitement que
   les champs (DEPL et FORC_NODA) aux différents numéros d'ordre ont la meme numérotation.
   C'est à dire que l'on calcule le produit scalaire F*U par un simple DDOT sur les objets
   .VALE des cham_no.
                                                                                            
                                                                             
   Cette hypothèse est fausse si la sd_resultat a été calculée en plusieurs "coups" (reuse)
   en changeant les conditions aux limites dualisées.
                                                                                            
                                                                             
   Comme il n'y a pas de vérification de la cohérence des champs, le calcul conduit à sommer
   des valeurs non-initialisées, ce qui entraines des résultats faux (ou NaN).
                                                                                            
                                                                             
                                                                                            
                                                                             
   Correction :
   ------------
   On corrige la routine pewext.f pour que le produit scalaire de 2 champs U et F soit fait
   correctement grace au passage par des champs "simples", ce qui permet aussi de vérifier
   que les 2 champs ont bien les memes ddls physiques.
                                                                                            
                                                                             
   Cette correction est possible car nous pensons (LI, JP et TDS) que les ddls de Lagrange ne
   doivent pas etre pris en compte dans le calcul du travail exterieur.
                                                                                            
                                                                             
                                                                                            
                                                                             
   Validation :
   ------------
   On valide le développement en comparant le paramètre TRAV_REEL de POST_ELEM / TRAV_EXT
   avec le paramètre TRAV_EXT calculé par STAT_NON_LINE / ENERGIE=_F().
   Pour cela, on enrichit le test ssnv217a.
                                                                                            
                                                                             
   Après correction, on trouve :
                                                                                            
                                                                             
   #ASTER 11.01.19 CONCEPT TRAV CALCULE LE 26/04/2012 A 15:32:34 DE TYPE
   #TABLE_SDASTER
    NUME_ORDRE   INST         TRAV_ELAS    TRAV_REEL
               0  0.00000E+00  0.00000E+00  0.00000E+00
               1  1.00000E-01  1.85400E+02  1.85400E+02
               2  2.00000E-01  7.87380E+01  4.10168E+02
               3  3.00000E-01  3.92847E+01  4.62632E+02
               4  4.00000E-01  2.30480E+01  4.81489E+02
               5  5.00000E-01  1.50456E+01  4.90260E+02
               6  6.00000E-01  1.05621E+01  4.95029E+02
               7  7.00000E-01  7.81103E+00  4.97906E+02
               8  8.00000E-01  7.11111E+00  4.99910E+02
               9  9.00000E-01  9.00000E+00  5.01799E+02
              10  1.00000E+00  1.11111E+01  5.03910E+02
              11  1.10000E+00  1.89824E+02  6.98544E+02
              12  1.20000E+00  8.28672E+01  9.29802E+02
              13  1.30000E+00  4.16395E+01  9.85115E+02
              14  1.40000E+00  2.44954E+01  1.00512E+03
              15  1.50000E+00  1.60111E+01  1.01444E+03
              16  1.60000E+00  1.12479E+01  1.01952E+03
              17  1.70000E+00  8.32179E+00  1.02259E+03
              18  1.80000E+00  6.66657E+00  1.02461E+03
              19  1.90000E+00  8.43737E+00  1.02638E+03
              20  2.00000E+00  1.04165E+01  1.02836E+03
              21  2.10000E+00  1.85400E+02  1.19663E+03
              22  2.20000E+00  7.87380E+01  1.42140E+03
              23  2.30000E+00  3.92847E+01  1.47386E+03
              24  2.40000E+00  2.30480E+01  1.49272E+03
              25  2.50000E+00  1.50456E+01  1.50149E+03
                                                                                            
                                                                             
   On constate aussi que l'ancienne programmation donnait des résultats FAUX (différents de
   NaN) pour les pas de temps 11 à 20.
                                                                                            
                                                                             
                                                                                            
                                                                             
   Résultats faux :
   ----------------
   Le calcul de POST_ELEM / TRAV_EXT donne des résultats faux si la structure de donnée
   résultat a été produite avec des "reuse" en changeant les conditions cinématiques
   dualisées (AFFE_CHAR_MECA) entre les "reuse".
                                                                                            
                                                                             
   Liste des fichiers impactés par la correction de la fiche:  18472
     cnsdot.f  pewext.f
                                                                                            
                                                                             
   NEW10 :
   La fiche pouvant donner des résultats faux, il faut reporter en NEW10 :
     * la correction de la routine pewext.f
     * l'ajout de la routine cnsdot.f
    
    
   Liste des fichiers impactés par la correction de la fiche:  18472
     cnsdot.f  enerca.f  pewext.f
     ssnv217a.comm
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 10.0
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 11.0
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssnv217a
DEJA RESTITUE DANS : 11.1.21
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR proix        PROIX Jean-Michel      DATE 05/10/2012 - 07:00:10

--------------------------------------------------------------------------------
RESTITUTION FICHE 018805 DU 2012-05-02 11:36:32
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    [FORUM] GDEF_LOG mal prot?g?
FONCTIONNALITE
   Probleme :
   ============
   La routine deflog.f n'est pas protégée contre des élongations négatives ou nulles (voir l 80)
   
   Ce serait bien:
   - soit d'émettre une erreur spécifique (élongation nulle ou négative), qui provient
   probablement d'un retournement de maille 
   - soit de proposer un code retour à la loi de comportement de manière à permettre la
   découpe du pas de temps dans ce cas. C'est ce qu'on avait fait pour ELAS_HYPER et ça avait
   permis de s'en sortir dans certaines situations.
   http://www.code-aster.org/forum2/viewtopic.php?id=16764
   
   Correction :
   ============
   On ajoute dans DEFLOG le même test que dans POSLOG (similaire à celui de SIMO_MIEHE) :
   
   C     DETERMINANT DE LA MATRICE F A L INSTANT T+ 
         CALL NMDETF(NDIM,FR,DETF)
         IF (DETF.LE.1.D-2 .OR. DETF.GT.1.D2) THEN
           CODRET = 1
           GOTO 9999
         END IF
   
   et en plus (ceintures et bretelles) lors du calcul des déformations logarithmiques :
            IF (LAMB(I).LE.R8MIEM()) THEN
               IRET=1
               GOTO 9999
            ENDIF
   avant de calculer le log : 
            LOGL(I)=LOG(LAMB(I))*0.5D0
   
   L'étude s'arrête alors pour cause de matrice non inversible.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    etude jointe (partiellement)
DEJA RESTITUE DANS : 11.1.21
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 05/10/2012 - 07:00:11

--------------------------------------------------------------------------------
RESTITUTION FICHE 018712 DU 2012-04-13 18:07:21
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    plantage en CPU_LIMIT
FONCTIONNALITE
   Problème
   ========
   
   Il s'agit d'un calcul utilisant STAT_NON_LINE.
   On lui impose un temps limite inférieur au temps nécessaire pour la
   résolution.
   On s'attend à ce que le calcul soit interrompu en levant une exception,
   que le calcul se termine normalement ensuite, et que la base soit
   sauvegardée.
   Or le calcul s'arrête brutalement en segmentation fault.
   
   Correction
   ==========
   
   L'erreur se situe dans l'utilisation du mécanisme d'émulation des exceptions
   en C. Pour cela, on utilise les fonctions setjmp/longjmp.
   setjmp sauvegarde l'environnement du "code", pour lever une exception (et
   donc interrompre le cours normal de l'exécution), un appel à longjmp
   restaure l'environnement là où setjmp a été appelé.
   
   D'une manière similaire au "marques" dans Jeveux, on gère une pile
   "d'environnement" indexée par un niveau de profondeur.
   
   Le mécanisme est utilisé lors de l'appel à une commande et
   lors des appels à getvectjev, getcolljev, putvecjev, prepcompcham.
   Cependant, il y a un mélange dans le stockage de la commande courante et
   la mise à jour du niveau de profondeur (fonction unique qui fait les
   deux opérations en même temps). Cette fonction est appelé pour l'exécution
   des commandes (aster_oper/execop) mais pas pour les autres fonctions.
   
   Dans le cas qui pose problème :
   
   - On stocke l'environnement avant op0070.
   
   - On appelle getvectjev et donc on stocke l'environnement avant getvectjev.
     Comme on n'incrémente pas le niveau, on écrase l'environnement "avant op0070".
   
   - au cours d'op0070, on lève l'exception ArretCPUError et donc on appelle
     longjmp avec l'environnement "avant op0070".
     Celui-ci ayant été écrasé, on est en fait "rebranché" dans la tâche de
     nettoyage de getvectjev et non là on devrait l'être : segfault.
   
   
   
   Pour que le problème apparaisse, il faut :
   
   - interrompre une commande (fortran) en levant une exception (erreur 'S'
     ou exception particularisée : ArretCPUError, NonConvergenceError...)
   
   - qu'au cours de cette commande, il y ait un appel à une des fonctions :
     getvectjev, getcolljev, putvecjev, prepcompcham qui sont toutes 4 des
     fonctions Python du module aster.
     Hors interrogation du catalogue, il ne doit y avoir que l'évaluation des
     formules qui retourne dans l'espace Python.
     Pour que l'évaluation d'une formule utilise une de ces fonctions, il faut
     qu'elle soit très compliquée ou bien que son expression demande d'évaluer
     une fonction ou une nappe (car on fera lors un getvectjev pour récupérer
     ses valeurs).
   
   Le problème existe depuis l'introduction de getvectjev en 7.0.7.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssnp142b en cpu limit
DEJA RESTITUE DANS : 11.1.21
NB_JOURS_TRAV  : 1.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR bottoni      BOTTONI Marina         DATE 05/10/2012 - 07:00:11

--------------------------------------------------------------------------------
RESTITUTION FICHE 017165 DU 2011-06-21 08:56:10
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    plantage BETON_DOUBLE_DP
FONCTIONNALITE
   L'utilisateur avait une étude qui se terminaient, en STA10, avec une erreur numérique.
   Pendant la recherche de l'anomalie, un autre erreur numérique a été détectée par la
   SIMU_POINT_MAT.
   On avait donc deux situations qui se terminaient avec la même erreur :
   
   1) étude - petite structure
   2) test avec simu_point_mat
   
   Or, en regardent plus en détail, on avait en effet deux problèmes différents.
   
   Pour le cas 1) de l'étude :
   ============================ 
   
   La matrice SECANTE (utilisée par STAT_NON_LINE si le pas de calcul est inférieur à
   PAS_MINI_ELAS)  n'était pas
   implementée, et pas initialisée dans la loi (on avait donc des zéros machine).
   J'ai donc résolu cette anomalie en implementant les options RIGI_MECA_ELAS (phase de
   prédiction de Newton-Raphson) et
   FULL_MECA_ELAS (phase de correction) dans la loi de comportement. En effet, pour la loi en
   question (BETON_DOUBLE_DP),
   qui est plastique, la matrice SECANTE (=matrice de décharge) est tout simplement la
   matrice élastique. 
   
   A partir de l'étude fournie par l'utilisateur, j'ai vérifié que avec la routine corrigée,
   la convergence (à partir du
   dernier pas de temps convergé avant l'erreur) a lieu avec la même vitesse et même résidu
   qu'en utilisant une matrice
   ELASTIQUE dans la STAT_NON_LINE.  
   
   
   
   Pour le cas 2) de simu_point_mat :
   =====================================
   
   La loi de comportement stocke en V3 une valeur de température, qui est la température
   maximale au cours du calcul).
   Si la variable de commande TEMP n'est pas définie dans le fichier de commande (paramètres
   matériau non-dépendant de la
   température, mot-clé ELAS), cette variable interne V3 était posée égale à NaN, ce qui est
   géré par la loi de
   comportement pour la stat_non_line, mais pas par les commandes de post-traitement à
   l'intérieur de SIMU_POINT_MAT.
   
   Après discussion avec Jean-Michel, nous avons décidé de poser V3=-1000 (une valeur
   physiquement non admissible)  
   en absence de définition de la température. 
   J'ai testé le bon comportement dans les deux situations (variable interne V3 avec et sans
   prise en compte de la
   température) avec des cas-test exprès.
   
   Au niveau de la loi de comportement, maintenant c'est aussi interdit de faire un calcul
   sans prise en compte de la température, puis de le continuer en la prenant compte (nouveau
   message d'erreur type F ).
   
   
   Routines impactées
   =========================
   plasbe.f --> loi de comportement 
   algorith9.py --> fichier des messages
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    cas-tests personnels
DEJA RESTITUE DANS : 11.1.21
NB_JOURS_TRAV  : 5.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR greffet      GREFFET Nicolas        DATE 05/10/2012 - 07:00:11

--------------------------------------------------------------------------------
RESTITUTION FICHE 018810 DU 2012-05-03 10:11:23
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    En NEW11.01.20, le cas-test sdnv100j s'arrete en erreur fatale sur Aster4, Rocks, Calibre5 et Calibre7.
FONCTIONNALITE
   Contexte :
   suite à la fiche issue18789 l'utilisation de MASS_DIAG='OUI' a été interdite avec un
   schéma implicite dans DNL.
   La macro MACRO_BASCULE_SCHEMA laissait traîner (à tort) cette option pour les intervalles
   de temps en implicite.
   
   
   Analyse :
   pas de résultat faux car en pratique en implicite on utilisait la matrice de masse
   consistante : c'est juste que l'utilisateur croyait à tort utiliser la masse lumpée car il
   voyait MASS_DIAG='OUI'.
   
   
   Correction :
   quand on a un schéma implicite, on reste en masse consistante.
   Je corrige aussi un deuxième bug sur la lecture du schéma utilisé pour la phase de
   rééquilibrage : en fait on reprenait le schéma de l'intervalle implicite et donc le choix
   de l'utilisateur n'était pas forcément respecté.
   
   Validation :
   cas-test sdnv100j dont les résultats sont inchangés (en mettant le même schéma pour le
   rééquilibrage)
   
   Pas d'impact doc.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sdnv100j
DEJA RESTITUE DANS : 11.1.21
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST MODIF sdll136a                         brie N.BRIE             653      4      4
 CASTEST MODIF sdnv100j                      macocco K.MACOCCO          293      6      4
 CASTEST MODIF sdnv103b                      macocco K.MACOCCO          413     25     25
 CASTEST MODIF ssls09b                       macocco K.MACOCCO          331      3      3
 CASTEST MODIF ssls09c                       macocco K.MACOCCO          190      3      3
 CASTEST MODIF sslv07a                       macocco K.MACOCCO          912      3      3
 CASTEST MODIF sslv07d                       macocco K.MACOCCO          316      3      3
 CASTEST MODIF sslv134d                      macocco K.MACOCCO          790      3      3
 CASTEST MODIF ssnp123a                      macocco K.MACOCCO          227      3      3
 CASTEST MODIF ssnp123b                      macocco K.MACOCCO          206      3      3
 CASTEST MODIF ssnp130a                      macocco K.MACOCCO          326      3      3
 CASTEST MODIF ssnp130d                      macocco K.MACOCCO          278      3      3
 CASTEST MODIF ssnv217a                      macocco K.MACOCCO          240      7      2
       C MODIF hdf/hdfcld                    macocco K.MACOCCO           45      2      2
       C MODIF hdf/hdfclf                    macocco K.MACOCCO           45      2      2
       C MODIF hdf/hdfclg                    macocco K.MACOCCO           44      2      2
       C MODIF hdf/hdfcrf                    macocco K.MACOCCO           59      2      2
       C MODIF hdf/hdfcrg                    macocco K.MACOCCO           72      4      4
       C MODIF hdf/hdfnbo                    macocco K.MACOCCO           73      2      2
       C MODIF hdf/hdfnom                    macocco K.MACOCCO           86      2      2
       C MODIF hdf/hdfopd                    macocco K.MACOCCO           73      4      4
       C MODIF hdf/hdfopf                    macocco K.MACOCCO           55      2      2
       C MODIF hdf/hdfopg                    macocco K.MACOCCO           65      3      3
       C MODIF hdf/hdfrat                    macocco K.MACOCCO           73      2      2
       C MODIF hdf/hdfrsv                    macocco K.MACOCCO           71      2      2
       C MODIF hdf/hdftsd                    macocco K.MACOCCO           70      2      2
       C MODIF hdf/hdftyp                    macocco K.MACOCCO          105      2      2
       C MODIF hdf/hdfwat                    macocco K.MACOCCO           74      3      3
       C MODIF hdf/hdfwsv                    macocco K.MACOCCO          137      3      3
       C MODIF supervis/astermodule          macocco K.MACOCCO         3936     20      2
 FORTRAN AJOUT calculel/cnsdot               macocco K.MACOCCO          141    141      0
 FORTRAN MODIF algorith/arg126               macocco K.MACOCCO          266      9     10
 FORTRAN MODIF algorith/deflog               macocco K.MACOCCO          382      9      5
 FORTRAN MODIF algorith/edgequ               macocco K.MACOCCO           63     12      2
 FORTRAN MODIF algorith/ndlect               macocco K.MACOCCO          482      5      3
 FORTRAN MODIF algorith/nmdlog               macocco K.MACOCCO          167      6     11
 FORTRAN MODIF algorith/nmfi2d               macocco K.MACOCCO          160     14      9
 FORTRAN MODIF algorith/pewext               macocco K.MACOCCO          150     29     17
 FORTRAN MODIF algorith/plasbe               macocco K.MACOCCO          495     48     45
 FORTRAN MODIF algorith/poslog               macocco K.MACOCCO          310      5      4
 FORTRAN MODIF algorith/prelog               macocco K.MACOCCO          127      6      6
 FORTRAN MODIF elements/resvoi               macocco K.MACOCCO          441     54     10
 FORTRAN MODIF elements/te0201               macocco K.MACOCCO          148      5      4
 FORTRAN MODIF modelisa/afrela               macocco K.MACOCCO          413     15     30
  PYTHON MODIF Intranet/macro_bascule_schema_cata    macocco K.MACOCCO          348     11      3
  PYTHON MODIF Intranet/macro_bascule_schema_ops    macocco K.MACOCCO          302     11      5
  PYTHON MODIF Macro/calc_europlexus_ops     macocco K.MACOCCO         2580      7      4
  PYTHON MODIF Macro/macr_lign_coupe_ops     macocco K.MACOCCO          988     52     51
  PYTHON MODIF Messages/algorith12           macocco K.MACOCCO          372      9      2
  PYTHON MODIF Messages/algorith9            macocco K.MACOCCO          267      6      2
  PYTHON MODIF Messages/compor1              macocco K.MACOCCO          371      6      2
  PYTHON MODIF Messages/indicateur           macocco K.MACOCCO          165     14      2
  PYTHON MODIF Messages/mecanonline5         macocco K.MACOCCO          232      6      2
  PYTHON MODIF Messages/plexus               macocco K.MACOCCO           77      5      3


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :    1         141       141              +141
 MODIF :   53       19564       472     335      +137
 SUPPR :    0           0                 0        +0
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :   54       19705       613     335      +278 
