

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR corus        CORUS Mathieu          DATE 05/07/2012 - 05:38:04

--------------------------------------------------------------------------------
RESTITUTION FICHE 018503 DU 2012-03-05 14:24:59
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    CALC_CORR_SSD - Probleme d'occupation de memoire - basevolatile
FONCTIONNALITE
   Probleme :
   ----------
   
   En testant un peu plus completement la commande CALC_CORR_SSD, je suis tombe sur un
   probleme de memoire. En effet, on recupere des alarmes du type :
   
     
   !------------------------------------------------------------------------------------------------!
      ! <A> <JEVEUX1_64>                                                                    
             !
      !                                                                                     
             !
      !  Le volume des donnÃ©es temporaires (objets de la base Volatile) Ã©crites sur disque
   (149.22 Mo) !
      !  est plus de 100.00 fois supÃ©rieur au volume de donnÃ©es lues (0.78 Mo).           
               !
      !                                                                                     
             !
      !                                                                                     
             !
      ! Ceci est une alarme. Si vous ne comprenez pas le sens de cette                      
             !
      ! alarme, vous pouvez obtenir des rÃ©sultats inattendus !                             
              !
     
   !------------------------------------------------------------------------------------------------!
   
   
   Suite a une discussion avec Jean Pierre, il convient donc de regarder precisement d'ou
   vient ce probleme, qui penalise les performances du code. Il faut commencer par regarder
   du cote des objets alloues non utilises. 
   
   Solution :
   ----------
   
   Il y a du menage qui n'etait pas fait correctement. Je fais un peu de menage "intelligent"
   en detruisant les "gros" concepts des qu'ils ne sont plus utilises.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    pompe sicodyn
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 018504 DU 2012-03-05 15:39:16
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    DEFI_MODELE_GENE - Gestion des modes apres CALC_CORR_SSD
FONCTIONNALITE
   Comme demandé en EDA, j'ai modifié la valeur de 1.D-14 (voir post ci-dessous) rentrée dans
   le dur dans le Fortran par 100.D0*R8PREM()*NORTOT. 
   
   NORTOT correspond ici à la norme du mode sans restriction à l'interface, au cas où les
   modes de la base modale ne sont pas normées a priori. 
   
   ********* Post du PRE_EDA ***********
   
   Analyse du probleme :
   ---------------------
   La construction de base modales a partir du mot cle "RITZ" peut engendrer des soucis dans
   DEFI_MODELE_GENE. En effet, certains modes peuvent ne pas etre "reconnus" comme etant a
   interface fixe. Meme si, sur ces interfaces, les deplacements sont tres petits, cela
   perturbe le recollement des deplacements d'interface, et la recherche des DDL independants
   avec NUME_DDL_GENE. 
   
   Solution :
   ----------
   
   Dans la mesure ou les deplacements "fautifs" sont des erreurs d'arrondis, on verifie dans
   la routine "rotlir" la nature du mouvement de l'interface. Si le mouvement moyen de
   l'interface est inferieur a 1.D-14 (en dur dans le fortran), alors on annule les
   mouvements de l'interface. Si cette solution d'un seuil en dur devait poser probleme, il
   reste possible de definir un seuil a partir du deplacement max. Mais ca fait rechercher le
   deplacement max sur tous les vecteurs, et donc ca prend du temps.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 11.0.22
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    pompe sicodyn
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR brie         BRIE Nicolas           DATE 05/07/2012 - 05:38:05

--------------------------------------------------------------------------------
RESTITUTION FICHE 018809 DU 2012-05-03 09:45:06
TYPE anomalie concernant Code_Aster (VERSION 11.1)
TITRE
    En NEW11.1.20, le cas-test sdnl136a s'arrete en erreur fatale sur Calibre 5.
FONCTIONNALITE
   Probleme :
   En NEW11.1.20, le cas-test sdnl136a s'arrete en erreur fatale sur Calibre 5.
   -------------------
   
   Analyse :
   Ce cas-test est tres sensible a la machine, a la version hebdomadaire, ... La moindre
   variation dans les donnees d'entree de DYNA_TRAN_MODAL, peut entrainer un plantage dans
   l'algorithme ITMI.
   -------------------
   
   Solution : 
   Je modifie le nombre de modes calcules dans MODE_ITER_SIMULT : 7 au lieu de 5. Remarque :
   cette modification n'a pas de justification objective. J'augmente aussi la duree autorisee
   du calcul dans le fichier .para car, sur Rocks uniquement, il y a parfois un probleme
   d'insuffisance de temps CPU.
   -------------------
   
   Impact :
   sdnl136a.comm   sdnl136a.para
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sdnl136a
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR assire       ASSIRE Aimery          DATE 05/07/2012 - 04:19:10

--------------------------------------------------------------------------------
RESTITUTION FICHE 018643 DU 2012-04-02 13:27:21
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    CALC_EUROPLEXUS : message erroné
FONCTIONNALITE
   Probleme :
   ----------
   Le message suivant de CALC_EUROPLEXUS n'est pas bon  :
   
      !------------------------------------------------------!
      ! <EXCEPTION> <PLEXUS_16>                              !
      !                                                      !
      ! En prÃ©sence du mot-clÃ© K_TR_D_N dans CALC_EUROPLEXUS !
      ! le mot-clÃ© NFAT est obligatoire dans AFFE_CARA_ELEM. !
      !------------------------------------------------------!
   
   NFAT est obligatoire en présence de A_TR_D_N et non pas de K_TR_D_N.
   
   Solution :
   ----------
   On corrige le message
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    plexu*
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 018453 DU 2012-02-23 10:07:45
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TMA : Necs
TITRE
    CALC_EUROPLEXUS : absence de message sur GROUP_NO_POI1
FONCTIONNALITE
   L'anomalie initiale n'a pas pu être reproduite en NEW11 et il apparaît qu'un message
   d'erreur est lancé quand GROUP_MA_POI1 est absent du concept cara_elem.
   Cependant les développements restitués la semaine dernière n'avaient pas pris en compte le
   cas des discrets dans CALC_EUROPLEXUS. 
   C'est d'ailleurs pour cette raison que plexu02a est cassé en NEW11.
   
   Proposition :
   ===========
   
   Pour corriger ce problème :
   
   Le message <plexu_6> n'est plus émis pour les modélisations commençant par "DIS_".
   Ce message passe en ALARME et non plus erreur fatale.
   
   Sources impactées :
   =================
   calc_europlexus_ops.py
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    plexu*
--------------------------------------------------------------------------------
RESTITUTION FICHE 017371 DU 2011-08-03 07:06:59
TYPE anomalie concernant Code_Aster (VERSION 11.1)
TITRE
    MACR_RECAL: FORMULE et DEFI_NAPPE non reconnus (calage paramètres source de chaleur)
FONCTIONNALITE
   Problème :
   ----------
   L'utilisatrice utilisait la macro MACR_RECAL (en mode INCLUSION) afin d'identifier les
   paramètres d'une source de chaleur.
   
   Elle tombait sur le message d'erreur suivant :
   
      !---------------------------------!
      ! <EXCEPTION> <RECAL0_85>         !
      !                                 !
      ! Erreur dans le calcul esclave:  !
      !    name 'FLUX_1' is not defined !
      !---------------------------------!
   
   Il y avait donc une erreur lors de l'évaluation du jeu de commandes esclaves, bien que
   l'étude esclave fonctionnait de façon autonome avec les paramètres choisis par MACR_RECAL.
   
   
   
   Explication :
   -------------
   En fait, il n'y a pas de problème dans MACR_RECAL mais quelques consignes à respecter pour
   l'écriture du fchier esclave.
   
   L'utilisatrice définissait des concepts "FLUX" de façon dynamique :
   
   FLUX=[None]*57
   
   for k in range(1,57):
   ...FLUX[k].=.DEFI_FONCTION.(NOM_PARA='INST',
   ............................VALE=(0,.....0.,
   ..................................TA__,..PHI__,
   ..................................TB__,..0.,
   ..................................244.,..0.,),);
   
   et utilisait ces concepts plus loin :
   
   FLUXSB.=.DEFI_NAPPE.(NOM_PARA.=.'Z',
   .....................PARA.=.(0., 5.E-3, 10.E-3, 15.E-3, 20.E-3, 25.E-3,..., 275.E-3,),
   .....................FONCTION = (
   FLUX_1,FLUX_2,FLUX_3,FLUX_4,FLUX_5,FLUX_6,
   FLUX_7,FLUX_8,FLUX_9,FLUX_10,FLUX_11,FLUX_12,FLUX_13,FLUX_14,
   FLUX_15,FLUX_16,FLUX_17,FLUX_18,FLUX_19,FLUX_20,FLUX_21,FLUX_22,FLUX_23,
   FLUX_24,FLUX_25,FLUX_26,FLUX_27,FLUX_28,FLUX_29,FLUX_30,FLUX_31,FLUX_32,FLUX_33,
   FLUX_34,FLUX_35,FLUX_36,FLUX_37,FLUX_38,FLUX_39,FLUX_40,FLUX_41,FLUX_42,FLUX_43,FLUX_44,
   FLUX_45,FLUX_46,FLUX_47,FLUX_48,FLUX_49,FLUX_50,FLUX_51,FLUX_52,FLUX_53,FLUX_54,
   FLUX_55,FLUX_56,), ) ;
   
   Ca fonctionne dans une étude Aster mais ca n'est pas syntaxiquement compatible avec
   Python, donc MACR_RECAL (qui évalue le jeu de commande via un execfile Python) ne sait pas
   faire la correspondance entre FLUX[1] et FLUX_1 (correspondance qui est fait par le
   superviseur Aster pour jeveux).
   
   La bonne façon d'écrire l'étude est :
   
   FLUXSB.=.DEFI_NAPPE.(NOM_PARA.=.'Z',
   .....................PARA.=.(0., 5.E-3, 10.E-3, 15.E-3, 20.E-3, 25.E-3,..., 275.E-3,),
   .....................FONCTION = (
   FLUX[1],FLUX[2],FLUX[3],FLUX[4],FLUX[5],FLUX[6],
   FLUX[7],FLUX[8],FLUX[9],FLUX[10],FLUX[11],FLUX[12],FLUX[13],FLUX[14],
   FLUX[15],FLUX[16],FLUX[17],FLUX[18],FLUX[19],FLUX[20],FLUX[21],FLUX[22],FLUX[23],
   FLUX[24],FLUX[25],FLUX[26],FLUX[27],FLUX[28],FLUX[29],FLUX[30],FLUX[31],FLUX[32],FLUX[33],
   FLUX[34],FLUX[35],FLUX[36],FLUX[37],FLUX[38],FLUX[39],FLUX[40],FLUX[41],FLUX[42],FLUX[43],FLUX[44],
   FLUX[45],FLUX[46],FLUX[47],FLUX[48],FLUX[49],FLUX[50],FLUX[51],FLUX[52],FLUX[53],FLUX[54],
   FLUX[55],FLUX[56],),) ;
   
   Avec la correction de l'étude esclave fournie, tout rentre dans l'ordre.
   
   
   Conclusion :
   ------------
   C'est une erreur utilisateur et aucune modification de source Aster n'est nécessaire.
   
   Note : concernant l'explication FLUX[i] <--> FLUX_i, je ne sais pas trop dans quelle
   documentation cela pourrait (ou devrait?) être décrit.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    Eude fournie
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR bodel        BODEL Charles          DATE 05/07/2012 - 02:57:58

--------------------------------------------------------------------------------
RESTITUTION FICHE 017900 DU 2011-11-14 14:00:51
TYPE anomalie concernant Code_Aster (VERSION 11.1)
TITRE
    Message d'erreur en cas de mauvaise utilisation de MACR_ELEM_DYNA
FONCTIONNALITE
   PROBLEME :
   ----------
   La base modale associee a un macro-element dynamique doit avoir ete creee par 
   DEFI_BASE_MODALE, meme si elle ne comporte qu'une base (c'est-a-dire lorsqu'elle n'est 
   pas un assemblage de differents modes, par exemple), et ce de maniere a la lier avec 
   une interface issue de DEFI_INTER_DYNA. 
   Si on ne le fait pas, le code plante dans DEFI_MODELE_GENE, dans arg126.f (l.261) avec 
   un message obscur : 
   
    !  Nom de Collection ou de Répertoire de noms inexistant :  .IDC_NOMS       $$XNOM !
   
   Il convient donc d'ajouter une verif dans arg126.f avec un message d'erreur un peu 
   plus explicite
   
   SOLUTION : 
   ----------
   On ajoute un message d'erreur plus explicite en amont de la commande qui plante dans 
   arg126.f. Le message est ajoute dans ALGORITH12 (mumero 3) : 
   
    On ne trouve pas le nom de l'interface associée à la sous-structure
    %(k1)s. La base modale utilisée pour définir le macro-élément associé
    à la sous-structure doit avoir été définie avec DEFI_BASE_MODALE, en
    mentionnant obligatoirement l'interface sous le mot-clé INTERF_DYNA.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    pas de validation
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 018336 DU 2012-02-02 14:41:21
TYPE anomalie concernant Code_Aster (VERSION 11.3)
TITRE
    MACR_ELEM_DYNA  => problxc3xa8me SDVERI
FONCTIONNALITE
   Problème :
   ----------
   MACR_ELEM_DYNA  => problème SDVERI
   Tests :  fdlv113a  sdll113c  sdls118a  sdls118b
   
   Solution :
   ----------
   Cas-tests fdlv113a, sdls118a et sdls118b : 
   L'objet .LINO est facultatif dans les macr_elem_dyna, il ne doit etre rempli que 
   lorsqu'on fait un calcul par sous-structuration. Dans les cas-tests MISS, le 
   macr_elem_dyna n'a pas besoin de cette liste de noeuds.
   Je propose donc de mettre le .LINO en facultatif.
   
   Pour le cas-test sdll113c, il y a encore plantage en SDVERI sur le REST_COND_TRAN, car on cree un objet 
   "interdit". Je ne peux pas trop repondre a cette question, et Ionel me dit que le travail est un peu plus 
   costaud qu'il n'y parait, car tous les REST_XXX_XXX creent cet objet.
   Je cree une nouvelle fiche pour ce probleme particulier.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    fdlv113a, sdls118a et sdls118b
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 018430 DU 2012-02-17 13:06:14
TYPE anomalie concernant Code_Aster (VERSION 11.1)
TITRE
    Couverture de code : PROJ_BASE et PROJ_RESU_BASE
FONCTIONNALITE
   Defauts de couverture : 
   PROJ_BASE           __                  NUME_DDL_GENE
   PROJ_BASE           MATR_ASSE_GENE      MATR_ASSE_GENE
   PROJ_BASE           RESU_GENE           RESU_GENE
   PROJ_BASE           VECT_ASSE_GENE      VECT_ASSE_GENE
   PROJ_RESU_BASE      __                  RESU_GENE
   
   Proposition : 
   Les commandes NUME_DDL_GENE, PROJ_MATR_BASE et PROJ_VECT_BASE sont regroupees dans une 
   macro-commande PROJ_BASE dans ce cas-test pour valider les 4 premiers defauts de 
   couverture. J'ajoute le mot-cle NUME_DDL_GENE dans sdld102a pour le premier defaut de couverture, les autres 
   defauts sont deja couverts par ce cas-test.
   
   Le 5e defaut ne peut pas etre resolu dans l'immediat, car il necessite 
   d'elargir le champ d'utilisation de PROJ_BASE et PROJ_RESU_BASE. Une fiche dediee 
   (18536) est emise. En attendant,je supprime du catalogue de PRB et PB l'option RESU_GENE.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.63.11
VALIDATION
    sdld102a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 018576 DU 2012-03-19 13:18:18
TYPE anomalie concernant Code_Aster (VERSION 11.3)
TITRE
    Couverture de Code : PROJ_SPEC_BASE / TYPE_FLUI_STRU
FONCTIONNALITE
   PROBLEME :
   ----------
   Suite à la restitution de la fiche 13439 en version 11.1.13, une nouvelle option pour 
   définir un inter-spectre d’excitation basé sur des fonctions analytiques 
   a été introduite.
   Le test de couverture indique alors le défaut suivant : 
   PROJ_SPEC_BASE      __                  TYPE_FLUI_STRU
   Après analyse, il s'agit de supprimer cette option qui ne semble plus utilisée.
   
   DIAGNOSTIC :
   ------------
   En fait, le mot-cle TYPE_FLUI_STRU n'est pas utilise dans l'operateur, on peut donc le 
   supprimer dans le catalogue.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.63.14
VALIDATION
    sdll110, sdll115, sdll116, sdll117, sdll148, sdll501, , sdll502, sdll503, sdll504, sdll505, sdll506, sdll507, sdll508, sdls105, sdls107
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 016866 DU 2011-05-02 15:45:02
TYPE evolution concernant Documentation (VERSION )
TITRE
    MN14 Documentation U2 pour la corrélation calcul-essai
FONCTIONNALITE
   Une nouvelle documentation a ete publiee decrivant les procedures de base pour la validation de modeles par 
   correlation calcul-essai : 
    - importation de donnees experimentales au format unv dans Aster,
    - projection de champs avec PROJ_CHAMP et OBSERVATION,
    - comparaison par critere de MAC et comparaison de FRF simulees/mesurees.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : U2.07.06
VALIDATION
    néant
NB_JOURS_TRAV  : 4.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 07/05/2012 - 16:12:11

--------------------------------------------------------------------------------
RESTITUTION FICHE 018712 DU 2012-04-13 18:07:21
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    plantage en CPU_LIMIT
FONCTIONNALITE
   Problème
   ========
   
   Il s'agit d'un calcul utilisant STAT_NON_LINE.
   On lui impose un temps limite inférieur au temps nécessaire pour la
   résolution.
   On s'attend à ce que le calcul soit interrompu en levant une exception,
   que le calcul se termine normalement ensuite, et que la base soit
   sauvegardée.
   Or le calcul s'arrête brutalement en segmentation fault.
   
   Correction
   ==========
   
   L'erreur se situe dans l'utilisation du mécanisme d'émulation des exceptions
   en C. Pour cela, on utilise les fonctions setjmp/longjmp.
   setjmp sauvegarde l'environnement du "code", pour lever une exception (et
   donc interrompre le cours normal de l'exécution), un appel à longjmp
   restaure l'environnement là où setjmp a été appelé.
   
   D'une manière similaire au "marques" dans Jeveux, on gère une pile
   "d'environnement" indexée par un niveau de profondeur.
   
   Le mécanisme est utilisé lors de l'appel à une commande et
   lors des appels à getvectjev, getcolljev, putvecjev, prepcompcham.
   Cependant, il y a un mélange dans le stockage de la commande courante et
   la mise à jour du niveau de profondeur (fonction unique qui fait les
   deux opérations en même temps). Cette fonction est appelé pour l'exécution
   des commandes (aster_oper/execop) mais pas pour les autres fonctions.
   
   Dans le cas qui pose problème :
   
   - On stocke l'environnement avant op0070.
   
   - On appelle getvectjev et donc on stocke l'environnement avant getvectjev.
     Comme on n'incrémente pas le niveau, on écrase l'environnement "avant op0070".
   
   - au cours d'op0070, on lève l'exception ArretCPUError et donc on appelle
     longjmp avec l'environnement "avant op0070".
     Celui-ci ayant été écrasé, on est en fait "rebranché" dans la tâche de
     nettoyage de getvectjev et non là on devrait l'être : segfault.
   
   
   
   Pour que le problème apparaisse, il faut :
   
   - interrompre une commande (fortran) en levant une exception (erreur 'S'
     ou exception particularisée : ArretCPUError, NonConvergenceError...)
   
   - qu'au cours de cette commande, il y ait un appel à une des fonctions :
     getvectjev, getcolljev, putvecjev, prepcompcham qui sont toutes 4 des
     fonctions Python du module aster.
     Hors interrogation du catalogue, il ne doit y avoir que l'évaluation des
     formules qui retourne dans l'espace Python.
     Pour que l'évaluation d'une formule utilise une de ces fonctions, il faut
     qu'elle soit très compliquée ou bien que son expression demande d'évaluer
     une fonction ou une nappe (car on fera lors un getvectjev pour récupérer
     ses valeurs).
   
   Le problème existe depuis l'introduction de getvectjev en 7.0.7.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssnp142b en cpu limit
NB_JOURS_TRAV  : 1.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 018788 DU 2012-04-26 14:58:45
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    Concept nommé PSD_****
FONCTIONNALITE
   Problème
   ========
   
   PSD_ = LIRE_MAILLAGE() conduit à :
   
   DEBUT CR validation : fort.1
    . Etape : LIRE_MAILLAGE . .ligne : 2 . .fichier : 'fort.1'
    . . .!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    . . .! Pas de nom pour le concept retourné !
    . . .!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    . Fin Etape : LIRE_MAILLAGE
   FIN CR validation :fort.1
   
   
   Correction
   ==========
   
   En fait, c'est 'SD_' qui est réservé par le superviseur (même si on pourrait
   sans doute s'en passer).
   
   On vérifie de manière un peu plus fine le nom fourni et on affiche un message
   plus clair en cas d'incohérence :
   
   DEBUT CR validation : fort.1
    . Etape : DEFI_CONSTANTE . .ligne : 3 . .fichier : 'fort.1'
    . . .!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    . . .! Nom de concept invalide ('SD_' est réservé) !
    . . .!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    . Fin Etape : DEFI_CONSTANTE
   FIN CR validation :fort.1
   
   'SD_', 'SD_0', 'SD_456'... sont invalides.
   'PSD_', 'SD_a', 'SD_1b' sont valides.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    élémentaire
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 018821 DU 2012-05-04 12:48:17
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    Option dbgjeveux non supportée
FONCTIONNALITE
   L'option '-dbgjeveux' n'est plus supporté dans l'ancien format (simple tiret).
   Il était obligatoire de l'appeler avec '--dbgjeveux' (double tirets).
   
   On ajoute cette option dans la fonction de rétro-comptatibilité pour qu'il soit encore
   possible de la renseigner avec un simple tiret.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    option
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 018822 DU 2012-05-04 13:15:00
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    NEW11.1.20: supv001d en erreur sur Rocks et Calibre5
FONCTIONNALITE
   Problème
   --------
   
   Le test supv001d échoue sur Rocks et Calibre 5.
   
   
   Correction
   ----------
   
   Dans gcdetc, on récupère l'adresse du vecteur &&SYS.KRESU et avant d'utiliser 
   ce vecteur, il y a un appel à gcuopr.
   Or gcuopr (via gcugen) peut modifier cette adresse en redimensionnement le 
   vecteur.
   C'est ce qui explique que l'erreur se produisait lors d'un redimensionnement.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    supv001d
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR delmas       DELMAS Josselin        DATE 07/05/2012 - 12:50:22

--------------------------------------------------------------------------------
RESTITUTION FICHE 018786 DU 2012-04-26 09:09:34
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TMA : Phimeca
TITRE
    Petite coquille dans les cas-tests sslv111f et g
FONCTIONNALITE
   Problème :
   ========
   Une petite coquille s'est glisée dans les cas-tests sslv111f et g. 
   La contrainte SIXY testée ne l'est pas au bon noeud.
   
   Correction :
   ==========
   Pour le cas-test sslv111f la contrainte est testée au noeud 317 au lieu de 1.
   Pour le cas-test sslv111g la contrainte est testée au noeud 317 au lieu de 137.
   
   Impacts :
   =======
   TESTS:
   sslv111f.comm
   sslv111g.comm
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : v3.04.111
VALIDATION
    passage des tests
--------------------------------------------------------------------------------
RESTITUTION FICHE 018729 DU 2012-04-16 12:14:30
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    En NEW11.01.17, le cas-test zzzz264b s'arrete anormalement sur Calibre5.
FONCTIONNALITE
   Problème :
   ========
   En NEW11.01.17, le cas-test zzzz264b s'arrête anormalement sur Calibre5.
   
   Correction :
   ==========
   Le test passe en 11.1.18 sur claut682 en le lançant à la main en debug et nodebug.
   De plus, une exécution avec Valgrind ne montre rien.
   
   On ferme la fiche sans rien faire.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    passage du test
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 018717 DU 2012-04-16 06:23:57
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    En NEW11.01.17, le cas-test comp011b s'arrete anormalement sur Calibre 5.
FONCTIONNALITE
   Problème :
   ========
   En NEW11.01.17, le cas-test comp011b s'arrete anormalement sur Calibre 5. 
   
   Correction :
   ==========
   Le test passe en 11.1.18 sur claut682 en le lançant à la main en debug et nodebug.
   De plus, une exécution avec Valgrind ne montre rien.
   
   On ferme la fiche sans rien faire.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    passage du test
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 018700 DU 2012-04-13 07:22:42
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    ssnp504 c plante sur aster4 en version couverture de code
FONCTIONNALITE
   Problème :
   ========
   ssnp504c plante sur aster4 en version couverture de code :
   Arrêt pour cause d'absence de convergence avec le nombre d'itérations requis.
   
   Correction :
   ==========
   Ce test ne plante plus en version couverture de code (11.1.19).
   
   Une exécution avec Valgrind montre effectivement une lecture invalide mais elle semble se
   produire dans MUMPS, on ne peut donc rien faire.
   
   ==25318== Invalid read of size 8
   ==25318==    at 0x635D979: __intel_new_memcpy (in
   /logiciels/intel/Compiler/11.1/046/lib/intel64/libintlc.so.5)
   ==25318==    by 0x2402552: dmumps_26_ (in /logiciels/aster/v11/NEW11/asterd)
   ==25318==    by 0x23677E3: dmumps_ (in /logiciels/aster/v11/NEW11/asterd)
   ==25318==    by 0x69D00D: amumpd_ (amumpd.F:204)
   ==25318==    by 0x5EEE55: amumph_ (amumph.F:362)
   ==25318==    by 0x71EF1D: tldlg3_ (tldlg3.f:208)
   ==25318==    by 0x70F407: preres_ (preres.f:223)
   ==25318==    by 0x19588B8: nmcoma_ (nmcoma.f:294)
   ==25318==    by 0x11611FB: nmdesc_ (nmdesc.f:140)
   ==25318==    by 0xEC2F81: nmnewt_ (nmnewt.f:273)
   ==25318==    by 0x7BC6C8: op0070_ (op0070.f:200)
   ==25318==    by 0x60A8A4: ex0000_ (ex0000.f:257)
   ==25318==  Address 0xecde5b8 is 0 bytes after a block of size 1,096 alloc'd
   ==25318==    at 0x4CBDCC6: memalign (vg_replace_malloc.c:694)
   ==25318==    by 0x4CBDD22: posix_memalign (vg_replace_malloc.c:835)
   ==25318==    by 0x5D7E37B: for__spec_align_alloc (in
   /logiciels/intel/Compiler/11.1/046/lib/intel64/libifcoremt.so.5)
   ==25318==    by 0x5D7E21F: for_allocate (in
   /logiciels/intel/Compiler/11.1/046/lib/intel64/libifcoremt.so.5)
   ==25318==    by 0x27AED96: mumps_754_ (in /logiciels/aster/v11/NEW11/asterd)
   ==25318==    by 0x23FA644: dmumps_26_ (in /logiciels/aster/v11/NEW11/asterd)
   ==25318==    by 0x23677E3: dmumps_ (in /logiciels/aster/v11/NEW11/asterd)
   ==25318==    by 0x69D00D: amumpd_ (amumpd.F:204)
   ==25318==    by 0x5EEE55: amumph_ (amumph.F:362)
   ==25318==    by 0x71EF1D: tldlg3_ (tldlg3.f:208)
   ==25318==    by 0x70F407: preres_ (preres.f:223)
   ==25318==    by 0x19588B8: nmcoma_ (nmcoma.f:294)
   
   On ferme la fiche sans rien faire.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    passage du test
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 018283 DU 2012-01-24 15:27:19
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    ssnp130 a sensible au format de son maillage
FONCTIONNALITE
   Problème :
   ========
   Le test ssnp130a devient NOOK (faiblement) lorsqu'on convertit son maillage au format MED.
   
   Correction :
   ==========
   Le NOOK provient du calcul de l'option ERME_ELEM. Pour cette option, on calcule pour
   chaque maille et pour chacune des faces un voisin (et un seul).
   
   Or dans le maillage il y a des mailles qui ont deux voisins : ce sont des mailles bordées
   à la fois par une maille de bord (noyée au milieux d'éléments volumiques) et une maille
   volumique.
   
   Et comme lors du passage au format MED, l'ordre de déclaration des types de mailles n'est
   plus le même ; on ne trouve pas toujours le même voisin (car on s'arrête de chercher dès
   qu'on a trouvé un voisin).
   
   Il peut être fréquent de rencontrer ce genre de situation mais le calcul de l'estimateur
   d'erreur n'est pas prévu pour gérer plusieurs voisins.
   On compte le nombre de voisin et dès qu'il est supérieur à 1, on s'arrête avec une erreur
   fatale et un message du type :
      !------------------------------------------------------------------------------!
      ! <F> <INDICATEUR_12> . . . . . . . . . . . . . . . . . . . . . . . . . . . .  !
      ! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  !
      !  La face numéro 1 de la maille M2 possède 2 voisins. . . . . . . . . . . . . !
      !  Or, ceci n'est pas prévu : un seul voisin par face est autorisé. . . . . . .!
      !  Cela signifie que la maillage comporte des mailles doubles ou qu'une maille !
      !  de bord est intercalée entre deux mailles volumiques. . . . . . . . . . .   !
      ! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  !
      !  Conseils : . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  !
      ! . .Vérifiez votre maillage. . . . . . . . . . . . . . . . . . . . . . . . .  !
      ! . .Il se peut que ces mailles doubles ou intercalées ne soient pas . . . . . !
      ! . .nécessaire au calcul. Dans ce cas ne les affectez pas avec le modèle ! . .!
      ! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  !
      ! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  !
      ! Cette erreur est fatale. Le code s'arrête. . . . . . . . . . . . . . . . .   !
      !------------------------------------------------------------------------------!
   
   La gestion de plusieurs voisins sera programmée lorsqu'il y aura un vrai besoin.
   
   Cette correction oblige à modifier des tests pour lesquels on faisait TOUT='OUI' dans
   AFFE_MODELE. On n'affecte que les mailles nécessaires au calcul.
   
   Au passage, on restitue le maillage MED pour ssnp130a.
   
   Impacts :
   =======
   F:
   resvoi.f
   
   PY:
   indicateur.py
   
   TESTS:
   ssls09b.comm  ssls09c.comm  ssnp123a.comm  ssnp123b.comm  ssnp130a.comm  ssnp130a.mmed
   ssnp130d.comm
   
   UNIGEST:
   ssnp130a.mail
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    passage des tests ERME_ELEM et ERTH_ELEM
NB_JOURS_TRAV  : 3.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 018282 DU 2012-01-24 15:25:50
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    sslv134 d sensible au format de son maillage
FONCTIONNALITE
   Problème :
   ========
   Le test sslv134d devient NOOK (faiblement) lorsqu'on convertit son maillage au format MED.
   
   Correction :
   ==========
   Le NOOK provient du calcul de l'option ERME_ELEM. Pour cette option, on calcule pour
   chaque maille et pour chacune des faces un voisin (et un seul).
   
   Or dans le maillage il y a des mailles qui ont deux voisins : ce sont des mailles bordées
   à la fois par une maille de bord (noyée au milieux d'éléments volumiques) et une maille
   volumique.
   
   Et comme lors du passage au format MED, l'ordre de déclaration des types de mailles n'est
   plus le même ; on ne trouve pas toujours le même voisin (car on s'arrête de chercher dès
   qu'on a trouvé un voisin).
   
   Il peut être fréquent de rencontrer ce genre de situation mais le calcul de l'estimateur
   d'erreur n'est pas prévu pour gérer plusieurs voisins.
   On compte le nombre de voisin et dès qu'il est supérieur à 1, on s'arrête avec une erreur
   fatale et un message du type :
      !------------------------------------------------------------------------------!
      ! <F> <INDICATEUR_12> . . . . . . . . . . . . . . . . . . . . . . . . . . . .  !
      ! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  !
      !  La face numéro 1 de la maille M2 possède 2 voisins. . . . . . . . . . . . . !
      !  Or, ceci n'est pas prévu : un seul voisin par face est autorisé. . . . . . .!
      !  Cela signifie que la maillage comporte des mailles doubles ou qu'une maille !
      !  de bord est intercalée entre deux mailles volumiques. . . . . . . . . . .   !
      ! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  !
      !  Conseils : . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  !
      ! . .Vérifiez votre maillage. . . . . . . . . . . . . . . . . . . . . . . . .  !
      ! . .Il se peut que ces mailles doubles ou intercalées ne soient pas . . . . . !
      ! . .nécessaire au calcul. Dans ce cas ne les affectez pas avec le modèle ! . .!
      ! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  !
      ! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  !
      ! Cette erreur est fatale. Le code s'arrête. . . . . . . . . . . . . . . . .   !
      !------------------------------------------------------------------------------!
   
   La gestion de plusieurs voisins sera programmée lorsqu'il y aura un vrai besoin.
   
   Cette correction oblige à modifier des tests pour lesquels on faisait TOUT='OUI' dans
   AFFE_MODELE. On n'affecte que les mailles nécessaires au calcul.
   
   Au passage, on restitue le maillage MED pour sslv134d.
   
   Impacts :
   =======
   F:
   resvoi.f
   
   PY:
   indicateur.py
   
   TESTS:
   sslv07a.comm  sslv07d.comm  sslv134d.comm
   
   UNIGEST:
   sslv134d.mail
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    passage des tests ERME_ELEM et ERTH_ELEM
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 018279 DU 2012-01-24 14:26:05
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    ssnv510c et ssnv510f très sensible au maillage
FONCTIONNALITE
   Problème :
   ========
   Lorsqu'on convertit le maillage de ces tests du format Aster au format MED, les tests
   plantent avec une matrice non factorisable.
   
   Correction :
   ==========
   En 11.1.19, les tests fonctionnent correctement avec les maillages convertis au format MED. 
   
   Lors de la conversion, l'ordre de déclaration des types d'élément peut ne pas être le même
   qu'au format Aster. C'est ce qui a pu poser problème à l'époque de l'émission de la fiche.
   
   On en profite pour restituer les maillages MED associés aux tests.
   
   Impacts :
   =======
   TESTS:
   ssnv510c.comm ssnv510c.mmed 
   ssnv510f.comm ssnv510f.mmed 
   
   UNIGEST:
   ssnv510c.mail ssnv510f.mail
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    passage des tests
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 018200 DU 2012-01-12 08:40:15
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    En NEW11.1.4, le cas-test perf009f s’arrete en erreur fatale sur Aster4_mpi
FONCTIONNALITE
   Problème :
   ========
   En NEW11.1.4, le cas-test perf009f s’arrête en erreur fatale sur Aster4_mpi.
   
   Correction :
   ==========
   Le test passe en 11.1.19.
   
   On ferme la fiche sans rien faire.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    passage du test
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 018080 DU 2011-12-14 08:44:25
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    Modification de sensm15b et couverture de code
FONCTIONNALITE
   Problème :
   ========
   La modification de sensm15b a produit la "découverture" des routines bptkb, coqsep, dbtdfn,
   dbtdms, dhfmss, dhsjf, dhsjm, djacbm, dmahsf, dmahsm, dvect.
   
   Correction :
   ==========
   Il est normal que sensm15b ne valide plus les routines mentionnées car la validation du
   calcul des dérivées par rapport à l'épaisseur pour les COQUE_3D (voir fiche issue17431) a
   été supprimée.
   
   Il est acté de supprimer la sensibilité (fiche issue18770), on ne fait donc rien pour
   cette fiche. Il faudra détruire ces routines.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    néant
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 018062 DU 2011-12-13 08:18:40
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    ssnv214 a defaut de convergence en couverture de code
FONCTIONNALITE
   Problème :
   ========
   ssnv214a stoppe en défaut de convergence en couverture de code sur aster4.
   
   Correction :
   ==========
   Le test passe en 11.1.19 sur les plateformes de qulaification.
   De plus une exécution avec Valgrind ne montre rien.
   
   On ferme la fiche sans rien faire.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    néant
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 017809 DU 2011-10-27 09:49:02
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    Problème de LIAISON_GROUP
FONCTIONNALITE
   Problème :
   ========
   Un calcul THM s'arrête en ERREUR_F avec MUMPS et pas avec MULT_FRONT. C'est bloquant pour
   une étude de dimensionnement géomécanique qui doit utiliser MUMPS (pivotage).
   
   Correction :
   ==========
   L'arrêt est dû au fait que MUMPS détecte une singularité numérique de la matrice traitée.
   En fait, celle-ci n'est pas méchante, car en modifiant légèrement le paramètre de
   détection de singularité (NPREC de 8 à 9) ou en le débranchant (NPREC<0) le calcul va
   jusqu'au bout. Tout va bien : IL N'Y A DONC RIEN DE BLOQUANT.
   
   En testant la matrice en stand-alone avec MUMPS on trouve:
   ______avec NPREC=8: 2 pivots presque nuls suivant le critère MUMPS
   ______avec NPREC=9: 0 pivots presque nul.
   
   Le léger écart fonctionnel entre MUMPS et MF est notamment du aux différences de critères
   de détection de singularité (expliquées ds la doc U2 notice sur les solveurs linéaires).
   Il n'a rien d'inquiétant. 
   
   Remarque : Il y a fort à parier que MF détecte la singularité à partir de NPREC=6 ou 7.
   
   Question subsidaire 1 : La vrai question est pourquoi ce maillage produit une matrice de
   travail MUMPS qui commence a être numériquement singulière. Mais nous n'avons pas le temps
   de l'instruire.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    néant
NB_JOURS_TRAV  : 3.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desroche     DESROCHES Xavier       DATE 05/07/2012 - 03:27:05

--------------------------------------------------------------------------------
RESTITUTION FICHE 018780 DU 2012-04-25 16:08:17
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    coquille dans RVCHL3
FONCTIONNALITE
   Bug dans POST_RELEVE_T dont la correction rend un cas-test NOOK
   
   J'ai repris le problème de Christophe, le cas-test NOOK analysé par Jacques et la 
   routine incriminée RVCHL3.
   
   A l'issue de cette analyse on peut dire :
   
   - la correction proposée par Christophe corrige effectivement son problème, qui était 
   du au fait qu'une variable nommée DEC1 valait 0 au lieu de 2 (protégé par un U2MESS).
   Comme il l'explique plus bas c'est du au fait que l'instruction M=MA(1) est hors de la 
   boucle au lieu d'être dedans. Or DEC1 dépend de M et M était dans certains cas mal 
   initialisé. On corrige donc un vrai bug en déplaçant l'instruction.
   
   - néanmoins la protection par U2MESS ne suffit pas (c'est bien dommage) car on peut 
   avoir des valeurs fausses de DEC1 qui passent le test. C'est ce qui se produit dans le 
   test zzzz136a où la variable DEC1 vaut 3 (dans un cas) sans correction au lieu de 2 
   avec correction. Or cette variable est un pointeur qui sert à calculer le champ de 
   sortie, d'où les NOOK. Attention, cette valeur fausse est loin d'être systématique,
   dans le test il y a 8 NOOK sur plusieurs centaines de tests qui passent dans RVCHL3.
   
   - point important : ces NOOK n'en sont pas, car les soi-disant références AUTRE_ASTER 
   ne sont autres que des NON_REGRESSION déguisées. En effet le cas-test n'est pas 
   physique et il n'y a pas de solution analytique ou autre. On se contente de valider 
   informatiquement POST_RELEVE et on a simplement recopier la colonne résultat dans la 
   colonne référence (comme on fait pour les NON_REGRESSION ).
   
   En conclusion, on peut dire :
   
   1. on a un vrai bug qu'il faut corriger dans RVCHL3
   2. il faut changer les TEST_TABLE NOOK dans zzzz136a et mettre tous les tests en 
   NON_REGRESSION 
   3. il y a (avait) des résultats faux possibles dans POST_RELEVE dans le cas suivant :
   extraction en 3D sur un chemin défini par INTE_MAIL_3D sur les points (intersections 
   entre le chemin et le maillage) qui appartiennent à plus de 2 éléments strictement, 
   soit les points situés sur des arêtes (pas forcément si on est au bord), ou sur des 
   sommets (même restriction). Pour un chemin quelconque, qui coupe les mailles 3D à 
   l'intérieur des faces, il n'y a pas de résultats faux.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 3.1
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 3.1
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    liste complète
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 017548 DU 2011-09-16 15:47:57
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TMA : Phimeca
TITRE
    Chemin nom reconnu dans INTE_MAIL_3D
FONCTIONNALITE
   Problème
   ---------
   
   L'utilisateur souhaite relever des valeurs avec POST_RELEVE_T. Pour cela, il définit un
   chemin avec INTE_MAIL_3D. 
   Cependant, le calcul se termine en erreur fatale dans l'INTE_MAIL_3D : 
   
    !----------------------------------------------------------------!
      ! <A> <INTEMAIL_28>                                              !
      !                                                                !
      !  l'intersection segment 1 avec le maillage MA_THER est vide    !
      !     origine   : 1.807178 0.842701 -3.519000                    !
      !     extrémité : 1.813975 0.845870 -3.519000                    !
      !                                                                !
      !                                                                !
      ! Ceci est une alarme. Si vous ne comprenez pas le sens de cette !
      ! alarme, vous pouvez obtenir des rÃ©sultats inattendus !         !
      !----------------------------------------------------------------!
      
      
      !-------------------------------------!
      ! <EXCEPTION> <INTEMAIL_11>           !
      !                                     !
      !  aucun segment ne coupe le maillage !
      !-------------------------------------!
   
   L'utilisateur a constaté qu'en augmentant la valeur PRECISION à 10^-5 (10^-6 par 
   défaut),
   le problème ne se présente plus. 
   
   Correction
   ----------
   Vue la complexité de l'algorithmie d'INTE_MAIL_3D, on se contente du jeu sur 
   la précision. En outre, l'utilisation de MACR_LIGN_COUPE est à privilégier.
   
   
   
   Réalisation
   -----------
   La documentation semble susceptible d'amener à des ambiguités pour certains
   utilisateurs en ce qui concerne le mot-clé PRECISION. Un complément d'explication est
   ajouté dans la documentation U4.81.12.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.81.12
VALIDATION
    sans
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR fernandes    FERNANDES Roméo       DATE 05/07/2012 - 01:23:09

--------------------------------------------------------------------------------
RESTITUTION FICHE 018223 DU 2012-01-16 08:54:18
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    Catalogue materieu de Mac3coeur
FONCTIONNALITE
   Dans la macro-commande CALC_MAC3COEUR pour le calcul des déformations d'assemblages
   combustibles, des caractéristiques matériau d'assemblages sont pré-définies, en
   particulier pour le grandissement des crayons et tubes-guides.
   
   Pour améliorer les performances numériques des simulations on ajoute dans ces catalogues
   matériau des CALC_FONC_INTERP pour interpoler les FORMULEs qui aujourd'hui sont données
   directement dans DEFI_MATERIAU mais qui au final coûtent très cher dans le calcul.
   
   A titre d'exemple sur coeur N4:
   Version initiale (avec FORMULE) : coût d'une iteration de Newton 17s
   Version modifiée (avec CALC_FONC_INTERP) : coût d'une itération de Newton 8.5s
   
   Impact dans Code_Aster:
   * Catalogue materiau : AF3G_CR_REF_A.NOMI, AF3G_TG_REF_A.NOMI, 
                          AFA_CR_REF_A.NOMI, AFA_TG_REF_A.NOMI
   * Cas-test : Mise à jour des fichiers mac*.para:
                mac3c01a (125s -> 100s)
                mac3c02a ( 14s ->  60s) : augmentation du CPU dans ce cas à   
                                          cause du coût de CALC_FONC_INTERP.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    mac3c0*a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR granet       GRANET Sylvie          DATE 05/07/2012 - 01:03:28

--------------------------------------------------------------------------------
RESTITUTION FICHE 018659 DU 2012-04-04 11:10:33
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    Défaut de couverture de REGUP1
FONCTIONNALITE
   La fonction regup1 sert à prolonger une courbe en un point par un polynôme de degré 1. En
   THM, elle n'est appelée que dans des cas extrêmes où l'on a des saturations proches de 0
   et où les perméabilités de Van-Genuchten peuvent devenir singulières, cette régularisation
   est alors effectuée.
   On rajoute une modélisation (e) au cas test wtnp119 afin de couvrir ce cas en partant
   d'une saturation inférieure à 0,01.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V7.32.119
VALIDATION
    Passage de wtnp119e
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 018766 DU 2012-04-23 15:32:01
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    u2.04.06 contient beaucoup trop de syntaxe Aster
FONCTIONNALITE
   La doc U2.04.06 détaille les méthodologies possibles pour simuler une excavation. La doc
   actuelle comprend en annexe 3 fichiers de commande Aster correspondant aux 3 méthodologies
   possible. 
   
   1 méthodologie (la 3eme dans la doc.) est portée actuellement par le test sslp105a. Je
   crée donc les tests sslp105b et sllp105c correspondant aux 2 autres méthodologies. A
   partir de là on peut supprimer toutes les lignes de commande de la doc et les remplacer
   par des références aux cas tests. Cela répond à l'objet de cette fiche.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : U2.04.06 V3.02.105
VALIDATION
    Passage cas test sslp105
NB_JOURS_TRAV  : 1.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 018796 DU 2012-04-27 16:34:46
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    Régularisation Van Genuchten
FONCTIONNALITE
   Dans le cadre des modèles diphasiques avec Van Genuchten, on régularise par précaution les
   perméabilités pour les cas extrêmes (S prés de 0 ou de 1). Je trouve une erreur qui rend
   cette barrière trop peu sévère, je corrige cette erreur.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    Passage des cas tests THM
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR greffet      GREFFET Nicolas        DATE 07/05/2012 - 18:37:09

--------------------------------------------------------------------------------
RESTITUTION FICHE 018745 DU 2012-04-19 09:23:51
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    En NEW11.01.18, le cas-test miss03b s'arrete en erreur fatale sur Rocks, Calibre5 et Calibre7.
FONCTIONNALITE
   Probl?me :
   suite ? la restitution de la fiche issue18249 , 
   le cas-test miss03b plante sur certaines plate-formes (autres qu'aster4).
   
   
   Analyse :
   c'est en fait un probl?me de noms trop longs pass?s ? MISS3D sur certaines machines.
   On utilise des chemins absolus (on croyait bien faire) pour les fichiers de travail, or,
   par exemple sur Calibre 7 ce chemin ne commence pas par :
   /tmp/...
   mais par :
   /local00/tmp/
   Et comme ensuite on a le repertoire provisoire aster, puis le sous-repertoire miss, 
   au final ?a faisait une ligne de commande trop longue pour MISS3D (code en F77).
   En python, ces chemins longs ne posent pas de probl?me.
   Sur aster4, les chemins ?taient un peu plus courts et ?a passait tr?s bien.
   Pas de r?sultat faux car ?a plante et ?a ne concernait que les nouveaux fichiers li?s ?
   l'ISS NL (option FICHIER_TEMPS).
   
   
   Solution :
   pour les fichiers utilis?s par python on garde les chemins absolus, 
   en revanche pour les donn?es pass?es en argument ? MISS3D on reste en chemin relatif,
   toujours.
   
   
   Validation : tous les tests appelant MISS3D.
   
   Pas d'impact doc.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    miss03b
NB_JOURS_TRAV  : 3.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 018810 DU 2012-05-03 10:11:23
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    En NEW11.01.20, le cas-test sdnv100j s'arrete en erreur fatale sur Aster4, Rocks, Calibre5 et Calibre7.
FONCTIONNALITE
   Contexte :
   suite ? la fiche issue18789 l'utilisation de MASS_DIAG='OUI' a ?t? interdite avec un
   sch?ma implicite dans DNL.
   La macro MACRO_BASCULE_SCHEMA laissait tra?ner (? tort) cette option pour les intervalles
   de temps en implicite.
   
   
   Analyse :
   pas de r?sultat faux car en pratique en implicite on utilisait la matrice de masse
   consistante : c'est juste que l'utilisateur croyait ? tort utiliser la masse lump?e car il
   voyait MASS_DIAG='OUI'.
   
   
   Correction :
   quand on a un sch?ma implicite, on reste en masse consistante.
   Je corrige aussi un deuxi?me bug sur la lecture du sch?ma utilis? pour la phase de
   r??quilibrage : en fait on reprenait le sch?ma de l'intervalle implicite et donc le choix
   de l'utilisateur n'?tait pas forc?ment respect?.
   
   Validation :
   cas-test sdnv100j dont les r?sultats sont inchang?s (en mettant le m?me sch?ma pour le
   r??quilibrage)
   
   Pas d'impact doc.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sdnv100j
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 018763 DU 2012-04-23 11:24:24
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    D?faut de couverture de CALC_MISS
FONCTIONNALITE
   Contexte :
   Suite ? la restitution des possiblit? d'ISS non-lin?aire dans CALC_MISS (dont fiche
   issue18249 ) on a pr?vu un mode de fonctionnement (calcul des forces sismiques) qui
   n'?tait pas valid? par un cas-test. En effet miss03b qui utilise CALC_MISS en non-lin?aire
   ne se sert que de l'imp?dance.
   Le cas-test miss03c existant manipule les forces simiques, mais en travaillant ? partir de
   fichiers existants et donc les options de calculs de ces forces ne sont pas appel?s lors
   de l'ex?cution.
   
   
   Solution :
   on va modifier miss03c pour r?ellement utiliser CALC_MISS pour recalculer ces forces et
   donc ne plus utiliser les donn?es de fichiers pr?existants.
   En pratique, on a d? changer de m?thode de calcul de ce second membre (passer de
   l'approche par Laplace ? une m?thode fr?quentielle plus classique) pour des raisons de
   robustesse.
   Le calcul de l'imp?dance en non-lin?aire, reste, lui, fait dans le domaine de Laplace car
   dans ce cas cela marche tr?s bien.
   Il sera toujours possible de faire une ?volution ult?rieure pour repasser compl?tement en
   domaine de Laplace si besoin est.
   Au niveau des sources on couple cette fiche ? la fiche issue18745 car on intervient sur
   plusieurs routines communes.
   
   On corrige aussi divers petit bugs (affichage des fr?quences complexes, coh?rence avec un
   cas particulier de calcul ISS lin?aire avec MACRO_MISS_3D pour le fichier de donn?e MISS3D).
   Le nombre de jours de travail comprend la contribution majeure d'Alex Nieto Ferro.
   
   
   Impact :
   calc_miss.capy (on retire des UL par d?faut qui n'avaient pas lieu d'?tre)
   miss0.py ((une nouvelle alarme en cas d'imp?dance non d?finie positive)
   miss_calcul.py
   miss_fichier_interf.py
   miss_fichier_sol.py
   miss_post.py
   miss_utils.py
   miss03c.comm (le temps CPU augmente notablement car au lieu de lire des donn?es de forces
   sismiques on les calcule compl?tement)
   
   
   Validation :
   miss03c (plus passage de tous les tests appelant MISS3D)
   
   
   Impact doc : V1.10.122, U7.03.12, U2.06.07
   
   
   
   Perspectives :
   certaines combinaisons de mot-cl?s de CALC_MISS resteront encore ? valider, mais ce sera
   fait ult?rieurement par de nouveaux cas-tests.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V1.10.122, U7.03.12, U2.06.07
VALIDATION
    miss03c
NB_JOURS_TRAV  : 10.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 018506 DU 2012-03-06 08:57:29
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    Critere d'instabilite en parall?le
FONCTIONNALITE
   Probl?me :
   dans NMFLIN on met en dur LDIST = .FALSE. pour l'appel ? ECHMAT qui a besoin de cet argument.
   Donc si on est en parall?le, on va modifier la valeur de LDIST et ?a ne devrait pas marcher.
   En s?quentiel pas de probl?me car cette variable est bien ? FALSE.
   
   
   Solution :
   pour la stabilisation, on va jouer la s?curit? en interdisant CRIT_STAB en parall?le car
   ce n'est pas valid?.
   On rajoute un beau message pour expliquer le probl?me ? l'utilisateur :
   MECANONLINE06_13 :
   <Erreur> On ne peut pas utiliser CRIT_STAB en calcul parall?le
   
   Impact :
   NMFLINT
   
   
   Par la suite on pourra ?mettre une fiche d'?volution pour tester CRIT_STAB en parall?le.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    cas-tests personnels
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR geniaut      GENIAUT Samuel         DATE 05/07/2012 - 03:57:49

--------------------------------------------------------------------------------
RESTITUTION FICHE 018774 DU 2012-04-24 13:40:29
TYPE anomalie concernant Code_Aster (VERSION 11.2)
TMA : Phimeca
TITRE
    DEFI_FOND_FISS : problème avec les lèvre collées
FONCTIONNALITE
   Problème:
   ---------
   En présence d'un maillage de 1/2 CT, lorsque le défaut est une fissure, placée sur le plan
   de symétrie, la commande DEFI_FOND_FISS aboutit à l'erreur suivante :
      !----------------------------------------------------!
      ! <EXCEPTION> <RUPTURE0_34>                          !
      !                                                    !
      ! L'hypothèse de lèvres collées n'est pas valide.    !
      ! Conseil : il faut utiliser CONFIG_INIT='DECOLLEE'. !
      ! Ou bien vérifier l'utilisation du mot-clé SYME.    !
      !----------------------------------------------------!
   
   Or, la lèvre est collée (tous les noeuds ont pour ordonnée 0, donc sont sur l'axe de
   symétrie).
   Le mot-clé SYME renseigné à 'OUI' ou 'NON', ne change rien.
   
   Analyse et solution:
   --------------------
   
   Il s'agit d'un bug de DEFI_FOND_FISS dans le cas 2D où
   il n'y a que 2 mailles connectées au fond de fissure.
   
   La routine fonno4 qui recherchait les bords libres ne prend pas en compte la dimension du
   maillage. 0n ajoute en argument de cette routine cette dimension.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    tests defi fond fiss
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR delmas       DELMAS Josselin        DATE 05/07/2012 - 03:57:50

--------------------------------------------------------------------------------
RESTITUTION FICHE 018786 DU 2012-04-26 09:09:34
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TMA : Phimeca
TITRE
    Petite coquille dans les cas-tests sslv111f et g
FONCTIONNALITE
   Problème :
   ========
   Une petite coquille s'est glisée dans les cas-tests sslv111f et g. 
   La contrainte SIXY testée ne l'est pas au bon noeud.
   
   Correction :
   ==========
   Pour le cas-test sslv111f la contrainte est testée au noeud 317 au lieu de 1.
   Pour le cas-test sslv111g la contrainte est testée au noeud 317 au lieu de 137.
   
   Impacts :
   =======
   TESTS:
   sslv111f.comm
   sslv111g.comm
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : v3.04.111
VALIDATION
    passage des tests
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR proix        PROIX Jean-Michel      DATE 05/07/2012 - 03:03:56

--------------------------------------------------------------------------------
RESTITUTION FICHE 018805 DU 2012-05-02 11:36:32
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    [FORUM] GDEF_LOG mal protégé
FONCTIONNALITE
   Probleme :
   ============
   La routine deflog.f n'est pas protégée contre des élongations négatives ou nulles (voir l 80)
   
   Ce serait bien:
   - soit d'émettre une erreur spécifique (élongation nulle ou négative), qui provient
   probablement d'un retournement de maille 
   - soit de proposer un code retour à la loi de comportement de manière à permettre la
   découpe du pas de temps dans ce cas. C'est ce qu'on avait fait pour ELAS_HYPER et ça avait
   permis de s'en sortir dans certaines situations.
   http://www.code-aster.org/forum2/viewtopic.php?id=16764
   
   Correction :
   ============
   On ajoute dans DEFLOG le même test que dans POSLOG (similaire à celui de SIMO_MIEHE) :
   
   C     DETERMINANT DE LA MATRICE F A L INSTANT T+ 
         CALL NMDETF(NDIM,FR,DETF)
         IF (DETF.LE.1.D-2 .OR. DETF.GT.1.D2) THEN
           CODRET = 1
           GOTO 9999
         END IF
   
   et en plus (ceintures et bretelles) lors du calcul des déformations logarithmiques :
            IF (LAMB(I).LE.R8MIEM()) THEN
               IRET=1
               GOTO 9999
            ENDIF
   avant de calculer le log : 
            LOGL(I)=LOG(LAMB(I))*0.5D0
   
   L'étude s'arrête alors pour cause de matrice non inversible.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    etude jointe (partiellement)
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 018732 DU 2012-04-17 07:50:18
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    Bug avec message incompréhensible dans SNL
FONCTIONNALITE
   Probleme :
   =========
   
   Dans STAT_NON_LINE (version NEW11) on a mis le mot-clé ITER_INTE_PAS avec la ldc LETK en
   version explicite (ALGO_INTE='SPECIFIQUE') + appel à la matrice ELASTIQUE.
   
   Le calcul plante avec un message incompréhensible (voir fichier *.mess). Le calcul passe en
   supprimant le mot-clé ITER_INTE_PAS.
   
   Solution :
   ==========
   
   le problème vient effectivement du découpage local du pas de temps : dans REDECE, on ne
   subdivise pas le pas de temps si on est à la prédiction. Or ici l'option de prédiction est
   cette "fameuse" option 'RIGI_MECA_ELAS', alors que tous les tests dans le fortran portent
   sur 'RIGI_MECA_TANG'. Je les remplace donc par IF (OPTION(1:9).EQ.'RIGI_MECA') THEN...
   
   Je viens de tester la correction : le calcul en est à 1000s cpu, et tout va bien
   
   Instant de calcul:  9.765273600000e+05 - Niveau de découpe: 1
   
    
   ---------------------------------------------------------------------
   |     NEWTON     |     RESIDU     |     RESIDU     |     OPTION     |
   |    ITERATION   |     RELATIF    |     ABSOLU     |   ASSEMBLAGE   |
   |                | RESI_GLOB_RELA | RESI_GLOB_MAXI |                |
   ---------------------------------------------------------------------
   |     0        X | 5.49376E-05  X | 8.51195E+02    |SECANTE         |
   |     1        X | 8.60091E-06  X | 1.33261E+02    |                |
   |     2        X | 1.27066E-06  X | 1.96874E+01    |                |
   |     3          | 1.86059E-07    | 2.88277E+00    |                |
   ---------------------------------------------------------------------
   
   Seul source modifie : REDECE (ci-joint)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    etude jointe
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR debonnieres  DE BONNIERES Philippe   DATE 05/07/2012 - 03:03:57

--------------------------------------------------------------------------------
RESTITUTION FICHE 018528 DU 2012-03-09 12:20:45
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    plantage non explicite lors d'un calcul avec META_LEMA_ANI
FONCTIONNALITE
   A cause d'erreurs liees Ã  la precision machine, on tombait dans la 
   routine EDGEQU sur une valeur de la variable EQUI tres legerement 
   negative (de l'ordre de 1.E-47) dont on essayait de prendre la racine 
   carree.
   On ajoute donc un test sur la valeur de EQUI:
   si - R8PREM < EQUI < 0 , alors EQUI = 0
   si EQUI < - R8PREM , on emet un message d'erreur
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    perso (sur l'étude liée à la fiche)
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR bottoni      BOTTONI Marina         DATE 05/07/2012 - 03:03:58

--------------------------------------------------------------------------------
RESTITUTION FICHE 017165 DU 2011-06-21 08:56:10
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    plantage BETON_DOUBLE_DP
FONCTIONNALITE
   L'utilisateur avait une étude qui se terminaient, en STA10, avec une erreur numérique.
   Pendant la recherche de l'anomalie, un autre erreur numérique a été détectée par la
   SIMU_POINT_MAT.
   On avait donc deux situations qui se terminaient avec la même erreur :
   
   1) étude - petite structure
   2) test avec simu_point_mat
   
   Or, en regardent plus en détail, on avait en effet deux problèmes différents.
   
   Pour le cas 1) de l'étude :
   ============================ 
   
   La matrice SECANTE (utilisée par STAT_NON_LINE si le pas de calcul est inférieur à
   PAS_MINI_ELAS)  n'était pas
   implementée, et pas initialisée dans la loi (on avait donc des zéros machine).
   J'ai donc résolu cette anomalie en implementant les options RIGI_MECA_ELAS (phase de
   prédiction de Newton-Raphson) et
   FULL_MECA_ELAS (phase de correction) dans la loi de comportement. En effet, pour la loi en
   question (BETON_DOUBLE_DP),
   qui est plastique, la matrice SECANTE (=matrice de décharge) est tout simplement la
   matrice élastique. 
   
   A partir de l'étude fournie par l'utilisateur, j'ai vérifié que avec la routine corrigée,
   la convergence (à partir du
   dernier pas de temps convergé avant l'erreur) a lieu avec la même vitesse et même résidu
   qu'en utilisant une matrice
   ELASTIQUE dans la STAT_NON_LINE.  
   
   
   
   Pour le cas 2) de simu_point_mat :
   =====================================
   
   La loi de comportement stocke en V3 une valeur de température, qui est la température
   maximale au cours du calcul).
   Si la variable de commande TEMP n'est pas définie dans le fichier de commande (paramètres
   matériau non-dépendant de la
   température, mot-clé ELAS), cette variable interne V3 était posée égale à NaN, ce qui est
   géré par la loi de
   comportement pour la stat_non_line, mais pas par les commandes de post-traitement à
   l'intérieur de SIMU_POINT_MAT.
   
   Après discussion avec Jean-Michel, nous avons décidé de poser V3=-1000 (une valeur
   physiquement non admissible)  
   en absence de définition de la température. 
   J'ai testé le bon comportement dans les deux situations (variable interne V3 avec et sans
   prise en compte de la
   température) avec des cas-test exprès.
   
   Au niveau de la loi de comportement, maintenant c'est aussi interdit de faire un calcul
   sans prise en compte de la température, puis de le continuer en la prenant compte (nouveau
   message d'erreur type F ).
   
   
   Routines impactées
   =========================
   plasbe.f --> loi de comportement 
   algorith9.py --> fichier des messages
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    cas-tests personnels
NB_JOURS_TRAV  : 5.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 018757 DU 2012-04-20 14:28:01
TYPE anomalie concernant Documentation (VERSION 10.*)
TITRE
    Anomalie doc Mazars
FONCTIONNALITE
   Coquille dans l'équation 2.1.8 : ce n'est pas les contraintes totales qu'on utilise pour
   le calcul de epsilon_t et alpha_t, mais les contraintes effectives (pour avoir alpha_t=1).
   Le fortran est correct.
   
   Jean-Luc est éditeur noté pour modifier la doc (évolutions de la loi de Mazars), 
   on est d'accord qu'il va se dénoter et qu'il mettra à jour la formule à la main dans sa
   version.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : R7.01.08
VALIDATION
    thèse de J. Mazars
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR sellenet     SELLENET Nicolas       DATE 05/07/2012 - 03:28:59

--------------------------------------------------------------------------------
RESTITUTION FICHE 018811 DU 2012-05-03 10:18:33
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    En NEW11.01.20, le cas-test ssls200a est NOOK sur Rocks, Calibre5 et Calibre7.
FONCTIONNALITE
   Problème :
   ----------
   """
   En NEW11.01.20, le cas-test ssls200a est NOOK sur Rocks, Calibre5 et Calibre7.
   """
   
   
   Solution :
   ----------
   Il y a des problèmes dans les routines appelées par DXDEGE (routines réalisant le calcul
   de DEGE_ELGA).
   
   Les NOOK s'expliquent par une mauvaise utilisation de la routine DXBMAT (calcul de la
   matrice reliant les déformations du premier ordre aux déplacements au point d'intégration
   pour les DST, DKT, DSQ, DKQ et Q4G) qui provoque des variables non initialisées dans les blas.
   
   Je ne suis pas parvenu à régler le problème donc j'ai décidé de changer de stratégie.
   
   En effet, TE0033 qui calcule DEGE_ELGA calcule aussi DEGE_ELNO. Les routines responsables
   du calcul de DEGE_ELNO sont aussi en mesure de calculer DEGE_ELGA par changement de la
   famille de points sur laquelle on travaille.
   
   Je fais donc en sorte que TE0033 utilise les mêmes routines pour calculer DEGE_ELGA et
   DEGE_ELNO.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssls200a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 018808 DU 2012-05-03 09:38:13
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    En NEW11.1.20, les cas-tests perfe03a, ssnv194a, wtnp127b et zzzz291a s'arrêtent en erreur fatale sur Rocks.
FONCTIONNALITE
   Problème :
   ----------
   """
   En NEW11.1.20, les cas-tests perfe03a, ssnv194a, wtnp127b et zzzz291a s'arrêtent en erreur
   fatale sur Rocks.
   """
   
   
   Solution :
   ----------
   Je corrige un test mal fait dans CHPOND que j'ai restitué la semaine dernière.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    perfe03a, ssnv194a, wtnp127b et zzzz291a
NB_JOURS_TRAV  : 0.3
--------------------------------------------------------------------------------
RESTITUTION FICHE 018760 DU 2012-04-20 17:28:11
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    [FORUM] CALC_VECT_ELEM/FORC_NODA non testé
FONCTIONNALITE
   Problème :
   ----------
   Un utilisateur du forum tente de faire un CALC_VECT_ELEM sur l'option FORC_NODA. Il
   obtient le plantage suivant :
   """
    Objet JEVEUX inexistant dans les bases ouvertes : > .REFE<
    l'objet n'a pas été créé ou il a été détruit                        
   """
   
   
   Analyse :
   ---------
   CALC_VECT_ELEM sur l'option FORC_NODA n'est pas testé et ça ne marche pas. Ce qui se
   passe, c'est que pour le calcul de cette option, on utilise la routine VEFNME. Cette
   routine peut avoir besoin dans certains cas du déplacement à l'instant précédent donc ce
   champ se retrouve en argument de cette routine.
   
   Ici, on n'en a pas besoin (on a juste besoin de SIEF_ELGA), néanmoins, VEFNME fait un
   DISMOI sur ce champ pour obtenir le nom du maillage. Or en argument dans CALC_VECT_ELEM,
   on a donné ' ' comme nom de champ pour le déplacement à l'instant précédent. On cherche
   donc ' .REFE' est on ne le trouve pas d'où le plantage.
   
   
   Solution :
   ----------
   Comme SIEF_ELGA est absolument nécessaire au calcul de FORC_NODA, on fait le DISMOI sur ce
   champ plutôt que sur le champ de déplacement. En procédant de la sorte, le calcul de
   l'utilisateur du forum se déroule correctement.
   
   
   Validation :
   ------------
   Suivant les conseils du demandeur (Thomas), j'enrichi le test zzzz237a qui fait des tests
   sur l'option FORC_NODA calculée par CALC_CHAMP. Je rajoute un CALC_VECT_ELEM et un
   ASSE_VECTEUR pour pouvoir comparer les deux façon de faire.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    zzzz237a
NB_JOURS_TRAV  : 0.3
--------------------------------------------------------------------------------
RESTITUTION FICHE 018739 DU 2012-04-18 09:29:08
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    La routine matimp est "fausse" si MATR_DISTRIBUEE='OUI'
FONCTIONNALITE
   Problème :
   ----------
   """
   On voit bien que la routine matimp.f (pour imprimer les matrices) ne tient pas compte du
   cas MATR_DISTRIBUEE.
   Il faudrait interdire ce cas de figure ou bien le traiter correctement.
   """
   
   
   Solution :
   ----------
   Je modifie matimp.f pour qu'elle soit compatible avec l'option MATR_DISTRIBUEE.
   
   Je fais en sorte qu'on imprime de manière distribuée la matrice en utilisant la
   numérotation globale des inconnues.
   
   Je fais le choix de ne pas reconstruire la matrice globale sur le processeur 0. En effet,
   si un utilisateur utilise MATR_DISTRIBUEE='OUI', c'est que sa matrice est trop volumineuse
   pour tenir en mémoire sur un seul processeur. La reconstruire serait donc voué à l'échec.
   Si ce n'est pas le cas, il ne lui sert à rien d'utiliser cette option !
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    unitaier
NB_JOURS_TRAV  : 0.02
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR pellet       PELLET Jacques         DATE 05/07/2012 - 03:29:00

--------------------------------------------------------------------------------
RESTITUTION FICHE 018436 DU 2012-02-20 15:15:24
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    Résultats faux obtenus à cause des erreurs dans MEMOY MESOMM et PEENCA
FONCTIONNALITE
   Problème :
   ----------
   Lors de la correction des fiches 18278 et 18284, on a du corriger les routines :
     mesomm.f
     memoy.f
     peenca.f
                                                                                            
                                                
   Avant la correction de ces 2 fiches, ces routines ont pu produire des résultats faux. Dans
   quels cas ?
                                                                                            
                                                
   Analyse :
   ---------
   Dans ces 3 routines on a :
     * 1 argument "in" de type cham_elem
     * La possibilité de donner une liste de mailles sur laquelle, il faut faire la somme ou
   la moyenne.
       Si on n'utilise pas cette possibilité, la somme a lieu sur tous les éléments.
                                                                                            
                                                
   Le bug (identique dans les 3 routines) concerne le cas où on donne cette liste de mailles :
                                                                                            
                                                
   On boucle sur les grels d'un cham_elem et quand le cham_elem n'est pas concerné par le grel,
   on "saute" à la fin de la boucle sans incrémenter le compteur d'éléments.
   Cette erreur conduit à sommer le champ d'un élément qui n'est pas celui que l'on croit,
   d'où un résultat faux.
                                                                                            
                                                
   Pour que le bug se produise, il faut que certains grels ne soient pas concernés par le
   cham_elem.
   C'est par exemple le cas du cham_elem des contraintes pour les éléments de "bord".
   Le problème est donc quasi sytématique si le ligrel associé au champ est le ligrel du modèle,
   car il est rare que les éléments "principaux" et les élémenst de bord calculent les memes
   options.
                                                                                            
                                                
   Heureusement, le plus souvent, le cham_elem n'est calculé que sur les mailles spécifiées
   par l'utilisateur.
   Si celui-ci n'a spécifié que des mailles ayant un sens pour le calcul, il n'y a pas de
   grels vides et donc pas de résultats faux.
                                                                                            
                                                
   Quand on "remonte" l'arbre d'appel de ces routines, on trouve les fonctionnalités suivantes :
                                                                                            
                                                
   memoy.f :
   POST_ELEM / RICE_TRACEY / GROUP_MA=xx (ou MAILLE=yy) + LOCAL='NON'
                                                                                            
                                                
   peenca.f :
   POST_ELEM / ENER_CIN / GROUP_MA=xx (ou MAILLE=yy)
   POST_ELEM / ENER_POT / GROUP_MA=xx (ou MAILLE=yy)
                                                                                            
                                                
   mesomm.f :
   AFFE_CHAR_MECA / LIAISON_ELEM / OPTION='PLAQ_POUT-ORTH'
   POST_ELEM / WEIBULL      / GROUP_MA=xx (ou MAILLE=yy)
   POST_ELEM / INDIC_ENER   / GROUP_MA=xx (ou MAILLE=yy)
   POST_ELEM / INDIC_SEUIL  / GROUP_MA=xx (ou MAILLE=yy)
   POST_ELEM / ENER_ELAS    / GROUP_MA=xx (ou MAILLE=yy)
   POST_ELEM / ENER_TOTALE  / GROUP_MA=xx (ou MAILLE=yy)
   POST_ELEM / ENER_DISS    / GROUP_MA=xx (ou MAILLE=yy)
                                                                                            
                                                
   Pour LIAISON_ELEM / OPTION='PLAQ_POUT-ORTH', la liste de mailles est celle donnée par
   l'utilisateur (mot clé GROUP_MA_1 ou MAILLE_1) et celui-ci est sensé donner des mailles
   surfaciques sur lesquelles le calcul peut etre fait. Si l'utilisateur ne s'est pas trompé,
   il n'y a pas de résultats faux.
                                                                                            
                                                
   Résultats FAUX:
   ---------------
   Les résultats faux concernent la commande POST_ELEM lorsqu'on utilise l'une des combinaisons :
                                                                                            
                                                
      RICE_TRACEY  + GROUP_MA=xx (ou MAILLE=yy) + LOCAL='NON'
                                                                                            
                                                
      ENER_CIN     + GROUP_MA=xx (ou MAILLE=yy)
      ENER_POT     + GROUP_MA=xx (ou MAILLE=yy)
      WEIBULL      + GROUP_MA=xx (ou MAILLE=yy)
      INDIC_ENER   + GROUP_MA=xx (ou MAILLE=yy)
      INDIC_SEUIL  + GROUP_MA=xx (ou MAILLE=yy)
      ENER_ELAS    + GROUP_MA=xx (ou MAILLE=yy)
      ENER_TOTALE  + GROUP_MA=xx (ou MAILLE=yy)
      ENER_DISS    + GROUP_MA=xx (ou MAILLE=yy)
                                                                                            
                                                
   Pour le mot clé RICE_TRACEY (+LOCAL='NON'), il est presque sur que les résultats sont faux.
                                                                                            
                                                
   En revanche, pour les autres mots clés, si l'utilisateur a demandé le post-traitement sur
   une liste de mailles ayant un "sens" (c'est à dire des mailles qui ne sont pas des mailles
   de peau), le résultat est correct.
                                                                                            
                                                
   Par exemple, pour ENER_CIN sur un modèle 3D, les mailles de "peau" ne calculent pas
   ENER_CIN (ça n'a pas de sens).
   Si l'utilisateur demande : ENER_CIN + GROUP_MA=GM1
   Si GM1 ne contient que des mailles 3D, le résultat est correct
   Si GM1 contient des mailles de peau, le résultat est assez probablement faux.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 10.0
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 11.0
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sans objet
NB_JOURS_TRAV  : 0.7
--------------------------------------------------------------------------------
RESTITUTION FICHE 018472 DU 2012-02-28 09:02:26
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    affichage NAN pour TRAV_EXT
FONCTIONNALITE
   Problème :
   ----------
   Quand on ajoute à la fin du test ssnv217a :
                                                                                            
                                                                             
   U=CALC_CHAMP(reuse = U, FORCE='FORC_NODA', RESULTAT=U, )
   TRAV = POST_ELEM( RESULTAT = U, TRAV_EXT = _F(),)
   IMPR_TABLE(TABLE=TRAV)
                                                                                            
                                                                             
   On s'aperçoit qu'à partir du pas de temps 21 TRAV_REEL est NAN.
   On peut aussi trouver "louche" qu'au pas de temps 11, TRAV_REEL passe brutalement à
   -1.53722E+10
                                                                                            
                                                                             
   #ASTER 11.01.19 CONCEPT TRAV CALCULE LE 26/04/2012 A 12:35:23 DE TYPE
   #TABLE_SDASTER
    NUME_ORDRE   INST         TRAV_ELAS    TRAV_REEL
               0  0.00000E+00  0.00000E+00  0.00000E+00
               1  1.00000E-01  1.85400E+02  1.85400E+02
               2  2.00000E-01  7.87380E+01  4.10168E+02
               3  3.00000E-01  3.92847E+01  4.62632E+02
               4  4.00000E-01  2.30480E+01  4.81489E+02
               5  5.00000E-01  1.50456E+01  4.90260E+02
               6  6.00000E-01  1.05621E+01  4.95029E+02
               7  7.00000E-01  7.81103E+00  4.97906E+02
               8  8.00000E-01  7.11111E+00  4.99910E+02
               9  9.00000E-01  9.00000E+00  5.01799E+02
              10  1.00000E+00  1.11111E+01  5.03910E+02
              11  1.10000E+00  1.89824E+02 -1.53722E+10
              12  1.20000E+00  8.28672E+01 -1.53722E+10
              13  1.30000E+00  4.16395E+01 -1.53722E+10
              14  1.40000E+00  2.44954E+01 -1.53722E+10
              15  1.50000E+00  1.60111E+01 -1.53722E+10
              16  1.60000E+00  1.12479E+01 -1.53722E+10
              17  1.70000E+00  8.32179E+00 -1.53722E+10
              18  1.80000E+00  6.66657E+00 -1.53722E+10
              19  1.90000E+00  8.43737E+00 -1.53722E+10
              20  2.00000E+00  1.04165E+01 -1.53722E+10
              21  2.10000E+00  1.85400E+02          NAN
              22  2.20000E+00  7.87380E+01          NAN
              23  2.30000E+00  3.92847E+01          NAN
                                                                                            
                                                                             
                                                                                            
                                                                             
   Analyse :
   ---------
   La programmation de la routine pewext.f (POST_ELEM / TRAV_EXT) suppose implicitement que
   les champs (DEPL et FORC_NODA) aux différents numéros d'ordre ont la meme numérotation.
   C'est à dire que l'on calcule le produit scalaire F*U par un simple DDOT sur les objets
   .VALE des cham_no.
                                                                                            
                                                                             
   Cette hypothèse est fausse si la sd_resultat a été calculée en plusieurs "coups" (reuse)
   en changeant les conditions aux limites dualisées.
                                                                                            
                                                                             
   Comme il n'y a pas de vérification de la cohérence des champs, le calcul conduit à sommer
   des valeurs non-initialisées, ce qui entraines des résultats faux (ou NaN).
                                                                                            
                                                                             
                                                                                            
                                                                             
   Correction :
   ------------
   On corrige la routine pewext.f pour que le produit scalaire de 2 champs U et F soit fait
   correctement grace au passage par des champs "simples", ce qui permet aussi de vérifier
   que les 2 champs ont bien les memes ddls physiques.
                                                                                            
                                                                             
   Cette correction est possible car nous pensons (LI, JP et TDS) que les ddls de Lagrange ne
   doivent pas etre pris en compte dans le calcul du travail exterieur.
                                                                                            
                                                                             
                                                                                            
                                                                             
   Validation :
   ------------
   On valide le développement en comparant le paramètre TRAV_REEL de POST_ELEM / TRAV_EXT
   avec le paramètre TRAV_EXT calculé par STAT_NON_LINE / ENERGIE=_F().
   Pour cela, on enrichit le test ssnv217a.
                                                                                            
                                                                             
   Après correction, on trouve :
                                                                                            
                                                                             
   #ASTER 11.01.19 CONCEPT TRAV CALCULE LE 26/04/2012 A 15:32:34 DE TYPE
   #TABLE_SDASTER
    NUME_ORDRE   INST         TRAV_ELAS    TRAV_REEL
               0  0.00000E+00  0.00000E+00  0.00000E+00
               1  1.00000E-01  1.85400E+02  1.85400E+02
               2  2.00000E-01  7.87380E+01  4.10168E+02
               3  3.00000E-01  3.92847E+01  4.62632E+02
               4  4.00000E-01  2.30480E+01  4.81489E+02
               5  5.00000E-01  1.50456E+01  4.90260E+02
               6  6.00000E-01  1.05621E+01  4.95029E+02
               7  7.00000E-01  7.81103E+00  4.97906E+02
               8  8.00000E-01  7.11111E+00  4.99910E+02
               9  9.00000E-01  9.00000E+00  5.01799E+02
              10  1.00000E+00  1.11111E+01  5.03910E+02
              11  1.10000E+00  1.89824E+02  6.98544E+02
              12  1.20000E+00  8.28672E+01  9.29802E+02
              13  1.30000E+00  4.16395E+01  9.85115E+02
              14  1.40000E+00  2.44954E+01  1.00512E+03
              15  1.50000E+00  1.60111E+01  1.01444E+03
              16  1.60000E+00  1.12479E+01  1.01952E+03
              17  1.70000E+00  8.32179E+00  1.02259E+03
              18  1.80000E+00  6.66657E+00  1.02461E+03
              19  1.90000E+00  8.43737E+00  1.02638E+03
              20  2.00000E+00  1.04165E+01  1.02836E+03
              21  2.10000E+00  1.85400E+02  1.19663E+03
              22  2.20000E+00  7.87380E+01  1.42140E+03
              23  2.30000E+00  3.92847E+01  1.47386E+03
              24  2.40000E+00  2.30480E+01  1.49272E+03
              25  2.50000E+00  1.50456E+01  1.50149E+03
                                                                                            
                                                                             
   On constate aussi que l'ancienne programmation donnait des résultats FAUX (différents de
   NaN) pour les pas de temps 11 à 20.
                                                                                            
                                                                             
                                                                                            
                                                                             
   Résultats faux :
   ----------------
   Le calcul de POST_ELEM / TRAV_EXT donne des résultats faux si la structure de donnée
   résultat a été produite avec des "reuse" en changeant les conditions cinématiques
   dualisées (AFFE_CHAR_MECA) entre les "reuse".
                                                                                            
                                                                             
   Liste des fichiers impactés par la correction de la fiche:  18472
     cnsdot.f  pewext.f
                                                                                            
                                                                             
   NEW10 :
   La fiche pouvant donner des résultats faux, il faut reporter en NEW10 :
     * la correction de la routine pewext.f
     * l'ajout de la routine cnsdot.f
    
    
   Liste des fichiers impactés par la correction de la fiche:  18472
     cnsdot.f  enerca.f  pewext.f
     ssnv217a.comm
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 10.0
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 11.0
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssnv217a
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 018772 DU 2012-04-24 12:26:35
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    Plantage affe_char_meca/sigm_interne en sdveri='oui'
FONCTIONNALITE
   Problème :
   ----------
   La commande :
                                                                                            
                           
   PIOU=AFFE_CHAR_MECA(MODELE=modele,
                       SIGM_INTERNE=_F(SIGM=CH2,),);
                                                                                            
                           
   Conduit à une erreur si SDVERI='OUI'
                                                                                            
                           
   Correction :
   ------------
   Une ligne a retirée par erreur en version 11.1.9 dans le catalogue de la structure de
   donnée char_meca (sd_char_meca.py) :
                                                                                            
                           
   <     SIINT = Facultatif(sd_carte())
                                                                                            
                           
   Je la rétablis et tout rentre dans l'ordre.
    
    
   Liste des fichiers impactés par la correction de la fiche:  18772
     sd_char_meca.py
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    étude jointe
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 018790 DU 2012-04-26 16:07:15
TYPE express concernant Code_Aster (VERSION 10.5)
TITRE
    problèmes routines enerca.f
FONCTIONNALITE
   Problème :
   ----------
   A l'occasion de la fiche 18472, je m'aperçois que dans la routine enerca.f :
   1) Certaines variables (ECIN par exemple) ne sont pas toujours initialisées.
   2) Les objets JEVEUX de travail ne respectent pas la règle : '&&NOMROUT.XXXX'
   3) La destruction des objets de travail est inutilement compliquée (avec des blocs "IF")
                                                                                            
                           
   Correction :
   ------------
   Les défauts repérés ont été corrigés dans le cadre de la fiche 18472 
   
   remarque : la routine n'existe qu'en version 11
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    rien de particulier
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR tardieu      TARDIEU Nicolas        DATE 05/07/2012 - 01:06:24

--------------------------------------------------------------------------------
RESTITUTION FICHE 018812 DU 2012-05-03 10:26:35
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    En NEW11.01.20, le cas-test sdnv103f est NOOK sur Rocks.
FONCTIONNALITE
   Problème :
   ---------
   En NEW11.01.20, le cas-test sdnv103f est NOOK sur Rocks. 
   
   Solution (qui n'en est pas) :
   ----------------------------
   J'ai relancé le test de nombreuses fois en batch et en interactif le cas test qui revient
   toujours OK.
   
   J'en profite juste pour corriger un petit problème dans NDLECT.F. A la ligne 352, on fait
   un GETVTX sur un mot-clé simple qui n'a pas de valeur par défaut sans tester le
   code-retour. Valgrind se plaignait ; je teste le code-retour.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    Passage du test
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR tran         TRAN Van-xuan          DATE 05/07/2012 - 02:25:12

--------------------------------------------------------------------------------
RESTITUTION FICHE 018781 DU 2012-04-26 06:22:25
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    En NEW11.01.19, le cas-test sslv135h,i,j,n et o s'arretent en erreur fatale sur Rocks.
FONCTIONNALITE
   Problème:
   =========
   En NEW11.01.19, le cas-test sslv135h,i,j,n et o s'arretent en erreur fatale sur Rocks.
   
   Analyse:
   =======
   Ces cas-test sont pour critères en formule or ils sont rentrées dans la partie des
   critères appelées par nom (des critères historiquement développés dans Code_Aster). J'ai
   ajouté une condition (IF criter = nom) pour éviter cette rentrée.
   
   Validation:
   ===========
   Cas tests cassés.
   
   Impact codes:
   ============
   acgrdo : évaluer les grandeurs équivalents
   
   Impact docs:
   ============
   None
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sslv135h,i,j,n,o
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 018746 DU 2012-04-19 09:40:47
TYPE anomalie concernant Code_Aster (VERSION 11.1)
TITRE
    En NEW11.01.18, les cas-test szlz107b, szlz107e échouent sur Aster4, Rocks, Calibre5 et Calibre7.
FONCTIONNALITE
   Problèmes:
   ==========
   En NEW11.01.18, les cas-test szlz107b, szlz107e échouent sur Rocks
   
   Analyse:
   =======
   Pour szlz107b: quand on teste avec une valeur de référence de 0, on a utilisé "RELATIF" avec la valeur 
   absolue obtenue avec Calibre 7. Cela ne marche pas avec ROCKS en raison des erreurs informatiques ===>On 
   change VALE = 0 et 'ABSOLU'
   
   Pour szlz107e: il y a deux problèmes:
     1. test de valeur de référence 0: comme szlz107b
     2. sur certaines conditions, il existe 2 plans dont le dommage est max. Pour l'instant, Aster ne sort qu'un 
   plan. On a jouté 2 valeurs (de 2 plans asscociés donnant le même dommage) dans VALE comme des cas-test de 
   CALC_FATIGUE. Une fiche d'évolution pour sortir tous les plans de dommage max est aussi émise (fiche 18802).
   
   J'ai profité cette fiche pour ajouter une option de calcul "PROJECTION = 'DEUX_AXES' " pour répondre au 
   problème de couverture il y 2 semaines. 
   
   J'ai aussi vérifié la couverture sur les routines FMAMPC, FMCROS, FMPAPA, FMPRHM et FMRAYO. Avec le cas-test 
   szlz107a, ces subroutines sont couvertes.
   
   Validation:
   ===========
   szlz107b,e
   
   Impact sources:
   ==============
   None
   
   Impact docs:
   ===========
   V9.01.107: pour ce cas-test
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V9.01.107
VALIDATION
    szlz107b,e
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 018682 DU 2012-04-10 15:54:47
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    RUPT : CALG et prise en compte de symétrie pour CALC_G_GLOB
FONCTIONNALITE
   Problème:
   =========
   dans sslv110e on ne modélise que 1/8 de la structure (un quart de la longueur 
   du fond et seulement une levre)
   
   le G global trouvé vaut 1/8 du Gglobal de réf.
   
   or d'apres la doc (et meme d'apres le fortran vite fait) il semblerait que la 
   symétrie fasse que l'on multiplie par 2 la valeur de G en sortie, 
   
   donc on devrait plutot avoir 1/4 de la valeur de réf
   
   Analyse:
   =======
   Pour la fissure maillée avec le champ théta foruni par CALC_THETA, il faut 
   indiquer que le champ théta est symmétrique.
   
   Pour ce problème, il suffit d'ajouter 'SYME = 'OUI' dans le champ THETA de 
   CALC_G suite à la restution de de la fiche 18065 pour regler cette fiche. 
   Cependant, il faut bien expliquer dans le document l'obligation du ce mot-
   clé dans les cas particulier.
   
   Validation
   ==========
   sslv110e
   
   Docs:
   ====
   V3.04.110
   
   U2.82.03: CALC_G
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V3.04.110, U2.82.03
VALIDATION
    sslv110e
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

       C MODIF supervis/astercore_module    courtois M.COURTOIS         515      6      4
       C MODIF supervis/astermodule         courtois M.COURTOIS        3182     19      4
 CASTEST AJOUT sslp105b                       granet S.GRANET           460    460      0
 CASTEST AJOUT sslp105c                       granet S.GRANET           432    432      0
 CASTEST AJOUT wtnp119e                       granet S.GRANET           468    468      0
 CASTEST MODIF fdlv113a                        bodel C.BODEL            335      3      2
 CASTEST MODIF mac3c02a                    fernandes R.FERNANDES         82      3      3
 CASTEST MODIF miss03b                       greffet N.GREFFET         1165      1      1
 CASTEST MODIF miss03c                       greffet N.GREFFET         1099    167     70
 CASTEST MODIF sdld102a                        bodel C.BODEL            907     11     22
 CASTEST MODIF sdls118a                        bodel C.BODEL            483      3      2
 CASTEST MODIF sdls118b                        bodel C.BODEL            569      4      3
 CASTEST MODIF sdls119b                        bodel C.BODEL            569      3      2
 CASTEST MODIF sdnl136a                      alarcon A.ALARCON          660      3      3
 CASTEST MODIF sdnv100j                      greffet N.GREFFET          293      5      3
 CASTEST MODIF ssls09b                        delmas J.DELMAS           323      2      2
 CASTEST MODIF ssls09c                        delmas J.DELMAS           204      2      2
 CASTEST MODIF ssls200a                     sellenet N.SELLENET         386      2      2
 CASTEST MODIF sslv07a                        delmas J.DELMAS           907      2      2
 CASTEST MODIF sslv07d                        delmas J.DELMAS           309      3      3
 CASTEST MODIF sslv110e                         tran V-X.TRAN           229      9      6
 CASTEST MODIF sslv111f                      macocco K.MACOCCO          294     22      4
 CASTEST MODIF sslv111g                      macocco K.MACOCCO          294      3      3
 CASTEST MODIF sslv134d                       delmas J.DELMAS           578      3      3
 CASTEST MODIF ssnp123a                       delmas J.DELMAS           233      2      2
 CASTEST MODIF ssnp123b                       delmas J.DELMAS           210      2      2
 CASTEST MODIF ssnp130a                       delmas J.DELMAS           329      3      3
 CASTEST MODIF ssnp130d                       delmas J.DELMAS           289      2      2
 CASTEST MODIF ssnv217a                     sellenet N.SELLENET         279     48      4
 CASTEST MODIF ssnv510c                       delmas J.DELMAS           295      2      2
 CASTEST MODIF ssnv510f                       delmas J.DELMAS           298      2      2
 CASTEST MODIF szlz107b                         tran V-X.TRAN           656     42     37
 CASTEST MODIF szlz107e                         tran V-X.TRAN           670     56      6
 CASTEST MODIF zzzz237a                     sellenet N.SELLENET         433     34      1
CATALOGU MODIF options/dege_elga            sellenet N.SELLENET          60      3      3
CATALOGU MODIF typelem/gener_medkg1         sellenet N.SELLENET         252      3      2
CATALOGU MODIF typelem/gener_medkt2         sellenet N.SELLENET         428      3      2
CATALOPY MODIF commande/calc_miss            greffet N.GREFFET          223      4      8
CATALOPY MODIF commande/proj_base              bodel C.BODEL             71      2      4
CATALOPY MODIF commande/proj_resu_base         bodel C.BODEL             30      2      4
CATALOPY MODIF commande/proj_spec_base         bodel C.BODEL             43      1      2
    CMAT MODIF AF3G_CR_REF_A.NOMI         R.FERNANDES 107                 12      4      0
    CMAT MODIF AF3G_TG_REF_A.NOMI         R.FERNANDES 126                 12      4      0
    CMAT MODIF AFA_CR_REF_A.NOMI          R.FERNANDES 107                 12      4      0
    CMAT MODIF AFA_TG_REF_A.NOMI          R.FERNANDES 126                 12      4      0
 FORTRAN AJOUT calculel/cnsdot              sellenet N.SELLENET         140    140      0
 FORTRAN MODIF algorith/arg126                 bodel C.BODEL            268      5      2
 FORTRAN MODIF algorith/deflog                 proix J-M.PROIX          100     10      7
 FORTRAN MODIF algorith/edgequ                 proix J-M.PROIX           63     12      2
 FORTRAN MODIF algorith/enerca              sellenet N.SELLENET         431     52     51
 FORTRAN MODIF algorith/ndlect               tardieu N.TARDIEU          496      3      1
 FORTRAN MODIF algorith/nmdlog                 proix J-M.PROIX          149      5     11
 FORTRAN MODIF algorith/nmflin               greffet N.GREFFET          117      5      2
 FORTRAN MODIF algorith/op0079                 bodel C.BODEL            303      3      2
 FORTRAN MODIF algorith/op0091               alarcon A.ALARCON          481      6      2
 FORTRAN MODIF algorith/permvc                granet S.GRANET            93      3      3
 FORTRAN MODIF algorith/pewext              sellenet N.SELLENET         151     73     61
 FORTRAN MODIF algorith/plasbe                 proix J-M.PROIX          494     43     38
 FORTRAN MODIF algorith/prelog                 proix J-M.PROIX           88      6      6
 FORTRAN MODIF algorith/redece                 proix J-M.PROIX          291      2      7
 FORTRAN MODIF algorith/rotlir               alarcon A.ALARCON          392     29      6
 FORTRAN MODIF algorith/vefnme              sellenet N.SELLENET         310      8      1
 FORTRAN MODIF debug/matimp                 sellenet N.SELLENET         264     43     17
 FORTRAN MODIF elements/fonno4               macocco K.MACOCCO          145      9      6
 FORTRAN MODIF elements/fonnor               macocco K.MACOCCO          369      4      3
 FORTRAN MODIF elements/resvoi                delmas J.DELMAS           441     54     10
 FORTRAN MODIF elements/te0033              sellenet N.SELLENET         343     18      2
 FORTRAN MODIF elements/te0424              courtois M.COURTOIS         131      9      5
 FORTRAN MODIF elements/te0425              courtois M.COURTOIS         153      9      5
 FORTRAN MODIF elements/te0573              courtois M.COURTOIS         137      8     13
 FORTRAN MODIF elements/te0574              courtois M.COURTOIS         153      8     13
 FORTRAN MODIF modelisa/afrela              courtois M.COURTOIS         412     15     30
 FORTRAN MODIF postrele/rvchl3              desroche X.DESROCHES        149      3      3
 FORTRAN MODIF prepost/acgrdo                   tran V-X.TRAN           774     15      2
 FORTRAN MODIF prepost/deltau                   tran V-X.TRAN           252      5      2
 FORTRAN MODIF prepost/dtauno                   tran V-X.TRAN           287      2      2
 FORTRAN MODIF supervis/gcdetc              courtois M.COURTOIS          85      3      3
 FORTRAN MODIF supervis/ib0mai              courtois M.COURTOIS          80      5      1
 FORTRAN MODIF utilifor/u2mesg              courtois M.COURTOIS         146      5      5
 FORTRAN MODIF utilitai/chpond              sellenet N.SELLENET         226      2      2
 FORTRAN SUPPR elements/dxdege              sellenet N.SELLENET         130      0    130
       H MODIF include/aster                courtois M.COURTOIS          76      1      1
       H MODIF include/aster_core           courtois M.COURTOIS          57      3      2
       H MODIF include/definition           courtois M.COURTOIS         345      6      2
  PYTHON MODIF Build/B_ETAPE                courtois M.COURTOIS         827      4      4
  PYTHON MODIF Contrib/macro_bascule_schema_cata    greffet N.GREFFET          348     11      3
  PYTHON MODIF Contrib/macro_bascule_schema_ops    greffet N.GREFFET          307     11      5
  PYTHON MODIF Execution/E_Core             courtois M.COURTOIS         402      2      2
  PYTHON MODIF Execution/E_Exception        courtois M.COURTOIS         188      7      2
  PYTHON MODIF Macro/calc_europlexus_ops      assire A.ASSIRE          2617     81    100
  PYTHON MODIF Macro/proj_base_ops             bodel C.BODEL             86      3      3
  PYTHON MODIF Messages/algorith12             bodel C.BODEL            370      8      1
  PYTHON MODIF Messages/algorith9              proix J-M.PROIX          263      6      1
  PYTHON MODIF Messages/compor1                proix J-M.PROIX          372      5      1
  PYTHON MODIF Messages/indicateur            delmas J.DELMAS           162     13      1
  PYTHON MODIF Messages/mecanonline6         greffet N.GREFFET          161      5      1
  PYTHON MODIF Messages/miss0                greffet N.GREFFET          141     10      1
  PYTHON MODIF Messages/plexus                assire A.ASSIRE            76      1      1
  PYTHON MODIF Miss/miss_calcul              greffet N.GREFFET          455     36     20
  PYTHON MODIF Miss/miss_fichier_interf      greffet N.GREFFET          448     72     56
  PYTHON MODIF Miss/miss_fichier_sol         greffet N.GREFFET          130      5      2
  PYTHON MODIF Miss/miss_post                greffet N.GREFFET          943     99    137
  PYTHON MODIF Miss/miss_utils               greffet N.GREFFET          246      2      2
  PYTHON MODIF Noyau/nommage                courtois M.COURTOIS         166      2      8
  PYTHON MODIF SD/sd_char_meca              sellenet N.SELLENET         110      2      1
  PYTHON MODIF SD/sd_macr_elem_dyna            bodel C.BODEL             74      7      3
  PYTHON MODIF Utilitai/Utmess              courtois M.COURTOIS         733     26     18
  PYTHON MODIF Utilitai/as_timer            courtois M.COURTOIS         273      4      4
  PYTHON MODIF Validation/V_ETAPE           courtois M.COURTOIS         240      4      3


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :    4        1500      1500             +1500
 MODIF :  104       37620      1421     943      +478
 SUPPR :    1         130               130      -130
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :  109       39250      2921    1073     +1848 
