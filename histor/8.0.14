

-----------------------------------------------------------------------
--- AUTEUR boyere E.BOYERE   DATE  le 04/04/2005 a 11:41:44

--------------------------------------------------------------------------
REALISATION EL 2005-066
   NB_JOURS_TRAV  : 1.5
   INTERET_UTILISATEUR : NON
   TITRE probleme d'utilisation de MACRO_MODE_MECA (AOM)
   FONCTIONNALITE
     Un utilisateur de MACRO_MODE_MECA n'arrivait pas a faire aboutir son
     calcul modal.
     Cela venait du fait qu'il avait subdivise de facon excessivment fine ses
     bandes de frequence. Une fois choisies des bandes plus larges, le calcul
     passe sans probleme.
     On a en a profite pour traduire l'etude de v6 en v7.
     Cela a permis de deceler des mailles repetees dans les affectations.
     A priori pas de resultats faux mais cela permet de se demander si des
     mailles n'ont pas ete oubliees lors des affectations.
     Enfin j'en profite pour rappeler que l'option VERI_MODE(_F(STOP_ERREUR='NON'))
     est dangereuse et qu'il faut l'eviter !!!
   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  NON
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION


-----------------------------------------------------------------------
--- AUTEUR cibhhlv L.VIVAN   DATE  le 01/04/2005 a 16:40:54

--------------------------------------------------------------------------
CORRECTION AL 2005-099
   NB_JOURS_TRAV  : 0.5
   POUR_LE_COMPTE_DE   : X.DESROCHES
   INTERET_UTILISATEUR : NON
   TITRE : LIAISON_SOLIDE pour les COQUE_3D
   FONCTIONNALITE
     Lors de l'affectation d'une charge de type LIAISON_SOLIDE pour une
     modélisation COQUE_3D, le code émet un message fatal :
       <F> <AFFE_CHAR_MECA> <ORDLRL> LE DDL DX  EST INTERDIT POUR
           LE NOEUD< NS26  >
     En effet, pour les éléments COQUE_3D :
     les DDL sont  DX DY DZ DRX DRY DRZ  en chaque noeud et
                            DRX DRY DRZ  au noeud central
     il n'y a pas de DDL de translation pour le noeud milieu.
   DETAIL
     routine drz13d :
     lors de l'ecriture des relations linéaires entre les degrés de
     liberté des noeuds, on vérifie que ces degrés de liberté existent.
   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  OUI
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
     passage de l'etude associé.
     passage des 29 tests validant LIAISON_SOLIDE.

--------------------------------------------------------------------------
RESTITUTION HORS AREX
   suite AL 2005-014
   NB_JOURS_TRAV  : 2
   INTERET_UTILISATEUR : OUI
   TITRE : POST_RCCM, validation de la méthode UNITAIRE
   FONCTIONNALITE
     Restitution du test rccm01a.com2
       TYPE_RESU_MECA='UNITAIRE',
       OPTION='FATIGUE',
       validation des combinaisons de situations
    Corrections de petites coquilles lors d'impressions dans le fichier
    message (INFO=2)
   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   VALIDATION
   IMPACT_DOCUMENTAIRE : OUI
     DOC_V : V1.01.107 RCCM01
       EXPL_ : ajout de la méthode unitaire


-----------------------------------------------------------------------
--- AUTEUR cibhhpd L.SALMONA   DATE  le 04/04/2005 a 15:51:44

--------------------------------------------------------------------------
REALISATION EL 2004-186
   POUR_LE_COMPTE_DE :V.CANO
   NB_JOURS_TRAV  : 10
   INTERET_UTILISATEUR : OUI
   TITRE : CALC_META:Calcul des phases metallurgiques aux noeuds des elements
   FONCTIONNALITE CALC_META
   DETAILS
      Precedemment le calcul des phases metallurgiques (CALC_META) etait
      fait aux points de Gauss. Elles etaient ensuite utilisees par les elements
      mecaniques. Il n'etait pas tres sain de supposer que les familles de points
      de Gauss des elements mecaniques devaient toujours etre coherents avec
      celles des elements thermiques.
      Dorenavant CALC_META calcule les phases directement aux noeuds des
      elements. L'option META_ELNO_TEMP est effectuee par defaut.
      L'option META_ELGA_TEMP a ete supprimee.
      De meme pour META_INIT qui a ete supprimee et a ete remplacee
      par META_INIT_ELNO (dans les cas tests META_INIT a ete remplacee
      par META_INIT_ELNO).
      De plus l'option DURT_ELGA_META a ete supprime et l'option
      DURT_ELNO_META est calculee directement aux noeuds des elements.

      Le champ EPHASRR dans les catalogues de mecanique est maintenant
      un champ au noeud. Le passage Noeud-Gauss est fait desormais dans
      les te de mecanique.

      Pour les cas tests effectuant des TEST_RESU sur les champs metallurgiques
      les tests sur META_ELGA_TEMP ont ete remplaces par des tests sur
      META_ELNO_TEMP sur des noeuds appartenant aux mailles precedemment testees.
      Il n'y avait pas de test sur DURT_ELGA_META mais seulement sur DURT_ELNO_META
      qui ont ete conserves.

      modif des cas tests
      -------------------
      hsnv101a : META_INIT a ete remplace par META_INIT_ELNO
      hsnv101b : idem
      hsnv101c : idem
      hsnv101d : idem
      hsnv102a : idem
      hsnv102b : idem
      hsnv102c : idem
      hsnv103a : idem
      hsnv103b : idem
      hsnv104a : idem
      hsnv105a : idem
      hsnv122a : idem
      hsnv123a : idem
      hsnv126a : idem
      hsnv126b : idem
      hsnv127a : idem
      hsnv128a : idem
      htna100a : idem

      mtlp100a : idem + ajustement des tolerances apres passage a META_ELNO_TEMP
      --------------------------------------------------------------------------------
      ---- RESULTAT:  TEMPE1   NUME_ORDRE: 110 NOM_CHAM: META_ELNO_TEMP
      REFERENCE: NON_REGRESSION
      NOOK V3           ABSO    -0.004   VALE: 6.2194157147408D-01
      M19      N66      TOLE     0.002   REFE: 6.2630000000000D-01
      ---- RESULTAT:  TEMPE1   NUME_ORDRE: 110 NOM_CHAM: META_ELNO_TEMP
      REFERENCE: NON_REGRESSION
      NOOK V3           ABSO    -0.023   VALE: 2.3532888307127D-01
      M19      N70      TOLE     0.002   REFE: 2.5810000000000D-01
      ---- RESULTAT:  TEMPE1   NUME_ORDRE: 165 NOM_CHAM: META_ELNO_TEMP
      REFERENCE: NON_REGRESSION
      NOOK V3           ABSO    -0.027   VALE: 7.7201161304819D-01
      M13      N39      TOLE     0.002   REFE: 7.9900000000000D-01
      ---- RESULTAT:  TEMPE1   NUME_ORDRE: 165 NOM_CHAM: META_ELNO_TEMP
      REFERENCE: NON_REGRESSION
      NOOK V4           ABSO     0.026   VALE: 2.2593527186498D-01
      M13      N39      TOLE     0.002   REFE: 1.9960000000000D-01
      ---- RESULTAT:  TEMPE1   NUME_ORDRE: 165 NOM_CHAM: META_ELNO_TEMP
      REFERENCE: NON_REGRESSION
      NOOK V4           ABSO     0.004   VALE: 3.7571454182270D-01
      M19      N66      TOLE     0.002   REFE: 3.7150000000000D-01
      ---- RESULTAT:  TEMPE1   NUME_ORDRE: 165 NOM_CHAM: META_ELNO_TEMP
      REFERENCE: NON_REGRESSION
      NOOK V4           ABSO     0.023   VALE: 7.6012985530425D-01
      M19      N70      TOLE     0.002   REFE: 7.3740000000000D-01
      ---- RESULTAT:  TEMPE1   NUME_ORDRE: 165 NOM_CHAM: DURT_ELNO_META
      REFERENCE: NON_REGRESSION
      NOOK HV           ABSO     0.612   VALE: 3.0962234059507D+02
      M1       N1       TOLE     0.005   REFE: 3.0901000000000D+02

      mtlp100b : idem + ajustement des tolerances apres passage a META_ELNO_TEMP
       --------
      ---- RESULTAT:  TEMPE    NUME_ORDRE: 110 NOM_CHAM: META_ELNO_TEMP 				
      REFERENCE: AUTRE_ASTER	
      NOOK V3		ABSO	-0.004   VALE: 6.2194155946012D-01
      M19      N19	TOLE	 0.002   REFE: 6.2630000000000D-01
       ---- RESULTAT:  TEMPE	NUME_ORDRE: 110 NOM_CHAM: META_ELNO_TEMP				
      REFERENCE: AUTRE_ASTER	
      NOOK V3		ABSO	-0.018   VALE: 5.1563721850618D-01
              M19      N593	TOLE	 0.002   REFE: 5.3340000000000D-01
       ---- RESULTAT:  TEMPE	NUME_ORDRE: 165 NOM_CHAM: META_ELNO_TEMP				
      REFERENCE: AUTRE_ASTER	
      NOOK V3		ABSO	-0.027   VALE: 7.7201188281796D-01
      M13      N13	TOLE	 0.002   REFE: 7.9900000000000D-01
       ---- RESULTAT:  TEMPE	NUME_ORDRE: 165 NOM_CHAM: META_ELNO_TEMP				
      REFERENCE: AUTRE_ASTER	
      NOOK V4		ABSO	 0.026   VALE: 2.2593499411433D-01
      M13      N13	TOLE	 0.002   REFE: 1.9960000000000D-01
       ---- RESULTAT:  TEMPE	NUME_ORDRE: 165 NOM_CHAM: META_ELNO_TEMP				
      REFERENCE: AUTRE_ASTER	
      NOOK V4		ABSO	 0.004   VALE: 3.7571455676595D-01
      M19      N19	TOLE	 0.002   REFE: 3.7150000000000D-01
       ---- RESULTAT:  TEMPE	NUME_ORDRE: 165 NOM_CHAM: META_ELNO_TEMP				
      REFERENCE: AUTRE_ASTER	
      NOOK V4		ABSO	 0.018   VALE: 4.8153624440479D-01
      M19      N593	TOLE	 0.002   REFE: 4.6380000000000D-01	
       ---- RESULTAT:  TEMPE	NUME_ORDRE: 165 NOM_CHAM: DURT_ELNO_META				
      REFERENCE: NON_REGRESSION
      NOOK HV		ABSO	 0.612   VALE: 3.0962234986629D+02
      M1       N1	TOLE	 0.600   REFE: 3.0901000000000D+02

      mtlp101a : idem + passage des tests de META_ELGA_TEMP a META_ELNO_TEMP
      mtlp102a : idem + passage des tests de META_ELGA_TEMP a META_ELNO_TEMP
      ttna200a : idem + passage des tests de META_ELGA_TEMP a META_ELNO_TEMP

      ttnp200a : idem + ajustement des tolerances apres passage a META_ELNO_TEMP
      ---- RESULTAT:  THL10    NUME_ORDRE:   1 NOM_CHAM: META_ELNO_TEMP 				
      REFERENCE: NON_REGRESSION   VERSION: 6.2.3	
      NOOK		RELA	 0.105 % VALE: 3.2040211075264D+03
      SOMM_ABS         TOLE	0.100 % REFE: 3.2006586323219D+03

      modif des fortran
      -----------------
      metau1.f  nmdeze.f  smevol.f  te0067.f  te0100.f  te0121.f
      te0320.f  te0350.f  te0358.f  te0546.f  te0552.f  metau2.f
      op0194.f  te0064.f  te0083.f  te0113.f  te0139.f  te0321.f
      te0353.f  te0539.f  te0551.f  thaclm.f

      modif des catalo
      ----------------
      durt_elno_meta.cata
      meta_elno_temp.cata
      meta_init_elno.cata
      gener_meax_2.cata    gener_mv3d_3.cata    gener_thpld2.cata
      gener_me3d_3.cata    gener_meaxs2.cata    gener_th3d_3.cata
      gener_me3dg_3.cata   gener_mecpg2.cata    gener_th3dd3.cata
      gener_me_x.cata      gener_mecpl2.cata    gener_thax_2.cata
      gener_me_xh.cata     gener_medpg2.cata    gener_thaxd2.cata
      gener_me_xht.cata    gener_medpl2.cata    gener_thaxf2.cata
      gener_me_xt.cata     gener_meshb3.cata    gener_thpl_2.cata
      mecpqs4.cata
      mecptr3.cata
      mecptr6.cata
      medpqs4.cata
      medpqs8.cata
      medptr6.cata
      thaxtr6.cata
      thpltr6.cata

      modif des capy
      --------------
      calc_meta.capy

      suppression des catalogues
      --------------------------
      META_INIT
      META_ELGA_TEMP
      DURT_ELGA_META

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : OUI
      DOC_U:U4.85.01
        EXPL_ : Doc de CALC_META
	suppression de META_ELGA_TEMP et META_INIT
      DOC_V:V4.61.100
        EXPL_ : Doc du test MTLP100
	remplacement de META_ELGA_TEMP par META_ELNO_TEMP
      DOC_U:U4.81.01
        EXPL_ : Doc du CALC_ELEM
	suppression de DURT_ELGA_TEMP
      DOC_U:U2.03.04
        EXPL_ : Notice d'utilisation pour des calculs thermometallomecaniques
   VALIDATION astout + cas tests modifies


-----------------------------------------------------------------------
--- AUTEUR galenne E.GALENNE   DATE  le 04/04/2005 a 13:34:52

--------------------------------------------------------------------------
RESTITUTION HORS AREX
   NB_JOURS_TRAV  : 1.5
   INTERET_UTILISATEUR : NON
   FONCTIONNALITE : amélioration de la performance de CALC_G_LOCAL_T
   DETAILS
   Problème : (soulevé par P. Le Delliou) dans certains cas, le temps de calcul de
   l'opérateur CALC_G_LOCAL_T semble trop important en comparaison avec le temps
   nécessaire à la résolution du problème mécanique.

   Modification : Un rapide profiling à partir d'une étude envoyée par P. Le Delliou
   montre que l'essentiel du temps CPU est consommé dans la routine gcour2 (calcul des
   champs théta : 34%), avant même le calcul de G en lui même (texxx : 24%).
   Dans la routine gcour2, on intervertit donc deux boucles pour ne plus projeter
   l'ensemble des noeuds du maillage sur le fond de fissure qu'une seule fois.

   Impact : sur le cas test envoyé par P. Le Delliou, on gagne 30% sur le temps calcul
   avec la méthode Lagrange (80 noeuds au fond de fissure) et 6% avec la méthode Legendre
   (degré 5).
   Sur les cas test Aster (sslv311, sslv134), le gain est beaucoup moins important (3-7%)
   car le nombre de noeuds en fond de fissure est plus faible.

                                 cas test perso       sslv311
                                 Avant    Après       Avant    Après
   MECA_STATIQUE                       32s                  24s
   CALC_G_LOCAL_T
      méthode Lagrange           18s      12s         3.6s     3.3s
   CALC_G_LOCAL_T
      méthode Legendre (deg 5)   6s       5.5s        1.2s     1.1s

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
   Passage des cas test aster appelant CALC_G_LOCAL_T

--------------------------------------------------------------------------
REALISATION EL 2004-148
   NB_JOURS_TRAV  : 2
   INTERET_UTILISATEUR : NON
   TITRE AOM POST_RCCM Calcul de SN*
   FONCTIONNALITE
   Cette fiche, émise par un utilisateur de l'UTO, s'étonnait du résultat du calcul de SN
   et SN* avec l'option UNITAIRE de l'opérateur POST_RCCM sur une étude d'un piquage RCV.

   Des anomalies sur le calcul de SN et SN* ont été corrigées dans la fiche AL2005-014
   (restitution en v7 et en v8). Le cas test de validation de la méthode UNITAIRE
   (rccm01a.com2) a également été restitué.

   Suite à ces différentes corrections, les résultats sur l'étude du piquage RCV sont
   complètement modifiés et semblent maintenant cohérents. Ne disposant que des tableaux
   de contraintes, on ne peut pas aller plus loin dans l'analyse de ce cas particulier.

   Remarque : le sens de variation entre SN et SN* est différent entre les 2 segments
   étudiés. Cela confirme qu'il n'y a pas de règle générale : l'amplitude de la norme
   de (sig_tot - sig_lin_th) n'est pas systématiquement inférieure à l'amplitude de la
   norme de sig_tot.

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
     (déjà pris en compte dans l'AL2005-014 : mise à jour des docs R7.04.03 et V1.01.107)
   VALIDATION

--------------------------------------------------------------------------
REALISATION EL 2004-150
   NB_JOURS_TRAV  : 0
   INTERET_UTILISATEUR : NON
   TITRE AOM POST_RCCM Calcul de SN*
   FONCTIONNALITE
     cf. correction de la fiche EL 2004-148 : correction d'anomalies et restitution
     du cas test de la méthode UNITAIRE
   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION


-----------------------------------------------------------------------
--- AUTEUR mabbas M.ABBAS   DATE  le 04/04/2005 a 13:29:13

--------------------------------------------------------------------------
CORRECTION AL 2004-462
   NB_JOURS_TRAV  : 4
   INTERET_UTILISATEUR : NON
   TITRE : DIS_CONTACT - STAT_NON_LINE
   FONCTIONNALITE
     Ce calcul plante quand j'utilise DIS_CONTACT alors qu'il me donne
     un résultat avec ELAS.
     Y a t-il un problème avec DIS_CONTACT ?
   DETAILS
     Le floating point exception provient de la decoupe automatique
     du pas de temps. Contact et recherche lineaire sont incompatibles
     parce qu'ils travaillent dans deux "directions opposees". L'algo
     divise le pas de temps pour essayer de s'en sortir, mais, bien sur,
     il ne peut pas s'en sortir. Si bien qu'on arrive a un increment de
     temps tres petit qui fait planter l'integration de la loi de comportement
     VISC_IRRA_LOG.
     J'ai emis une fiche pour blinder la subdivision auto du pas de temps
     (EL 2004-264).
     Par ailleurs, je blinde nmvpir pour eviter le plantage sale.
     De plus, il y a une erreur dans l'utilisation de CALC_FONC_INTERP.
     Le Septen (Antoine Billerey, Aubelia Maurice)  a corrige.
     Avec cette correction et en enlevant la recherche lineaire,
     tout se passe bien jusqu'au pas de temps 2.586180000E+07 ou l'on
     plante avec le message:
       <STAT_NON_LINE> <RCFON3> ON DEBORDE A DROITE REDEFINISSEZ VOS NAPPES
        ALPHA - MOMENT
   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  OUI
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
     Etude associee a la fiche

--------------------------------------------------------------------------
RESTITUTION HORS AREX
   NB_JOURS_TRAV  : 0.1
   INTERET_UTILISATEUR : OUI
   TITRE : CONTACT - Affichages
   FONCTIONNALITE
   DETAILS
     Correction des affichages sales dans le cas de
     l'option "APPARIEMENT='NON'"
   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  OUI
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION

--------------------------------------------------------------------------
REALISATION EL 2005-040
   NB_JOURS_TRAV  : 7
   INTERET_UTILISATEUR : OUI
   TITRE : AOM - Calcul SAGRAPPE avec STAT_NON_LINE
   FONCTIONNALITE
     Il s'agit d'une descente controlée d'une poutre entre deux plaques
     guides avec contact frottement.
     Description rapide du pb :
     On traine un pivot nul sur le premier noeud qui entre en contact
     avec le guide. Au bout de quelques incréments, le calcul plante en
     erreur numérique. De plus, la suppression des modes de corps rigide
     n'est pas été optimisée.
   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
      essai
   DETAILS
     Après analyse, j'ai découvert un certain nombre de bugs dans le
     contact qui contribuent certainement à rendre la résolution difficile,
     voire impossible.
     Le fait de ne pas avoir forcément le même nombre de liaisons de contact
     lorsqu'on réactualise la géométrie (par le biais de l'option
     TOLE_PROJ_EXT par exemple) n'est pas pris en compte correctement par
     les algos de frottement. En effet, ces derniers considérent que le
     nombre de liaisons restent constant après réactualisation (même si le
     changement de l'appariement proprement dit est effectivement pris en
     compte)  et ne réinitialisent pas certains vecteurs, ce qui entraînent
     des problèmes en cascade (en particulier des divisions par zéro par
     décalage du vecteur des lagrangiens de contact <FLOATING POINT EXCEPTION>
     dans frolgd).
     AL emise AL2005-091
     Après correction, le modèle ne passe toujours pas (la matrice de contact
     est singulière).
     J'ai donc enlevé le contact pour voir.
     Sans contact, le modèle est déjà en limite de validité.
     On perd 7 décimales sur 8 autorisées dès le début:
        Perte de décimales important sur équation 4932:
           NOEUD:N387     CMP:DX
     Donc, sans contact, le problème a déjà du mal à passer.
     Avec, on perd une décimale de plus et on ne passe plus du tout.
     Il faut verifier le modele qui doit imperativement passer proprement
     sans contact avant d'aller plus loin.

--------------------------------------------------------------------------
RESTITUTION HORS AREX
   NB_JOURS_TRAV  : 2
   INTERET_UTILISATEUR : OUI
   TITRE  STAT_NON_LINE et CONTACT (AOM EL2004-248)
   FONCTIONNALITE
     L'utilisateur se plaint qu'il n'arrive pas à faire passer son étude
     qui comporte un nombre important de liaisons de contact avec 12 Go
     de mémoire et 24h de temps.
     Dans un premier temps, il a été remarqué que la méthode de résolution
     utilisée était "PENALISATION". Le calcul a alors été lancé avec la
     méthode "CONTRAINTE" (valeur par défaut) et il est 'passé' avec 4 Go.
     En fait 'passer' est un peu exagéré : la calcul tourne mais le résidu
     relatif est toujours à 1.e-4.
     Je me suis alors aperçu qu'un élément avait un module d'Young 1.E7 fois
     plus petit que le module des autres matériaux : il était là pour accrocher
     une partie flottante du modèle mais il était vraiment trop mou. Si on
     affecte un module d'Young 1.E3 fois plus petit, tout converge bien!
     Il s'agissait donc bien d'un problème de conditionnement de la matrice
     globale (diagnostic initial) qui empéchait Newton de converger.
   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION


-----------------------------------------------------------------------
--- AUTEUR mcourtoi M.COURTOIS   DATE  le 04/04/2005 a 15:40:07

--------------------------------------------------------------------------
REALISATION EL 2004-209
   NB_JOURS_TRAV  : 8 pour EDF (temps total des 3 personnes),
                    et une à deux semaines pour le CDM
   INTERET_UTILISATEUR : OUI
   TITRE : Couplage Zmat-Aster
   FONCTIONNALITE
      Dans le cadre du partenariat EDF (MMC-AMA-LAMSID)-Ecole des Mines
      (Centre des Matériaux), le couplage entre ZMAT, qui est le module de
      définition des comportements du code Zebulon, et Aster a été réalisé
      par S.Quilici de l'ENSMP, avec l'aide de Toufik Kanit, Jean-Michel
      Proix et Mathieu Courtois.
      Ceci se traduit pour l'utilisateur de Code_Aster de la façon suivante :
       - au niveau de COMP_INCR, le mot-clé RELATION='ZMAT', pour aller lire
         le fichier contenant les données ZMAT (qui permet à la fois le choix
         du comportement et la définition des coefficients matériau).
         Ce fichier peut faire appel à un comportement déjà disponible dans
         Zmat, ou bien défini par l'utilisateur dans un langage relativement
         simple (Zebfront).
       - toujours sous COMP_INCR, un mot-clé UNITE permet de définir l'unité
         logique sur laquelle ont vient lire le ficher zmat et un mot_clé
         NB_VARI permettant de préciser le nombre de variables internes du
         comportement, et bien sûr les mots clés habituels : GROUP_MA,
         DEFORMATION (PETIT ou PETIT_REAC pour le moment), ...

      Dans ASTK, par rapport à une étude classique, il suffit d'ajouter le
      fichier ZMAT correspondant à l'unité définie ci-dessus.

      Attention, ZMAT n'est pas un logiciel libre ! Le contrat de partenariat
      EDF-ENSMP actuel nous permet de l'utiliser seulement pour des études de
      R&D. Le couplage ZMAT-Aster sera  donc utilisable en INTRANET seulement,
      et ZMAT est installé physiquement sur 2 machines : Alphaserveur et
      clp50a8 (Linux).

      Un premier test de performances (à vérifier sur un cas plus important)
      donne les résultats suivants (plaque trouée) :
         RELATION='CHABOCHE'        35 s
         RELATION='VISC_CIN1_CHAB'  20 s
         RELATION='ZMAT'            87 s

   DETAILS

      Dans NMCOMP, si COMPOR=ZMAT, appel à la routine NMZMAT qui récupère le
      nom du fichier (via la carte COMPOR) et s'interface avec les routines C
      d'intégration du comportement de ZMAT (bibliothèque dynamique)

      Pour développer un comportement "utilisateur", dans un répertoire
      personnel de la machine d'exécution :
       1. créer un fichier library_files contenant ceci :
#------------------------------------------------------
!MESSAGE User Z7 project
!TOP Makefile.Motif.c++

!DYNAMIC
#!INSTALL_LIBS
!CFLAGS -I${Z7PATH}/include
!BFLAGS -L${Z7PATH}/PUBLIC/lib-${Z7MACHINE}

!MAKE target: lib

#
#  The main place for user files.
#
!INC   material
!SRC   material material

!DEBUG material

!LIBLIB -ZL Zmat_base
!LIB Zmat_ut_TyPeMaCHiNe material

!!RETURN
#------------------------------------------------------

       2. déposer le(s) fichier(s) matériau dans un sous-répertoire "material"

         Rem : le nom des fichiers doit commencer par une majuscule, et terminer
         par ".z".

       3. charger l'environnement ZMAT (en ksh, bash). Le plus sûr est de lire
         le fichier aster_profile.sh :
      Sur l'AlphaServer :
         prompt> . /aster/ASTK/ASTK_SERV/conf/aster_profile.sh

      Sur clp50a8 :
         prompt> . /logiciels/aster/Linux/ASTK/ASTK_SERV/conf/aster_profile.sh

       4. Création du Makefile Zmat :
         prompt> Zsetup

       5. Compilation du comportement déposé dans le répertoire "material"
         prompt> Zmake


       6. Dans le fichier de commande, définir la variable d'environnement
         ZEBU_PATH :

         import os
         os.environ['ZEBU_PATH'] = 'répertoire où se trouve la librairie .so'


   Pour tester le mode de fonctionnement où l'utilisateur développe son propre
   comportement, on définit le comportement "Chab1" qui a été compilé et déposé
   dans '$Z7PATH/PUBLIC/lib-Linux4'. Les sources du "User-project" sont dans
   '$Z7PATH/PUBLIC/test/Chab1_project.tar.gz'.

#------------------------------------------------------
#include <Elasticity.h>
#include <External_parameter.h>
#include <Basic_nl_behavior.h>
#include <Basic_nl_simulation.h>
#include <Flow.h>
#include <Criterion.h>
#include <Isotropic.h>
#include <Print.h>

@Class CHAB1 : BASIC_NL_BEHAVIOR {
  @Name chab1;
  @SubClass ELASTICITY YE;
  @Coefs R0, Q, b;
  @Coefs K, n, C, D;
  @tVarInt eel, alpha;
  @sVarInt evcum;
  @tVarAux evi, X;
  @sVarAux R;
};

@StrainPart {
 evi = eto - eel;
 sig = *YE*eel;
 if (m_flags&CALC_TG_MATRIX) m_tg_matrix=*YE;
}

@Derivative {
 sig = *YE*eel;
 X = (2.0*C/3.0)*alpha;
 R = R0 + Q*(1.-exp(-b*evcum));

 TENSOR2 sigeff = deviator(sig - X);
 double J = sqrt(1.5*(sigeff|sigeff));
 double f = J - R  ;

 deel = deto;

 if (f>0.0) {
           devcum = pow(f/K,n);
   TENSOR2 norm = sigeff*(1.5/J);
           deel -= devcum*norm;
   if (C>0.0) dalpha = devcum*(norm - D*alpha);
 }
}
#------------------------------------------------------

       7. On peut a priori tester que les bibliothèques sont bien chargées
       (logiquement $ZEBU_PATH devrait être utilisé pour chercher les
       bibliothèques utilisateur)
         prompt> Zrun -H

      Au début, on voit quelles .so sont chargées et si çà se passe bien,
      puis chercher le comportement ajouté dans la liste.

   Problèmes rencontrés :
      - ne pas utiliser E mais YE, sinon conflit sur l'Alpha
      - library_files doit contenir Zmat_base et Zmat_base_public
         (sinon virtual table undefined)
      - faire un ldd sur les .so et ZebFront pour vérifier que les librairies
         sont bien trouvées, sinon ajouter des liens dans
         $Z7PATH/PUBLIC/lib-${architecture}, notamment pour libblas et libXm

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI

   IMPACT_DOCUMENTAIRE : OUI
   DOC_U : U4.51.11 Comportements incrémentaux
      EXPL_ : possiblite de fournir un fichier zmat
   DOC_U : U2.10.01 Notice d'utilisation du couplage Zmat-Aster
      EXPL_ : utilisation d'un comportement de la bibliothèque Zmat et
      développement d'un comportement utilisateur.
   DOC_V : V1.03.111 zmat001
   DOC_V : V1.03.112 zmat002
   DOC_V : V1.03.113 zmat003

   Voir aussi : CR-AMA 2005-049 (pour l'installation et configuration)

   La doc d'utilisation de ZMat est disponible dans la répertoire
   d'installation de Zmat sur les 2 machines ci-dessus. Sur l'AlphaServer,
   dans /aster/public/Z8.3/HANDBOOK

   VALIDATION

      zmat001a : test issu de ssnv101d, traction-cisaillement avec une loi de
      Chaboche (VISC_CIN1_CHAB).

      zmat002 : thermoplasticité en traction simple (VMIS_ISOT_TRAC).
      La modélisation A en AXIS , la modélisation B (C_PLAN).

      zmat003a : visco-plasticité en traction biaxiale en utilisant un
      comportement utilisateur (identique à VISC_CIN1_CHAB, intégration
      explicite), issu de hsnv127b.

--------------------------------------------------------------------------
RESTITUTION HORS AREX
   NB_JOURS_TRAV  : 0.5
   INTERET_UTILISATEUR : NON
   FONCTIONNALITE
      En cas d'erreur <S> ou d'arrêt par 'kill -USR1 ...', les bases sont
      correctement fermées.
      Problème si on a mis FIN(FORMAT_HDF='OUI'), car le script cherche à
      recopier bhdf.1. Si on a commencé par POURSUITE(FORMAT_HDF='OUI'), on
      récupère en résultat la base initiale, si on a commencé par POURSUITE(),
      on doit s'arrêter en erreur.
      Modifs :
        - ibbase.f supprime le fichier bhdf.i après l'avoir lu,
        - le script recopie glob.* si jamais il ne trouve pas de bhdf.*.
   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  OUI
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : OUI
     DOC_U : U1.04.00
       EXPL_ : ajouter cette précision sous forme d'une remarque
   VALIDATION
      test en poursuite HDF + fin HDF arrêté prématurément par kill -USR1


-----------------------------------------------------------------------
--- AUTEUR vabhhts J.PELLET   DATE  le 01/04/2005 a 08:46:22

--------------------------------------------------------------------------
REALISATION EL 2004-246
   NB_JOURS_TRAV : 25 (JP)
   INTERET_UTILISATEUR : OUI
   TITRE : "Un solveur précis pour les matrices non positives"
   FONCTIONNALITE
   On ajoute un nouveau solveur pour les systèmes linéaires (MUMPS). Ce solveur "direct"
   présente l'avantage (par rapport à LDLT et MULT_FRONT) de permettre un "pivotage" tardif
   (après la factorisation symbolique) des inconnues lorsque des problèmes numériques apparaissent.
   Par exemple, cette fonctionnalité est en principe indispensable lorsque la modélisation conduit à des
   matrices ayant des 0. sur sa diagonale ; cela peut arriver avec les modélisations incompressibles.

   MUMPS est une bibliothèque développée et diffusée par le CERFACS (et d'autres).
   Code_Aster ne fait que se "brancher" sur cette bibliothèque.

   Avantages supplémentaires non encore utilisés dans Code_Aster :
      - MUMPS est parallélisé MPI
      - MUMPS sait traiter les matrices à connectivité non-symétrique alors que les matrices
        non-symétriques actuelles d'aster ont obligatoirement une connectivité symétrique.

   Remarques :
   -----------
   R1)  Bien que le solveur MUMPS soit un solveur direct, son usage s'apparente
      plus à celui du gradient conjugué (GCPC). Concrètement, celà veut dire que :
         1) MUMPS n'est pas accepté pour les solveurs "modaux" (recherche de modes propres),
         2) MUMPS n'est pas accepté dans STAT_NON_LINE pour un redécoupage du pas de temps
            si la matrice est singulière (flambement) STOP_SINGULIER='DECOUPE'

      Pourquoi ?
      Les solveurs directs actuels (LDLT, MULT_FRONT, FETI ??) savent (ou croient savoir !) déterminer
      si la matrice à factoriser est "quasi-singulière". Pour cela ils comparent la diagonale de la
      matrice factorisée à la diagonale initiale. Si un terme diagonal est devenu très petit
      (par défaut : 1.e-8 fois plus petit qu'initialement), ils en concluent (un peu hativement ?) que la
      matrice est presque singulière (alors qu'en réalité, la seule chose certaine est que la factorisée
      est imprécise).
      Du coup, on a introduit un mot clé SOLVEUR/STOP_SINGULIER= /OUI/NON/DECOUPE qui est examiné
      lors de la factorisation de la matrice (et donc ignoré avec GCPC qui ne factorise pas la matrice).

      Ce mot clé permet à l'appelant de la factorisation de prendre des mesures en cas de matrice
      singulière (si STOP_SINGULIER=NON/DECOUPE) :
        - les solveurs modaux        => on change le "shift",
        - STAT_NON_LINE + flambement => on redécoupe le pas de temps.

      Lors de la factorisation, les 2 solveurs directs LDLT et MULT_FRONT ne prennent
      aucune précaution particulière. Il estiment que si la factorisation s'est bien passée, la
      résolution (descente/remontée) doit forcément donner la bonne solution.

      En revanche, le gradient conjugué (GCPC) et MUMPS vérifient (ou peuvent vérifier) la qualité de la solution
      en calculant une erreur sur la solution : ||Ax-F||/||F||. L'utilisateur peut indiquer une erreur maximum
      à ne pas dépasser (RESI_RELA=1.e-6 par défaut).
      Si l'erreur constatée est supérieure à RESI_RELA, GCPC continue à itérer. De même, on pourrait demander à MUMPS
      d'effectuer des itérations de "raffinement" pour améliorer la solution (on ne le fait pas encore).
      Si, après ces itérations, l'erreur est encore supérieure à RESI_RELA, le code s'arrête en erreur fatale.


   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI

   IMPACT_DOCUMENTAIRE : OUI
     DOC_D : D4.06.11
       EXPL_: donner la signification des valeurs stockées dans la SD SOLVEUR

     DOC_D : D4.06.07
       EXPL_: modif SD NUME_DDL :
              ajout de l'objet facultatif .NSLV : OJB S V K24 LONG=1
                                  1 -> SOLVEUR
              Cet objet est obligatoire si MUMPS

     DOC_U : U4.50.01 (mot clé SOLVEUR)
       EXPL_: ajouter la possibilité : MUMPS,
             - mots clés déjà connus pour d'autres solveurs :
               SYME            = /OUI /NON
               # erreur relative maximum autorisée
               RESI_RELA = eps   [R]   (defaut=1.e-6 sauf pour STAT_NON_LINE et DYNA_NON_LINE : -1)
                  Si RESI_RELA <= 0, on ne controle pas la qualité de la solution !
                  mais c'est sensé être plus rapide.

             - propres à MUMPS :
               # choix de l'algorithme de résolution :
               TYPE_RESOL      =   ktypr  [defaut='AUTO']
                  / 'NONSYM' : matrice non-symétrique (utilisable aussi avec des matrices symétriques)
                  / 'SYMGEN' : matrice symétrique "générale" (c'est à dire pas forcément définie positive)
                               C'est le cas "général" aster des matrices symétriques lorsque l'on a des
                               conditions cinématiques dualisées.
                  / 'SYMDEF' : matrice symétrique définie positive.
                               Cet algorithme peut etre utilisé si TOUTES les conditions cinématiques
                               sont données via la commande AFFE_CHAR_CINE.
                  / 'AUTO'   : choix automatique fait par le code :
                     - NONSYM pour les matrices non-symétriques
                     - SYMGEN pour les matrices symétriques



               PCENT_PIVOT     =SIMP(statut='f',typ='I',defaut=20,),
               # PCENT_PIVOT (défaut 20) est le pourcentage de mémoire que réserve MUMPS pour pouvoir
                 faire ses pivotages tardifs. Si ce nombre st insuffisant, le solveur s'arrete en erreur
                 fatale ('<F> DIFFICULTE POUR FACTORISER : AUGMENTER LA VALEUR DE SOLVEUR/PCENT_PIVOT.').
                 Si il est trop grand, on "gache" de la mémoire.

             Recopier le Copyright MUMPS dans la doc U4.50.01

     DOC_U : U4.61.11 (commande NUME_DDL)
       EXPL_: commenter les mot clés METHODE=MUMPS et RENUM=SANS

     DOC_U : U4.55.01 (commande FACT_LDLT)
       EXPL_: commenter les mot clés TYPE_RESOL et PCENT_PIVOT

     DOC_U : U4.55.02 (commande RESO_LDLT)
       EXPL_: commenter le mot clé RESI_RELA


   VALIDATION :

     - ajout du test MUMPS01A :
                     ---------
       Un cube se déformant sous l'effet de la pesanteur.
       On compare le solveur MUMPS au solveur MULT_FRONT/METIS :
       => les résultats sont identiques à 1.e-13 près.
       Ce test valide les 3 variantes de la factorisation MUMPS:
          symétrique générale, symétrique définie et non-symétrique.
       Ce test valide MUMPS en réel  : charges dualisées + charges cinématiques
       Ce test dure 1.5 s

     - ajout du test MUMPS02A :
                     ---------
       Il s'agit d'un modele DPLAN_INCO (rectangle 10X10 quad8) pour lequel on
       impose tous les déplacements. Si on utilise le solveur par défaut (MULT_FRONT), le code s'arrête
       en erreur fatale : "pivot vraiment nul à la ligne ...".
       Avec MUMPS, on peut résoudre le problème en acceptant d'allouer un grand pourcentage de mémoire
       pour les pivotages tardifs (PCENT_PIVOT=250) et en acceptant une estimation de l'erreur de 1.e-5
       (contre 1.e-6 par défaut).
       Remarque : Je ne sais pas si l'estimation de l'erreur est bonne ou surestimée mais sur le noeud
                  observé, l'erreur est très faible (1.e-14)
       Ce test valide la "supériorité" de MUMPS vis à vis de MULT_FRONT pour les matrices difficiles.
       Ce test dure 2.5 s

     - ajout du test MUMPS03A :
                     ---------
       Il s'agit d'un test d'acoustique (en complexe)
       Ce test valide MUMPS avec les commandes éclatées : NUME_DDL+FACT_LDLT+RESI_LDLT
       Ce test valide MUMPS en complexe  : charges dualisées + charges cinématiques
       Ce test dure 1.5 s

   DETAILS

 Intégration du solveur MUMPS :

 1) Compilation des bibliothèque MUMPS (en -r8 -i4 : défaut)
    Cela parait naturel car les BLAS utilisés par MUMPS sont en i4 sur
    l'alphaserver.

 2) il faut une routine "aster" (en réalité 3) qui connaisse à la fois
    les commons JEVEUX et les type_derivés DMUMPS_STRUC et ZMUMPS_STRUC
    Cette routine ne peut être compilée que par un vrai compilateur f90.
    Cette routine utilise des déclarations INTEGER (pour Aster) et INTEGER*4 pour MUMPS.

    Remarque : en réunion de RTA, Christophe avait suggéré de programmer cette routine
    d'interface en "C". Après une courte reflexion, j'ai abandonné cette idée car, pour
    pouvoir traiter plusieurs matrices simultanément, je suis obligé de stocker plusieurs
    instances "mumps" dans des variables globales. Je me sers actuellement d'un COMMON
    fortran qui contient un tableau de 5 instances Mumps. Je ne sais pas faire la
    même chose en C.

    Pour gérer cette routine, JPL et MC ont modifié agla/astk/scripts d'installation pour :
      - prendre en compte du vrai fortran 90 : compilation et link
      - que la procédure d'installation intègre le fait que certains "packages"
        sont facultatifs. Par exemple, sur une machine locale sans compilateur f90,
        le package mumps ne sera pas compilé et sera donc indisponible (erreur <F>).

 4) modification du config.txt officiel:
      - ajout des include "mumps" pour la compilation
      - ajout des librairies "mumps" pour le "link"

 6) on permet MUMPS dans :
     - MECA_STATIQUE
     - STAT_NON_LINE (SOLVEUR et SOLV_NON_LOCAL)
     - DYNA_NON_LINE (SOLVEUR et SOLV_NON_LOCAL)
     - THER_LINEAIRE
     - THER_NON_LINE
     - NUME_DDL + FACT_LDLT + RESO_LDLT

 7) on accepte les charges dualisées et les charges cinématiques

 8) la correspondance des 3 étapes ASTER : NUMDDL, PRERES, RESOUD avec les 3
    étapes MUMPS (%JOB=1/2/3) n'est pas respectée :
      NUMDDL : on ne fait rien
      PRERES : on fait %JOB=1 et 2 (factorisation symbolique et numérique)
      RESOUD : on fait %JOB=3
      On y est obligés car on ne peut pas faire %JOB=1 tant que l'on ne sait pas
      si la matrice est réelle ou complexe et symétrique ou non.
      Dans Aster, un même NUME_DDL peut convenir à des matrices réelles et complexes
      symétriques et non-symétriques (car les matrices non-symétriques d'Aster
      ont une topologie symétrique et le stockage de MAT(J,I) est similaire au
      stockage de MAT(I,J)).
      Donc pour l'instant, à chaque fois que l'on fait une factorisation numérique,
      on recommence la factorisation symbolique.
      On pourrait sans doute améliorer cela (en se souvenant qu'une matrice a déjà
      été factorisée symboliquement) mais on peut aussi se demander (je n'ai pas
      encore "investigué" suffisamment) si la connaissance des valeurs de la matrice
      ne peut pas aider MUMPS dans sa factorisation symbolique (zéros sur la diagonale
      par exemple).

 9) Si l'on veut contrôler la qualité de la solution ou non (RESI_RELA > 0),
    on ne désalloue les gros objets %A, %IRN et %ICN entre les 2 étapes de la résolution : / PRERES / RESOUD
    Si l'on ne veut pas contrôler, on désalloue ces objets => un gain de mémoire (mais pas pour JEVEUX!)

10) on ne sait pas encore déterminer les "pivots nuls" avec MUMPS
    => on ne peut pas se servir de MUMPS pour :
        - MODE_ITER_SIMULT
        - la recherche des pertes d'unicité de solution dans STAT_NON_LINE

12) le calcul est fait en séquentiel, mais la parallélisation MPI est prévue
    dans la bibliothèque Mumps. Il faudra l'essayer plus tard : JPL, post-doc d'Olivier Boiteau ?

14) on peut traiter jusqu'à 5 matrices simultanément (plusieurs instances MUMPS)
    C'est un PARAMETER que l'on peut facilement modifier.

16) MUMPS n'est pas disponible sous LINUX (on cherche un compilateur gratuit et fiable ...)

18) Performances observées (il y a 3 mois) :
    18-a) mémoire : je n'ai rien comparé  (=> à faire)
    18-b) CPU :
      essai sur un cube 20X20X20 d'hexa8 (matrice symétrique):

      * MECA_STATIQUE: 24.80 :0.67 :25.47 *   Mumps : charge dualisée + charge_cinématique
      * MECA_STATIQUE: 26.10 :0.18 :26.28 *   Mumps : charge_cinématique seule
      * MECA_STATIQUE: 18.37 :1.15 :19.52 *   Mult_front/metis : charge dualisée + charge_cinématique
      * MECA_STATIQUE: 17.90 :1.28 :19.18 *   Mult_front/metis : charge_cinématique seule

19) Avec Mumps, on peut forcer la résolution en "non symétrique" même si la matrice est symétrique.
    Cela peut etre essayé sur les systèmes linéaires difficiles à résoudre car l'algorithme s'autorise
    sans doute plus de pivotages (ceux qui perdent le caractère symétrique de la matrice).

20) Concernant la mémoire :
    La mémoire utilisée par MUMPS pour stocker la matrice initiale (stockée Morse) et sa factorisée n'est
    pas prise sur la mémoire JEVEUX. Elle est prise "ailleurs" par les ordres "ALLOCATE" faits par MUMPS.
    Ces ALLOCATE entrent en concurrence avec les "malloc" faits par le C ou les programmes python.
    Pour utiliser MUMPS en batch lorsque les matrices sont grosses, il faut donc se préoccuper de laisser
    de la mémoire à MUMPS : il ne faut pas tout donner à JEVEUX comme c'est fait aujourd'hui.
    (En réalité je crois que JEVEUX ne prend pas vraiment tout : il laisse quelques miettes ...)
    Ce problème est à instruire pour que ASTK permette à l'utilisateur de "partitionner" la mémoire
    utilisée par le "job".

21) Concernant les "doubles Lagranges" : Mumps permettant un pivotage tardif des équations, il est probable
    que la technique des "doubles Lagrange" ne lui sert à rien. On pourrait envisager de n'utiliser que des
    "simples Lagrange" si le solveur est MUMPS. Cela permettrait sans doute de gagner en performances pour
    les modélisations qui utilisent beaucoup de relations linéaires : LIAISON_MAILLE, ARLEQUIN, ...

  ----------------------------------------------------------------------------------------------
  - Copyrigth MUMPS   :
  ----------------------------------------------------------------------------------------------

   THIS FILE IS PART OF MUMPS VERSION 4.3.2
   This Version was built on Wed Nov 12 16:57:09 2003


 COPYRIGHT (c) 1996-2003 P. R. Amestoy, I. S. Duff, J. Koster,
                       J.-Y. L'Excellent

  CERFACS      , Toulouse    (France)  (http://www.cerfacs.fr)
  ENSEEIHT-IRIT, Toulouse    (France)  (http://www.enseeiht.fr)
  INRIA                      (France)  (http://www.inria.fr)
  PARALLAB     , Bergen      (Norway)  (http://www.parallab.uib.no)

 All rights reserved.

  Your use or distribution of the package implies that you agree
  with this License. Up-to-date copies of the MUMPS package can be
  obtained from the Web page http://www.enseeiht.fr/apo/MUMPS/

  This package is provided to you free of charge. It was
  initially based on public domain software developed during
  the European Esprit IV project PARASOL (1996-1999).

  THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
  EXPRESSED OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.

  Permission is hereby granted to use or copy this
  package provided that the Copyright and this License is
  retained on all copies and that the package is used
  under the same terms and conditions. User documentation
  of any code that uses this software should include this
  complete Copyright notice and this License.

  You can modify this code but, at no time shall the right
  or title to all or any part of this package pass to you.
  All information relating to any alteration or addition
  made to this package for the purposes of extending the
  capabilities or enhancing the performance of this package
  shall be made available free of charge to the authors for
  any purpose.

  You shall acknowledge (using references [1] and [2])
  the contribution of this package in any publication
  of material dependent upon the use of the package.
  You shall use reasonable endeavours to notify
  the authors of the package of this publication.


  [1] P. R. Amestoy, I. S. Duff and  J.-Y. L'Excellent (1998),
  Multifrontal parallel distributed symmetric and unsymmetric solvers,
  in Comput. Methods in Appl. Mech. Eng., 184,  501-520 (2000).
  An early version appeared as a Technical Report ENSEEIHT-IRIT (1998)
  and is available at http://www.enseeiht.fr/apo/MUMPS/.

  [2] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
  A fully asynchronous multifrontal solver using distributed dynamic
  scheduling, SIAM Journal of Matrix Analysis and Applications,
  Vol 23, No 1, pp 15-41 (2001).
  An  early version appeared as a Technical Report ENSEEIHT-IRIT,
  RT/APO/99/2 (1999)  and is available at http://www.enseeiht.fr/apo/MUMPS/.

  None of the text from the Copyright notice up to and
  including this line shall be removed or altered in any way.

--------------------------------------------------------------------------
CORRECTION AL 2005-071
   NB_JOURS_TRAV : 0.5
   INTERET_UTILISATEUR : OUI
   TITRE : Quel solveur utiliser pour la méthode XFEM  ?
   FONCTIONNALITE
   L'étude fournie par Samuel (test ssnv182a légèrement modifié), montre que la
   matrice d'un problème XFEM n'est pas positive (hors CL dualisées) : il y a des 0 sur la diagonale.

   Les 2 solveurs directs actuels (LDLT et MULT_FRONT) ne pivotant pas lors de la factorisation,
   Il peut arriver que l'on tombe sur un pivot nul sans que cela traduise un système singulier.

   C'est ce qui arrive avec cette étude. Avec le solveur LDLT, la factorisation va jusqu'au bout
   mais avec MULT_FRONT, on tombe sur un pivot nul.
   Remarque : pour les problèmes XFEM, il semble (d'après Samuel) que LDLT soit plus robuste que MULT_FRONT,
   mais je ne sais pas pourquoi ...

   J'ai utilisé le solveur MUMPS (qui pivote au cours de la factorisation) et la factorisation
   s'est bien passée (ainsi que la résolution). Cela confirme que MUMPS est un bon candidat pour
   etre le juge de paix entre les solveurs directs.

   DETAILS
   1) J'ai réussi à faire passer l'étude avec MUMPS mais il m'a fallu changer la valeur par défaut
      du mot clé PCENT_PIVOT : 20(défaut) -> 50.
      Cela prouve que les matrices XFEM ont besoin de beaucoup de pivotage.

   2) J'ai aussi remarqué que LDLT était plus lent que MUMPS (286s au lieu de 175s) mais
      qu'il pouvait passer avec beaucoup moins de mémoire : 16 Mw (au lieu de 100Mw) !

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   VALIDATION : RAS
   IMPACT_DOCUMENTAIRE : OUI
     DOC_U : U4.82.08
     EXPL_: expliquer que la méthode XFEM conduit à des matrices "difficiles" et qu'il faut
            parfois essayer plusieurs solveurs. MUMPS devrait normalement etre robuste pour
            cette modélisation.


========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST AJOUT mumps01a                      vabhhts J.PELLET            84     84      0
 CASTEST AJOUT mumps02a                      vabhhts J.PELLET            52     52      0
 CASTEST AJOUT mumps03a                      vabhhts J.PELLET            76     76      0
 CASTEST AJOUT zmat001a                     mcourtoi M.COURTOIS         215    215      0
 CASTEST AJOUT zmat002a                     mcourtoi M.COURTOIS         249    249      0
 CASTEST AJOUT zmat002b                     mcourtoi M.COURTOIS         216    216      0
 CASTEST AJOUT zmat003a                     mcourtoi M.COURTOIS         150    150      0
 CASTEST MODIF hsnv101a                      cibhhpd L.SALMONA          423      3      4
 CASTEST MODIF hsnv101b                      cibhhpd L.SALMONA          393      3      3
 CASTEST MODIF hsnv101c                      cibhhpd L.SALMONA          409      3      3
 CASTEST MODIF hsnv101d                      cibhhpd L.SALMONA          626      3      3
 CASTEST MODIF hsnv102a                      cibhhpd L.SALMONA          441      3      3
 CASTEST MODIF hsnv102b                      cibhhpd L.SALMONA          434      3      3
 CASTEST MODIF hsnv102c                      cibhhpd L.SALMONA          461      3      3
 CASTEST MODIF hsnv103a                      cibhhpd L.SALMONA          337      3      3
 CASTEST MODIF hsnv103b                      cibhhpd L.SALMONA          323      3      3
 CASTEST MODIF hsnv104a                      cibhhpd L.SALMONA          275      3      4
 CASTEST MODIF hsnv105a                      cibhhpd L.SALMONA          457      3      3
 CASTEST MODIF hsnv122a                      cibhhpd L.SALMONA          387      3      3
 CASTEST MODIF hsnv123a                      cibhhpd L.SALMONA          336      3      3
 CASTEST MODIF hsnv126a                      cibhhpd L.SALMONA          380      3      3
 CASTEST MODIF hsnv126b                      cibhhpd L.SALMONA          380      3      3
 CASTEST MODIF hsnv127a                      cibhhpd L.SALMONA          433      3      3
 CASTEST MODIF hsnv128a                      cibhhpd L.SALMONA          376      3      3
 CASTEST MODIF htna100a                      cibhhpd L.SALMONA          991      3      3
 CASTEST MODIF mtlp100a                      cibhhpd L.SALMONA          784     36     32
 CASTEST MODIF mtlp100b                      cibhhpd L.SALMONA          732     25     24
 CASTEST MODIF mtlp101a                      cibhhpd L.SALMONA          118     16     15
 CASTEST MODIF mtlp102a                      cibhhpd L.SALMONA          239     21     19
 CASTEST MODIF rccm01a                       cibhhlv L.VIVAN            199      1      1
 CASTEST MODIF sslv311a                      galenne E.GALENNE          199     29      1
 CASTEST MODIF ttna200a                      cibhhpd L.SALMONA          606      8     45
 CASTEST MODIF ttnp200a                      cibhhpd L.SALMONA          600      6     47
CATALOGU MODIF options/durt_elno_meta        cibhhpd L.SALMONA           30      1      1
CATALOGU MODIF options/meta_elno_temp        cibhhpd L.SALMONA           32      1      2
CATALOGU MODIF options/meta_init_elno        cibhhpd L.SALMONA           28      1      2
CATALOGU MODIF typelem/gener_me3d_3          cibhhpd L.SALMONA          578      2      2
CATALOGU MODIF typelem/gener_me3dg_3         cibhhpd L.SALMONA          360      2      2
CATALOGU MODIF typelem/gener_me_x            cibhhpd L.SALMONA          563      2      2
CATALOGU MODIF typelem/gener_me_xh           cibhhpd L.SALMONA          245      2      2
CATALOGU MODIF typelem/gener_me_xht          cibhhpd L.SALMONA          145      2      2
CATALOGU MODIF typelem/gener_me_xt           cibhhpd L.SALMONA          147      2      2
CATALOGU MODIF typelem/gener_meax_2          cibhhpd L.SALMONA          558      2      2
CATALOGU MODIF typelem/gener_meaxs2          cibhhpd L.SALMONA          527      2      2
CATALOGU MODIF typelem/gener_mecpg2          cibhhpd L.SALMONA          361      2      2
CATALOGU MODIF typelem/gener_mecpl2          cibhhpd L.SALMONA          549      2      2
CATALOGU MODIF typelem/gener_medpg2          cibhhpd L.SALMONA          363      2      2
CATALOGU MODIF typelem/gener_medpl2          cibhhpd L.SALMONA          565      2      2
CATALOGU MODIF typelem/gener_meshb3          cibhhpd L.SALMONA          427      2      2
CATALOGU MODIF typelem/gener_mv3d_3          cibhhpd L.SALMONA          409      2      2
CATALOGU MODIF typelem/gener_th3d_3          cibhhpd L.SALMONA          242      5     15
CATALOGU MODIF typelem/gener_th3dd3          cibhhpd L.SALMONA          213      5     15
CATALOGU MODIF typelem/gener_thax_2          cibhhpd L.SALMONA          205      5     16
CATALOGU MODIF typelem/gener_thaxd2          cibhhpd L.SALMONA          232      5     15
CATALOGU MODIF typelem/gener_thaxf2          cibhhpd L.SALMONA          128      5     15
CATALOGU MODIF typelem/gener_thpl_2          cibhhpd L.SALMONA          215      5     16
CATALOGU MODIF typelem/gener_thpld2          cibhhpd L.SALMONA          234      5     15
CATALOGU MODIF typelem/mecpqs4               cibhhpd L.SALMONA          497      2      2
CATALOGU MODIF typelem/mecptr3               cibhhpd L.SALMONA          535      2      2
CATALOGU MODIF typelem/mecptr6               cibhhpd L.SALMONA          531      2      2
CATALOGU MODIF typelem/medpqs4               cibhhpd L.SALMONA          508      2      2
CATALOGU MODIF typelem/medpqs8               cibhhpd L.SALMONA          512      2      2
CATALOGU MODIF typelem/medptr6               cibhhpd L.SALMONA          544      2      2
CATALOGU MODIF typelem/thaxtr6               cibhhpd L.SALMONA          197      5     16
CATALOGU MODIF typelem/thpltr6               cibhhpd L.SALMONA          207      5     16
CATALOGU SUPPR options/durt_elga_meta        cibhhpd L.SALMONA           30      0     30
CATALOGU SUPPR options/meta_elga_temp        cibhhpd L.SALMONA           32      0     32
CATALOGU SUPPR options/meta_init             cibhhpd L.SALMONA           28      0     28
CATALOPY MODIF commande/calc_meta            cibhhpd L.SALMONA           47      3      3
CATALOPY MODIF commande/dyna_non_line        vabhhts J.PELLET           314     13      3
CATALOPY MODIF commande/fact_ldlt            vabhhts J.PELLET            52      6      2
CATALOPY MODIF commande/macro_matr_asse      vabhhts J.PELLET            97      2      2
CATALOPY MODIF commande/meca_statique        vabhhts J.PELLET            95     14      2
CATALOPY MODIF commande/nume_ddl             vabhhts J.PELLET            44      5      2
CATALOPY MODIF commande/reso_ldlt            vabhhts J.PELLET            41      3      1
CATALOPY MODIF commande/stat_non_line        vabhhts J.PELLET           277     13      3
CATALOPY MODIF commande/ther_lineaire        vabhhts J.PELLET            92      7      2
CATALOPY MODIF commande/ther_non_line        vabhhts J.PELLET           114      7      2
CATALOPY MODIF commun/c_comp_incr           mcourtoi M.COURTOIS         310      6      1
 FORTRAN AJOUT algeline/creso3               vabhhts J.PELLET           116    116      0
 FORTRAN AJOUT algeline/detmat               vabhhts J.PELLET            35     35      0
 FORTRAN AJOUT algorith/nmzmat              mcourtoi M.COURTOIS         122    122      0
 FORTRAN MODIF algeline/op0014               vabhhts J.PELLET           203     29     13
 FORTRAN MODIF algeline/op0015               vabhhts J.PELLET           195     25      7
 FORTRAN MODIF algeline/preres               vabhhts J.PELLET           217     17      1
 FORTRAN MODIF algeline/resoud               vabhhts J.PELLET           207      8      3
 FORTRAN MODIF algorith/cfimp1                mabbas M.ABBAS            195      6     14
 FORTRAN MODIF algorith/cfimp2                mabbas M.ABBAS            186      4      1
 FORTRAN MODIF algorith/cfimp3                mabbas M.ABBAS            170      7      4
 FORTRAN MODIF algorith/cresol               vabhhts J.PELLET           314     26      8
 FORTRAN MODIF algorith/mestat               vabhhts J.PELLET           304      8      8
 FORTRAN MODIF algorith/nmcomp              mcourtoi M.COURTOIS         678      9      7
 FORTRAN MODIF algorith/nmdeze               cibhhpd L.SALMONA           97      2      2
 FORTRAN MODIF algorith/nmdorc              mcourtoi M.COURTOIS         499      7      6
 FORTRAN MODIF algorith/nmvpir                mabbas M.ABBAS            597      7      4
 FORTRAN MODIF algorith/op0025               vabhhts J.PELLET           338      7      5
 FORTRAN MODIF algorith/op0046               vabhhts J.PELLET           277      6      1
 FORTRAN MODIF algorith/op0070               vabhhts J.PELLET           841      5      1
 FORTRAN MODIF algorith/op0186               vabhhts J.PELLET           640      5      2
 FORTRAN MODIF algorith/smevol               cibhhpd L.SALMONA          323     23    108
 FORTRAN MODIF algorith/te0350               cibhhpd L.SALMONA          224     21      4
 FORTRAN MODIF assembla/asmatr               vabhhts J.PELLET           250     15      3
 FORTRAN MODIF assembla/numero               vabhhts J.PELLET           328     11      2
 FORTRAN MODIF assembla/op0011               vabhhts J.PELLET           157     33     11
 FORTRAN MODIF assembla/profma               vabhhts J.PELLET            96      9      1
 FORTRAN MODIF calculel/thaclm               cibhhpd L.SALMONA          916      2      2
 FORTRAN MODIF elements/gcour2               galenne E.GALENNE          464     22     18
 FORTRAN MODIF elements/metau1               cibhhpd L.SALMONA          137     16      6
 FORTRAN MODIF elements/metau2               cibhhpd L.SALMONA          124     19     13
 FORTRAN MODIF elements/te0064               cibhhpd L.SALMONA          146     19     45
 FORTRAN MODIF elements/te0067               cibhhpd L.SALMONA          143     31     50
 FORTRAN MODIF elements/te0083               cibhhpd L.SALMONA          143      1      1
 FORTRAN MODIF elements/te0100               cibhhpd L.SALMONA          305     25      6
 FORTRAN MODIF elements/te0113               cibhhpd L.SALMONA          231     20      3
 FORTRAN MODIF elements/te0121               cibhhpd L.SALMONA          214     21      3
 FORTRAN MODIF elements/te0139               cibhhpd L.SALMONA          291     22      5
 FORTRAN MODIF elements/te0320               cibhhpd L.SALMONA          140     37     55
 FORTRAN MODIF elements/te0321               cibhhpd L.SALMONA          133     24     40
 FORTRAN MODIF elements/te0353               cibhhpd L.SALMONA          423     45     21
 FORTRAN MODIF elements/te0358               cibhhpd L.SALMONA          426     38     17
 FORTRAN MODIF elements/te0539               cibhhpd L.SALMONA          337     22      5
 FORTRAN MODIF elements/te0546               cibhhpd L.SALMONA          289     23      6
 FORTRAN MODIF elements/te0551               cibhhpd L.SALMONA           99     10     15
 FORTRAN MODIF elements/te0552               cibhhpd L.SALMONA          103     11     15
 FORTRAN MODIF modelisa/drz13d               cibhhlv L.VIVAN            359     14      2
 FORTRAN MODIF postrele/rc3201               cibhhlv L.VIVAN            568      8     13
 FORTRAN MODIF postrele/rc32ac               cibhhlv L.VIVAN            425     30     19
 FORTRAN MODIF supervis/ibbase              mcourtoi M.COURTOIS         219      4      1
 FORTRAN MODIF utilitai/copisd               vabhhts J.PELLET           497      7      1
 FORTRAN MODIF utilitai/detrsd               vabhhts J.PELLET           512     18      3
 FORTRAN MODIF utilitai/dismms               vabhhts J.PELLET           157      9      1
 FORTRAN MODIF utilitai/dismnu               vabhhts J.PELLET           135     18      1
 FORTRAN MODIF utilitai/op0194               cibhhpd L.SALMONA          131      7      7
  PYTHON MODIF Macro/macro_matr_asse_ops     vabhhts J.PELLET           163     10      1


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :   10        1315      1315             +1315
 MODIF :  121       39275      1186    1038      +148
 SUPPR :    3          90                90       -90
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :  134       40680      2501    1128     +1373 
