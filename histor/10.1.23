

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR andriam      ANDRIAMBOLOLONA Hari   DATE 03/05/2010 - 14:12:19

--------------------------------------------------------------------------------
RESTITUTION FICHE 014600 DU 2010-02-10 14:04:24
TYPE evolution concernant Documentation (VERSION )
TMA : DeltaCad
TITRE
   doc absente pour les cas-tests sdls113 et sdlv124
FONCTIONNALITE
   Ces cas test permettent de valider le calcul de réponse harmonique avec DYNA_LINE_HARM. La
   solution de référence étant celle obtenue par calcul transitoire avec DYNA_LINE_TRAN.
   
   J'ai apporté quelques modifications après analyse de ces cas tests.
   
   Pour le cas test sdls113 :
   - j'ai supprimé le calcul modal qui ne sert à rien pour ce cas test
   
   Pour le cas test sdlv124 :
   - la solution de référence choisie pour le calcul de réponse harmonique avec des matrices
   projetées sur base modale a été celle obtenue par un calcul transitoire sur base modale
   qui n'est qu'une approximation de la solution exacte. Par conséquent, j'ai supprimé le
   calcul de réponse transitoire sur base modale, et changé la référence en choisissant celle
   obtenue sur base physique.
   
   J'ai profité de cette fiche pour passer les deux cas tests en SDVERI = OUI, et modifier la
   référence de la solution en AUTRE_ASTER au lieu de ANALYTIQUE.
   
   Ils sont restés en PAR_LOT = NON.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V2.03.113, V2.04.124
VALIDATION
   Repasser les cas tests en question
--------------------------------------------------------------------------------
RESTITUTION FICHE 014998 DU 2010-04-26 15:19:33
TYPE evolution concernant Documentation (VERSION )
TITRE
   Doc de validation pour le cas test sdnd105
FONCTIONNALITE
   Ce cas test valide le calcul de réponse transitoire avec une non-linéarité de choc et
   possibilité de flambage de la paroi (DYNA_TRAN_MODAL / FLAMBAGE).
   
   La modélisation A traite le cas d'un choc entre un point matériel et une paroi fixe
   (obstacle de type PLAN_Y).
   La modélisation B traite le cas d'un choc entre deux points matériels mobiles (obstacle de
   type BI_PLAN_Y)
   
   Actuellement, il n'y a aucune relation entre les deux modélisations. Pour assurer une
   certaine cohérence, j'ai modifié les paramètres de choc de la deuxième modélisation afin
   d'avoir la même solution de référence pour les deux modélisations. Cela est possible en
   exploitant la symétrie du problème.
   Le temps cpu demandé pour la modélisation B a été augmenté en conséquence.
   
   J'ai modifié également les paramètres du pas adaptatif pour la résolution du problème avec
   DYNA_TRAN_MODAL. Cela a permis de diviser le nombre de pas de calcul par 5 pour la
   modélisation A.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V5.01.105
VALIDATION
   Repasser le cas test en question
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR boyere       BOYERE Emmanuel        DATE 03/05/2010 - 15:26:24

--------------------------------------------------------------------------------
RESTITUTION FICHE 014984 DU 2010-04-21 11:58:57
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Gestion du pas de temps avec DYNA_TRAN_MODAL
FONCTIONNALITE
   Un utilisateur a remarqué qu'avec la méthode en temps NEWMARK DYNA_TRAN_MODAL fait sa tête
   de mule et ne respecte pas les instructions du fichier de commande. 
   
   En effet, l'opérateur, quelle que soit la méthode d'intégration en temps, se base sur les
   fréquences de la base modale pour préconiser un pas de temps maximal (pour la méthode de
   NEWMARK 10 fois plus petit que la plus petite pulsation propre du système). Pour une
   méthode implicite c'est un principe de précaution très pessimiste. C'est pourquoi, pour
   cette méthode, la programmation était imaginée pour résumer la vérification à une simple
   alarme et pour laisser l'utilisateur responsable de son choix.
   
   Malheureusement une erreur de programmation a inversé la logique prévue et impose
   systématiquement le pas de temps calculé par DYNA_TRAN_MODAL en ignorant celui entré par
   l'utilisateur (sauf si celui ci est encore plus petit, ce qui est peu probable !).
   
   Je rétablis le fonctionnement qui était prévu à l'origine et qui est décrit dans la doc,
   c'est-à-dire qu'on prend toujours le pas de temps donné par l'utilisateur et on l'avertit
   s'il ne respecte pas le critère (plutôt strict) de l'opérateur.
   
   Le risque de résultats faux est négligeable puisque l'on prenait systématiquement un pas
   de temps plus petit que nécessaire. En revanche ce pouvait être une gêne pour
   l'utilisateur qui se pouvait se retrouver avec un échantillonnage  exagérément fin de la
   réponse.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sdld04a + astout sur DYNA_TRAN_MODAL
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 014807 DU 2010-03-18 06:54:57
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Pas de temps adaptatif dans Aster (augmentation)
FONCTIONNALITE
   Evolution du fonctionnement du schéma en temps ADAPT dans DYNA_TRAN_MODAL.
   La fiche a été résolue par Nicolas Greffet (cf. fiche 14906 - version 10.1.21)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sans objet
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desoza       DE SOZA Thomas         DATE 04/05/2010 - 13:13:14

--------------------------------------------------------------------------------
RESTITUTION FICHE 014979 DU 2010-04-20 16:25:36
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Detection de la dimension des surfaces de contact
FONCTIONNALITE
   Anomalie
   ========
   
   Dans un calcul 2D réalisé lors du stage benchmark NAFEMS. On a par erreur déclaré comme
   surface maître un groupe de mailles massives (et non de bord).
   
   Le calcul se passe sans problème et donne forcément des résultats inattendus !
   
   Correction
   ==========
   
   On écrit une nouvelle routine CFBORD. Celle-ci parcourt toutes les mailles de contact est
   vérifie que dim(maille) < dim(problème). Si ce n'est pas le cas, on émet un message
   d'alarme : 
   
   !---------------------------------------------------------------------------------------------------------------------------!
   !.<F>.<CONTACT2_11>.........................................................................................................!
   !...........................................................................................................................!
   !.Au.moins.une.des.mailles.de.contact.que.vous.avez.définies.est.de.dimension.3,.or.la.dimension.de.votre.problème.est.:.3..!
   !.Cette.maille.n'est.donc.pas.une.maille.de.bord..Il.doit.y.avoir.une.erreur.dans.votre.mise.en.données.....................!
   !...........................................................................................................................!
   !.Conseil.:.................................................................................................................!
   !.Vérifiez.votre.AFFE_MODELE.et.le.type.de.vos.mailles.dans.la.définition.des.surfaces.de.contact...........................!
   !...........................................................................................................................!
   !...........................................................................................................................!
   !.Cette.erreur.est.fatale..Le.code.s'arrete.................................................................................!
   !---------------------------------------------------------------------------------------------------------------------------!
   
   Impact : limaco.f, dimmai.f, cfbord.f
   À faire en V9.
   
   On modifie la routine DIMMAI pour compléter les types de maille reconnus.
   
   Résultats faux
   ==============
   
   En 3D, le fait d'entrer une maille volumique à la place d'une maille de peau n'était pas
   dangereux car on finit toujours par tomber dans un ASSERT.
   
   En 2D, si l'on utilise la formulation continue, on ne craint rien non plus, car on
   n'arrive pas à construire l'élément de contact et on plante en ASSERT.
   
   En 2D, si l'on utilise la formulation discrète, on peut avoir des résultats faux mais :
   - si c'est la surface maître qui est massive, on va observer un contact bizarre qui
   devrait mettre la puce à l'oreille.
   - si c'est la surface esclave qui est massive, on risque d'avoir des interpénétrations,
   que l'on doit pouvoir observer visuellement.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 9.0.0
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 9.0.0
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   astout contact continu + discret
NB_JOURS_TRAV  : 0.3
--------------------------------------------------------------------------------
RESTITUTION FICHE 014978 DU 2010-04-20 16:15:48
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Condition unilatxc3xa9rale et MECA_STATIQUE
FONCTIONNALITE
   Anomalie
   ========
   
   Un utilisateur du SEPTEN s'est aperçu qu'une condition unilatérale imposée à
   l'aide de l'opérateur AFFE_CHAR_MECA/LIAISON_UNILATER n'était pas prise en compte lors
   d'un calcul MECA_STATIQUE.
   Pour Christophe : canal de remontée == téléphone.
   
   Correction
   ==========
   
   C'est normal car seul le solveur non-linéaire permet de résoudre des problèmes avec
   conditions unilatérales ... mais néanmoins, il faut absolument blinder ce cas. C'est à
   dire détecter dans MECA_STATIQUE l'utilisation d'une telle charge et les interdire.
   
   En V9, on détecte en plus des charges de type CONTACT les charges de type
   LIAISON_UNILATER. On en profite pour améliorer le message d'erreur et donner le nom de la
   charge fautive.
   
   En V10, on supprime la vérification dans MECA_STATIQUE car il n'est plus possible de se
   tromper. Le superviseur arrête l'utilisateur à cause d'une erreur de syntaxe (typage des SD).
   
   Documentation
   =============
   
   Dans la doc U4.44.11, on précise en V9 seulement que les charges de type LIAISON_UNILATER
   ne sont utilisables qu'avec STAT_NON_LINE ou DYNA_NON_LINE.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.44.11
VALIDATION
   test joint
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 014976 DU 2010-04-20 14:43:45
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Composante GLI de VALE_CONT en formulation continue
FONCTIONNALITE
   Anomalie
   ========
   
   Lors du stage sur le benchmark NAFEMS, on s'est aperçu que la composante du champ
   VALE_CONT donnant le glissement est non nulle en des endroits où il n'y a pas contact.
   
   Correction
   ==========
   
   Cela ne se produisait qu'en formulation 'CONTINUE'. On calculait systématiquement le
   glissement sans se soucier du statut de contact.
   Il faut initialiser à 0 ce champ pour les points non contactants.
   
   Impact : mmmres.f
   À faire en V9.
   
   Conséquence sur les résultats
   =============================
   
   On obtenait des valeurs fausses (au lieu de 0) sur les noeuds qui n'étaient pourtant pas
   en contact. De même lorsqu'il n'y avait pas de frottement, le glissement était aussi non nul.
   Cela pouvait porter à confusion.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test perso
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR berard       BERARD Alexandre       DATE 04/05/2010 - 13:13:15

--------------------------------------------------------------------------------
RESTITUTION FICHE 014993 DU 2010-04-26 05:35:34
TYPE anomalie concernant Code_Aster (VERSION 10.4)
TITRE
   En NEW10.1.21, le cas-test zzzz261a s'arrete anormalement sur Rocks, Calibre 4 et 5.
FONCTIONNALITE
   Dans le traitement de la fiche issue14926, une modification syntaxique a été effectuée au sein de la 
   commande PROJ_CHAMP : il a été procédé au remplacement du mot-clé CHAM_NO par le mot-clé CHAM_GD. 
   
   J'avais fait les modifications dans le cas-test zzzz261a... mais je ne les ai pas restituées !
   
   Les rectifications sont effectuées.
   
   
   
   En NEW10.1.21, le cas-test zzzz261a s'arrete anormalement sur Rocks, Calibre 4 et 5.
   A titre d'exemple, le message d'erreur obtenu sur Rocks est le suivant:
   "
   ==========================================
   ==========================================
   JDC.py : ERREUR A L'INTERPRETATION DANS ACCAS - INTERRUPTION
   >> JDC.py : DEBUT RAPPORT
   CR phase d'initialisation
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      ! Etape  PROJ_CHAMP ligne :  120 fichier :  fort.1  impossible d affecter un type !
      ! au resultat   File "./Python/Cata/cata.py", line 11065, in proj_champ_prod      !
      !     raise AsException("type de concept resultat non prevu")                     !
      !  AsException: type de concept resultat non prevu                                !
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   fin CR phase d'initialisation
   
   >> JDC.py : FIN RAPPORT
   JDC.py : ERREUR A LA VERIFICATION SYNTAXIQUE - INTERRUPTION
   >> JDC.py : DEBUT RAPPORT
   DEBUT CR validation : fort.1
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      ! - Il faut au moins un mot-clé parmi : ('FIN',)                      !
      ! - L'objet : DEBUT doit etre suivi d'un objet de la liste : ('FIN',) !
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      ! Etape  PROJ_CHAMP ligne :  120 fichier :  fort.1  impossible d affecter un type !
      ! au resultat   File "./Python/Cata/cata.py", line 11065, in proj_champ_prod      !
      !     raise AsException("type de concept resultat non prevu")                     !
      !  AsException: type de concept resultat non prevu                                !
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      Etape : PROJ_CHAMP    ligne : 120    fichier : 'fort.1'
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         ! Règle(s) non respectée(s) : - Il faut un et un seul mot-clé parmi : ('RESULTAT', !
         ! 'CHAM_GD')                                                                       !
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         ! Mots cles inconnus :CHAM_NO !
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         ! Concept retourné non défini !
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      Fin Etape : PROJ_CHAMP
   FIN CR validation :fort.1
   
   >> JDC.py : FIN RAPPORT
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   Perso
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR geniaut      GENIAUT Samuel         DATE 03/05/2010 - 17:23:58

--------------------------------------------------------------------------------
RESTITUTION FICHE 014944 DU 2010-04-15 08:39:06
TYPE express concernant Code_Aster (VERSION 10.1)
TITRE
   X-FEM : bug dans PROPA_FISS si K2 est nul
FONCTIONNALITE
   Problème :
   ----------
   
   Dans PROPA_FISS, si le K2 est nul sur un point, alors on plante en division par 0 dans le
   calcul de l'angle de bifurcation :
   beta = 2*atan(0.25*(k1/k2-abs(k2)/k2*sqrt((k1/k2)**2+8)))
   
   
   
   
   Solution :
   ----------
   
   Si k2 est nul, alors on renvoie beta = 0 (propagation en mode plan)
   
   impact : propa_fiss_ops.py
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test perso
NB_JOURS_TRAV  : 0.4
--------------------------------------------------------------------------------
RESTITUTION FICHE 014948 DU 2010-04-15 09:19:02
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
   En NEW10.1.19, le cas-test zzzz255a s'arrete en CPU_LIMIT_<S> sur Bull
FONCTIONNALITE
   Problème :
   -----------
   
   En NEW10.1.19, le cas-test zzzz255a s'arrete en CPU_LIMIT_<S> sur Bull.
   
   
   Solution :
   ----------
   
   le .para donne 250s alors que la dernière exécution du test sur bull donne :
   
    COMMAND.................:.......USER.:.....SYSTEM.:...USER+SYS.:....ELAPSED.*
   TOTAL_JOB................:.....236.45.:.......3.15.:.....239.60.:.....240.62.*
   
   
   Le test plante par manque de temps en fin de la commande PROPA_FISS
   ( * PROPA_FISS               :     209.99 :       2.21 :     212.20 :     212.26 )
   
   Il reste donc les commandes suivantes à exécuter :
    * CREA_CHAMP               :       0.07 :       0.00 :       0.07 :       0.08 *
    * POST_RELEVE_T            :       0.69 :       0.01 :       0.70 :       0.70 *
    * IMPR_TABLE               :       0.07 :       0.00 :       0.07 :       0.08 *
    * TEST_TABLE               :       0.01 :       0.00 :       0.01 :       0.01 *
    * TEST_TABLE               :       0.00 :       0.00 :       0.00 :       0.01 *
    * FIN                      :       0.14 :       0.12 :       0.26 :       0.26 *
   
   Je propose d'augmenter le .para à 300 s.
   
   (ce test est un test de PROPA_FISS, je pense que l'on pourrait aussi changer de
   responsable pour ce test -> J. MESSIER)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   zzzz255a
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR nistor       NISTOR Ionel           DATE 04/05/2010 - 08:28:01

--------------------------------------------------------------------------------
RESTITUTION FICHE 014995 DU 2010-04-26 09:37:38
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   test de performance pour MODE_ITER_INV
FONCTIONNALITE
   Descriptif:
   --------------------------
   L'objectif de cette fiche est d'introduire un nouveau cas-test de performance pour évaluer 
   en temps 
   l'opérateur de calcul modal MODE_ITER_INV. On enrichit donc le cas-test existant perf003 
   dédié à l'analyse 
   modale.
   
   Contexte:
   --------------------------
   Lors du nettoyage des cas-tests yyyy* fait par Nicolas Sellenet, on a supprimé un ancien 
   cas-test dit de "performance", le yyyy115 (analyse modale du BR de Civaux) qui met en oeuvre 
   l'opérateur MODE_ITER_INV. Même si largement testé dans d'autres cas-tests, cet opérateur 
   est peu utilisé en 
   rapport avec son "frère" MODE_ITER_SIMULT et aucun suivi de performance est réalisé à ce 
   jour.
   
   Solution:
   --------------------------
   On restitue une nouvelle modélisation pour cas-test de performance dédié à l'analyse modale, 
   perf003d, qui 
   met en jeu l'opérateur MODE_ITER_INV en utilisant le maillage identique de la modélisation 
   A: nb_ddl=104508.
   La taille de la mémoire consommée est la même par contre le temps CPU passe de 110 s pour 
   CALC_MODAL (basée 
   sur MODE_ITER_SIMULT) à 216 s pour MODE_ITER_INV. C'était attendu car ce dernier opérateur 
   utilise des 
   algorithmes plus coûteux afin de affiner la recherche des modes propres.
   
   Sources restituée:
   --------------------------
   perf003d.comm
   perf003d.mmed
   perf003d.para
   perf003d.datg - contient le script du maillage SALOME
   
   Impact documentaire:
   --------------------------
   V1.01.244
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V1.01.244
VALIDATION
   perf003d
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 014994 DU 2010-04-26 09:26:07
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Alarmes nouvelles dans les cas-tests de recalage en dynamique
FONCTIONNALITE
   Problème:
   -------------------------------
   Suite à la refonte de l'opérateur MACR_RECAL (fiche 11119 de Aimery), les fonctionnalités de 
   recalage en dynamique ont été aussi revues et mises à jours. Désormais, la lecture des 
   résultats expérimentaux (modes propres) est faite dans le fichier maître et non-plus dans le 
   fichier esclave comme avant. Ce changement a eu comme conséquence l'apparition de plusieurs 
   nouvelles alarmes jusqu'à maintenant "cachées" par le fait que la construction du modèle expérimental 
   et la lecture des résultats expérimentaux étaient faites dans le calcul esclave:
   - SUPERVIS_1 - on utilise PAR_LOT='OUI' car on injecte un peu de Python
   - PREPOST_59 - un petit problème avec la lecture d'un maillage GIBI
   - UTILITAI2_87 - incohérence de formats entre le maillage et le fichier des résultats
   le but de la fiche est de supprimer autant que possibles ces alarmes.
   
   Solution:
   -------------------------------
   - la première alarme est justifiée et on peut rien faire, on utilise encore pour un certain temps du Python 
   dans le fichier maître pour transformer une sd_table en Numeric.Array. D'après Aimery, un jour MACR_RECAL va 
   accepter en entrée des sd_table et alors cette alarme va sauter
   
   - pour les deux dernieres alarmes la solution est de stocker dans un seul fichier .unv (format IDEAS reclamé 
   par LIRE_RESU dans ces cas-tests) le maillage et les résultats expérimentaux. On a fait donc l'opération et 
   les deux dernières alarmes ne sont plus émises.
   
   Impact dans les sources:
   --------------------------------
   - suppression de sdls121a.23, sdls121b.23, sdls121c.23: les anciens maillages gibi du modèle expérimental
   - modification de sdls121a.2, sdls121b.2, sdls121c.2 pour lire le maillage et les résultats expérimentaux 
   dans le même fichier 
   
   Validation:
   ---------------------------------
   sdls121a,b,c
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sdls121a,b,c
NB_JOURS_TRAV  : 1.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 013144 DU 2009-02-18 12:37:40
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   Petite correction dans le catalogue NORM_MODE
FONCTIONNALITE
   Dans le catalogue de la commande NORM_MODE le mot clé NORME est facultatif sans valeur par défaut et j'ai cru 
   à une erreur. Après une analyse plus profonde, il se trouve qu'une regle UN_PARMI est plus forte et donc ce 
   mot-clé est bien facultatif, donc rien à corriger finalement.
   Fiche à solder sans restitution.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   neant
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 015016 DU 2010-04-30 08:26:28
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   Dimensionnement d'un tableau dans MACR_RECAL pour l'affichage de la fenxc3xaatre MAC
FONCTIONNALITE
   Contexte:
   ----------------------
   Lors d'un recalage dynamique avec MACR_RECAL on effectue l'appariement des modes (calcul de la matrice de MAC 
   entre les modes numériques et ceux expérimentaux). Une réponse dite "numérique" est ensuite extrait de cette 
   matrice (sa diagonale) pour la comparer à la réponse équivalent dite "expérimental"  (qui est une liste de 
   1.0 - appariement parfait).
   Actuellement la taille donnée la liste qui stocke la réponse numérique est égale au nombre des fréquences 
   numériques qui peut être plus grand que le nombre des fréquences expérimentales (on n'arrive pas toujours à 
   mesurer expérimentalement tous les modes calculés numériquement). Cela pourra provoquer des plantages dans 
   une boucle sur le nombre des fréquences expérimentales.
   
   Solution:
   ---------------------
   On initialise dans recal.py la taille de la réponse numérique avec le nombre des fréquences expérimentales 
   (toujours le même et toujours le plus petit)pour éviter un plantage
   
   Impact dans les sources:
   ----------------------
   recal.py
   
   Validation:
   ----------------------
   sdls121a,b,c
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sdls121a,b,c
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR proix        PROIX Jean-Michel      DATE 03/05/2010 - 13:56:43

--------------------------------------------------------------------------------
RESTITUTION FICHE 014965 DU 2010-04-18 18:08:21
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW10.1.19, le cas-test ssna303a s'arrete erreur_<F> sur Bull
FONCTIONNALITE
   Problème et correction :
   ________________________
   
   Le test SSNA303A plantait en erreur numérique sur Bull.
   Cela provenait de deux erreurs d'initilisation dans le cas RIGI_MECA_TANG, pour
   GDEF_HYPO_ELAS. 
   
   Le test SSNA303A était le seul à activer cette option ; les autres tests de GDEF_HYPO_ELAS
   fonctionnaient avec PREDICTION='ELASTIQUE'.
   
   On corrige en protégeant les accès aux valeurs pour RIGI_MECA_TANG.
   
   Détails :
   ___________
   
   diff fort_avant/nmsh1.f fort/nmsh1.f
   169c169,180
   <       CALL DAXPY(NDDL,1.D0,DEPLD,1,GEOMP,1)
   ---
   >       IF (RESI) THEN
   >          CALL DAXPY(NDDL,1.D0,DEPLD,1,GEOMP,1)
   > C        DEPLT : DEPLACEMENT TOTAL ENTRE CONF DE REF ET INSTANT T_N+1
   >          DO 20 I=1,NNO*NDIM
   >             DEPLT(I) = DEPLM(I) + DEPLD(I)
   >  20      CONTINUE
   >       ELSE
   >          DO 21 I=1,NNO*NDIM
   >             DEPLT(I) = DEPLM(I)
   >             DEPLD(I) = 0.D0
   >  21      CONTINUE
   >       ENDIF
   171,174d181
   < C     DEPLT : DEPLACEMENT TOTAL ENTRE CONF DE REF ET INSTANT T_N+1
   <       DO 20 I=1,NNO*NDIM
   <          DEPLT(I) = DEPLM(I) + DEPLD(I)
   <  20   CONTINUE
   
   De plus il y avait une erreur de transformation tenseur-vecteur dans prep2. La correction
   est :
   diff fort_avant/prep2.f fort/prep2.f
   97c97
   <       CALL TNSVEC(3,NDIM,EPSMT,EPSM,1.D0)
   ---
   >       CALL TNSVEC(6,NDIM,EPSMT,EPSM,1.D0)
   
   Validation :
   ____________
   
   le test SSNA303A lui -même plus
   tous les tests GDEF_HYPO_ELAS (hors zmat, qui n'utilise pas cette programmation) :
   ssnd106a
   ssnd106b
   ssnd107a
   ssnd108a (en modifiant PREDICTION pour appeler RIGI_MECA_TANG)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ssna303a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 015004 DU 2010-04-28 12:15:01
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   mieux tester SIMU_POINT_MAT dans le cas SUPPORT='POINT'
FONCTIONNALITE
   Cette fiche express fait suite à une remarque de Jacques sur un défaut de validation de
   CALC_POINT_MAT (appelée par SIMU_POINT_MAT dans le cas SUPPORT='POINT'). 
   
   "Si j'ai bien compris, calc_point_mat est une nouvelle commande. Pourquoi, y-a-t-il autant
   de mots clés non encore testés ? Peux-tu nous rassurer ?
   Jacques"
   
   Je vais tenter de nous rassurer ! Ci-joint la liste des mots-clés non testés, et la
   description de ce qui est fait pour tester chacun d'eux ou ne pas les tester (sans objet)
   
   
   calc_point_mat/archivage/arch_etat_init#oui
   calc_point_mat/archivage/cham_exclu#depl
   calc_point_mat/archivage/cham_exclu#sief_elga
   calc_point_mat/archivage/cham_exclu#vari_elga
   calc_point_mat/archivage/detr_nume_suiv#oui
   calc_point_mat/archivage/inst
   calc_point_mat/archivage/list_inst
   calc_point_mat/archivage/nume_init
   calc_point_mat/archivage/pas_arch
   calc_point_mat/archivage/precision
   
   => je supprime le mot-clé ARCHIVAGE de CALC_POINT_MAT (c'est d'un intérêt limité). 
   Ce mot-clé subsiste intégralement dans SIMU_POINT_MAT pour SUPORT='ELEMENT', par contre
   dans le cas SUPPORT='POINT', on peut définir ARCHIVAGE/LIST_INST (seul mot-clé) pour
   réduire un peu la taille de la table, en sortie de CALC_POINT_MAT.
   
   calc_point_mat/comp_elas/deformation#petit
   calc_point_mat/comp_elas/iter_inte_maxi
   calc_point_mat/comp_elas/resi_inte_rela
   => modification du test comp001i (ELAS_VMIS*) pour tester ces mots-clés. 
   
   calc_point_mat/massif/angl_euler
   calc_point_mat/comp_incr/reso_inte#implicite_reli
   calc_point_mat/comp_incr/type_matr_tang#perturbation
   calc_point_mat/newton/prediction#tangente
   => modification du test SSNV171B pour prendre en compte ces mots-clés
   
   calc_point_mat/comp_incr/unite
   calc_point_mat/comp_incr/nb_vari
   => modification du test ZMAT001C pour prendre en compte ces mot-clés (spécifiques ZMAT)
   
   par contre les mots-clé suivants sont sans utilité pour SUPPORT=POINT.
   Ces mots-clés sont toutefois laissés dans le catalogue car on utilise c_comp_incr.capy
   
   calc_point_mat/comp_incr/algo_1d#deborst
   calc_point_mat/comp_incr/algo_c_plan#deborst
   calc_point_mat/comp_incr/resi_debo_maxi
   => sans objet : l'algo de Deborst n'a pas d'intérêt dans CALC_POINT_MAT. Ajout d'une alarme.
   
   calc_point_mat/comp_incr/deformation#gdef_hypo_elas
   calc_point_mat/comp_incr/deformation#green_reac
   calc_point_mat/comp_incr/deformation#grot_gdep
   calc_point_mat/comp_incr/deformation#petit_reac
   calc_point_mat/comp_incr/deformation#simo_miehe
   => sans objet : CALC_POINT_MAT ne fonctionne actuellement qu'en petites déformations
   
   calc_point_mat/comp_incr/group_ma
   calc_point_mat/comp_incr/maille
   calc_point_mat/comp_incr/tout#oui
   => sans objet pour le point matériel
   
   calc_point_mat/comp_incr/reso_inte#runge_kutta_4
   => sans objet car limité aux poutres
   
   calc_point_mat/comp_incr/amplitude
   calc_point_mat/comp_incr/seuil
   calc_point_mat/comp_incr/taux_retour
   calc_point_mat/comp_incr/type_matr_tang#tangente_secante
   => sans objet car limité a GLRC (DKTG)
   
   calc_point_mat/convergence/arret#non
   calc_point_mat/convergence/depl_refe
   calc_point_mat/convergence/epsi_refe
   calc_point_mat/convergence/flux_hyd1_refe
   calc_point_mat/convergence/flux_hyd2_refe
   calc_point_mat/convergence/flux_ther_refe
   calc_point_mat/convergence/forc_refe
   calc_point_mat/convergence/plateau_iter
   calc_point_mat/convergence/plateau_rela
   calc_point_mat/convergence/resi_comp_rela
   calc_point_mat/convergence/resi_refe_rela
   calc_point_mat/convergence/sigm_refe
   calc_point_mat/convergence/type#plateau
   calc_point_mat/convergence/vari_refe
   => sans objet : le résidu par valeur de référence n'a pas de sens pour un point matériel
   
   calc_point_mat/etat_init/critere#absolu
   calc_point_mat/etat_init/critere#relatif
   calc_point_mat/etat_init/evol_noli
   calc_point_mat/etat_init/inst
   calc_point_mat/etat_init/inst_etat_init
   calc_point_mat/etat_init/nume_didi
   calc_point_mat/etat_init/nume_ordre
   calc_point_mat/etat_init/precision
   => etat_init est supprimé du catalogue de CALC_POINT_MAT, car inutile (on fournit
   SIGM_INIT, EPSI_INIT, VARI_INIT)
   
   calc_point_mat/increment/erre_temps#oui ??
   calc_point_mat/increment/nume_inst_fin
   
   calc_point_mat/newton/evol_noli
   calc_point_mat/newton/prediction#depl_calcule
   => sans objet, puisuqe l'on n'a pas de champ
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   tous les tests appelant SIMU_POINT_MAT
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR sfayolle     FAYOLLE Sebastien      DATE 04/05/2010 - 14:46:21

--------------------------------------------------------------------------------
RESTITUTION FICHE 015015 DU 2010-04-30 08:12:38
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   Correction matrice tangente GLRC_DM
FONCTIONNALITE
   Problème :
   ~~~~~~~~~~
   
   Christelle a identifiée un terme que j'ai oublié de supprimer dans le calcul de la matrice
   tangente de GLRC_DM. Les résultats ne devraient pas être modifiés seule la vitesse de
   convergence peut être améliorée.
   
   Solution :
   ~~~~~~~~~~
   
   Remplacer dans lcgldm.f
   
   QME33 = COF1*TREPS + MU*EPS33
   
   par
   
   QME33 = COF1*TREPS
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   cas test GLRC
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR sellenet     SELLENET Nicolas       DATE 04/05/2010 - 14:46:22

--------------------------------------------------------------------------------
RESTITUTION FICHE 015013 DU 2010-04-30 06:29:02
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   Oubli de certains tests yyyy
FONCTIONNALITE
   Problème :
   ----------
   Oubli de suppression de quelques cas test yyyy* (yyyy118* et yyyy102a).
   
   
   Solution :
   ----------
   On supprime.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   aucune
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST AJOUT perf003d                       nistor I.NISTOR           105    105      0
 CASTEST MODIF comp001i                        proix J-M.PROIX          347    276   1455
 CASTEST MODIF sdls113a                      andriam H.ANDRIAMBOLOLONA    419     14     13
 CASTEST MODIF sdls121a                       nistor I.NISTOR           121      1      1
 CASTEST MODIF sdls121b                       nistor I.NISTOR           110      1      1
 CASTEST MODIF sdls121c                       nistor I.NISTOR           113      1      1
 CASTEST MODIF sdlv124a                      andriam H.ANDRIAMBOLOLONA    566     28     21
 CASTEST MODIF sdnd105a                      andriam H.ANDRIAMBOLOLONA    217     10      7
 CASTEST MODIF sdnd105b                      andriam H.ANDRIAMBOLOLONA    215     50     10
 CASTEST MODIF sdns106e                     sfayolle S.FAYOLLE          333      1      1
 CASTEST MODIF ssna303a                        proix J-M.PROIX          272      1      1
 CASTEST MODIF ssnd108a                        proix J-M.PROIX          257      7      4
 CASTEST MODIF ssns106a                     sfayolle S.FAYOLLE          899     27    101
 CASTEST MODIF ssns106b                     sfayolle S.FAYOLLE         1436      1      1
 CASTEST MODIF ssns106c                     sfayolle S.FAYOLLE         1560      6      6
 CASTEST MODIF ssns106d                     sfayolle S.FAYOLLE          469      1      1
 CASTEST MODIF ssns106e                     sfayolle S.FAYOLLE          588      1      1
 CASTEST MODIF ssns106f                     sfayolle S.FAYOLLE          741      1      1
 CASTEST MODIF ssns106g                     sfayolle S.FAYOLLE          493      1      1
 CASTEST MODIF ssnv160e                        proix J-M.PROIX          195      1      2
 CASTEST MODIF ssnv171b                        proix J-M.PROIX          176     11     19
 CASTEST MODIF zmat001c                        proix J-M.PROIX           99     49    121
 CASTEST MODIF zzzz255a                      geniaut S.GENIAUT          120      3      2
 CASTEST MODIF zzzz261a                       desoza T.DESOZA           132      4      4
 CASTEST SUPPR yyyy102a.comm                sfayolle S.FAYOLLE           89      0     89
 CASTEST SUPPR yyyy118a.comm                sfayolle S.FAYOLLE          221      0    221
 CASTEST SUPPR yyyy118b.comm                sfayolle S.FAYOLLE          219      0    219
 CASTEST SUPPR yyyy118c.comm                sfayolle S.FAYOLLE          208      0    208
 CASTEST SUPPR yyyy118e.comm                sfayolle S.FAYOLLE          194      0    194
CATALOPY MODIF commande/calc_point_mat         proix J-M.PROIX           82      4     28
CATALOPY MODIF commande/propa_fiss           geniaut S.GENIAUT          160      2      2
CATALOPY MODIF commande/simu_point_mat         proix J-M.PROIX          131     15     11
 FORTRAN AJOUT modelisa/cfbord                desoza T.DESOZA           102    102      0
 FORTRAN MODIF algorith/mdptem                boyere E.BOYERE           222      3      2
 FORTRAN MODIF algorith/mmmres                desoza T.DESOZA           927     24     32
 FORTRAN MODIF algorith/nmcrli                 proix J-M.PROIX          330      6      1
 FORTRAN MODIF algorith/nmsh1                  proix J-M.PROIX          427      9      2
 FORTRAN MODIF algorith/nmzmat                 proix J-M.PROIX          198      9      3
 FORTRAN MODIF algorith/op0033                 proix J-M.PROIX          343     26      4
 FORTRAN MODIF algorith/op0046                desoza T.DESOZA           247      9     24
 FORTRAN MODIF algorith/pmdorc                 proix J-M.PROIX          185     33     22
 FORTRAN MODIF algorith/pminit                 proix J-M.PROIX          316     22      5
 FORTRAN MODIF algorith/prep2                  proix J-M.PROIX          101      2      2
 FORTRAN MODIF elements/lcgldm              sfayolle S.FAYOLLE          467      7     13
 FORTRAN MODIF modelisa/limaco                desoza T.DESOZA           189      5      1
  PYTHON MODIF Macro/propa_fiss_ops          geniaut S.GENIAUT          984      7      1
  PYTHON MODIF Macro/recal                    nistor I.NISTOR          1578      2      2
  PYTHON MODIF Macro/simu_point_mat_ops        proix J-M.PROIX          654      3      3
  PYTHON MODIF Messages/contact2              desoza T.DESOZA            56      9      1
  PYTHON MODIF Messages/mecastatique          desoza T.DESOZA            30      1      6


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :    2         207       207              +207
 MODIF :   43       17505       694    1940     -1246
 SUPPR :    5         931               931      -931
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :   50       18643       901    2871     -1970 
