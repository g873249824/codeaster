========================================================================
Version 11.2.27 du : 05/12/2012
========================================================================


-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR assire       ASSIRE Aimery          DATE 12/04/2012 - 10:38:40

--------------------------------------------------------------------------------
RESTITUTION FICHE 020028 DU 2012-11-29 15:54:07
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    Recette graphique Stanley
FONCTIONNALITE
   La recette Stanley a ete effectuee sur :
   - Calibre 7 avec la NEW10
   - Calibre 6 avec la NEW11.
   
   Un certain nombre d'anomalies a été observé :
   
   - Le label "sur déformée" n'apparaît pas
   Il faut remplacer les chaines _(" par _(u" dans les routines stanley_engine.py et
   ihm_parametres.py.
   A faire en NEW10 et NEW11.
   
   - Une ligne contenant /home/bodel est présente dans salomeVisu.py. C'est une scorie de
   debug et il faut  supprimer cette ligne ainsi que l'import shutil de la ligne qui précède.
   A faire en NEW11
   
   - Création d'un point ou d'un chemin (par exemple forma03a) : n'apparaît pas dans la liste
   ensuite.
   Suite au chantier des variables temporaires dans les macros, il restait des variables
   temporaires non autorisées dans sup_gmsh.py
   A faire en NEW11
   
   - Les autres problèmes sont soit non reproductibles soit non pertinents.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    Stanley
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 04/12/2012 - 10:56:34

--------------------------------------------------------------------------------
RESTITUTION FICHE 019956 DU 2012-11-19 10:18:32
TYPE aide utilisation concernant Code_Aster (VERSION 11.2)
TITRE
    Optimisation du post-traitement d un calcul
FONCTIONNALITE
   Demande d'Adrien Guery (MMC) pour optimiser un post-traitement sur une table issue d'un
   calcul avec STAT_NON_LINE.
   
   Résumé:
   
   Initialement, on enchaînait 44.752 commandes pour un temps d'environ 12.000s (par
   extrapolation).
   
   Le gain est obtenu en exécutant successivement plusieurs actions dans la même commande
   CALC_TABLE et car la création du tableau croisé est déjà programmée dans IMPR_TABLE.
   Le post-traitement se limite alors à CALC_TABLE suivi de 2 IMPR_TABLE, pour 20s au total.
   
   
   
   Post-traitement en STA11
   ------------------------
   
   En mpi 4 procs jusqu'au STAT_NON_LINE + CREA_TABLE::
   
   .  Exécution de Code_Aster. . . . . . .  12855.58. .  186.39.  13041.97. . 3372.30
   . .  Exécution de Code_Aster - rang #0. . 3189.54. . . 70.04. . 3259.58. . .  0.00
   . .  Exécution de Code_Aster - rang #1. . 3222.50. . . 37.78. . 3260.28. . .  0.00
   . .  Exécution de Code_Aster - rang #2. . 3222.07. . . 38.34. . 3260.41. . .  0.00
   . .  Exécution de Code_Aster - rang #3. . 3220.82. . . 39.87. . 3260.69. . .  0.00
   
   
   Manipulation de la table
   ------------------------
   
   La table initiale : 213582 lignes x 11 colonnes, 3 instants, 71194 noeuds de forme::
   
   . . RESULTAT. NOM_CHAM. INST. NUME_ORDRE. NOEUD. COOR_X. COOR_Y. COOR_Z. DX. DY. DZ
   
   
   On boucle sur les noeuds pour produire 2 tables de forme::
   
   . . INST. DX_N1. DX_N2. DX_N3...
   
   
   On souhaite faire la boucle sur 5594 noeuds, autant de colonnes.
   
   Post-traitement en séquentiel, LIRE_TABLE + CALC_TABLE::
   
   . . LIRE_TABLE :. 57.44
   . . LIRE_TABLE :.  0.61
   . . {
   . . CALC_TABLE :.  2.24
   . . CALC_TABLE :.  0.00
   . . CALC_TABLE :.  0.01
   . . CALC_TABLE :.  0.00
   . . CALC_TABLE :.  0.01
   . . CALC_TABLE :.  0.01
   . . CALC_TABLE :.  0.01
   . . DETRUIRE.  :.  0.00
   . . }...
   
   
   Vérifié sur 100 noeuds:
   
   - On vérifie que la mémoire n'augmente pas au cours des itérations.
   
   - Les temps des CALC_TABLE sont constants, seul le premier est significatif.
   
   
   Version initiale
   ~~~~~~~~~~~~~~~~
   
   Extrapolé à partir de 100 itérations, 2.1205s par itération : 11861s
   
   
   Réduction de la table
   ~~~~~~~~~~~~~~~~~~~~~
   
   En réduisant la table initiale aux colonnes INST, NOEUD, DX, DY : 5501s (tinit/2.16)
   
   dont temps de réduction de la table : 15.40s
   
   
   IMPR_TABLE/FORMAT='TABLEAU_CROISE'
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   
   Sur les 71194 noeuds (au lieu de 5594) : 241s (tinit/49)
   
   dont temps de réduction de la table : 15.40s et environ 112s par IMPR_TABLE.
   
   
   IMPR_TABLE/FORMAT='TABLEAU_CROISE' + filtre
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   
   On limite la table réduite aux 4 colonnes aux 5594 noeuds : 20.79s (tinit/570)
   
   dont temps de réduction + filtre de la table : 19.07s et 0.86s par IMPR_TABLE.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    post-traitement optimisxc3xa9
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 020016 DU 2012-11-28 14:18:41
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    Le temps de certaines commandes est absent du .resu
FONCTIONNALITE
   Pour stocker le temps de chaque commande dans l'objet timer, on 
   identifie la commande avec id(etape) qui représente l'adresse de 
   l'objet etape sous forme d'un entier.
   
   Sauf que depuis que l'on supprime les étapes dès qu'elles ont été 
   exécutées (issue11522, en 11.1.19), il peut arriver que l'étape 
   suivante ait la même adresse.
   Du coup, dans le timer, on n'ajoute pas une nouvelle entrée, on 
   cumule le temps passé avec la commande précédente.
   
   On avait :
    * LIRE_TABLE 0.69 *
    * CALC_TABLE 0.01 *
    * CALC_TABLE 0.01 *
   
   au lieu de :
    * LIRE_TABLE 0.07 *
    * LIRE_TABLE 0.61 *
    * CALC_TABLE 0.01 *
    * CALC_TABLE 0.01 *
    * CALC_TABLE 0.00 *
    * CALC_TABLE 0.01 *
   
   Les temps sont faibles, on voit que les deux premières commandes 
   ont été fusionnées. C'est le nom de la dernière commande qui était 
   affiché.
   
   Pour avoir un identifiant que l'on espère unique, on utilise le 
   moment de création de l'objet dont la résolution est de l'ordre de 
   la milliseconde (1ère discrimination) + numéro de la commande 
   (discriminant sauf pour les commandes cachées).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    test trivial
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 020031 DU 2012-12-03 07:27:14
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    Recette graphique Calc_Essai
FONCTIONNALITE
   Corrections de l'ihm de CALC_ESSAI suite à la recette graphique
   
   En version 11
   -------------
   
   - suppression de référence à un /home/...
   
   - KeyError: 'FONCTION' dans l'onglet "Traitement du signal": dans la méthode 
   'recup_objects', il faut réinitialiser les objets de stockage pour ne pas y 
   conserver des concepts qui ont été détruits.
   De plus, quand on détruit une table, il faut rafraîchir la liste des tables 
   (qui appelle 'recup_objects').
   A cette occasion, on a vu que 'recup_objects' était "appelée" à deux 
   endroits sans les parenthèses donc pas appelée. On suppose que c'est un 
   oubli.
   
   - problème avec la liste des couleurs des courbes quand il y en a plus de 
   12. Il suffit de prendre le modulo pour boucler sur les 12 couleurs connues.
   
   
   En version 10
   -------------
   
   - les labels ne sont pas accentués, problème d'affichage non reproduit.
   
   - problème de tracé de courbe dans xmgrace (courbe vide): un report n'avait 
   pas été reporté. Une liste d'abscisse pour N listes d'ordonnées.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    zzzz241a
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR delmas       DELMAS Josselin        DATE 04/12/2012 - 16:12:56

--------------------------------------------------------------------------------
RESTITUTION FICHE 020019 DU 2012-11-29 09:00:38
TYPE anomalie concernant Code_Aster (VERSION 11.2)
TITRE
    En NEW11.02.26, le cas-test plexu04a s'arrete en erreur fatale sur Aster4.
FONCTIONNALITE
   Problème :
   ========
   En NEW11.02.26, le cas-test plexu04a s’arrête en erreur fatale sur Aster4.
   
   Correction :
   ==========
   Il y a effectivement une lecture invalide due à un mauvais décalage dans caprec.f
   (AFFE_CHAR_MECA / RELA_CINE_BP / SIGM_BPEL='OUI') avec un risque de résultat faux
   lorsqu'on a plus d'un câble.
   
   De plus, on corrige dans le fichier de commande deux variables python qui doivent être
   des entiers mais sont affecté comme float.
   
   Impact :
   ======
   F:
   caprec.f
   
   TESTS:
   plexu04a.comm
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    liste des tests RELA_CINE_BP
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR bargelli     BARGELLINI Renaud      DATE 04/12/2012 - 16:12:57

--------------------------------------------------------------------------------
RESTITUTION FICHE 020012 DU 2012-11-28 08:58:45
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    bug dans la routine lcrous.f ? (loi de Rousselier)
FONCTIONNALITE
   Problème
   --------
   
   Dans la routine LCROUS, RIGDMO (scalaire) est modifié par appel à la routine lcprsv 
   (multiplication scalaire*vecteur), ce qui n'est donc pas normal et peut
   engendrer un écrasement mémoire.
   
   Solution
   --------
   
   De manière incroyablement futée, je propose de réaliser une bête multiplication
   scalaire*scalaire.
   
   Validation
   ----------
   
   Les 13 cas-tests utilisant ROUSSELIER sont relancés sur Calibre7 et Aster4, pas de
   problème soulevé.
   
   Impact
   ------
   
   lcrous.f
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssna113a, ssna120a...
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 04/12/2012 - 16:12:57

--------------------------------------------------------------------------------
RESTITUTION FICHE 020045 DU 2012-12-04 14:45:28
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    [FORUM] ssnp118u en arret anormal sur debian 6.0, ubuntu...
FONCTIONNALITE
   Le test ssnp118u s'arrête sur une erreur d'allocation d'un tableau local dans nmfihm 
   avec la remontée d'erreur :
   
   #3  0x. in malloc_printerr
   #4  0x. in nmfihm 
   #5  0x. in te0322 
   #6  0x. in te0000 
   #7  0x. in calcul 
   
   On ne comprend pas la remontée d'erreur : le tableau COOPG est déclarée 
   COOPG(NDIM,NPG) dans nmfihm.f.
   Or dans gedisc.f, il est déclaré COOPG(NDIM+1,NPG) mais appelé plus tard dans nmfihm. 
   Comment l'erreur du malloc peut se produire avant l'exécution de la première ligne de 
   nmfihm.f ?!
   
   Quoiqu'il en soit, la déclaration correcte en COOPG(NDIM+1,NPG) corrige le problème.
   Les 3 autres appelants de gedisc.f avaient pris cette précaution.
   
   D'autre part, le poids n'est pas rempli par gedisc.f !
   Ici, on se contente de l'initialiser à 0. Retirer la case réservée soit disant pour 
   le poids est plus risqué car je ne sais pas rapidement comment c'est utilisé dans les 
   lois de comportements...
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssnp118u
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desoza       DE SOZA Thomas         DATE 03/12/2012 - 18:32:50

--------------------------------------------------------------------------------
RESTITUTION FICHE 019984 DU 2012-11-23 09:22:35
TYPE aide utilisation concernant Code_Aster (VERSION 10.5)
TITRE
    Pour expertise : problxc3xa8me de contact
FONCTIONNALITE
   Contexte
   ========
   
   Un étude UTO avec contact et comportement élasto-plastique présente des difficultés :
   '''
   Suite à notre conversation d'avant hier à la journée de Salomé, je me permets de te
   soumettre mon modèle pour une expertise technique liée à un problème de contact :
   - modèle représenté : manchette dudgeonnée dans le fond du pressuriseur du palier 900,
   - maillage : quadratique (SEG3, TRIA6, QUAD8, HEXA20, PENTA15), avec une condition de symétrie
   - contact : manchette sur fond pressuriseur
   - méthode de contact : formulation continue sans frottement (formulation discrète
   induisant une surabondance des DDLs)
   - chargement : pression seule (pour l'instant)
   
   L'utilisation de la formation continue me permet d'extraire la pression de contact.
   Malheureusement, le calcul n'aboutit pas.
   '''
   
   Analyse
   =======
   
   Il s'agit d'une étude de grande taille avant tout (plus de 750 000 ddls).
   Les non-linéarités sont :
   - du contact sur une petite partie du modèle (moins de 250 noeuds)
   - un comportement élasto-plastique de Von Mises (écrouissage isotrope non-linéaire)
   
   Compte-tenu de ces spécificités, on applique les conseils suivants à l'étude :
   
   - modélisation sous-intégré (3D_SI). Seuls quelques PENTA15 dans le modèle resteront en
   intégration complète
   - condition aux limites cinématiques sur la face du pressuriseur soumise à des CL
   homogènes (diminue le nombre de ddls du problème)
   - prédiction 'ELASTIQUE' dans la méthode de Newton
   - j'ai aussi rétabli le critère de convergence à sa valeur par défaut sans réfléchir mais
   on peut certainement remettre 1.0E-5 comme dans les fichiers fournis
   
   Le temps de calcul étant essentiellement liés à la résolution des systèmes linéaires, il
   faut diminuer à tout prix le coût de cette phase. Pour cela, on choisit :
   
   - pour un calcul en V10 (NEW10) : solveur direct MUMPS, PCENT_PIVOT=30
   ==> c'est le seul solveur possible en V10 car le solveur itératif PETSc n'est pas
   utilisable en 10 pour des raisons trop longues à expliquer.
   ==> avec ces réglages le calcul nécessite environ 23000Mo de mémoire dans ASTK. Je ne l'ai
   pas exécuté jusqu'au bout mais il prendra au moins 8h
   
   - pour un calcul en V11 (NEW11_impi) : solveur itératif PETSC, PCENT_PIVOT=30,
   METHODE='NEWTON_KRYLOV'
   ==> !!ATTENTION!! pour utiliser le solveur PETSC il faut impérativement sélectionner dans
   ASTK une version Aster *_impi
   ==> avec ces réglages le calcul nécessite environ 3h30 et 15000Mo de mémoire dans ASTK
   
   Le fait que le calcul prenne beaucoup moins de temps en version 11 est lié :
   - à la méthode de résolution du contact qui implique moins d'itérations de Newton
   (changement des statuts à chaque itération de Newton, pas de point fixe sur la géométrie)
   - à l'utilisation de la méthode Newton-Krylov qui permet d'économiser des itérations dans
   le solveur itératif (sans ça le solveur PETSc sur ce cas est légèrement plus lent que le
   solveur MUMPS)
   
   Résultats
   =========
   
   J'ai post-traité rapidement quelques résultats. On n'observe pas de phénomène
   d'oscillations des contraintes, le champ de déplacement amplifié n'est pas aberrant.
   
   Conclusion
   ==========
   
   Le calcul tourne donc avec Code_Aster. Il est toutefois plus facile et surtout plus rapide
   de l'exécuter en version 11.
   
   Je joins à la fiche :
   - un fichier de commandes V10
   - un fichier de commandes V11
   
   J'ai utilisé les versions NEW10 et NEW11 car la stabilisation aura lieu très
   prochainement, ces versions sont donc quasiment des "STA".
   
   Pour information
   ================
   
   J'ai fait quelques tests en parallèle avec ce calcul sur la machine Ivanoé en NEW11. Il
   s'avère qu'il tire assez bien parti du parallélisme : 35 min sur 64 processeurs.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    xc3xa9tude
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 019987 DU 2012-11-23 13:25:03
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    En NEW11.02.25, le cas-test sslv139a est NOOK sur Rocks
FONCTIONNALITE
   Contexte
   ========
   
   En 11.2.25, le cas-test sslv139a est NOOK sur Rocks.
   Il avait déjà fait l'objet d'un ajustement de tolérance dans issue19770.
   
   Analyse
   =======
   
   Des essais avec la version officielle comme avec une version complètement reconstruite ont
   montré le côté "aléatoire" de ce test : sur 10 runs, certains sont OK d'autres NOOK.
   On a d'abord pensé à un problème lié à un noeud de calcul (les NOOK ne se produisant que
   sur un noeud en particulier) mais des tests supplémentaires n'ont pas permis de le confirmer.
   
   Ce qui a pu être vérifié : 
   
   - les matrices en entrée de MODE_ITER_SIMULT sont identiques (mode debug de calcul)
   - les déplacements en sortie (modes) ne le sont pas (en particulier les normes d'erreur
   varient beaucoup)
   - les valeurs propres sont identiques tout le temps
   - dans MODE_ITER_SIMULT (celui en fréquence) en INFO=2 on a des affichages qui diffèrent
   légèrement parfois (sortie de routine LAPACK ou ARPACK visiblement) mais je ne pense pas
   que ça porte à conséquence (car entre un run OK avec la version officiel et un run OK avec
   ma version j'ai aussi ces différences)
   
   Conclusion
   ==========
   
   Cette variabilité rend de plus difficile toute analyse plus poussée. Comme plusieurs
   personnes se sont déjà penchées sur le problème sans succès et qu'un run valgrind et un
   run avec vérification des initialisations n'ont rien découvert, on propose d'augmenter la
   tolérance du TEST_RESU problématique.
   
   Remarque : il s'agit peut être d'un problème matériel. De toute manière cette machine va
   être remplacée prochainement et une action de rebalayage des tolérances élevées
   (TOLE_MACHINE) est d'ores et déjà prévue.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sslv139a
NB_JOURS_TRAV  : 1.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR flejou       FLEJOU Jean Luc        DATE 12/03/2012 - 02:39:38

--------------------------------------------------------------------------------
RESTITUTION FICHE 020013 DU 2012-11-28 09:04:29
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    Bug dans la routine irrini.f ? (loi IRAD3M)
FONCTIONNALITE
   Dans la routine irrini.f :
            CALL LCPRMV(HOOK,VTMP1,DSIG)
   
   DSIG est un scalaire, il devrait être un vecteur.
   
   Cette routine sert à initialiser les incréments de contrainte pour l'algorithme de Newton
   interne à la ldc. Elle est appelée au début d'une itération de Newton.
   
   Ce n'est qu'une initialisation, meilleure elle est, mieux l'algo de Newton de la ldc converge.
   Tous les cas tests restent OK. Pour ssna118a on passe de 650sec à 620sec, pour les
   STAT_NON_LINE. Pour les autres tests, les temps restent inférieurs à 30sec.
   
   A faire en 10 et 11
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    passage tous les cas tests IRRAD3M
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR geniaut      GENIAUT Samuel         DATE 12/03/2012 - 05:04:30

--------------------------------------------------------------------------------
RESTITUTION FICHE 020021 DU 2012-11-29 09:11:17
TYPE anomalie concernant Code_Aster (VERSION 11.3)
TITRE
    En NEW11.02.26, le cas-test sslv315a est NOOK sur Rocks.
FONCTIONNALITE
   Problème :
   ----------
   
   En NEW11.02.26, le cas-test sslv315a est NOOK sur Rocks. 
   Le problème est lié à la fiche 19989. En effet, il avait été décidé d'augmenter une
   tolérance en NON_REGRESSION : 
   TOLE_MACHINE=3.E-6,
   
   Il semble que cela ne soit pas toujours suffisant. 
   
   
   Solution : 
   ----------
    
   On augmente TOLE_MACHINE à 2e-5.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sslv315a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR lefebvre     LEFEBVRE Jean-Pierre   DATE 12/04/2012 - 09:32:44

--------------------------------------------------------------------------------
RESTITUTION FICHE 020027 DU 2012-11-29 09:43:12
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    En NEW11.02.26, le cas-test sdlv128a s'arrxc3xaate en erreur fatale sur Calibre7.
FONCTIONNALITE
   Problème :
   ==========
   Le cas-test sdlv128a s'arrête en erreur fatale sur Calibre7 du type JEVEUX_62 :
   
      !  Erreur lors de l'allocation dynamique. Il n'a pas été possible d'allouer !
      !  une zone mémoire de longueur 9 Mo, on dépasse la limite maximum          !
      !  fixée à 561 Mo et on occupe déjà  553 Mo.                                !
      !  La dernière opération de libération mémoire a permis de récupérer 28 Mo. !
   
   Analyse :
   =========
   Lors de l'opération d'allocation de mémoire JEVEUX on contrôle si la mémoire cumulée reste
   inférieure à une limite qui est réactualisée régulièrement en fonction du VmSize. Dans le
   cas présent, on arrive à la limite JEVEUX, on enclenche une opération de libération des
   objets en
   choisissant uniquement ceux qui ne conduisent pas à une écriture. On obtient une taille
   cumulée qui est supérieure à l'espace que l'on veut allouer, mais on réactualise aussi la
   limite JEVEUX qui diminue.
   
   Correction effectuée :
   ======================
   On modifie la routine JJALLS pour vérifier que l'espace libéré après réactualisation est
   suffisant, sinon on relance une opération de libération sur tous les objets avec une
   éventuelle écriture sur disque.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sdlv128a + liste complxc3xa8te
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR nicolas      NICOLAS Gérald        DATE 12/03/2012 - 01:28:41

--------------------------------------------------------------------------------
RESTITUTION FICHE 020026 DU 2012-11-29 09:30:05
TYPE anomalie concernant Code_Aster (VERSION 11.2)
TITRE
    En NEW11.02.26, le cas-test zzzz319a est NOOK sur Rocks.
FONCTIONNALITE
   Le résultat NON_OK provient du fait que la variable de test est mal choisie dans la table
   ! Elle est quasiment nulle, donc ce n'est pas pertinent.
   On la change pour une qui reste valide.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 11.2.26
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V1.01.319
VALIDATION
    zzzz319a
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR sellenet     SELLENET Nicolas       DATE 12/04/2012 - 12:39:26

--------------------------------------------------------------------------------
RESTITUTION FICHE 020020 DU 2012-11-29 09:10:15
TYPE anomalie concernant Code_Aster (VERSION 11.2)
TITRE
    Variable non initialisxc3xa9e dxc3xa9tectxc3xa9e xc3xa0 l'exxc3xa9cution en NEW11.2.26
FONCTIONNALITE
   Problème :
   ----------
   Avec la version instrumentée avec l'option --check uninit, on détecte un problème dans la
   routine RECBGL :
   
   sdlv301a.o3780137:forrtl: severe (193): Run-Time Check Failure. The variable
   'recbgl_$LTORA' is being used without being defined
   sdlv301b.o3780685:forrtl: severe (193): Run-Time Check Failure. The variable
   'recbgl_$LTORA' is being used without being defined
   
   
   Solution :
   ----------
   Il faut initialiser LTORA à 1.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    aucune
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------
RESTITUTION FICHE 020014 DU 2012-11-28 11:47:06
TYPE express concernant Code_Aster (VERSION 10.5)
TITRE
    Routine plus appelee en 11.2.26
FONCTIONNALITE
   La routine GDFONC n'est plus appelée, il faut la supprimer.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    aucune
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR tardieu      TARDIEU Nicolas        DATE 12/03/2012 - 06:17:21

--------------------------------------------------------------------------------
RESTITUTION FICHE 019995 DU 2012-11-26 13:32:56
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    Performances en NEW11.2.25 : plexu04a degradxc3xa9
FONCTIONNALITE
   Problème :
   ----------
   Performances en NEW11.2.25 : plexu04a dégradé. La commande qui demande plus de temps est
   DEFI_CABLE_BP : + 20%.
   
   Solution :
   ----------
   En faisant un profiling de DEFI_CABLE_BP, on constate que la routine la plus souvent
   appelée est JELIRA, qui est utilisée pour explorer le maillage.
   On propose de remplacer l'usage de cette commande par la consultation directe de la
   collection contigüe. 
   Voila le gain de performance sur plexu04a:
   
   Avant :
    * DEFI_CABLE_BP            :       9.53 :       0.00 :       9.53 :       9.53 *
    * DEFI_CABLE_BP            :      26.68 :       0.02 :      26.70 :      26.71 *
   
   Après :
    * DEFI_CABLE_BP            :       0.28 :       0.01 :       0.29 :       0.29 *
    * DEFI_CABLE_BP            :       0.68 :       0.00 :       0.68 :       0.69 *
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    Passage des tests DEFI_CABLE_BP
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 020025 DU 2012-11-29 09:26:17
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    En NEW11.02.26, le cas-test ssnv219c est NOOK sur Rocks.
FONCTIONNALITE
   Problème :
   ----------
   En NEW11.02.26, le cas-test ssnv219c est NOOK sur Rocks. 
   Pas de modifications en version 11.2.26.  
   
   Solution :
   ----------
   Il s'agit d'une variabilité sur le calcul du taux de convergence du déplacement sur la
   surface de contact.
   Ce chiffre vient d'une régression linéaire. J'adapte la tolérance.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    Passage du test sur toutes les plate-formes
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 020035 DU 2012-12-03 12:08:15
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    Supprimer SD_VERI='OUI' dans certains tests
FONCTIONNALITE
   Problème :
   ----------
   Dans certains tests, l'ajout de SD_VERI='OUI' a provoqué une augmentation du temps CPU.
   
   Solution :
   ----------
   De manière à suivre de manière pertinente les performances de ces tests, on propose de
   supprimer SD_VERI='OUI' dans les tests suivants :
   sdls119b
   sdnv105a
   sdnv105c
   sdls121d
   miss06c
   ssnp158a
   sdll113c
   sdnv106a
   sdls114a
   miss02a
   wdnp101a
   miss06b
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    Passage des tests
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST MODIF miss02a                       tardieu N.TARDIEU          545      3      2
 CASTEST MODIF miss06b                       tardieu N.TARDIEU          838      3      2
 CASTEST MODIF miss06c                       tardieu N.TARDIEU          836      3      2
 CASTEST MODIF plexu04a                       delmas J.DELMAS           690      3      3
 CASTEST MODIF sdll113c                      tardieu N.TARDIEU          472      3      2
 CASTEST MODIF sdls114a                      tardieu N.TARDIEU          308      3      2
 CASTEST MODIF sdls119b                      tardieu N.TARDIEU          619      3      2
 CASTEST MODIF sdls121d                      tardieu N.TARDIEU          356      3      2
 CASTEST MODIF sdnv105a                      tardieu N.TARDIEU         1506      3      2
 CASTEST MODIF sdnv105c                      tardieu N.TARDIEU          952      3      2
 CASTEST MODIF sdnv106a                      tardieu N.TARDIEU          693      3      2
 CASTEST MODIF sslv139a                       desoza T.DESOZA           204      2      2
 CASTEST MODIF sslv315a                      geniaut S.GENIAUT          274      2      2
 CASTEST MODIF ssnp158a                      tardieu N.TARDIEU          341      3      2
 CASTEST MODIF ssnv219c                      tardieu N.TARDIEU          677      2      2
 CASTEST MODIF wdnp101a                      tardieu N.TARDIEU         1096      3      2
 CASTEST MODIF zzzz319a                      nicolas G.NICOLAS          265     16      5
 FORTRAN MODIF algeline/fettsd               tardieu N.TARDIEU          554     37      4
 FORTRAN MODIF algorith/fetrin               tardieu N.TARDIEU          640      7      3
 FORTRAN MODIF algorith/irrini                flejou J-L.FLEJOU         181     24     25
 FORTRAN MODIF algorith/lcrous                delmas J.DELMAS           412      3      3
 FORTRAN MODIF algorith/nmfihm                delmas J.DELMAS           299      3      3
 FORTRAN MODIF algorith/recbgl              sellenet N.SELLENET         411      2      1
 FORTRAN MODIF elements/gedisc                delmas J.DELMAS            43      3      2
 FORTRAN MODIF jeveux/jjalls                lefebvre J-P.LEFEBVRE       188     17     11
 FORTRAN MODIF jeveux/jjldyn                lefebvre J-P.LEFEBVRE       298      6      2
 FORTRAN MODIF modelisa/caprec                delmas J.DELMAS           502      9     10
 FORTRAN MODIF modelisa/projkm               tardieu N.TARDIEU          229     11      7
 FORTRAN SUPPR elements/gdfonc              sellenet N.SELLENET         100      0    100
  PYTHON MODIF Calc_essai/cata_ce           courtois M.COURTOIS        1228     12      1
  PYTHON MODIF Calc_essai/ce_calc_spec      courtois M.COURTOIS         828      7      6
  PYTHON MODIF Calc_essai/ce_calcul_expansion   courtois M.COURTOIS         337      1      6
  PYTHON MODIF Calc_essai/ce_ihm_expansion   courtois M.COURTOIS         349      2      2
  PYTHON MODIF Calc_essai/ce_ihm_parametres   courtois M.COURTOIS         939      2     11
  PYTHON MODIF Execution/E_ETAPE            courtois M.COURTOIS         272      7      3
  PYTHON MODIF Stanley/ihm_parametres         assire A.ASSIRE           704     10     10
  PYTHON MODIF Stanley/salomeVisu             assire A.ASSIRE           412      1      5
  PYTHON MODIF Stanley/stanley_engine         assire A.ASSIRE          3283     34     34
  PYTHON MODIF Utilitai/sup_gmsh              assire A.ASSIRE          1416     15     15


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :    0           0         0                +0
 MODIF :   38       24197       274     202       +72
 SUPPR :    1         100               100      -100
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :   39       24297       274     302       -28 
