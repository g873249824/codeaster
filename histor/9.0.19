

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 17/04/2007 - 22:47:59

--------------------------------------------------------------------------------
RESTITUTION FICHE 010780 DU 2007-04-16 07:16:33
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   Impression des messages : xc3xa9volutions et homogxc3xa9nxc3xa9isation python/fortran
FONCTIONNALITE
   Cette fiche a pour but de faire évoluer l'impression des messages.
   
   Pour l'impression depuis le fortran, on a :
   - U2MESG : routine la plus générale dont les arguments sont l'id du message, les tableaux
   de chaines de caractères, d'entiers et de réels
   - U2MESS : idem sans les tableaux
   - U2MESK, U2MESI, U2MESR : idem avec uniquement un des trois tableaux.
   
   A résorber : UTMESS, UTDEBM, UTFINM, UTIMPK, UTIMPI, UTIMPR.
   
   Pour l'impression depuis python (principalement pour les macros), on a :
   - UTMESS de Utilitai.Utmess : à l'ancienne syntaxe où l'on passe le texte du message.
   
   
   On supprime les traitements en doublon en python et fortran. En particulier, la liste des
   unités logiques sur lesquelles on boucle pour l'impression était définie dans U2MESG.f et
   Utmess.
   
   L'interface Fortran-Python est toujours UTPRIN dont les arguments changent et sont les
   memes que U2MESG (il n'y a plus la liste des unités logiques).
   
   Pour Python, on crée un nouvel utilitaire U2MESS dans Utilitai.Utmess (que l'on
   s'empressera de renommer UTMESS dès que le basculement aura été fait dans les macros). Il
   n'y a pas de variante K, I, R, les tableaux de valeurs étant optionnels.
   
   
   U2MESS(py) et U2MESG(f) se limitent à :
   - imprimer le message
   - lever l'exception ou déclencher un arret du code
   
   L'impression de message est commune et confiée à un objet Python interne : MessageLog
   instance unique de la classe MESSAGE_LOGGER.
   "log" car on prévoit de stocker des infos que l'on traitera ultérieurement à l'appel
   UTMESS proprement dit comme des éléments de contexte pouvant aider l'utilisateur à la
   compréhension du message...
   
   En pratique, seule la méthode print_message est utilisée par U2MESS/U2MESG (via UTPRIN)
   via la méthode __call__ comme raccourci pour simplifier l'appel.
   
   Le premier apport de ce fonctionnement est de restaurer la fonctionnalité d'impression de
   messages par morceaux (UTDEBM/UTFINM). Il suffit d'ajouter le caractère '+' au type de
   message pour indiquer qu'il sera compléter par un autre appel à UTMESS et qu'il ne doit
   pas etre imprimé tout de suite.
   L'impression du message sera effective lors du prochain appel à UTMESS sans le caractère
   de suite ('+').
   Exemple (fointe.f) :
   
      CALL U2MESK('A+', 'FONCT0_9',  1, VALK)  avec VALK(1)=nom de la fonction
      CALL U2MESK('A',  'FONCT0_10', 1, VALK)  avec VALK(1)=nom de la maille concernée
   
   ==> Erreur lors de l'interpolation de la fonction 'func'
       sur la maille 'MA1'
   
   Le fonctionnement est identique en Python :
   
      U2MESS('A+', 'FONCT0_9',  valk='func')
      U2MESS('A',  'FONCT0_10', valk='MA1')
   
   
   
   On en profite pour rajouter un découpage pour éviter les lignes trop longues.
   
   Remarque importante : L'utilisation des éléments de contexte n'est pas encore développée
   (il y a juste de quoi tester le bon fonctionnement). Cela impose de compléter le catalogue
   des messages et d'ajouter les traitements adéquats (qui seront probablement mis dans un
   module indépendant d'Utmess.py) et avant de les définir...
   
   
   
       
       class MESSAGE_LOGGER
        |  Classe gérant l'impression de messages.
        |  On ne crée qu'une instance de ce type.
        |  Cette instance est accessible via le module E_Global pour astermodule.c
        |  
        |  Methods defined here:
        |  
        |  __call__(self, *args, **kwargs)
        |      Raccourci pour simplifier l'appel depuis astermodule.c et UTMESS.
        |  
        |  __init__(self)
        |      Initialisation
        |  
        |  add_to_buffer(self, dictmess)
        |      Ajoute le message décrit dans le buffer en vue d'une impression
        |      ultérieure.
        |  
        |  context_concept(self, nom_concept)
        |  
        |  format_message(self, dictmess)
        |      Formate le message décrit dans un dico :
        |      'code'          : A, E, S, F, I
        |      'id_message'    : identification du message
        |      'corps_message' : texte
        |  
        |  get_message(self, code, idmess, dicarg)
        |      Retourne le texte du message dans un dictionnaire dont les clés sont :
        |      'code', 'id_message', 'corps_message'
        |  
        |  get_type_message(self, code)
        |      Retourne le type du message affiché.
        |      En cas d'erreur, si on lève une exception au lieu de s'arreter,
        |      on n'affiche pas le type de l'erreur pour ne pas fausser le diagnostic
        |  
        |  init_buffer(self)
        |      Initialise le buffer.
        |  
        |  list_unit(self, code)
        |      Retourne la liste des noms de fichiers (logiques) sur lesquels doit
        |      etre imprimé le message.
        |  
        |  print_buffer_content(self)
        |      Extrait l'ensemble des messages du buffer dans un dictionnaire unique,
        |      imprime le message, et vide le buffer pour le message suivant.
        |         - code : celui du message le plus grave (cf. dgrav)
        |         - id   : celui du premier message qui est affiché
        |         - corps : concaténation de tous les messages.
        |  
        |  print_message(self, code, idmess, valk=(), vali=(), valr=())
        |      Appelé par la routine fortran U2MESG ou à la fonction python UTMESS
        |      pour afficher un message.
        |      L'impression de ce message est différée si le `code` est suivi d'un "+".
        |         code  : 'A', 'E', 'S', 'F', 'I'
        |         idmess : identificateur du message
        |         valk, vali, valr : liste des chaines, entiers ou réels.
        |  
        |  use_context(self, ctxt_msg, idmess, dicarg)
        |      Prise en compte du context du message pour donner d'autres infos
        |      à l'utilisateur.
        |      ctxt_msg est un dictionnaire. Les clés traitées sont :
        |         - CONCEPT
   
   FUNCTIONS
       U2MESS(code, idmess, valk=(), vali=(), valr=())
           Utilitaire analogue à la routine fortran U2MESS/U2MESG avec les arguments
           optionnels.
              code   : 'A', 'E', 'S', 'F', 'I'
              idmess : identificateur du message
              valk, vali, valr : liste des chaines, entiers ou réels.
           
           Appel sans valeurs :                avec valeurs :
              U2MESS('A', 'SUPERVIS_55')          U2MESS('A', 'SUPERVIS_55', vali=[1, 2])
           
           Remarques :
              - Nommer les arguments permet de ne pas tous les passer.
              - Meme fonctionnement que U2MESG :
                 + appel à MessageLog
                 + puis exception ou abort en fonction du niveau d'erreur.
       
       UTMESS(code, sprg, texte)
           Conserver le temps de réalisé le basculement
       
       clean_string(chaine)
           Supprime tous les caractères non imprimables.
       
       cut_long_lines(txt, maxlen, sep='\n', l_separ=(' ', ',', ';', '.', ':'))
           Coupe les morceaux de `txt` (isolés avec `sep`) de plus de `maxlen`
           caractères.
           On utilise successivement les séparateurs de `l_separ`.
       
       force_enum(obj)
           Retourne `obj` si c'est une liste ou un tuple,
           sinon retourne [obj,]
       
       maximize_lines(l_fields, maxlen, sep)
           Construit des lignes dont la longueur est au plus de `maxlen` caractères.
           Les champs sont assemblés avec le séparateur `sep`.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : D6.04.01
VALIDATION
   asrest + dxc3xa9clenchement manuel d'erreurs
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 010781 DU 2007-04-16 11:27:35
TYPE express concernant Code_Aster (VERSION 2.x)
TITRE
   Valeur par défaut dans TEST_TABLE
FONCTIONNALITE
   En relisant la doc, on s'est aperçu que la PRECISION par défaut du test était à 1.2e-3 au
   lieu de 1.e-3 (valeur par défaut habituelle du mot-clé PRECISION).
   
   On met 1.E-3 comme partout ailleurs.
   
   Dans le test sslv04h, je mets 1.2e-3 car l'écart était (et est toujours) de 0.117% !
   
   Note : je réarrange les tests et une boucle dans RCVALB car je suis tombé a priori sur des
   problèmes d'optimisation... ce qui est curieux (louche) c'est que le problème apparait
   avec le compilateur g77 et intel !
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ras
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR delmas       DELMAS Josselin        DATE 17/04/2007 - 14:13:10

--------------------------------------------------------------------------------
RESTITUTION FICHE 010445 DU 2007-01-12 15:40:13
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TITRE
   Plantage de ERRE_ELEM_SIGM en mxc3xa9canique avec xc3xa9lxc3xa9ments de Barsoum
FONCTIONNALITE
   Le plantage se produit dans la routine calnor.f en 2D et en 3D qui permet de calculer la
   normale sortante d'un element en chaque point de gauss.
   
   Dans le cas des élements de Barsoum, la matrice jacobienne est singulière. Or la valeur du
   déterminant de la matrice est utilisé pour normer les vecteurs : on divise par zéro.
   
   La solution retenue est de traiter de manière particulière les éléments de Barsoum. Au
   lieu de conserver le noeud au quart dans le calcul de la normale, on le ramène au milieu
   de l'arête ; le jacobien n'est plus nul!
   
   Ces deux cas-tests (en 2D : sslp108a et en 3D : sslv134d) plantaient lorsqu'on ajoutait un
   ERRE_ELEM_SIGM. Ils passent avec la modification. On ajoute un test_resu (sur l'erreur
   absolue globale) dans chacun des cas-tests.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   passage cas-tests
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 010776 DU 2007-04-12 14:54:55
TYPE express concernant Code_Aster (VERSION 2.x)
TITRE
   Permettre tous les champs de type erreur dans Stanley
FONCTIONNALITE
   On souhaitait pouvoir manipuler tout les champs de type erreur dans Stanley. Seuls les
   champs ERRE_ELEM_SIGM et ERRE_ELNO_ELEM sont utilisables,  ERZ1_ELEM_SIGM, ERZ2_ELEM_SIGM,
   QIRE_ELNO_ELEM et QIRE_ELEM_SIGM manquaient.
   
   Le calcul des options ERZ1_ELEM_SIGM et ERZ2_ELEM_SIGM est conditionné par
   l'existence du champ DEPL (le champs de contraintes lissées est calculé par défaut).
   
   Le calcul du champ QIRE_ELEM_SIGM n'est pas conditionné, ce champ est issu de deux
   résultats donc il est impossible de la calculer par le biais de Stanley.
   
   Enfin le calcul du champ QIRE_ELNO_ELEM est conditionné par l'existence du champ
   QIRE_ELEM_SIGM.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   tests perso
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR kham         KHAM Marc              DATE 16/04/2007 - 17:26:58

--------------------------------------------------------------------------------
RESTITUTION FICHE 010631 DU 2007-03-12 08:05:24
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TITRE
   NEW9.0.12, les cas tests ssnv504i et j s'arretent en ERREUR_<F> (BR)
FONCTIONNALITE
   > SSNV504I
     --------
   
   pour ssnv504i (méthode continue avec glissière),
   la reprogrammation de la glissière "progressive" (fiche 
   10452) est moins contraignante qu'avant:
   les noeuds sont libres au départ et non plus forcément en 
   contact, ce qui fait que l'on a du flip-flop au tout début.
   
   pour passer ce cap difficile (non présent avant parce que 
   la glissière old version forcait le contact), il faut 
   augmenter ITER_CONT_MAXI=40 (au lieu de 20).
   
   > SSNV504J
     --------
   
   arret par manque de temps cpu sur bull (9.00.15)
   je mets le temps cpu à 3000s (au lieu de 2400s)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   cas-test
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 010699 DU 2007-03-27 07:30:11
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TITRE
   Test ssnv197c en version NEW9.0.14
FONCTIONNALITE
   le cas-test ne passait pas sur rocks à cause d'un terme:
   
   EXP(-BETA*EPSVP)
   
   qui explose.
   
   Je mets un test autour de ce terme pour prévenir des 
   valeurs infinies:
   
   AEXP=-BETA*EPSVP
   EXPTOL=LOG(R8MAEM())    % valeur numérique maximale tolérée
   IF (AEXP.LT.EXPTOL) THEN
     PC=PCO*EXP(-BETA*EPSVP)
   ELSE
     IRET=1  % et dans ce cas, on redécoupe le pas de temps
     RETURN
   ENDIF
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   cas-test
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 010700 DU 2007-03-27 07:37:57
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   ajout de variables internes dans camclay
FONCTIONNALITE
   $1
   à des fins de post-traitement, je propose pour la loi de 
   camclay d'ajouter dans la liste des variables internes 
   récupérées en sortie les paramètres suivants:
   
   V(3) = P'
   V(4) = Q
   V(5) = déformation plastique volumique
   V(6) = déformation plastique équivalente
   V(7) = indice des vides
   
   (V(1) = Pcr et V(2) = ind_pla étant déjà utilisés)
   
   $2
   Je valide sur un nouveau cas-test d'oedomètre SSNV202A en 
   0D avec comparaison des solutions avec flaq.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V6.04.202
VALIDATION
   ssnv202
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST AJOUT ssnv202a                         kham M.KHAM             327    327      0
 CASTEST MODIF sslp108a                       delmas J.DELMAS           231     69     49
 CASTEST MODIF sslv04h                      courtois M.COURTOIS         373      3      1
 CASTEST MODIF sslv134d                       delmas J.DELMAS          1328    868    843
 CASTEST MODIF ssnv197c                         kham M.KHAM             530      1      1
 CASTEST MODIF ssnv504i                         kham M.KHAM             213      3      5
 CASTEST MODIF ssnv504j                         kham M.KHAM             260      1      3
CATALOPY MODIF commande/test_table          courtois M.COURTOIS          60      2      2
CATALOPY MODIF commun/c_comp_incr               kham M.KHAM             349      2      2
       C MODIF supervis/astermodule         courtois M.COURTOIS        3629      9      5
 FORTRAN MODIF algorith/hujcri                  kham M.KHAM              57      8      2
 FORTRAN MODIF algorith/hujddd                  kham M.KHAM             299     15      2
 FORTRAN MODIF algorith/hujmid                  kham M.KHAM             230      2      2
 FORTRAN MODIF algorith/nmccam                  kham M.KHAM             967     80      7
 FORTRAN MODIF algorith/posvar                  kham M.KHAM             385     22      2
 FORTRAN MODIF modelisa/rcvalb              courtois M.COURTOIS          88     13     17
 FORTRAN MODIF utilifor/u2mesg              courtois M.COURTOIS         151     13     62
 FORTRAN MODIF utilitai/calnor                delmas J.DELMAS           339     98     26
 FORTRAN MODIF utilitai/fointe              courtois M.COURTOIS         341     30     32
 FORTRAN MODIF utilitai/fointr              courtois M.COURTOIS         273     24     25
 FORTRAN MODIF utilitai/folocx              courtois M.COURTOIS         148      6      6
  PYTHON AJOUT Messages/context_info        courtois M.COURTOIS          67     67      0
  PYTHON MODIF Execution/E_Global           courtois M.COURTOIS          71      6     11
  PYTHON MODIF Messages/compor1                 kham M.KHAM              77     18      2
  PYTHON MODIF Messages/compor1                 kham M.KHAM              77     18      2
  PYTHON MODIF Messages/fonct0              courtois M.COURTOIS         185    137     14
  PYTHON MODIF Messages/sdveri              courtois M.COURTOIS         144      4     80
  PYTHON MODIF Messages/supervis            courtois M.COURTOIS         271      5      5
  PYTHON MODIF Messages/utilitai2           courtois M.COURTOIS         382      1     45
  PYTHON MODIF Messages/utilitai6           courtois M.COURTOIS         448      1     65
  PYTHON MODIF Stanley/cata_champs            delmas J.DELMAS           233      8      4
  PYTHON MODIF Utilitai/Utmess              courtois M.COURTOIS         478    410     21
  PYTHON SUPPR Messages/utprin              courtois M.COURTOIS           0      0      0


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :    2         394       394              +394
 MODIF :   30       12617      1877    1343      +534
 SUPPR :    1           0                 0        +0
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :   33       13011      2271    1343      +928 
