

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desoza       DE SOZA Thomas         DATE 25/08/2008 - 18:22:44

--------------------------------------------------------------------------------
RESTITUTION FICHE 010553 DU 2007-02-21 15:29:53
TYPE evolution concernant Code_Aster (VERSION 2.x)
TITRE
   MN10 - CONTACT - Performances mxc3xa9thode continue
FONCTIONNALITE
   Anomalie
   ========
   
   Les cas-tests utilisant la méthode continue de contact présentent des temps plus long sur
   la machine Bull comme a pu l'observer Christophe lors du passage Alpha Server ==> Bull.
   
   Ainsi des tests comme SSNA102D présentent les temps suivants :
   
   SSNA102D
    ********************************************************************************
    * COMMAND                  :       USER :     SYSTEM :   USER+SYS :    ELAPSED *
    ********************************************************************************
    * == BULL ==
    * TOTAL_JOB                :     208.60 :       0.91 :     209.51 :     211.08 *
    ********************************************************************************
    * == CLPASTER ==
    * TOTAL_JOB                :      72.92 :       1.90 :      74.82 :      86.89 *
    ********************************************************************************
    * == CALIBRE4(CLAUT626) ==
    * TOTAL_JOB                :     198.06 :       0.98 :     199.04 :     199.21 *
    ********************************************************************************
    * == CALIBRE5(CLAU5AAA) ==
    * TOTAL_JOB                :     203.38 :       0.91 :     204.30 :     205.85 *
    ********************************************************************************
   
   Analyse
   =======
   
   Dans la fiche 10970, on a analysé avec des outils de profiling ces tests. Sur SSNA102D, on
   observe ceci :
   
     %    cumulative   self                 self     total           
     time   seconds   seconds     calls    s/call   s/call  name    
    75.33    108.43   108.43 3966286263     0.00     0.00  exisdg_
    10.27    123.22    14.78       3856     0.00     0.03  cnocns_
     1.17    124.91     1.69     378355     0.00     0.00  jjalls_
   
   Ni la routine exisdg, ni cnocns ne sont des routines de la méthode continue. Leur
   programmation n'est donc pas en cause (a priori). Par contre, on voit que exisdg est
   appelée 3966286263 fois. Et si on regarde par qui :
   
                 106.91    0.00 3910755200/3966286263     cnocns_ [10]
   [11]    75.3  108.43    0.00 3966286263         exisdg_ [11]
   
   On voit que c'est à cause ... de cnocns :
   
                  14.77  107.62    3852/3856        callam_ [9]
   [10]    85.1   14.78  107.73    3856         cnocns_ [10]
   
                   0.00  123.25    3852/3852        mmmbca_ [8]
   [9]     85.6    0.00  123.25    3852         callam_ [9]
   
   
   Ce sont donc mmmbca et callam (deux routines de la méthode continue) qui sont la cause du
   grand nombre d'appels à exisdg.
   
   En regardant ce que l'on cherche à faire dans mmmbca (boucle de point fixe sur les statuts
   de contact), on voit que callam sert à extraire du champ de déplacements DEPPLU la valeur
   du multiplicateur de contact dans une maille donnée en un point de contact donné.
   Or mmmbca boucle sur les mailles puis sur les points de contact de la maille et l'appel à
   callam se trouve dans la seconde boucle.
   
   Une possibilité est donc de découper callam afin de :
   - réaliser les opérations invariantes en dehors des boucles (transformation d'un CHAM_NO
   en CHAM_NO_S)
   - remonter le gros de l'appel d'un niveau de boucle puisqu'une grande partie de ce qui est
   fait dedans ne dépend pas du point de contact (l'extraction des multiplicateurs de contact
   en chaque noeud de la maille courante).
   
   
   Résultats
   =========
   
   Sur SSNA102D :
   
    ********************************************************************************
    * COMMAND                  :       USER :     SYSTEM :   USER+SYS :    ELAPSED *
    ********************************************************************************
    * == BULL ==
    * TOTAL_JOB                :      22.32 :       1.46 :      23.77 :      24.03 *
    ********************************************************************************
    * == CLPASTER ==
    * TOTAL_JOB                :      18.63 :       1.73 :      20.36 :      20.44 *
    ********************************************************************************
   
   Cette petite modification permet ainsi de retrouver un temps correct sur Bull et
   quasi-identique sur chaque plate-forme. On a partiellement répondu à la fiche dans la
   mesure où le temps initialement beaucoup plus faible sur Clpaster reste inexpliqué (cela
   semble tournait autour des appels à exisdg, qui utilise la fonction intrinsèque IAND).
   On gagne en moyenne un facteur 2 dès que l'on fait quelques itérations de
   contact/frottement (au sens point fixe).
   
   Sur un astout méthode continue :
   
   ** Avant                               Temps CPU   Temps SYS   CPU + SYS
         65     64          1               9613.44      287.38     9900.82
   
   ** Après                               Temps CPU   Temps SYS   CPU + SYS
         65     65          0               6400.93      310.13     6711.06
   
   On voit que ssnv128m, le seul cas-test méthode continue cassé (manque de mémoire) s'est
   corrigé tout seul car on ne fragmente plus la mémoire (on créait et détruisait en
   permanence le CHAM_NO_S créé à partir du champ de déplacement)
   
   Impacts
   =======
   
   (M) : mmmbca.f, reaclm.f, callam.f
   
   Au passage on supprime la routine zzzero.f (au profit de r8inir.f et on modifie donc
   conlig.f et xconli.f)
   
   (M) : conlig.f, xconli.f
   (S) : zzzero.f
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   astout mxc3xa9thode continue
NB_JOURS_TRAV  : 3.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 012384 DU 2008-08-20 12:43:17
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   PETSc - petit bug et ajout de cas-tests
FONCTIONNALITE
   Fiche express
   =============
   
   Bug apetsr.F
   Nicolas m'a fait remarquer un petit bug (sans conséquence) dans apetsr.F. On allait
   chercher une valeur à l'aide d'une adresse JEVEUX non initialisée. La valeur en question
   ne servait qu'à faire un ASSERT (en doublon par rapport à apets1 et apets2).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   petsc
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------
RESTITUTION FICHE 012389 DU 2008-08-22 12:46:52
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   MUMPS - Actualisation et ajout de messages, nettoyage
FONCTIONNALITE
   Fiche express
   =============
   
   1/ Petit nettoyage des sources MUMPS (variables non utilisées)
   
   2/ Actualisation des messages
   
   * suppression dans factor.py de message en double (singularité), de messages faux
   (factor_51 ==> mecanonline3_96, impact exfonc.f)
   
   * amélioration du message "manque de mémoire"
   
   * ajout d'un diagnostic après la phase d'analyse (avec émission de messages d'erreur
   correspondants) pour aider l'utilisateur
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   mumps
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR durand       DURAND Christophe      DATE 26/08/2008 - 10:45:21

--------------------------------------------------------------------------------
RESTITUTION FICHE 012395 DU 2008-08-26 08:25:33
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   r?rption d?nitive de impr_charge.capy
FONCTIONNALITE
   résorption définitive de impr_charge.capy
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   n?t
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR foucault     FOUCAULT Alexandre     DATE 25/08/2008 - 17:50:12

--------------------------------------------------------------------------------
RESTITUTION FICHE 012086 DU 2008-05-13 12:01:41
TYPE evolution concernant Code_Aster (VERSION 7.0)
TITRE
   Loi de Hujeux cyclique avec micro-dxc3xa9charge
FONCTIONNALITE
   Fiche d'anomalie relative au probleme de micro-decharges 
   sollicitant les seuils deviatoires de la loi de Hujeux 
   qui necessite un passage en type evolution.
   
   Phenomene mis en jeu localement:
   --------------------------------
   Ce type de chargements cycliques cree temporairement un 
   seuil deviatoire cyclique qui reste elastique durant le 
   microcycle avant la reprise theorique du seuil 
   déviatoire precedemment sollicite.
   
   Probleme rencontre dans la version NEW9:
   ---------------------------------------
   La solution proposee actuellement dans la version NEW9 
   de Code_Aster ne permet pas de gerer ces problemes de 
   façon efficace qui, de plus, cree des problèmes de non 
   convergence a l'echelle locale pour des essais cycliques 
   avec rotation du tenseur des contraintes (stage de 
   H.Berkani actuellement en cours) 
   
   Solution  proposee:
   -------------------
   1)Probleme liee a la micro-decharge:
   ----------------------------------
   La solution proposee pour traiter cette anomalie qui 
   bloque l'avancement des travaux actuellement en cours 
   sur la loi de Hujeux est d'ajouter au nombre de 
   variables internes les vecteurs permettant de generer à 
   nouveau les surfaces de charge perdues lors de ces micro-
   decharges. 
   
   Cela necessite l'ajout de 15(3*5) variables internes 
   (VIN) supplementaires:
   -)Facteur 3 car il existe 3 plans déviatoires dans la 
   loi de Hujeux
   -)2 VIN pour conserver les coordonees vectorielles du 
   point de tangence precedent
   -)2 VIN pour conserver les coordonnees vectorielles de 
   la normale à la surface de charge precedent
   -)1 VIN pour conserver le rayon déviatoire atteint par 
   la surface de charge avant la micro-decharge
   
   L'ajout de ces 15 VIN portent à 50 le nombre de VIN 
   propres à la loi de Hujeux.
   Pour les post-traitements, en HM, la routine fortran 
   posthm.f est utilisee. Or un nombre maximum de VIN est 
   fixe dans cette routine - NVMAX=40.
   Pour passer cet ecueil, j'ai augmenté NVMAX à 60.
   _________________________________________________________
   
   2)Probleme lie a la non-convergence locale constatee 
   pour des chemins de chargement à rotation de contraintes:
   ----------------------------------------------------
   
   La solution envisagee consiste à mettre à l'échelle les 
   inconnues du systeme local d'equations non lineaires à 
   resoudre R(Y).
   Les composantes de l'inconnue Y sont:
   -)increment de contraintes: DSIG = SIGF - SIGD [Pa]
   -)increment de deformation volumique plastique [S.U.]
   -)increment des rayons lies au surface de charge [S.U.]
   -)increment des multiplicateurs plastiques associes aux 
   surfaces de charge de Hujeux [S.U.]. 
   L'increment de contraintes est normalisee par la 
   pression de reference definie par l'utilisateur dans les 
   proprietes materiaux de Hujeux, PREF.
   Il faut egalement mettre a l'echelle les termes de la 
   matrice jacobienne dR/dY.
   
   
   Validation:
   -----------
   SSNV207A : 
   Cas test supplementaire de cisaillement cyclique 
   controlé en contraintes avec micro-decharge. 
   Neanmoins, la validation par rapport a GEFDYN n'est pas 
   possible, car GEFDYN ne prend pas en compte ce phénomène.
   La validation est assurée en réaisant un essai identique 
   controlé en contraintes, mais sans les micro-décharges.
   Le matériau doit se déformer de la même facon pour les 
   deux essais.
   
   La mise à l'echelle du probleme local à resoudre a 
   conduit à modifier legerement les seuils de tolerance 
   sur des cas-tests utilisant la loi de Hujeux: SSNV197A, 
   SSNV197D, WTNV132a, WTNV134a.
    
   Fortran modifies:
   -----------------
   hujact, hujddd, hujdp, hujdrc, hujiid, hujjid, hujmed, 
   hujmid, hujnvi, hujpot, hujpre, hujpxd, hujres, hujtid, 
   nmhuj, posthm
   
   Fichier python modifie:
   ----------------------
   hujeux.py
   
   Cas-test modifies:
   -----------------
   SSNV197A, SSNV197D, WTNV132a, WTNV134a
   
   Cas-test ajouté:
   ---------------
   SSNV207A
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : R7.01.23, V7.31.132, V7.31.134, V6.04.197A, V6.04.197D,
VALIDATION
   CAS-TEST
NB_JOURS_TRAV  : 8.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR zentner      ZENTNER Irmela         DATE 25/08/2008 - 14:22:30

--------------------------------------------------------------------------------
RESTITUTION FICHE 012362 DU 2008-07-31 15:30:23
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   POST_FATI_ALEA et POST_DYNA_ALEA
FONCTIONNALITE
   Lors de la refonte de POST_DYNA_ALEA, on a supprimé dans 
   le tableau résultats une colonne - GRANDEUR-  qui 
   contenait le type de la DSP (par exemple DSP_DEPL).
   Cette information est utilisée par POST_FATI_ALEA, qui 
   lit la table en sortie de POST_DYNA_ALEA. 
   Jusqu'ici l'omission ne posait pas problème car cette 
   fonctionalité n'est pas testé (on peut aussi directement 
   donner les moments spectraux à POST_FATI_ALEA sans 
   passer par POST_DYNA.).
   
   Il y a deux possibilités pour y remédier
   1)	rajouter la colonne ?Grandeur? dans la table 
   résultat de POST_DYNA_ALEA, elle contiendra une 
   information sur la nature du associé à la DSP lu, si 
   l?info est disponible
   2)	enlever la lecture de ?Grandeur? dans 
   POST_FATI_ALEA : il s?agit d?un test uniquement pour 
   vérifier s?il s?agit bien de moments obtenu à partir 
   d?un champ de contrainte. Ainsi, c?est ok si on a  
   DSP_SIPO, DSP_SIGM ou DSP_EFGE.
   La deuxième solution semble meilleure car la 
   vérification échoue de toutes façons dans beaucoup de 
   cas: si le spectre a été crée par CALC_SPECTRE suite à 
   un calcul temporel des contraintes, alors on n'a pas 
   d'information sur le champ (Grandeur = DSP_DSP) et une 
   alarme est émise (injustifiée !).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   szlz106a
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST AJOUT ssnv207a                         kham M.KHAM             264    264      0
 CASTEST MODIF ssnv197a                         kham M.KHAM             479      1     12
 CASTEST MODIF ssnv197d                         kham M.KHAM             489      3      3
 CASTEST MODIF wtnv132a                         kham M.KHAM             635     27      7
 CASTEST MODIF wtnv134a                         kham M.KHAM             873      5      4
CATALOGU SUPPR commande/impr_charge           durand C.DURAND            26      0     26
 FORTRAN MODIF algorith/callam                desoza T.DESOZA           124     20     26
 FORTRAN MODIF algorith/conlig                desoza T.DESOZA           175      3      3
 FORTRAN MODIF algorith/exfonc                desoza T.DESOZA           205      5      5
 FORTRAN MODIF algorith/hujact                  kham M.KHAM             446     76     28
 FORTRAN MODIF algorith/hujddd                  kham M.KHAM             591      2      1
 FORTRAN MODIF algorith/hujdp                   kham M.KHAM             246      2      2
 FORTRAN MODIF algorith/hujdrc                  kham M.KHAM             103     23      4
 FORTRAN MODIF algorith/hujiid                  kham M.KHAM             751      2      2
 FORTRAN MODIF algorith/hujjid                  kham M.KHAM            1087     33     32
 FORTRAN MODIF algorith/hujmed                  kham M.KHAM             133      8      1
 FORTRAN MODIF algorith/hujmid                  kham M.KHAM             370     41     36
 FORTRAN MODIF algorith/hujnvi                  kham M.KHAM              73      2      2
 FORTRAN MODIF algorith/hujpot                  kham M.KHAM             408      4      4
 FORTRAN MODIF algorith/hujpre                  kham M.KHAM             161      7      7
 FORTRAN MODIF algorith/hujpxd                  kham M.KHAM             105     13      4
 FORTRAN MODIF algorith/hujres                  kham M.KHAM             302     20     32
 FORTRAN MODIF algorith/hujtid                  kham M.KHAM             468      6      5
 FORTRAN MODIF algorith/mmmbca                desoza T.DESOZA           399     24      8
 FORTRAN MODIF algorith/nmhuj                   kham M.KHAM             519     45     22
 FORTRAN MODIF algorith/posthm                  kham M.KHAM             129      2      2
 FORTRAN MODIF algorith/reaclm                desoza T.DESOZA           122     25      8
 FORTRAN MODIF algorith/xconli                desoza T.DESOZA           145      3      3
 FORTRAN MODIF prepost/op0170                zentner I.ZENTNER          150     10     10
 FORTRAN SUPPR algorith/zzzero                desoza T.DESOZA            59      0     59
  PYTHON MODIF Comportement/hujeux              kham M.KHAM              40      3      3
  PYTHON MODIF Messages/factor                desoza T.DESOZA           255     27     16
  PYTHON MODIF Messages/mecanonline3          desoza T.DESOZA            80      4      1


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :    1         264       264              +264
 MODIF :   30       10063       446     293      +153
 SUPPR :    2          85                85       -85
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :   33       10412       710     378      +332 
