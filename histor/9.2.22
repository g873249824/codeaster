

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR boyere       BOYERE Emmanuel        DATE 05/05/2008 - 13:22:36

--------------------------------------------------------------------------------
RESTITUTION FICHE 012035 DU 2008-04-25 14:08:51
TYPE express concernant Code_Aster (VERSION 9.2)
TITRE
   Erreur dans le calcul de la sensibilite des contraintes de poutre
FONCTIONNALITE
   En corrigeant la fiche 11466 (prise en compte du passage repère global/repère de la poutre
   dans le calcul des sensibilités pour les contraintes de poutre d'Euler) j'ai
   malencontreusement introduit une erreur dans le calcul de la sensibilité au coefficient de
   poisson (NU) des contraintes de poutre d'Euler.
   La sensibilité au coefficient de poisson des contraintes de poutre d'Euler (On néglige le
   cisaillement entre les sections de la poutre.)
   est nulle, sauf pour la torsion.
   Pour les poutre de Timoshenko, c'est beaucoup plus compliqué.
   
   Je corrige.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sensd09c, sensd09d
NB_JOURS_TRAV  : 4.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR abbas        ABBAS Mickael          DATE 06/05/2008 - 14:42:31

--------------------------------------------------------------------------------
RESTITUTION FICHE 011927 DU 2008-04-04 12:08:26
TYPE evolution concernant Code_Aster (VERSION )
TMA : CS
TITRE
   MN10 - Resorption CONTACT dans AFFE_CHAR_MECA_F
FONCTIONNALITE
   Objet:
   ======
   Le mot-clef facteur 'CONTACT' est présent dans AFFE_CHAR_MECA_F mais UNIQUEMENT pour
   pouvoir entrer une fonction (ou une formule) pour les mots-clefs DIST_MAIT et DIST_ESCL.
   Cette fiche vise à résorber CONTACT dans AFFE_CHAR_MECA_F en demandant que ces deux
   mots-clefs n'acceptent qu'une formule ou une fonction dans AFFE_CHAR_MECA. 
   L'utilisateur désirant entrer une constante fera simplement un DEFI_CONSTANTE.
   
   Impact:
   =======
   capy:
   -----
   affe_char_meca_f.capy
   c_contact.capy
   fortrans:
   --------
   cazocm.f
   cazoco.f
   charme.f
   Cas-tests:
   ----------
   sdnv100a
   ssnl107b
   ssnl107c
   ssnl107d
   ssnv503b
   ssnv503f
   ssnv505a
   ssnv505f
   ssnv505g
   ssnv505h
   
   Validation:
   ===========
   as.tout
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.44.01,U4.44.11
VALIDATION
   astout
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 06/05/2008 - 14:42:32

--------------------------------------------------------------------------------
RESTITUTION FICHE 010667 DU 2007-03-19 11:26:57
TYPE evolution concernant Code_Aster (VERSION 2.x)
TMA : CS
TITRE
   IMPR_FONCTION format TABLEAU : lignes non num?ques non comment?
FONCTIONNALITE
   Il s'agit d'une *vieille* demande : pouvoir ajouter un caractère de commentaire lors de
   l'impression de fonction afin de relire le fichier avec des traceurs de courbes divers en
   utilisant le format TABLEAU.
   
   On ajoute un mot-clé COMM_PARA qui permet de fournir un caractère qui sera ajouté devant
   la liste des paramètres de la fonction.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.91.03, U4.33.01
VALIDATION
   visuelle sur un IMPR_FONCTION de zzzz100a
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR corus        CORUS Mathieu          DATE 06/05/2008 - 14:29:16

--------------------------------------------------------------------------------
RESTITUTION FICHE 012058 DU 2008-04-30 13:11:28
TYPE express concernant Code_Aster (VERSION 9.2)
TITRE
   Carte responsable pour les commandes concernant l'analyse modale
FONCTIONNALITE
   Reprise de la fiche de Ionel mise au gout des operateurs de sous structuration dynamique
   dont je suis responsable :
   
   Les responsables des opérateurs d'Aster seront desormais 
   indiqués dans une carte introduite dans les catalogues 
   capy correspondants. Suite au partage fait au sein de 
   T61, aprouvé par l'équipe Aster, en ce qui concerne les 
   opérateurs de dynamique linéaire, je reprends la 
   responsabilité des opérateurs d'analyse modale. C'est 
   principalement une opération administrative qui 
   n'affectera pas les developpements qui seront portés 
   toujours par tous ceux qui ont les competences.
   J'ajoute donc une carte de responsable avec mon 
   nom dans:
   
   defi_interf_dyna.capy
   impr_macr_elem.capy
   macr_elem_dyna.capy
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   NEANT
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desoza       DE SOZA Thomas         DATE 06/05/2008 - 09:25:18

--------------------------------------------------------------------------------
RESTITUTION FICHE 011789 DU 2008-02-21 15:28:54
TYPE anomalie concernant Code_Aster (VERSION 9.2)
TITRE
   Stat_non_line + Contact avec reuse
FONCTIONNALITE
   Objet
   =====
   
   La méthode GCP est mise en défaut en modifiant le cas-test SSNA102E afin de réaliser un
   incrément de charge nul.
   Par ailleurs ce même test est NOOK en mode "debug" et atteint le maximum d'itérations de
   contact (fixé en dur à 2*Noeuds_Esclaves) sur clpaster.
   
   Analyse
   =======
   
   Jean-Luc et Nicolas ont trouvé un bug dans l'algorithme de GCP. Il s'agit du calcul des
   forces nodales de contact par l'algorithme.
   Les algorithmes 'CONTRAINTE' et GCP tels qu'ils sont implémentés dans Code_Aster (approche
   globale-locale du contact) renvoient naturellement des quantités totales. C'est à dire que
   l'on ne calcule pas des incréments. Ainsi AT.MU représente l'effort total de contact sur
   la structure.
   
   Or ce que faisait GCP, c'était bien de renvoyer un effort total mais maladroitement calculé :
   MU était initialisé à chaque début de pas de temps (grâce à ITERAT) et ensuite incrémenté
   pendant les itérations de *Newton*. On sauvegardait en entrée dans GCP, MU dans MU0 et on
   renvoyait finalement AT.(MU-MU0)
   C'est problématique dans la mesure où les multiplicateurs de Lagrange ne conservent aucune
   signification physique d'une itération de Newton sur l'autre à cause des possibles
   ré-appariements.
   
   Solution
   ========
   
   On initialise MU en début d'algorithme à 0. Et on renvoie bien AT.MU.
   
   Validation
   ==========
   
   Tous les tests méthode GCP.
   Sur l'étude de Jean-Luc, on retrouve un nombre d'itérations proche du cas REAC_GEOM='SANS'.
   
   Version d'exploitation
   ======================
   
   Modif à reporter en 8.
   
   Pas de résultats faux : si les forces renvoyées sont réellement fausses alors il ne peut y
   avoir équilibre (le déplacement lui étant correct) donc convergence.
   ==> touchait seulement REAC_GEOM='CONTROLE' ou 'AUTOMATIQUE'
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : R5.03.50
VALIDATION
   tout test utilisant GCP
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 011880 DU 2008-03-26 10:36:36
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   MN10 - Bug DIST_* mxc3xa9thode continue
FONCTIONNALITE
   Objet
   =====
   
   L'utilisation des mots-clefs DIST_POUTR ou DIST_COQUE avec la méthode continue est bugguée.
   Elle confond la référence dans l'objet.
   L'objet stockant la valeur supplémentaire du jeu introduit par ces mots-clefs est
   dimensionné par le nombre de noeuds esclaves (voir cacoco et capoco)
   Or la méthode continue y accède via le numéro de zone de contact (dans mmmbca/mmdist)
   Bug possible si l'épaisseur/rayon de la poutre est variable entre les mailles.
   
   Analyse
   =======
   
   Le jeu calculé par la méthode continue l'est non pas aux noeuds esclaves comme pour une
   méthode discrète mais en "sous-points" d'une maille esclave qui peuvent être les noeuds de
   la maille (si intégration aux noeuds) ou bien des points à l'intérieur de celle-ci dans
   les autres cas (intégration aux points de gauss, intégration de type Simpson, etc ...).
   Or on ne récupère depuis le cara_elem que des informations aux noeuds (esclaves). Quid du
   choix ? (interpolation, moyenne, etc ...)
   
   Conclusion
   ==========
   
   Deux solutions possibles :
   
   - soit on interdit d'utiliser DIST_* avec autre chose que l'intégration aux noeuds (un peu
   drastique)
   - soit on choisit un critère pour récupérer l'information (ce peut être la moyenne, le
   noeud le plus proche, etc ...)
   
   Dans tous les cas, cela relève plus d'une EL pour moi (cf. fiche 10611), et je propose
   plutôt de blinder pour l'instant.
   
   Pas de report en 8 car DIST_* n'a été introduit pour la méthode continue qu'en 9.1.3
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   nxc3xa9ant
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 012034 DU 2008-04-25 11:56:21
TYPE express concernant Code_Aster (VERSION 9.2)
TITRE
   Petite modif dans SSNV506A et cazocm.f
FONCTIONNALITE
   Cette fiche express a pour but de :
   
   - rétablir la condition au limite (implicite) DX=0 sur l'axe d'axisymétrie dans SSNV506A,
   en effet, on en a quand même besoin sans quoi un élément touchant l'axe se décolle (voir
   image jointe)
   
   - enlever un write laissé dans cazocm.f
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V6.04.506
VALIDATION
   ssnv506a
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR galenne      GALENNE Erwan          DATE 06/05/2008 - 12:47:46

--------------------------------------------------------------------------------
RESTITUTION FICHE 012031 DU 2008-04-25 08:38:30
TYPE express concernant Code_Aster (VERSION 9.2)
TITRE
   POST_GP : retsitution du cas test ssnp131b
FONCTIONNALITE
   Contexte
   ========
   La macro-commande POST_GP a été étendue au 3D dans le cadre de la fiche 11614.
   Le cas test ssnp131b, validant l'évolution, n'a cependant pas été restitué jusqu'à présent
   car il était trop gros (en mémoire et en temps).
   
   Modifications
   ============
   Le cas test ssnp131b est un calcul élasto-plastique sur un maillage 3D de 35000 noeud. La
   résolution du pb mécanique nécessite en jeveux statique / MULT_FRONT 4Go de mémoire et 700
   s / pas de temps.
   
   En introduisant les modifications suivantes :
   -passage à jeveux dynamique (DYNAMIQUE=400)
   - remplacement de AFFE_CHAR_MECA par AFFE_CHAR_CINE pour les blocages de ddl
   - passage du solveur MULT_FRONT à MUMPS (PCENT_PIVOT=50)
   j'arrive à faire passer le test avec 1 Go de mémoire (dont 200 Mo pour Aster), et le
   STAT_NON_LINE prend 180 s par itération.
   Le test complet (avec le calcul et le post-traitement) nécessite donc 250 s environ, pour
   un pas de temps. On le restitue tel quel.
   
   Remarque 1 : des alarmes sont émises dans le cas test : 
   - CALCULEL6_78 (loi de comportement différent entre le calcul et le post-traitement) :
   c'est normal, c'est la méthode Gp qui veut ça
   - CALCULEL6_65 (nombre de charges différent entre le calcul et le post-traitement) : les
   charges cinématiques ne sont pas prises en comptes dans CALC_G  et POST_ELEM, il ne faut
   donc pas les mettre dans la liste des charges à considérer.
   
   Remarque 2 : POST_ELEM plante (à l'interprétation du jdc) si on lui donne en entrée une
   charge cinématique. Il faudrait peut-être simplement l'ignorer, comme c'est fait dans CALC_G.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V6.03.131
VALIDATION
   ssnp131b
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR geniaut      GENIAUT Samuel         DATE 05/05/2008 - 16:59:14

--------------------------------------------------------------------------------
RESTITUTION FICHE 011874 DU 2008-03-25 13:09:39
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   X-FEM : prevenir les fissures trop proches ou les intersections de fissures
FONCTIONNALITE
   Pour le moment, il n'est pas possible de  définir des fissures avec X-FEM "trop proches",
   et a fortiori, des fissures qui s'intersectent.
   
   Si un tel cas se produit, on plante dans MODI_MODELE_XFEM assez salement.
   
   En fait, un message devait etre emis lorsqu'on concatene des cham_no de plusieurs
   fissures, dans le cas ou le cham_no a deja une composante remplie sur un noeud. sauf que
   le test était mal fait.
   
   Maintenant, pour chaque type 'r', i', 'l', 'k8',
   si le cham_no a deje ete rempli, on verifie que c'est avec la meme valeur et on s'arrete
   au cas ou, 
   sinon, on le remplit
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   perso
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 011653 DU 2008-01-18 14:57:47
TYPE anomalie concernant Code_Aster (VERSION 9.2)
TITRE
   En NEW9.2.5, le cas-test ssnp110d s'arrete en ERREUR_<F> sur Bull, Calibre et Rocks
FONCTIONNALITE
   Problème: 
   --------
   
   En NEW9.2.5, le cas-test ssnp110d s'arrete en ERREUR_<F> sur les machines Bull, Calibre et
   Rocks.
   
   Cela provient de ma dernière restitution sur l'intégration des éléments 2d X-FEM : passage
   de 3 à 12 points de gauss pour l'intégration de la rigidité par sous-triangles.
   J'avais oublié d'appeller la nouvelle famille dans le te de COMP_INCR
   
   Solution :
   ----------
   
   On appelle la bonne famille (FPG12) dans la routine te0539 -> xnmpl -> xnmpl2
   
   J'en profite pour harmoniser les noms des routines
   xkin3d -> xnmpl
   xinc3d -> xnmpl3
   xinc2d -> xnmpl2
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ssnp110d
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 012038 DU 2008-04-27 20:46:16
TYPE anomalie concernant Code_Aster (VERSION 9.2)
TITRE
   En NEW9.2.21, certains cas-tests s'arretent en ERREUR_<F> sur Bull, Calibre et Rocks
FONCTIONNALITE
   Problème :
   ----------
   
   Depuis la restitution de la fiche 11826, la vérification des SEG enrichis par X-FEM se
   fait dans la commande DEFI_FISS_XFEM.
   
   Or certains tests utilisent cette commande en cas non XFEM pour la définition des level
   sets avec fissure maillée (donc avec des SEG qui devraient etre enrichis si on utilisait
   X-FEM). D'ou plantage pour ces tests :
   hplv103a
   sdls114b
   sslv134f
   sslv311a
   sslv313a
   ssnv166c
   ssnv185a
   
   
   Solution :
   ----------
   
   
   Maintenant, on fait la vérification des SEG enrichis dans la commande MODI_MODELE_XFEM,
   donc seulement pour les cas ou X-FEM est utilisé.
   
   impact :
   op0113.f  xenrch.f  xmolig.f
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   tests incrimin?
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR greffet      GREFFET Nicolas        DATE 05/05/2008 - 13:36:02

--------------------------------------------------------------------------------
RESTITUTION FICHE 012053 DU 2008-04-30 10:00:10
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   Nettoyage routine NMCHSV (schxc3xa9ma HHT complet dans DYNA_NON_LINE)
FONCTIONNALITE
   On retire SDDISC comme argument de NMCHSV car il ne sert pas.
   Il faut donc aussi modifier NMIHHT et OP0070 qui sont les routines qui font 
   appel à NMCHSV.
   La routine NMIHHT n'a plus besoin de SDDISC non plus car cet objet était juste 
   fourni à NMCHSV.
   On doit donc retirer SDDISC des arguments de NMIHHT et donc aussi de NIMINIT qui 
   est la seule routine à appeler NMIHHT. 
   Routines modifiées :
   OP0070
   NMIHHT
   NMCHSV
   NMINIT
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sdld31a
NB_JOURS_TRAV  : 0.05
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR kham         KHAM Marc              DATE 06/05/2008 - 12:33:30

--------------------------------------------------------------------------------
RESTITUTION FICHE 009550 DU 2006-03-14 09:54:00
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   orientation d'?ments seg(2-3)
FONCTIONNALITE
   On propose la méthodologie suivante pour une définition 
   SANS AMBIGUITE de la normale de contact DANS LE CAS OU 
   CELLE-CI DOIT ETRE EVALUEE SUR UNE POUTRE:
   
   1) On oriente d'abord la poutre sur laquelle on prend
      la normale à l'aide d un nouveau mot-clé-facteur
      MODI_MAILLAGE->ORIE_LIGNE (comme ORIE_NORM_COQUE):
   
      ORIE_LIGNE =_F( * GROUP_MA =list_group_ma
                         o VECT_TANG = (vx, vy, vz),
                           / NOEUD = noeud,
                           / GROUP_NO = group_no )
                         
      On donne le vecteur VECT_TANG qui permet d'orienter la
      poutre. Par exemple, si on veut orienter
      la poutre AB dans le sens V, il faudra choisir VECT_TANG
      de façon à ce que VECT_TANG.V >0, soit par exemple
      VECT_DIR =(1.,0.,0.)           Y
                                      ^
      A                      B        |
      X======================X        |---> X
      -----> V=(vx,vy,vz)
   
   2) Dans la définition du contact, définir VECT_Y de façon à
      ce que la normale de contact VECT_NC = V ^ VECT_Y.
   
   On explicite la procédure dans la doc U4.41.01 du contact.
   
   FORTRANS  : orilgm (modif), ioriv3 (ajout), orvlse (ajout)
   CATALOGUE : modi_maillage.capy
   VALIDATION: cas-test SSNV505F
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.41.01, U4.23.04, V6.04.505
VALIDATION
   cas-test
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 012039 DU 2008-04-27 20:51:00
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW9.2.21, certains cas-tests s'arretent en ERREUR_<F> sur Bull, Calibre et Rocks:
FONCTIONNALITE
   résolu par la fiche 11399.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   cas-test
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 012040 DU 2008-04-27 20:55:11
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW9.2.21, le cas-test wtnv132a s'arrete en ERREUR_<F> sur Bull, Calibre et Rocks.
FONCTIONNALITE
   idem 12039
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ras
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 06/05/2008 - 17:21:56

--------------------------------------------------------------------------------
RESTITUTION FICHE 011937 DU 2008-04-07 11:34:34
TYPE evolution concernant Code_Aster (VERSION )
TMA : DeltaCad
TITRE
   encapsulation ?iture messages MED dans INFO=2
FONCTIONNALITE
   Objectif
   ========
   pour IMPR_RESU et LIRE_RESU : encapsulation des impressions du type :
   
    RESULTAT           : DUD_RESU
    CHAMP              : SIEF_ELGA       
      ==> NOM MED DU CHAMP : DUD_RESUSIEF_ELGA_______________
   
     . ECRITURE DES  4 *   3 *       86 VALEURS POUR LE NUMERO 
   D'ORDRE :     29
        ( PAS DE TEMPS NUMERO :   29, T =    9.0000     )
     . NOM DE LA LOCALISATION DES POINTS DE GAUSS : 
   TR6_____FPG3____________________
     . ECRITURE DES  4 *   9 *      109 VALEURS POUR LE NUMERO 
   
   dans un INFO=2, pour ne pas les avoir à chaque fois.
   
   Modification
   ============
   Modifications des fortrans suivants en faisant intervenir le paramètre d'impression NIVINF
   de CALL INFNIV ( IFM, NIVINF ) pour régler le niveau d'impression issu du mot clé INFO:
   
    IMPR_RESU : irchme.f  ircmec.f, ircame.f 
    LIRE_RESU : lrcmva.f  lrcmve.f
   
   Validation visuelle
   ===================
   - IMPR_RESU : forma01a
   - LIRE_RESU : ssnp115a, zzzz162a
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   asrest
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desroches    DESROCHES Xavier       DATE 06/05/2008 - 14:34:14

--------------------------------------------------------------------------------
RESTITUTION FICHE 011952 DU 2008-04-09 14:46:41
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TMA : CS
TITRE
   SIGM_ELNO_DEPL et ELAS_COQUE
FONCTIONNALITE
   Texte de la fiche :
   
   Calcul ELAS_COQUE sur DKT. On fait un CALC_ELEM / 
   SIGM_ELNO_DEPL et on a l'alarme très paradoxale
   suivante :
   
   Le type de comportement ELAS_COQUE n'est pas prévu pour le 
   calcul de  SIGM_ELNO_DEPL. Les seuls comportements autorisés 
   sont :	 ELAS, ELAS_COQUE, ou ELAS_ORTH
   
   Il y a plusieurs problèmes :
   - sous te0033/dxsigv, on entre systématiquement dans dxsigm 
   et (le pb est là) dxsigt, quand bien meme on n'a pas de 
   thermique (d'où l'émission de l'alarme).
   - le message lui même qui n'a pas de sens.
   
   
   Réponse :
   
   Il faut imprimer un message d'alarme seulement si on a un 
   chargement thermique avec ELAS_COQUE , ce message disant :
    " Le type de comportement ELAS_COQUE n'est pas prévu pour le 
   calcul de  SIGM_ELNO_DEPL avec chargement thermique. Les 
   seuls comportements autorisés      sont : ELAS, ou ELAS_ORTH "
   
   Modification :
   
   Les fichiers fortran suivants ont été modifiés :
   · dxsigt.f
   
   Le message d?alarme a été modifié aussi :
   · Elements.py
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sans
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR abbas        ABBAS Mickael          DATE 06/05/2008 - 14:34:14

--------------------------------------------------------------------------------
RESTITUTION FICHE 011942 DU 2008-04-08 07:35:23
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TMA : CS
TITRE
   STAT_NON_LINE et forces suiveuses
FONCTIONNALITE
   Charges de type EVOL_CHAR.
   
   Les charges de type EVOL_CHAR sont traitées à part dans la routine VECGME qui calcule le
   second membre.
   Qu'on les donne comme suiveuses (TYPE_CHARG='SUIV') ou non, elles sont considérés comme
   suiveuses !
   
   Le traitement est fait dans la routine NMVGME.
   Donc, TOUTES les charges EVOL_CHAR sont suiveuses
   Pour ne pas s'arreter en erreur fatale dans VECGME dans les deux cas-tests cocernés, il
   faut modifier VECGME comme suit.
   
   IF (TAB(K).EQ.1) THEN
      SOMME = SOMME + 1
   ENDIF
   
   En:
   EVOLCH= ZK24(JCHAR+ICHA-1) (1:8)//'.CHME.EVOL.CHAR'
   CALL JEEXIN(EVOLCH,IER)
   
   IF ((TAB(K).EQ.1).OR.(IER.GT.0))  THEN
     SOMME = SOMME + 1
   ENDIF
   
   Ca devrait fonctionner.
   Il faut faire une évolution pour faire entrer le cas EVOL_CHAR dans le canevas standard
   des charges suiveuses.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   liste restreinte
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 06/05/2008 - 14:34:14

--------------------------------------------------------------------------------
RESTITUTION FICHE 010916 DU 2007-05-30 12:04:02
TYPE evolution concernant Code_Aster (VERSION )
TMA : CS
TITRE
   message d'erreur a ameliorer dans fointa
FONCTIONNALITE
   Un champ supplémentaire a été rajouté dans les structures de données fonction, fonction_C
   et fonction_I au niveau du .PROL.
   
   Pour une fonction ou une nappe, le .PROL(6) contiendra le nom de la fonction ou de la nappe.
   
   De plus, lorsque le code s?arrêtera dans fointa.f pour une erreur d'interpolation fatale,
   
   le nom de la fonction apparaîtra dans le message d?erreur.
   
   Exemple :
   
   !-------------------------------------------------------------------------!
   
   ! <F> <CALCULEL6_62>                                                       !
   
   !
   
   !
   
   !
   
   !
   
   !  Erreur de programmation (fointa) :                                      !
   
   !     Pour l'interpolation de la fonction D_T sur la maille M1,   !
   
   !     il manque le paramètre TEMP                                           !
   
   !
   
   !
   
   !
   
   !
   
   !
   
   !
   
   ! Cette erreur est fatale. Le code s'arrête.                                 !
   
   !------------------------------------------------------------------------!
   
   
   
   Les routines fortran modifiées sont :
   
   calcfo.f, calcna.f, calcsp.f, calfig.f, cbondp.f, charci.f, deffen.f,
   
   dismcm.f, fo0182.f, foattr.f, foc1su.f, focain.f, focrch.f, focrr0.f,
   
   focrr2.f, focrr3.f, focste.f, foec1n.f, foec2n.f, foimpr.f, fointa.f,
   
   fointe.f, fointn.f, fointr.f, fonbpa.f, fopro1.f, fovern.f, fozero.f,
   
   fozerv.f, gchs2f.f, nmdomc.f, nmdome.f, ntdoth.f, op0002.f, op0003.f,
   
   op0004.f, op0064.f, op0073.f, op0118.f, op0120.f, op0131.f, op0134.f,
   
   op0135.f, op0142.f, op0146.f, op0169.f, op0182.f, ordcoq.f, rcmome.f,
   
   rcstoc.f, rctrac.f, rfbefl.f, rfhge1.f, rfhge2.f, rfmge1.f, rfmge2.f, rfnapp.f,
   
   rfrgen.f, sfifj.f, speph1.f, spephy.f et tbexfo.f.
   
   
   
   Les scripts python modifiés sont :
   
   calculel6.py,  co_fonction.py,  impr_fonction_ops.py et sd_fonction.py.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : D4.02.02
VALIDATION
   Liste restreinte et liste de validation
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR markovic     MARKOVIC Damijan       DATE 06/05/2008 - 10:58:03

--------------------------------------------------------------------------------
RESTITUTION FICHE 011692 DU 2008-01-29 14:22:49
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   MN13 - Une nouvelle methode de calcul de la masse lumpee pour les elements coques
FONCTIONNALITE
   Dans le cadre du projet SAGA-2 on souhaite modifier 
   le calcul de la matrice de masse lumpee 
   (MASS_MECA_EXPLI) pour les elements DKT, DKTG, selon 
   la methode utilisee dans Europlexus. Cela nous 
   permettra de pouvoir mieux comparer les deux codes 
   EPX et Aster sur les problématiques SAGA-2, mais 
   surtout d'introduire dans Aster la methode 
   preconisee dans la litterature pour les applications 
   de dynamique rapide. 
   
   Cette fiche pourrait être vue comme la continuation 
   de la fiche 9952, ou on a du mettre en place deux 
   masses lumpees pour les coques : une pour la 
   dynamique explicite (MASS_MECA_EXPLI) et l'autre 
   pour la dynamique implicite (MASS_MECA_DIAG, ou la 
   masse lumpee est beaucoup moins utilisee mais quand 
   meme). Car pour les coques MASS_MECA_EXPLI peut 
   fausser les résultats en basse fréquence et 
   MASS_MECA_DIAG fait diverger l'integration 
   explicite. Pour les non-coques MASS_MECA_EXPLI = 
   MASS_MECA_DIAG. 
   
   
   Le calcul d'une matrice masse lumpée se fait en trois 
   étapes :
   
   1) Calcul d'une matrice "consistante" au niveau 
   élémentaire.
   
   2) Application d'une technique de "lumping" sur la 
   matrice consistante, au niveau élémentaire.
   
   3) Correction des termes d'inerties pour maximiser le 
   pas de temps de stabilité.
   
   On propose de remplacer les méthodes des trois étapes 
   par celle utilisées dans Europlexus, meilleurs en 
   dynamique explicite.
   
   1) La matrice masse "améliorée" (voir R3.07.03) est 
   remplacée par la version "simple".
   
   2) L'approche actuelle de lumping (voir R3.07.03) est 
   inadaptée pourt les termes d'inerties. On la remplace 
   par la technique de "sommation par collone" (qui est 
   incompatible avec l'approche 1) actuelle).
   
   3) On applique la technique de Hughes et al., 1978, pour 
   modifier les termes d'inerties.
   
   Tous le développement sera effectué sous l'option 
   MASS_MECA_EXPLI pour les DKT, DKTG. MASS_MECA et 
   MASS_MECA_DIAG restent telles quelles.
   
   Aucun impact pour l'utilisateur.
   
   Les modélisations concernées : DKT et DKTG, seulement 
   pour les mailles T3. En principe, on pourrait l'étendre 
   au mailles Q4, mais c'est sans interet. En dynamique 
   explicite on reactualise la geometrie (approche 
   eulerienne) et les Q4 ne le permettent pas (approche 
   corotationnelle n'est pas implantee). 
   
   sources modifies : 
   
   TE0031.F et TE0409.F : la modification de la masse se 
   fait entierement dans dktmas.f
   
   DKTMAS.F : procedure speciale pour l'option 
   MASS_MECA_EXPLI
   
   ajoutee :
   DIAEXP.F : construit la nouvelle matrice MASS_MECA_EXPLI
   
   
   Interet principale de l'evolution : 
   Construire une matrice de masse lumpee de sorte qu'elle 
   augmente le pas de stabilite. 
   
   Projet : SAGA-2, benchmark Europlexus/Code_Aster
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : R3.07.03
VALIDATION
   sdns106a,sdns106d
NB_JOURS_TRAV  : 5.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 011516 DU 2007-11-28 10:31:11
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   Mise a jour de la mise en donnees du modele GLRC_DAMAGE
FONCTIONNALITE
   Le modele GLRC_DAMAGE, developpe sous Europlexus, a ete 
   implante dans Aster en 2006. Dans EPX on a depuis fait 
   evoluer la mise en donnees, qui est devenue plus 
   ergonomique. On propose, dans le cadre du projet SAGA II, 
   de synchroniser la mise en donnees des deux codes, donc 
   de mettre a jour celle du Code_Aster.
   
   Desormais le matériau GLRC_DAMAGE sera obligatoirement 
   construit par le nouvel opérateur DEFI_GLRC et non plus par 
   DEFI_MATERIAU.
   
   Pour l'utilisation courante, l'opérateur DEFI_GLRC aura en 
   entrée les mot-clefs facteur définissant les propriétés des 
   différentes composantes : béton (BETON), nappes d'acier 
   (NAPPE), liner (LINER) et cables de precontrainte 
   (CABLE_PREC). Ces différents mot-clefs auront en entrée les 
   propriétés mécaniques définies au préalable avec un 
   DEFI_MATERIAU et les propriétés géométriques (position des 
   aciers, leurs sections etc.). En sortie, DEFI_GLRC produit un 
   matériau GLRC_DAMAGE, utilisable par MECA_NON_LINE sous 
   COMP_INCR.
   
   On construit un concept materia contenant les parametres 
   suivants :
   
   BN11,BN22,BN33,BN12 : tenseur elastique pour la partie 
   membrane
   
   BT1,BT2 : termes du tenseur elastique pour le cisaillement 
   transverse (obsolete dans l'etat actuel, mais permettrait 
   d'etre applique avec les EF coques epaisses, comme dans EPX)
   
   MF1,MF2 : seuil d'endommagement (flexion positive/negative)
   
   GAMMA,QP1,QP2 : pentes en non-linéaire
   C(1-2)(M,N)(1-3) : parametres (tenseur de Prager) pour 
   l'ecrouissage cinematique
   
   4 fonctions seuils (+leurs derivees premieres et secondes = 
   12 en totale) ayant des nom generees avec gcncon.f
   
   Ces donnees sont imprimables a travers le mot-clef IMPRESSION 
   = _F(), commme dans l'operateur DEFI_COQU_MULT.
   
   
   Remarque : 
   L'operateur DEFI_GLRC a besoin en entree de la valeur de 
   l'epaisseur de la plaque/coque. Cette valeur est stockee dans 
   le concept de sortie et on verifie dans MECA_NON_LINE qu'elle 
   est egale a celle definie dans AFEE_CARA_ELEM. Faute de quoi 
   on s'arrete.
   
   Code impacte :
   
   modif DEFI_MATERIAU.CAPY : on enleve le materia GLRC_DAMAGE
   ajout DEFI_GLRC.CAPY : construction du materia pour le 
   comportement GLRC_DAMAGE
   
   ajout LSQPOL.F, MOCONM.F : routines provenant de MOCO 
   (logiciel servant a identifier les parametres des modeles du 
   type GLRC).
   
   ajout OP0057.F : source du DEFI_GLRC
   
   modif MAGLRC.F : lecture des parametres materiau. Avant on 
   faisait un peu d'homogeneisation la-dedans. Maintenant tout 
   se fait dans DEFI_GLRC.
   
   Tests existants modifies : SSLS126A,B et SSLS127A,B.
   Le test non-lineaire, SSNS104A,B est resorbe. Il s'agit d'un 
   test validant l'ancienne version du modele GLRC, ou on ne 
   modelisait ni l'endommagement ni l'elasto-plasticite en 
   membrane. L'actuelle version du GLRC_DAMAGE n'est pas adapte 
   au calcul implicite, car la matrice tangente correspondante 
   n'est pas implantee, ce qui le rend peu robuste pour des 
   increments importants. De plus, la modelisation des plaques 
   plastifiant en flexion est mieux representee par une approche 
   multi-couches, ou les aciers sont modelises par les couches 
   de GRILLE_MEMBRANE, que par une approche GLRC comme dans 
   SSNS104A,B.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.43.01,U4.42.06,V6.05.104
VALIDATION
   sdns106a
NB_JOURS_TRAV  : 10.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 011515 DU 2007-11-28 10:24:23
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   MN13 - Amelioration du PETIT_REAC pour les coques
FONCTIONNALITE
   En faisant des etudes en dynamique rapide avec un schema 
   explicite on a observe dans le projet SAGA II une 
   mauvaise convergence des calculs en elasticite. Les 
   memes etudes lancees sous Europlexus convergaient bien. 
   
   Ayant pour objectif de disposer de memes capacites de 
   calcul dans Aster et EPX, on souhaiterais d'abord 
   comprendre puis eliminer le mieux possible les 
   difference de modelisation dans les deux codes sans se 
   preoccuper, dans un premier temps, de performances CPU.
   
   Bien que deconseille pour les coques, on utilise 
   l'option PETIT_REAC dans Aster pour s'approcher le plus 
   de EPX. Neanmoins, la gestion des grandes deformations 
   n'est pas ainsi completement equivalente dans les deux 
   codes. Le repere corotationel utilise dans les deux cas 
   n'est pas forcement le meme, puis on sait deja que EPX 
   utilise le tenseur d'Euler-Almansi pour la mesure de 
   deformation tandis que Aster utilise le tenseur linaire.
   
   On décide d'introduire une nouvelle option "DEFORMATION 
   = EULER_ALMANSI" dans MECA_NON_LINE uniquement pour les 
   modélisations DKT, DKTG. 
   
   Le tenseur d'Euler-Almansi est décrit dans R5.03.21 et 
   respecte l'objectivité (voir §3.3 du R5.03.21), ce qui 
   n'est pas le cas du PETIT_REAC. En plus, il est mieux 
   adapté aux grandes rotations. 
   
   Potentiellement, EULER_ALMANSI pourrait entièrement 
   remplacer PETIT_REAC à condition qu'on le valide sur une 
   gamme large des applications. Par ailleurs, c'est une 
   approche aux grandes transformations généralisée du code 
   Europlexus, spécialisé dans le domaine de la dynamique 
   rapide.
   
   Il reste à comprendre son lien avec "DEFORMATION = 
   COROTATIONNEL" pour eventuellement reduire le nombre des 
   mesures de deformation differentes, tout en gardant 
   toutes les fonctionnalites de modelisation.
   
   
   modif C_COMP_INCR.CAPY : rajout de l'option DEFORMATION 
   = EULER_ALMANSI sous COMP_INCR
   
   modif DKTNLI.F, DXGLRC.F : implantation de la methode 
   
   modif TE0031.F, TE0409.F : reactualisation de la 
   geometrie comme pour DEFORMATION=PETIT_REAC.
   
   Remarque : 
   Pour PETIT_REAC, vu qu'il n'est pas coherent avec la 
   theorie generale des grandes deplacements, on emet un 
   message d'alarme lors de l'utilisation avec des EF 
   plaque/coque. On juge que pour EULER_ALMANSI cela n'est 
   pas necessaire, puisqu'il est base sur une formulation 
   theoriquement plus rigoureuse.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.51.11
VALIDATION
   sdns106a,sdns106d
NB_JOURS_TRAV  : 4.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 011740 DU 2008-02-11 16:22:22
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Problxc3xa8me avec plusieurs matxc3xa9riaux GLRC_DAMAGE
FONCTIONNALITE
   Le modèle GLRC_DAMAGE fait appel au materiau 
   GLRC_DAMAGE qui contient des fonctions Aster 
   définissant les fonctions de seuils et leurs 
   dérivées. Je me suis aprerçu qu'actuellement le 
   modèle ne peut lire qu'un seul jeu de 
   données "fonction" ce qui devient embêtant lorsqu'on 
   veut définir plusieurs matériaux du même type.
   
   Dans GLRC_DAMAGE, qui a été copié de Europlexus (EPX 
   dans la suite), fiche 9729, on remplace la gestion 
   des fonctions de seuil de EPX (des commun-s) par des 
   objets jeveux qui vont bien. Le problème c'est que 
   dans les routines élémentaires (TEs) de l'Aster, on 
   est incapable de connaître le nom du concept de la 
   fonction paramètre, puisque la SD "materiau codé" ne 
   copie pas cette information de la SD matériau. Or, 
   dans ce cas on est obligé de connaître les noms de 
   ces fonctions à cause de certaines opérations (du 
   type : chercher les max et les min, les 
   intersections etc.) à y effectuer avant les calculs. 
   Ainsi, actuellement on récupère les noms des 
   fonctions à partir de la SD directement, mais comme 
   on ne sait pas, à l'intérieur d'un TE, quel matériau 
   nous concerne, on ne peut accéder qu'aux données du 
   matériau No. 1.
   
   Tote difficulte provient du fait que pour GLRC_DAMAGE on a 
   besoin des operations de preparation precedant le calcul, 
   ce qui n'etait pas possible avant la resolution de la 
   fiche 11516. Desormais, toutes operations prealables au 
   calcul sont faites dans l'operateur DEFI_GLRC.
   
   On rend la gestion des fonctions "classique", ce qui non 
   seulement permet d'avoir plusieurs materiaux GLRC_DAMAGE 
   dans une etude, mais, en plus, reduit le temps CPU de 40% 
   (pour sdns106a).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sdns106a
NB_JOURS_TRAV  : 3.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR kham         KHAM Marc              DATE 06/05/2008 - 10:58:05

--------------------------------------------------------------------------------
RESTITUTION FICHE 011399 DU 2007-10-25 16:40:16
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   CODHYBAR2 : loi d'Hujeux en cyclique : compl?nts
FONCTIONNALITE
   Dans cette restit, je traite les points 1, 2 et 3 du mémo 
   de François. Les points 4 et 5 me semblent moins urgents, 
   et peuvent être reportés dans une fiche suivante. Le point 
   6 également, mais demande là un vrai travail.
   
   1) Mécanisme de traction
      =====================
   je propose une solution qui semble bien marcher:
   on introduit une cohésion qui permet de décaler légèrement 
   la surface de charge de Hujeux vers les pressions isotropes 
   positives.
   On introduit un nouveau paramètre, positif, PTRAC dans
   DEFI_MATERIAU->HUJEUX
   qui est facultatif et qui vaut zéro par défaut.
   
   VALIDATION:
   On valide sur le triaxial cyclique non-drainé WTNV134A, en 
   poussant le calcul beaucoup plus loin, jusqu'à la phase 
   ultime du comportement dans ce genre d'essai (stabilisation 
   autour de zéro, formes de clepsydre dans le plan P-Q).
   On compare les solutions obtenues par rapport à GEFDYN.
   
                        * * *
   
   2) On modifie tous les cas-tests pour tenir compte
      de la modification précédente.
   
                        * * *
   
   3) Rotation des plans de glissement
      ================================
   On rappelle que dans la loi de Hujeux, on travail sur 3 
   plans de glissement perpendiculaires qui définissent les
   3 mécanismes déviatoires. Actuellement, ces 3 plans sont 
   liés au repère global, c'est-à-dire au maillage lors de sa 
   conception.
   On permet ici de redéfinir l'orientation des plans 
   déviatoires à l'aide de l'opérateur:
   AFFE_CARA_ELEM->MASSIF
   On donne les angles nautiques (ANGL_REP) ou d'Euler 
   (ANGL_EULER) qui permettent de passer du repère global au 
   repère local sur lequel s'appuieront les plans de 
   glissement.
   En outre, on permet de donner des paramètres élastiques
   orthotropes (i.e. propres à chaque direction de glissement),
   à l'aide de DEFI_MATERIAU->ELAS_ORTH.
   Pour l'instant, cette fonctionalité n'est opérationnelle 
   qu'en MECANIQUE PUR.
   
   VALIDATION:
   On porpose 2 cas-tests de validation:
   + compression isotrope d'un matériau ORTHOTROPE ELASTIQUE
     SSNV204B. On dégénère la loi de Hujeux en loi élastique
     orthotrope, et on valide par rapport à un calcul élastique
     vrai;
   + triaxial drainé avec une rotation du repère local de
     45° par rappart à la verticale (direction de chargement).
     On compare la solution obtenue à un calcul où le maillage
     est tourné. =>SSNV197D
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : R7.01.23, V6.04.197, U4.43.01, U4.51.11, V6.04.204, V7.31.132, V7.31.133, V7.31.134
VALIDATION
   ssnv204, ssnv197, wtnv134
NB_JOURS_TRAV  : 10.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR mazet        MAZET Sylvain          DATE 05/05/2008 - 18:18:44

--------------------------------------------------------------------------------
RESTITUTION FICHE 011974 DU 2008-04-11 20:53:39
TYPE anomalie concernant Code_Aster (VERSION 9.2)
TITRE
   En NEW9.2.19, les cas-tests ssnv209b/c/d/e s'arretent en ERREUR_<F> sur Calibre et Rocks.
FONCTIONNALITE
   En NEW9.2.19, les cas-tests suivants s'arretent en ERREUR_<F>:
   - sur Calibre: ssnv209b ssnv209c ssnv209d 
   - sur Calibre et Rocks: ssnv209e 
   pour un probleme de dimensionnement de memoire.
   
   Redimensionnement des cas.
   On en profite pour nettoyer les fichiers de commande.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 9.2.19
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V6.04.209
VALIDATION
   cas test ssnv209
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR nistor       NISTOR Ionel           DATE 05/05/2008 - 13:29:52

--------------------------------------------------------------------------------
RESTITUTION FICHE 012056 DU 2008-04-30 12:00:40
TYPE express concernant Code_Aster (VERSION 9.2)
TITRE
   Carte responsable pour les commandes concernant l'analyse modale
FONCTIONNALITE
   Les responsables des opérateurs d'Aster seront desormais 
   indiqués dans une carte introduite dans les catalogues 
   capy correspondants. Suite au partage fait au sein de 
   T61, aprouvé par l'équipe Aster, en ce qui concerne les 
   opérateurs de dynamique linéaire, je reprends la 
   responsabilité des opérateurs d'analyse modale. C'est 
   principalement une opération administrative qui 
   n'affectera pas les developpements qui seront portés 
   toujours par tous ceux qui ont les competences.
   J'ajoute donc une carte de responsable avec mon 
   nom dans:
   extr_mode.capy
   impr_sturm.capy
   macro_mode_meca.capy
   mode_iter_inv.capy
   mode_iter_simult.capy
   norm_mode.capy
   mode_statique.capy
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   neant
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR pellet       PELLET Jacques         DATE 06/05/2008 - 11:29:51

--------------------------------------------------------------------------------
RESTITUTION FICHE 011314 DU 2007-10-02 13:53:52
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   MN12 - Volumes finis dans Aster
FONCTIONNALITE
   Evolution souhaitée :
   ---------------------
   On veut permettre certains schémas de type "volumes finis" (VF) dans Code_Aster.
                                                                                            
                          
   Ces schémas numériques nécessitent 3 évolutions significatives :
     1) Ajouter au maillage une structure de données sd_voisinage décrivant le voisinage de
   chaque maille.
        remarque : ce sd_voisinage pourra etre réutilisé pour les calculs d'estimateurs
   d'erreurs.
     2) Une modification de la routine calcul.f pour que dans une routine te00ij, on puisse
   accéder aux champs "in" des éléments voisins.
     3) une modification de la structure de données sd_resuelem car un élément fini de type
   "volume fini" calcule une "matrice élémentaire"  qui implique les ddls de ses voisins.
                                                                                            
                          
                                                                                            
                          
   Conséquences :
   --------------
   1) Les éléments des modélisations "volumes finis" ont un nouvel attribut "VOLU_FINI='OUI'".
                                                                                            
                          
   2) Dans AFFE_MODELE, lorsque le modèle contient des "volumes finis", on ajoute au maillage
   la structure de données sd_voisinage (routine crevge.f).
      Pour chaque maille du maillage, la sd_voisinage contient la liste des voisins de cette
   maille. Ces voisins sont classés en "paquets" :
        "F3" : voisins 3D par une face
        "A2" : voisins 2D par une arrete
        ...
        "S0" : voisins 0D par un sommet.
                                                                                            
                          
      Un élément fini de type "volume fini" déclare quels sont les "paquets" de voisins qui
   l'intéresse. Pour cela, il utilise un nouvel attribut dans son catalogue. Par exemple :
      ATTRIBUT__  VOLU_FINI=OUI  TYPE_VOISIN=A2S2
                                                                                            
                          
      La routine permettant d'accéder au voisinage d'un élément est la routine voiuti.f
                                                                                            
                          
                                                                                            
                          
   3) Dans la routine calcul.f, si le ligrel contient des "volumes finis", les matrices
   élémentaires "out" sont allouées plus "grandes" que pour les éléments ordinaires. On dit
   qu'elles sont "VOISIN_VF".
      Ces matrices sont toujours non-symétriques.
                                                                                            
                          
      La convention de rangement est la suivante :
        Soit n0 le nombre de ddls de l'élément fini courant  E0
             n1 le nombre de ddls du 1er voisin              E1
             n2 le nombre de ddls du 2eme voisin             E2
             ...
    
        V(1)       : contribution (E0_1,E0_1)     )
        V(2)       : contribution (E0_2,E0_1)     ) => contribution E0 X E0
        ...                                       )
        V(n0+1)    : contribution (E0_1,E0_2)     )
        V(n0+2)    : contribution (E0_2,E0_2)     )
        ...                                       )
        V(n0*n0)   : contribution (E0_n0,E0_n0)   )
    
        V(n0*n0+1) : contribution (E0_1,E1_1)     )
        V(n0*n0+2) : contribution (E0_2,E1_1)     ) => contribution E0 X E1
        ...                                       )
    
   4) Lors de la construction du profil de la matrice assemblée (nume_ddl) et lors de son
   assemblage, prise en compte des nouvelles matrices élémentaires "VOISIN_VF".
                                                                                            
                          
   5) Certains calculs élémentaires ont un nouvel attribut "AVEC_VOISIN". Cet attribut
   indique que lorsque l'on traite un élément fini dans une routine te00ij, on veut pouvoir
   accéder aux champs "in" de ses voisins.
   Pour l'instant, les seuls calculs élémentaires "AVEC_VOISIN" sont ceux des éléments
   "volumes finis". Mais on pourrait se servir de cet attribut pour les calculs d'estimateur
   d'erreur.
      L'accès aux champs "in" des voisins se fait grace au nouvel utilitaire tecac2.f qui
   fait la meme chose que tecach.f pour un élément voisin.
                                                                                            
                          
      Remarques :
        - le nouvel attribut "AVEC_VOISIN" signifie que dans la routine calcul.f, les
   éléments finis ne sont pas traités indépendamment les uns des autres. Cette nouveauté
   remet a priori en cause le parallélisme des calculs élémentaires.
        - Les routines te00ij qui utiliseront tecac2.f utiliseront également voiuti.f pour
   connaitre la liste de leurs voisins.
                                                                                            
                          
                                                                                            
                          
                                                                                            
                          
   limites actuelles :
   -------------------
    1) Pour pouvoir utiliser TECAC2 sur une maille du voisinage, il faut que celle-ci soit
   incluse dans le meme GRELque l'élément courant. Pratiquement, cela veut dire que tous les
   éléments finis appartiennent au meme GREL. D'où deux contraintes pour l'utilisateur :
      1.1 : mailler avec un seul type de maille TRIA3, QUAD4, ...
      1.2 : si le maillage est conséquent, augmenter DEBUT/MEMOIRE/TAILLE_BLOC de façon à ce
   que les matrices élémentaires de tous les éléments finis puissent tenir dans un seul bloc.
      Cette limitation devra etre rapidement levée (fiche 12003)
                                                                                            
                          
    2) Ne pas utiliser le parallémisme MPI des calculs élémentaires. En effet, si un champ
   "in" est un cham_elem, il ne sera que partiellement renseigné sur les voisins d'un
   éléments. Les calculs seront alors faux.
                                                                                            
                          
                                                                                            
                          
                                                                                            
                          
   Validation :
   ------------
   On ajoute un nouveau test (vfin001a) qui utilise une modélisation de type VOLUME_FINI : "VF1".
   Dans ce test, on se contente de faire :
      - CALC_MATR_ELEM / 'RIGI_MECA'
      - NUME_DDL
      - ASSE_MATRICE
   On a vérifié (à la main) que l'assemblage des contributions des éléments voisins était
   bien fait.
   On fait un TEST_RESU sur l'objet .VALM de la matrice assemblée.
                                                                                            
                          
   Remarque : la modélisation VF1 est 1 modélisation bidon 2D concernant les TRIA3 et QUAD4.
   Elle est destinée à etre détruite dès qu'une vraie modélisation "VF" sera introduite.
                                                                                            
                                                                                                 
                          
   Impact documentaire :
   ---------------------
     D4.06.01 : sd_maillage :
        Ajout de la sd_voisinage
     D4.06.05 : sd_resuelem :
        NOLI(3) = ' '/'VOISIN_VF'
   
   Nombre de jours de travail : 12 = 5 (CC) + 7 (JP)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : D4.06.01 D4.06.05
VALIDATION
   nouveau test vfin001a
NB_JOURS_TRAV  : 12.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR lefebvre     LEFEBVRE Jean-Pierre   DATE 06/05/2008 - 11:29:51

--------------------------------------------------------------------------------
RESTITUTION FICHE 012004 DU 2008-04-18 10:44:16
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   cartes responsables pour chaque catalogue de commandes
FONCTIONNALITE
   Afin de mieux gérer les responsabilités des : commandes, modèles, comportements, et ne
   plus gérer cette information à part du source dans des fichiers excel, j'enrichis les
   catalogues.
   
   Chaque catapy de commande aura donc sa carte RESPONSABLE qui devra être tenue à jour au
   gré des réaffectations à gérer avec les CdG concernés.
   
   Pour les modèles, je ne sais pas faire autrement que mettre un commentaire avec le nom du
   responsable en vis à vis des modèles sous le mot clé RELATION d'AFFE_MODELE.
   
   Pour les comportements, en attendant d'avoir des catalogues de ldc qui eux pourront porter
   la carte responsable ad hoc, je gère par des commentaires, comme pour les modèles, dans le
   catalogue c_comp_incr.capy.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sans objet
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR pellet       PELLET Jacques         DATE 06/05/2008 - 11:29:51

--------------------------------------------------------------------------------
RESTITUTION FICHE 012017 DU 2008-04-18 18:01:41
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW9.2.20, le cas-test ssnv166b s'arrete en ERREUR_<F> sur Rocks.
FONCTIONNALITE
   Ce test est déjà en "mémoire dynamique". Il est OK sur bull avec 1Go.
   
   J'ai constaté qu'avec 1Go sur clpaster, le test se plante dans Mumps par manque de
   mémoire. Pourtant, côté Aster, les entiers sont 2 fois moins gros que sur bull.
   
   La différence de comportement enter les 2 machines doit donc venir de la gestion du batch :
    - Sur bull, on ajoute 350 Mo et rms vérifie que l'on ne dépasse pas la limite de mem_job.
    -  Sur clpaster, on n'ajoute pas de "rab" et je ne sais pas si le gestionnaire de batch
   utilise mem_job ou bien s'il se contente de vérifier que l'on dépasse pas la limite de la
   classe.
   
   En augmentant la mémoire autorisée : 1Go -> 1.3Go, le test est OK sur clpaster.
   
   Je modifie donc le .para du test pour qu'ils soit OK sur toutes les palteformes.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ssnv166b
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR galenne      GALENNE Erwan          DATE 06/05/2008 - 17:15:42

--------------------------------------------------------------------------------
RESTITUTION FICHE 011940 DU 2008-04-07 14:17:56
TYPE anomalie concernant Code_Aster (VERSION 9.2)
TMA : DeltaCad
TITRE
   CALC_G : bug en 3D pour LAGRANGE-LAGRANGE
FONCTIONNALITE
   Anomalie
   --------
   Résultats du taux de restitution d'énérgie faux dans le cas suivant: 
   - 3D local
   - fissure définie par le groupe de noeuds du fond et par la normale,
   - maillage quadratique.
   
   Anomalie qui fait suite à la réalisation de la fiche 11523 (restitué en 9.2.11).
   
   Correction
   ----------
   La routine gcour2.f a ete corrigee.
   On rappelle que l'objectif de cette routine est de déterminer :
   - la direction du champ theta,
   - le module de theta,
   - la variable booléene MILIEU qui caractérise le maillage(linéaire/quadratique).
   Dans la situation décrite ci-dessus, la variable MILIEU n'etait plus
   initialisée. Elle vallait donc FALSE par défaut, ce qui correspond à un maillage linéaire.
   Cette variable était ensuite exploitée pour le calcul de G avec le lissage
   LAGRANGE_LAGRANGE (routine gmeth3.f): les résultats étaient faux dès que le maillage etait
   quadratique.
   
   Validation informatique
   -----------------------
   Cas-test sslv110e:
   - définition d'un fond de fissure défini entre autres par le mot-clé DEFI_FOND_FISS/NORMALE,
   - calcul de G en 3D local avec un lissage LAGRANGE_LAGRANGE et le fond de fissure défini
   ci-dessus.
   - ajout d'un TEST_RESU de non-regression.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 9.2.11
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sslv110e
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR zentner      ZENTNER Irmela         DATE 25/04/2008 - 15:45:38

--------------------------------------------------------------------------------
RESTITUTION FICHE 012014 DU 2008-04-18 17:44:02
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW9.2.20, le cas-test zzzz180a s'arrete en ARRET_<A> sur Bull et Rocks.
FONCTIONNALITE
   Il y avait une erreur dans l'appel à RECU_FONCTION dans 
   POST_DYNA_ALEA: il y avait une valeur None dans la liste 
   lu. Il s'agit de la case correspondant à la premiere 
   ligne du tableau ou on ne renseigne pas NUME_ORDRE_I. On 
   évite donc les None:
   
   
   if NUME_ORDRE_I_present :
               imode = list(Set
   (intespec.NUME_ORDRE_I.not_none_values()))
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   zzzz180a
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST AJOUT sdns106d                     markovic D.MARKOVIC         187    187      0
 CASTEST AJOUT ssnp131b                      galenne E.GALENNE          368    368      0
 CASTEST AJOUT ssnv197d                     markovic D.MARKOVIC         489    489      0
 CASTEST AJOUT ssnv204b                     markovic D.MARKOVIC         350    350      0
 CASTEST AJOUT vfin001a                       pellet J.PELLET            45     45      0
 CASTEST MODIF hpla100i                      mahfouz D.MAHFOUZ          443     24      7
 CASTEST MODIF sdns106a                     markovic D.MARKOVIC         273    133    188
 CASTEST MODIF sdnv100a                      cnguyen C.NGUYEN           385      4      2
 CASTEST MODIF sensd09c                       boyere E.BOYERE           380     21     21
 CASTEST MODIF sensd09d                       boyere E.BOYERE           226     11     11
 CASTEST MODIF ssls126a                     markovic D.MARKOVIC         288     47    110
 CASTEST MODIF ssls126b                     markovic D.MARKOVIC         229     51    113
 CASTEST MODIF ssls127a                     markovic D.MARKOVIC         257     51    111
 CASTEST MODIF ssls127b                     markovic D.MARKOVIC         259     48    112
 CASTEST MODIF sslv110e                      rezette C.REZETTE          387     26      1
 CASTEST MODIF ssnl107b                      cnguyen C.NGUYEN           166      3      2
 CASTEST MODIF ssnl107c                      cnguyen C.NGUYEN           177      2      2
 CASTEST MODIF ssnl107d                      cnguyen C.NGUYEN           228      3      2
 CASTEST MODIF ssnv166b                       pellet J.PELLET           436      1      1
 CASTEST MODIF ssnv208a                     markovic D.MARKOVIC         591     13     27
 CASTEST MODIF ssnv209b                        mazet S.MAZET            512      9      9
 CASTEST MODIF ssnv209c                        mazet S.MAZET            512      9      9
 CASTEST MODIF ssnv209d                        mazet S.MAZET            516     10     10
 CASTEST MODIF ssnv209e                        mazet S.MAZET            512     10     10
 CASTEST MODIF ssnv209g                        mazet S.MAZET            452      9     80
 CASTEST MODIF ssnv209h                        mazet S.MAZET            448      8      8
 CASTEST MODIF ssnv503b                      cnguyen C.NGUYEN           429      5      2
 CASTEST MODIF ssnv503f                      cnguyen C.NGUYEN           543      4      2
 CASTEST MODIF ssnv505a                      cnguyen C.NGUYEN           225      3      2
 CASTEST MODIF ssnv505f                         kham M.KHAM             291     45     44
 CASTEST MODIF ssnv505g                      cnguyen C.NGUYEN           251      8      4
 CASTEST MODIF ssnv506a                       desoza T.DESOZA           286     14      6
 CASTEST MODIF wtnv134a                     markovic D.MARKOVIC         872    365     57
 CASTEST SUPPR ssns104a.comm                markovic D.MARKOVIC         400      0    400
 CASTEST SUPPR ssns104b.comm                markovic D.MARKOVIC         399      0    399
CATALOGU AJOUT typelem/gener_mevf1            pellet J.PELLET            42     42      0
CATALOGU MODIF compelem/phenomene_modelisation__     pellet J.PELLET          1391     19      1
CATALOPY AJOUT commande/defi_glrc           markovic D.MARKOVIC          72     72      0
CATALOPY MODIF commande/affe_char_meca_f     cnguyen C.NGUYEN           484      3      8
CATALOPY MODIF commande/affe_modele           pellet J.PELLET           247      2      1
CATALOPY MODIF commande/defi_interf_dyna       corus M.CORUS             39      3      2
CATALOPY MODIF commande/defi_materiau       markovic D.MARKOVIC        2860      2     35
CATALOPY MODIF commande/extr_mode             nistor I.NISTOR            57      3      2
CATALOPY MODIF commande/impr_fonction        cnguyen C.NGUYEN           137      3      1
CATALOPY MODIF commande/impr_macr_elem         corus M.CORUS             63      3      2
CATALOPY MODIF commande/impr_sturm            nistor I.NISTOR            42      3      2
CATALOPY MODIF commande/impr_table           cnguyen C.NGUYEN           123     16      1
CATALOPY MODIF commande/macr_elem_dyna         corus M.CORUS             42      3      2
CATALOPY MODIF commande/macro_mode_meca       nistor I.NISTOR            91      2      2
CATALOPY MODIF commande/mode_iter_inv         nistor I.NISTOR            97      3      2
CATALOPY MODIF commande/mode_iter_simult      nistor I.NISTOR           150      3      2
CATALOPY MODIF commande/mode_statique         nistor I.NISTOR            71      3      2
CATALOPY MODIF commande/modi_maillage           kham M.KHAM             158     22      9
CATALOPY MODIF commande/norm_mode             nistor I.NISTOR            61      3      2
CATALOPY MODIF commun/c_comp_incr           markovic D.MARKOVIC         369      5      4
CATALOPY MODIF commun/c_contact              cnguyen C.NGUYEN           319      7      4
 FORTRAN AJOUT algorith/hujori              markovic D.MARKOVIC         291    291      0
 FORTRAN AJOUT calculel/digde3                pellet J.PELLET            65     65      0
 FORTRAN AJOUT calculel/digde4                pellet J.PELLET            72     72      0
 FORTRAN AJOUT calculel/tecac2                pellet J.PELLET           365    365      0
 FORTRAN AJOUT elements/cdnfo2              markovic D.MARKOVIC          52     52      0
 FORTRAN AJOUT elements/diaexp              markovic D.MARKOVIC          49     49      0
 FORTRAN AJOUT elements/dimmai                pellet J.PELLET            34     34      0
 FORTRAN AJOUT elements/lsqpol              markovic D.MARKOVIC         222    222      0
 FORTRAN AJOUT elements/moconm              markovic D.MARKOVIC         274    274      0
 FORTRAN AJOUT elements/nbsomm                pellet J.PELLET            41     41      0
 FORTRAN AJOUT elements/parglr              markovic D.MARKOVIC          84     84      0
 FORTRAN AJOUT elements/te0427                pellet J.PELLET            98     98      0
 FORTRAN AJOUT elements/voiuti                pellet J.PELLET           217    217      0
 FORTRAN AJOUT modelisa/adlivo                pellet J.PELLET            77     77      0
 FORTRAN AJOUT modelisa/crevge                pellet J.PELLET           245    245      0
 FORTRAN AJOUT modelisa/crvloc                pellet J.PELLET           132    132      0
 FORTRAN AJOUT modelisa/dimvoi                pellet J.PELLET            42     42      0
 FORTRAN AJOUT modelisa/eclevo                pellet J.PELLET            60     60      0
 FORTRAN AJOUT modelisa/impvoi                pellet J.PELLET           129    129      0
 FORTRAN AJOUT modelisa/ioriv3                  kham M.KHAM              70     70      0
 FORTRAN AJOUT modelisa/op0057              markovic D.MARKOVIC         471    471      0
 FORTRAN AJOUT modelisa/orvlse                  kham M.KHAM             262    262      0
 FORTRAN AJOUT modelisa/somloc                pellet J.PELLET            64     64      0
 FORTRAN MODIF algorith/algocg                desoza T.DESOZA           654      8     27
 FORTRAN MODIF algorith/calcme              markovic D.MARKOVIC         468     14      8
 FORTRAN MODIF algorith/cfalgo                desoza T.DESOZA           191      2      2
 FORTRAN MODIF algorith/hujcdc              markovic D.MARKOVIC         120     22     22
 FORTRAN MODIF algorith/hujci1              markovic D.MARKOVIC         223     37     14
 FORTRAN MODIF algorith/hujcrd              markovic D.MARKOVIC          89     17     13
 FORTRAN MODIF algorith/hujddd              markovic D.MARKOVIC         590     86     72
 FORTRAN MODIF algorith/hujdp               markovic D.MARKOVIC         246     85     16
 FORTRAN MODIF algorith/hujdrc              markovic D.MARKOVIC          84      6      2
 FORTRAN MODIF algorith/hujela              markovic D.MARKOVIC         235    147     43
 FORTRAN MODIF algorith/hujiid              markovic D.MARKOVIC         751    220     77
 FORTRAN MODIF algorith/hujjid              markovic D.MARKOVIC        1086    248    179
 FORTRAN MODIF algorith/hujmat              markovic D.MARKOVIC         157     71     12
 FORTRAN MODIF algorith/hujmed              markovic D.MARKOVIC         126     12      9
 FORTRAN MODIF algorith/hujmid              markovic D.MARKOVIC         365      3      2
 FORTRAN MODIF algorith/hujpot              markovic D.MARKOVIC         408     70     58
 FORTRAN MODIF algorith/hujprc              markovic D.MARKOVIC         131     36     24
 FORTRAN MODIF algorith/hujpre              markovic D.MARKOVIC         161     20     11
 FORTRAN MODIF algorith/hujpxd              markovic D.MARKOVIC          96     16     10
 FORTRAN MODIF algorith/hujtel              markovic D.MARKOVIC         122     57     21
 FORTRAN MODIF algorith/hujtid              markovic D.MARKOVIC         467    128     64
 FORTRAN MODIF algorith/mecgme               mahfouz D.MAHFOUZ          306     14      9
 FORTRAN MODIF algorith/nmchsv               greffet N.GREFFET          162      3      3
 FORTRAN MODIF algorith/nmcomp              markovic D.MARKOVIC         793      2      2
 FORTRAN MODIF algorith/nmhuj               markovic D.MARKOVIC         494    102     71
 FORTRAN MODIF algorith/nmihht               greffet N.GREFFET          126      4      4
 FORTRAN MODIF algorith/nminit               greffet N.GREFFET          373      2      2
 FORTRAN MODIF algorith/op0070               greffet N.GREFFET          629      2      2
 FORTRAN MODIF algorith/op0113               geniaut S.GENIAUT          344      6      7
 FORTRAN MODIF algorith/vecgme               mahfouz D.MAHFOUZ          254     14      6
 FORTRAN MODIF algorith/xconno               geniaut S.GENIAUT          198     39     31
 FORTRAN MODIF algorith/xenrch               geniaut S.GENIAUT          501      2      7
 FORTRAN MODIF assembla/asretm                pellet J.PELLET            75     13      8
 FORTRAN MODIF assembla/assma2                pellet J.PELLET           185     31     34
 FORTRAN MODIF assembla/assma3                pellet J.PELLET           393    145     75
 FORTRAN MODIF assembla/assmam                pellet J.PELLET           764    125    110
 FORTRAN MODIF assembla/moinsr                pellet J.PELLET           199      2      2
 FORTRAN MODIF assembla/promor                pellet J.PELLET           446    257    208
 FORTRAN MODIF calculel/alchlo                pellet J.PELLET           128      4     13
 FORTRAN MODIF calculel/alresl                pellet J.PELLET           180     75     25
 FORTRAN MODIF calculel/alrslt                pellet J.PELLET           148     13      6
 FORTRAN MODIF calculel/caundf                pellet J.PELLET           225     28     18
 FORTRAN MODIF calculel/chloet                pellet J.PELLET           110      3      3
 FORTRAN MODIF calculel/dchlmx                pellet J.PELLET           162     24     11
 FORTRAN MODIF calculel/debca1                pellet J.PELLET           120     29      4
 FORTRAN MODIF calculel/debcal                pellet J.PELLET           401     11      5
 FORTRAN MODIF calculel/jevech                pellet J.PELLET           183     24      4
 FORTRAN MODIF calculel/mecoel                pellet J.PELLET           351     24      4
 FORTRAN MODIF calculel/modatt                pellet J.PELLET            77      2      1
 FORTRAN MODIF calculel/montee                pellet J.PELLET           155     19      7
 FORTRAN MODIF calculel/teattr                pellet J.PELLET           122      5     11
 FORTRAN MODIF calculel/tecach                pellet J.PELLET            30      4    303
 FORTRAN MODIF elements/brbagl              markovic D.MARKOVIC         132     31     33
 FORTRAN MODIF elements/cdnfon              markovic D.MARKOVIC          44     13     23
 FORTRAN MODIF elements/critnu              markovic D.MARKOVIC          73      8     23
 FORTRAN MODIF elements/d0mpfn              markovic D.MARKOVIC          64     23     53
 FORTRAN MODIF elements/d1crit              markovic D.MARKOVIC          85     16     13
 FORTRAN MODIF elements/d1cro2              markovic D.MARKOVIC         122     19     32
 FORTRAN MODIF elements/d2crit              markovic D.MARKOVIC         129     17     20
 FORTRAN MODIF elements/d2cro2              markovic D.MARKOVIC         218     22     34
 FORTRAN MODIF elements/ddmpfn              markovic D.MARKOVIC          84     25     69
 FORTRAN MODIF elements/distfo              markovic D.MARKOVIC          88     11      7
 FORTRAN MODIF elements/dktmas              markovic D.MARKOVIC         264     41      7
 FORTRAN MODIF elements/dktnli              markovic D.MARKOVIC         540     34      7
 FORTRAN MODIF elements/dndiss              markovic D.MARKOVIC         334    105     42
 FORTRAN MODIF elements/dxglrc              markovic D.MARKOVIC         453     30     10
 FORTRAN MODIF elements/dxsigt               mahfouz D.MAHFOUZ          176      4      3
 FORTRAN MODIF elements/gcour2               rezette C.REZETTE          623      7      1
 FORTRAN MODIF elements/glrcad              markovic D.MARKOVIC         297     39     35
 FORTRAN MODIF elements/glrcdd              markovic D.MARKOVIC         188     14     12
 FORTRAN MODIF elements/glrcmm              markovic D.MARKOVIC         131     43    156
 FORTRAN MODIF elements/interf              markovic D.MARKOVIC          66     22     22
 FORTRAN MODIF elements/maglrc              markovic D.MARKOVIC         214     92    238
 FORTRAN MODIF elements/mmfonc              markovic D.MARKOVIC          66      3     14
 FORTRAN MODIF elements/mppffn              markovic D.MARKOVIC          81     17     44
 FORTRAN MODIF elements/nmnet1              markovic D.MARKOVIC          67      7     13
 FORTRAN MODIF elements/nmnet2              markovic D.MARKOVIC          73      8     16
 FORTRAN MODIF elements/restzo              markovic D.MARKOVIC          88     17     41
 FORTRAN MODIF elements/te0030              markovic D.MARKOVIC         193      8      1
 FORTRAN MODIF elements/te0031              markovic D.MARKOVIC         415      7     24
 FORTRAN MODIF elements/te0142                boyere E.BOYERE           239      5      5
 FORTRAN MODIF elements/te0409              markovic D.MARKOVIC         396      7      5
 FORTRAN MODIF modelisa/cazocm               cnguyen C.NGUYEN           326      3     20
 FORTRAN MODIF modelisa/cazoco               cnguyen C.NGUYEN           189      2      3
 FORTRAN MODIF modelisa/charme               cnguyen C.NGUYEN           382      5      5
 FORTRAN MODIF modelisa/op0018                pellet J.PELLET           645      9      2
 FORTRAN MODIF modelisa/orilgm                  kham M.KHAM             357     66      4
 FORTRAN MODIF modelisa/xmolig               geniaut S.GENIAUT          328      9      1
 FORTRAN MODIF prepost/ircame              lebouvier F.LEBOUVIER        323      3      1
 FORTRAN MODIF prepost/irchme              lebouvier F.LEBOUVIER        261      4      3
 FORTRAN MODIF prepost/ircmec              lebouvier F.LEBOUVIER        206      6      6
 FORTRAN MODIF prepost/lrcmva              lebouvier F.LEBOUVIER        282      2      2
 FORTRAN MODIF prepost/lrcmve              lebouvier F.LEBOUVIER        327      2      2
 FORTRAN MODIF utilitai/dismlg                pellet J.PELLET           365     22      1
 FORTRAN SUPPR elements/cafonc              markovic D.MARKOVIC         137      0    137
  PYTHON AJOUT Messages/volufini              pellet J.PELLET            52     52      0
  PYTHON MODIF Macro/impr_fonction_ops       cnguyen C.NGUYEN           407      3      2
  PYTHON MODIF Macro/impr_table_ops          cnguyen C.NGUYEN           250     17      6
  PYTHON MODIF Macro/post_dyna_alea_ops      zentner I.ZENTNER          428      7      4
  PYTHON MODIF Messages/calculel4             pellet J.PELLET           256     10      1
  PYTHON MODIF Messages/compor1             markovic D.MARKOVIC         224     32      1
  PYTHON MODIF Messages/elements5           markovic D.MARKOVIC         190      7      1
  PYTHON MODIF Messages/elements             mahfouz D.MAHFOUZ          338      7      1
  PYTHON MODIF Messages/mecanonline2         mahfouz D.MAHFOUZ          114      6      1
  PYTHON MODIF Messages/modelisa4               kham M.KHAM             435      9      4
  PYTHON MODIF SD/sd_maillage                 pellet J.PELLET           123     11      1
  PYTHON MODIF SD/sd_mater                  markovic D.MARKOVIC          95     15      1
  PYTHON MODIF SD/sd_modele                   pellet J.PELLET            62      8      1
  PYTHON MODIF SD/sd_resuelem                 pellet J.PELLET            52      6      3
  PYTHON MODIF Utilitai/Graph                cnguyen C.NGUYEN          1210      4      2
  PYTHON MODIF Utilitai/Table                cnguyen C.NGUYEN          1023      8      8


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :   31        5021      5021             +5021
 MODIF :  156       47920      4356    3809      +547
 SUPPR :    3         936               936      -936
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :  190       53877      9377    4745     +4632 
