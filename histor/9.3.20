

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR abbas        ABBAS Mickael          DATE 03/11/2008 - 16:19:27

--------------------------------------------------------------------------------
RESTITUTION FICHE 012288 DU 2008-07-10 09:51:26
TYPE anomalie concernant Code_Aster (VERSION 9.3)
TITRE
   CRIT_FLAMB + LOI DE HUJEUX
FONCTIONNALITE
   Je n'ai constaté aucune différence en NEW9 sur les déplacements entre la version avec
   CRIT_FLAMB ou sans CRIT_FLAMB.
   Il semblerait que le problème ait disparu. Par contre, ça ne marche toujours pas en STA9.2
   
   
   NMOP45 a été corrigé en 9.3.15 par Nicolas (plus de CALL JEDETC('V','.&',20))
   Mais ce n'est pas ça (si on remet le CALL JEDETC, ça marche aussi bien que sans).
   
   
   Il s'est passé quelque chose entre la STA9.2 et la NEW9
   Peut-etre le nouveau solveur QZ en 9.3.11 a corrigé des choses sans qu'on le voit ?
   
   Je classe sans suite.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   celui de la fiche
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 012319 DU 2008-07-18 09:23:26
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   STAT_NON_LINE + DEPL_CALCULE
FONCTIONNALITE
   n ne restreint pas l'usage de DEPL_CALCULE avec ARRET=NON et ITER_GEOM_MAXI=0
   
   Dans le cas où l'on n'a pas de chargements de Dirichlet (AFFE_CHAR_MECA uniquement), on ne
   peut pas projeter le champ de deplacement donné sur un champ cinématiquement admissible ->
   on ne calcule pas de matrice en prédiction -> on n'a pas l'objet qu'il faut pour
   AFFE_CHAR_CINE -> actuellement, on plante en erreur fatale (ALGELINE2_88)
   
   Dans ce cas (pas de matrice), la modif. pour pouvoir quand même utilsier
   DEPL_CALCULE/EXTRAPOL consiste à:
   - alarmer l'utilisateur sur le fait que son champ peut ne pas etre cinématiquement admissible
   
   48 : _("""
     Vous utilisez l'option EXTRAPOL ou DEPL_CALCULE en prédiction,
     mais il n'y a aucune condition aux limites de Dirichlet dans EXCIT.
     donnée par AFFE_CHAR_MECA.
     On n'a donc pas pu projeter votre champ de déplacement donné ou extrapolé
     sur un champ cinématiquement admissible.
     -> Risque & Conseil :
      La convergence risque d'etre difficile si le champ donné ou extrapolé
      est vraiment cinématiquement non admissible.
   
   """),
   
   - Faire en sorte qu'on ne calcule pas le résidu d'équilibre et donc, qu'on n'a PAS
   convergence à la prédiction. Il y aura donc nécessairement une itération de correction
   après, ce qui implique que l'utilisateur l'ait proposé ou fait en sorte de ne pas en tenir
   compte (ARRET=NON et ITER_GLOB_MAXI=0)
   
   
   49 : _("""
     Vous utilisez l'option EXTRAPOL ou DEPL_CALCULE en prédiction,
     mais il n'y a aucune condition aux limites de Dirichlet dans EXCIT.
     donnée par AFFE_CHAR_MECA.
     L'absence de matrice en correction va empecher le code d'évaluer le
     résidu d'équilibre.
     -> Risque & Conseil :
      - Choisir REC_ITER et REAC_INCR judicieusement pour avoir une
      matrice en CORRECTION  
   """),
   
   On modifie un peu l'affichage. Dans le cas où l'on n'a pas calculé de résidu (DEPL_CALCULE
   sans Dirichlet ou même Erreur), le tableau de convergence:
   
   ---------------------------------------------------------------------
   |...ITERATIONS...|.....RESIDU.....|.....RESIDU.....|.....OPTION.....|
   |.....NEWTON.....|.....RELATIF....|.....ABSOLU.....|...ASSEMBLAGE...|
   |................|.RESI_GLOB_RELA.|.RESI_GLOB_MAXI.|................|
   ---------------------------------------------------------------------
   |.....0........X.|.--.NO..VALUE.--|.--.NO..VALUE.--|................|
   ---------------------------------------------------------------------
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.51.03
VALIDATION
   liste complete
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 012555 DU 2008-09-29 15:03:46
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Cas-tests avec charges suiveuses
FONCTIONNALITE
   Les cas-tests avec chargements suiveurs sont censés calculer des matrices_élémentaires
   spécifiques et les ajouter à la matrice globale.
   Or il s'avère, au vu du script de couverture de code que ce n'est plus le cas depuis la
   9.3.12.
   Ca ne provoque pas de résultats faux, juste des différences de vitesse de convergence
   (voir HSNA122A par exemple).
   Peut-etre est-ce aussi à l'origine des pivots nuls erratiques dans le cas-test ssnv145c
   sur ROcks.
   
   Il y a un bug dans l'évaluation de la présence des charges suiveuses dans NMFONC
   (ZI(JINFC+NBCHAR+ICHAR).EQ.4) 
   
   et non
   (ZI(JINFC+ICHAR).EQ.4)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ssnv145c
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 012650 DU 2008-10-16 15:23:45
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW 9.3.16, le cas-test ssnv145c s?arrete en ERREUR_<F> sur Rocks.
FONCTIONNALITE
   Ca marche en 9.3.18
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ssnv145c
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------
RESTITUTION FICHE 012672 DU 2008-10-20 12:25:45
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW 9.3.16, le cas-test sdnd100c est NOOK sur Rocks.
FONCTIONNALITE
   Bug dans ACEVD2
   
   CALL GETVTX(MCF,'CARA'     ,IOC,1,NBCAR,CAR      ,NCAR)
   
   
            DO 25 ICAR=1,NBCAR
              IF (CAR(ICAR)(3:4).EQ.'TR') GOTO 28
      25    CONTINUE
   
   
   Or NBCAR est un PARAMETER
   PARAMETER    ( NBCAR = 100 )
   Et le tableau CAR n'est pas initialisé
   
   Je corrige par:
   
   IF (NCAR.GT.NBCAR) CALL ASSERT(.FALSE.) (protection débordement)
   
   et la boucle:
   DO 25 ICAR=1,NCAR 
   
   A faire en 8
   
   En fait, c'est un premier bug. Mais il y en a un plus subtil
   
   Dans DICHOC.
   Pour savoir s'il y a glissement, on fait le test suivant:
   IF (FORT.GT.ABS(COULOM*KTY2)) THEN
    patacouffin
   ENDIF
   
   FORT-ABS(COULOM*KTY2) vaut -5.55111512E-17 sur les deux machines.
   Par contre, suivant la machine ou le niveau de DEBUG, on passe dans le test... ou non.
   Or ce test conditionne le passage glissant/adhérent, ça entraine donc une différence qui
   se propage tout au long du transitoire pour aboutir à un NOOK sur Rocks:
   NOOK DX           RELA    -4.219 % VALE: 3.4002311838543D-05
            NO1      TOLE     0.200 % REFE: 3.5500000000000D-05
   
   On pourrait essayer de blinder mieux DIS_CHOC, mais c'est dangereux en plus d'etre
   difficile. Il est fort probable qu'une modif dans DIS_CHOC impacte d'autres cas-tests.
   
   On propose donc de relever la tolerance à 5%
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sdnd100c
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 012694 DU 2008-10-23 10:52:36
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   THETA-Schema avec AFFE_CHAR_MECA
FONCTIONNALITE
   Le theta-schema dans DYNA_NON_LINE ne converge plus si on utilise des AFFE_CHAR_MECA.
   Le cas-test sdld31a validant le schéma utilise AFFE_CHAR_CINE. 
   
   En fait, le problème est plus grave.
   On ne respecte pas l'équilibre de manière générale !
   En élastique, sachant qu'on converge tout de suite, j'avais un peu "forcé" la convergence
   (RESi_GLOB_MAXI = 10)
   Si on laisse l'algo se "débrouiller" (vérifier l'équilibre strictement), ça devient faux
   ça ne converge pas
   
   
   Si on veut vérifier l'équilibre pour un theta_schema on doit avoir
   
   h*(Fint(theta)-Fext(theta))-M(Vm-Vp) = 0
   
   M est la masse
   h est le pas de temps
   Vm la vitesse avant l'équilibre
   Vp la vitesse à l'équilibre
   Fint les forces internes telles que Fint(theta) = (1-theta).Fint(m)+theta.Fint(p)  
   Fext les forces externes telles que Fext(theta) = (1-theta).Fext(m)+theta.Fext(p)  
   
   Pour vérifier cette équilibre un développement dans Aster est nécessaire. En effet lors de la
   recherche de la vitesse Vp, on utilise une équation de résolution différente (avec des
   termes différents) que lors de la verification de l'équilibre:
   
   On calcule Vp  = Vm+V_delta
   avec
   V_delta = (1./(M_tilde))*(Fext(theta)-Fint(m)-M_chap*Vm) 
   M_tilde = (M+pasdt*pasdt*theta*theta*K)/pasdt
   M_chap  = (theta*pasdt*K)
   (pasdt est le pas de temps, K la matrice de rigidité)
   
   Le terme de rappel dynamique M_chap*Vm est informatiquement intégré aux forces externes
   Fext(theta)
   Or, l'on voit que dans le cas de la vérification de l'équilibre, ce terme n'existe plus et
   est remplacé par M(Vm-Vp) qui est complétement différent.
   De plus, il convient de remplacer Fint(m) par Fint(theta).
   
   Les schémas classiques style Newmark (et même HHT avec modification de l'équilibre)
   permettent de retrouver des termes
   équivalents entre les deux équations (résolution et équilibre) qui ne nécessitent pas de
   modifications.
   Le theta-schema demande une ré-écriture partielle des routines.
   
   La routine NMFEXT se propose de calculer les forces externes. C'est cette routine qu'on
   appelait directement lors de la verification de la convergence. Avec le theta schema, on ne
   peut plus.
   
   1/ Modification de NMDEPL
   NMDEPL calcule les corrections des déplacements sur la solution donnée par Newton en
   fonction du pilotage, de la recherche linéaire et du contact discret. De plus, il
   recalcule les forces internes, les réactions d'appuis et les forces externes.
   On propose de séparer ces deux fonctions (calcul depl/force) en deux routines distinctes:
   NMDEPL et NMFCOR.
   
   2/ Modification de l'usage de NMFEXT
   NMFEXT est appelé principalement par deux type de routines:
   - quand on fait de la recherche linéaire ou du pilotage, afin d'avoir un second membre
   complet pour minimiser l'énergie
   - quand on évalue la convergence de Newton (NMCONV)
   On s'aperçoit qu'avec l'arrivée du theta-schema, il devient nécessaire de séparer les deux
   usages.
   NB: on ne fait pas de recherche linéaire ou de pilotage en dynamique, mais ça peut changer
   dans un court avenir (au moins pour la recherche linéaire).
   
   
   On sépare NMFEXT en deux sous-classes:
   - l'ancien usage: calcul du chargement extérieur pour la résolution du problème de
   dynamique -> conservé dans NMFEXT
   - le nouvel usage: calcul des termes pour équilibre de la structure -> déplacé dans une
   nouvelle routine (NMEQUI).
   
   3/ La nouvelle routine NMEQUI s'occupe d'évaluer l'équilibre de la structure
   - en statique et en dynamique implicite (sauf theta-schema en vitesse) NMRESI appelle NMFEXT
   - pour le theta schema, une nouvelle routine NDTHET
   
   Avec ces modifications l'équilibre est bien vérifié avec AFFE_CHAR_CINE (résidu valant
   quasiment zéro dès la première itération).
   Par contre avec AFFE_CHAR_MECA, ça ne fonctionne pas. Les réactions d'appui sont
   incorrectes, du fait que les Lagranges sont placé sur le vecteur vitesse et non sur le
   vecteur déplacement.
   Le terme de "réaction d'appui" est alors Bt.Lambda(vitesse), ce qui ne correspond PAS aux
   vraies réactions d'appui.
   
   Nous n'avons actuellement pas de solution pour ce problème. A noter que ce problème existe
   également pour le schéma explicite sauf qu'on n'évalue PAS l'équilibre, ce qui implique
   que des réactions d'appui fausses n'ont aucun impact sur le résultat final.
   
   Solution:
   Tout comme les DDL actuellement affectés d'une relation de type AFFE_CHAR_CINE, on propose
   que les DDL impliqués par un Lagrange (double dualisation) soient ignorés lors de
   l'estimation de l'équilibre pour le theta-schema en vitesse e tle Newmark en accélération. 
   
   Remarques:
   - Les conditions limites étant linéaires dans Aster, il est inutile en théorie de tester
   leur convergence.
   - Si la structure n'a pas de chargement en force, on aura le même problème qu'avec les
   AFFE_CHAR_CINE actuellement (on ne pourra estimer la convergence.
   - Le post-traitement des réactions d'appuis (REAC_NODA) est JUSTE car il fait simplement
   la différence entre forces externes et forces internes et n'utilise donc pas les Lagrange.
   - Quand on écrit DDL_IMPO dans le cas des schémas en vitesse/accélération, on impose la
   valeur de ces dernières et non celle du déplacement. Si c'est zéro, aucun problème, si on
   dit DDL_IMPO=4, on dit que la vitesse (ou l'accélération) vaut 4 et non les déplacements.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 9.3.11
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : R5.05.05
VALIDATION
   liste complete
NB_JOURS_TRAV  : 4.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 012719 DU 2008-10-24 11:48:15
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   STAT_NON_LINE - Second membre pour les variables de commandes
FONCTIONNALITE
   C'est normal et pas tout en fait en même temps.
   
   L'option CNVCPR calcule la _variation_ de chargement due à la variation de température.
   C'est le cas pour toutes les variables de commande (sauf pour les phases métallurgiques).
   
   DELTA_FEXT(VARI_COMM) = FEXT(VARI_COMM_T+) - FEXT(VARI_COMM_T-) 
   Il y a donc bien DEUX appels à l'option CHAR_MECA_TEMP_R (un en T+, un en T-)
   
   L'option CVNVF0 calcule la valeur en T+ des variables de commandes. Mais ceci ne sert que
   dans l'estimation de la convergence (NMCONV). Ce n'est effectivement pas optimal puisqu'on
   va recalculer deux fois la quantité FEXT(VARI_COMM_T+).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   rien
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 012720 DU 2008-10-24 12:10:10
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   calcul d'agregat en parallele (STAT_NON_LINE)
FONCTIONNALITE
   La méthode de subdivision par extrapolation echoue.
   En fait, on plante au niveau de l'estiamtion du ratio:
   IF ( (CIBLEN-MAXITE) .LE. (-10.0D0*XA1/XDET) ) THEN
             RATIO = EXP( (CIBLEN-MAXITE)*XDET/XA1 )
           ELSE
             RATIO = EXP( -10.0D0 )
           ENDIF
   
   Car XA1 est nul. XA1 est nul car la régression a échoué.
   Il faut prévoir une echappatoire:
   Quand XA1 est nul, on prend le ratio "par défaut" :
   
   RATIO    = 24.0D0/((3.0D0*NBRPAS+UN)**2 - UN)
   
   Et on force la subdivision uniforme.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   etude jointe
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 012748 DU 2008-10-29 14:22:23
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   mesure temps STAT_NON_LINE
FONCTIONNALITE
   Sur la bull en NEW9 : les temps mesurés pour l'intégration (0s),
   résolution (0s) ... sont un peu léger par rapport au temps réel ...
   
   
   
   
   ---------------------------------------------------------------------
    
   INSTANT DE CALCUL :  1.000000000E+00
    
   ---------------------------------------------------------------------
   |   ITERATIONS   |     RESIDU     |     RESIDU     |     OPTION     |
   |     NEWTON     |     RELATIF    |     ABSOLU     |   ASSEMBLAGE   |
   |                | RESI_GLOB_RELA | RESI_GLOB_MAXI |                |
   ---------------------------------------------------------------------
   |     0          | 8.09964E-14    | 7.18343E-17    |TANGENTE        |
   ---------------------------------------------------------------------
    
   <*> CRITERE(S) DE CONVERGENCE ATTEINT(S)
    
   RESIDU RESI_GLOB_RELA   VAUT  8.099635736E-14 SUR N3965   DX      
    
   ARCHIVAGE DES CHAMPS: 
      CHAMP STOCKE : DEPL             INSTANT :  1.00000E+00  NUMERO D'ORDRE :     1
      CHAMP STOCKE : SIEF_ELGA        INSTANT :  1.00000E+00  NUMERO D'ORDRE :     1
      CHAMP STOCKE : VARI_ELGA        INSTANT :  1.00000E+00  NUMERO D'ORDRE :     1
    
   TEMPS CPU CONSOMME DANS CE PAS DE TEMPS :  1 m 16.420 s           
      TEMPS PAR ITERATION DE NEWTON  :  0.000 s                 - NBRE NEWT.:     1
      TEMPS ARCHIVAGE                :  0.000 s                
      TEMPS CREATION NUMEROTATION    :  0.000 s                 - NBRE NUME.:     1
      TEMPS FACTORISATION MATRICE    :  0.000 s                 - NBRE FACT.:     1
      TEMPS INTEGRATION COMPORTEMENT :  0.000 s                 - NBRE INTE.:     2
      TEMPS RESOLUTION K.U = F       :  0.000 s                 - NBRE RESO.:     1
      TEMPS AUTRES OPERATIONS        :  0.000 s                
    
   
   Un bug dans impfot: SECOND n'était pas initialisé
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   neant
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR assire       ASSIRE Aimery          DATE 04/11/2008 - 15:16:42

--------------------------------------------------------------------------------
RESTITUTION FICHE 011222 DU 2007-09-07 09:08:24
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TITRE
   Stanley et sensibilitxc3xa9
FONCTIONNALITE
   Pour un calcul qui contient a la fois un resultat avec sensibilité et un resultat sans
   sensibilité, lorsque l'on choisit le concept résultat sans sensibilité avec un paramètre
   sensible dans PRE_STANLEY, alors Aster aboutit en arretanormal avec un message peut
   explicite pour l'utilisateur.
   
   On corrige : maintenant, la colone des parametres sensibles est rafraichit lorsque l'on
   selectionne un resultat (du coup les parametres sensibles disparaissent s'ils sont sans
   objet pour le resultat non derive).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   perso
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 012413 DU 2008-08-29 13:26:39
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW8.7.3, le cas-test feti007a est NOOK sur Rocks.
FONCTIONNALITE
   Ce test est OK en 8.7.4.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   feti007a
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 012639 DU 2008-10-16 14:11:31
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW 9.3.16, les cas-tests forma03d et zzzz159e s?arretent en ARRET_<A> sur Bull et Rocks
FONCTIONNALITE
   Petit soucis dans MACR_RECAL : lorsque la liste de liste des parametres ne contient qu'un
   seul parametre, comme dans les tests zzzz159e et forma03d, alors on perd un niveau de
   liste lors de la transmision du mot-clé.
   
   On corrige simplement en testant si on envoie un seul parametre ou plusieurs.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   zzzz159e et forma03d
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR bodel        BODEL Charles          DATE 03/11/2008 - 17:48:32

--------------------------------------------------------------------------------
RESTITUTION FICHE 012247 DU 2008-06-27 12:16:44
TYPE anomalie concernant Code_Aster (VERSION 9.3)
TITRE
   En NEW9.3.2, le cas-test sdlv125a s?arrete en Abormal Abort sur Calibre 5 (claut626).
FONCTIONNALITE
   Probleme : 
   ----------
   
   En NEW9.3.2, le cas-test sdlv125a s?arrete en Abormal Abort sur la machine Calibre 5.
   avec un fpe
   
   Solution :
   ----------
   On avait désactivé les fpe pour les opérations d'inversion délicates (svd). Sur calibre 5
   (machine clau5aaa), il y a aussi plantage par fpe sur certaines multiplications de matrices.
   On résout le problème en désactivant les fpe sur toutes les étapes du calcul inverse, avec
   un commentaire dans le .py sur les raisons.
   
   Sources modifiées : meidee_calcul_turbulent.py
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sdlv125a
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 012706 DU 2008-10-23 18:59:11
TYPE anomalie concernant Code_Aster (VERSION 9.3)
TITRE
   En NEW 9.3.17, le cas-test sdlv125a s?arrete en ERREUR_<F> sur Calibre 5.
FONCTIONNALITE
   Voir fiche 12247
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sdlv125a
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR boyere       BOYERE Emmanuel        DATE 03/11/2008 - 17:33:17

--------------------------------------------------------------------------------
RESTITUTION FICHE 012222 DU 2008-06-20 12:56:03
TYPE anomalie concernant Code_Aster (VERSION 9.3)
TITRE
   En NEW9.3.1, le cas-test sdll112a s?arrete en NOOK sur Rocks
FONCTIONNALITE
   Le test sdll112a donne des NOOK qui semblent aléatoires suivant les machines ou le type de
   compilation (debug ou nodebug). Ce cas teste les méthodes de calcul des réponses sismique
   en spectral (opérateur COMB_SISM_MODAL). Une revue détaillée des sources de l'opérateur ne
   met en évidence aucun souci de programmation (en dehors de l'organisation et de
   l'optimisation des performances en mémoire et temps CPU).
   
   En revanche le test révèle nettement la limitation de la méthode SRSS (square root of the
   square sum) pour le calcul une réponse sismique. En effet, comme le précise la doc
   R4.05.03 en page 21, la méthode SRSS "oublie", dans sa restitution de la réponse totale à
   partir des réponses de chaque mode, la contribution des termes croisés entre mode. Or la
   littérature explique clairement que ces termes croisés ne peuvent être négligés que si les
   modes sont "indépendants" entre eux, c'est-à-dire s'ils sont "éloignés" en fréquence.
   Voir, par exemple, Structural Dynamics - Theory & Applications, Tedesco, McDougal, Allen
   Ross, p 643, Addison Wesley 1999 ou "A replacement for the SRSS method in seismic
   analysis", Wilson, Der Kuireghian, Bayo in Earthquake Engineering & Structural Dynamics
   vol. 9 pp 178-194 (1981).
   En conséquence la méthode SRSS est assez bien adaptée pour les analyses dans le plan
   maisfortement déconseillée pour les études en 3D, particuliérement lors de la présence de
   modes doubles.
   
   Or le test sdll112a met en oeuvre un calcul sismique en 3D sur une structure filaire, qui
   possède donc des modes doubles dont l'orientation varie suivant le déroulement du calcul
   modal. Jusqu'à la version 9.3.1, il validait uniquement la méthode CQC (combinaison
   quadratique complète), qui intègre les termes croisées et qui, donc, donne des résultats
   invariables et acceptables. On a alors introduit en complément un calcul avec la méthode
   SRSS, probablement pour en démontrer l'insuffisance et l'inconstance.
   A la demande de l'EDA je supprime le test en question, puisqu'il constitue plus un
   contre-exemple de l'emploi de la méthode SRSS qu'une validation de cette méthode.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sdll112a
NB_JOURS_TRAV  : 3.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 010814 DU 2007-04-25 13:53:26
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TITRE
   Problxc3xa8me SD DYNA_TRANS
FONCTIONNALITE
   Fiche resolue par Jacques (fiche 12736) et Ionel qui ont fait un ménage important dans les
   structures de données de type resultat_dyn. Les details du travail sont donnés donc dans
   la fiche 12736.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   astout
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------
RESTITUTION FICHE 010975 DU 2007-06-13 12:17:52
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TITRE
   REST_BASE_PHYS crxc3xa9e parfois une SD_resultat incorrecte
FONCTIONNALITE
   Fiche resolue par Jacques (fiche 12736) et Ionel qui ont fait un ménage important dans les
   structures de données de type resultat_dyn. Les details du travail sont donnés donc dans
   la fiche 12736.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   astout
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR pellet       PELLET Jacques         DATE 04/11/2008 - 10:44:24

--------------------------------------------------------------------------------
RESTITUTION FICHE 012655 DU 2008-10-17 10:46:38
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   Tests de performance xc3xa0 harmoniser
FONCTIONNALITE
   Tests de performance :
   ----------------------
                                                                                            
                           
   1) Je simplifie et harmonise les fichiers .para (et .comm) des tests de performance :
       - .comm : on utilise la mémoire JEVEUX par défaut (DYNAMIQUE=1)
       - .para : on donne un seul paramètre memjob=1.15*(mémoire minimum jeveux)
                 on diminue le temps CPU (de l'ordre de 30% en plus du temps nécessaire)
                                                                                            
                           
   2) perf002b est cassé sur bull en 9.3.16 :
       Le test s'est arreté lors du finmaj du 15/10 avec un message "le fichier gibi est vide."
       J'ai fait passer 4 fois les 2 tests perf002a,b sur bull le 17/10 :
         Seul le test perf002a s'est planté 1 fois par le message "le fichier gibi est vide."
                                                                                            
                           
       Mathieu Courtois pense que ce problème aléatoire vient peut-etre d'un problème de
   licence gibi : plusieurs jobs cherchent à écrire en meme temps dans ce fichier.
                                                                                            
                           
       => je modifie tous les tests de performance :
                                                                                            
                           
          < EXEC_LOGICIEL(MAILLAGE=_F(FORMAT='GIBI', UNITE_GEOM=14, UNITE=20,
   MAILLAGE=CO('MA'),),INFO=1,)
          ---
          > MA=LIRE_MAILLAGE(FORMAT='MED')
                                                                                            
                           
       Ce qui veut dire que gibi ne sera plus exécuté à chaque fois.
       J'ai du produire les fichiers .mmed (à partir des fichiers gibi).
       Inconvénient : le volume des 17 fichiers *.mmed fait 231 Mo
                                                                                            
                           
                                                                                            
                           
   3) Utilisation de la nouvelle macro CALC_MODAL pour les tests perf003.
                                                                                            
                           
   Dernière remarque :
   Je cherche une ame charitable pour faire la restitution de cette fiche (asrest assez long !)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   tests de performance
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 04/11/2008 - 14:22:47

--------------------------------------------------------------------------------
RESTITUTION FICHE 012641 DU 2008-10-16 14:26:19
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW 9.3.16, le cas-test sslv130a s?arrete en ARRET_<A> sur Bull.
FONCTIONNALITE
   La variable YAXFEM n'était pas initialisée dans meca01.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sslv130a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 012758 DU 2008-10-31 09:13:33
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW 9.3.19, le cas-test sensd08a s?arrete en ARRET_<A> sur Rocks, sensd09b sur Bull.
FONCTIONNALITE
   sensd08a passe sans surcharge sur Rocks.
   sensd09b passe aussi sans surcharge sur Bull.
   => 2 bugs relevés dans semoco.f et wpsorn.f (variables non initialisées)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sensd08a, sensd09b
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR delmas       DELMAS Josselin        DATE 27/10/2008 - 13:11:13

--------------------------------------------------------------------------------
RESTITUTION FICHE 012423 DU 2008-09-02 10:44:29
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   nouveau test perf008 : calcul statique sur une structure massive
FONCTIONNALITE
   Contexte :
   ==========
   Jacques a restitué des cas tests de performance (fiche 12190). Pour l'élasticité linéaire,
   la structure était un tube creux (perf001). Pour une structure plus massive, la
   connectivité des mailles n'est plus la même : une maille est connectée à plus de maille
   que dans le cas du tube creux. Ainsi le système à résoudre est plus important ; la matrice
   à inverser est "moins" creuse que dans le cas du tube creux. Il manque donc un test de
   performance sur une structure massive.
   
   Fonctionnalité :
   ================
   On restitue un nouveau cas test de performance (perf008). La structure est un diabolo
   soumis à un chargement thermique sinusoïdal.
   
   PERF008
   ********
   Type d'analyse :
     Calcul élastique (1 pas de temps)
   Structure :
     Diabolo
   Chargement :
     Thermique
   Comportement matériel :
     élastique
   Type de maille dominant :
     HEXA8
   ..............................A...........B...........C...........D
   Nb ddls.....................5E5.........5E5.........1E6.........2E6
   Nb elements..............187680.......50348......367480......716976
   Mémoire (Mo)...............8000.......15000.......20000.......32000
   CPU (TOTAL_JOB).........1764.78.....3395.50.....7516.45..........NC
   CPU (MECA_STATIQUE).....1743.00.....3378.06.....6652.64..........NC
   
   On note que la modélisation B est en quadratique.
   
   Les tests sont ajoutés à la liste de performance.
   
   Remarque :
   ==========
   Le solveur est par défaut est le solveur multi-frontal MULT_FRONT. Ce solveur intègre deux
   stratégies différentes (une normale et une économique). Quand on utilise comme paramètres
   mémoire ceux donnés à la fin de l'exécution, le solveur plante car il essaie d'utiliser la
   stratégie économique qui semble être bugguée (fiche 12567 émise à ce sujet). Ceci explique
   les paramètres mémoires importants. On propose de restituer les tests avec ces valeurs et
   de les modifier quand la fiche sur MULT_FRONT sera traitée.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   non r?ession
NB_JOURS_TRAV  : 5.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desoza       DE SOZA Thomas         DATE 03/11/2008 - 14:02:46

--------------------------------------------------------------------------------
RESTITUTION FICHE 012677 DU 2008-10-20 12:42:08
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW 9.3.16, le cas-test ssnv129c est NOOK sur Calibre 4 et Rocks.
FONCTIONNALITE
   Anomalie
   ========
   
   En 9.3.16, le cas-test ssnv129c est NOOK sur Calibre 4 et Rocks sur des tests de non
   régression.
   
   Analyse
   =======
   
   Un passage en INFO=2 montre une différence d'appariement entre les machines 64 bits (Bull
   et Calibre 5) et les machines 32 bits.
   Les tests analytiques restent OK, la différence est trop minime pour justifier une
   investigation poussée.
   
   Conclusion
   ==========
   
   On ajuste la tolérance de 0.01 % à 0.02 % sur les tests de non-régression.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ssnv129c
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 012693 DU 2008-10-23 08:33:05
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   Petite erreur dans l'interface PETSc
FONCTIONNALITE
   Nicolas m'a fait remarquer une petite bévue dans l'interface PETSc de Code_Aster. En effet
   en séquentiel, on est susceptible de faire deux fois l'opération de préparation du
   préconditionneur (si celui-ci ne teste pas si l'opération a déjà été faite).
   Il s'agit de rajouter 2 lignes dans apets3.F
   
   Pour les cas d'utilisation autorisés à l'heure actuelle, cela n'entraînait pas de surcoût.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   perso
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 012696 DU 2008-10-23 11:18:43
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   MN10 - CONTACT - Bugs calculs ?mentaires m?ode 'CONTINUE'
FONCTIONNALITE
   Anomalies
   =========
   
   Une relecture des sources appelées à partir de TE0364/TE0365 (calculs élémentaires des
   matrices et seconds membres de la méthode 'CONTINUE') a mis en évidence des bugs.
   
   Analyse
   =======
   
   * Les nombreux tableaux utilisés (TE0364/TE0365) ne sont pas initialisés entièrement, on
   le fait systématiquement pour éviter des surprises.
   * Dans la réactualisation géométrique (MMGEOM), lorsque que l'on est en formulation
   'VITE', un mauvais c/c entraîne l'utilisation des fonctions de formes de l'esclave au lieu
   du maître.
   * Dans l'usure, toutes les boucles sont sur I=1,NDIM (dimension de l'espace) alors que la
   dernière est sur I=1,3. Le tableau VECT passé alors en argument de nombreuses routines est
   alors non initialisé (possible lien avec 12526).
   * Dans une sous-routine appelée quand il y a du frottement pour le calcul de la matrice
   élémentaire, on trouve une boucle sur I,J sans dépendance sur I et J à l'intérieur. Dans
   le doute je la laisse mais il faudra statuer.
   
   Sources impactées
   =================
   
   (M) te0364.f te0365.f mmgeom.f mmmjac.f mmmab0.f
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   astout contact
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 012701 DU 2008-10-23 18:30:03
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW 9.3.17, le cas-test feti009a est NOOK sur Bull, Calibre 4, Calibre 5 et Rocks.
FONCTIONNALITE
   Anomalie
   ========
   
   Suite à la restitution de la fiche 11236 sur le rétablissement des fonctions de forme
   standards de Code_Aster pour la méthode 'CONTINUE', le cas-test feti009a est NOOK. Les
   tests concernés sont des tests de non-régression.
   
   Analyse
   =======
   
   Les surfaces de contact sont des triangles à 3 noeuds. Le changement des fonctions de
   forme a justement entraîné le déplacement de l'élément de référence pour ce cas précis (et
   donc des points de contact).
   Ici le schéma d'intégration est aux noeuds et comme les noeuds des surfaces en contact
   sont en vis à vis, cela peut entraîner un appariement différent (visible en INFO=2) pour
   un rien.
   
   Pour pallier à cela, j'ai essayé de changer de points d'intégrations mais aucun autre
   choix que 'NOEUD' ne fonctionne (soit on ne converge pas dans Newton, soit on diverge dans
   'FETI') !
   
   Conclusion
   ==========
   
   Je propose donc l'ajustement des valeurs de non-régression à une nouvelle référence. Je
   peux me le permettre car :
   ce test fait apparaître l'alarme "convergence forcée sur la boucle de géométrie". En
   augmentant ITER_GEOM_MAXI, cette alarme disparaît mais le test est NOOK, j'en conclue donc
   que les valeurs de référence étaient déjà sensibles et que je peux les ajuster.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   feti009a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 012708 DU 2008-10-23 19:05:50
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW 9.3.17, le cas-test ssnp121j est NOOK sur Bull et Rocks.
FONCTIONNALITE
   Anomalie
   ========
   
   Suite à la restitution de la fiche 11236 sur le rétablissement des fonctions de forme
   standards de Code_Aster pour la méthode 'CONTINUE', le cas-test ssnp121j est NOOK. Les
   tests concernés sont des tests analytiques auparavant parfaitement OK.
   Par ailleurs en debug, le test est OK avec les mêmes valeurs qu'avant.
   
   Analyse
   =======
   
   Afin de déterminer la cause du NOOK, un première exécution en INFO=2 montre que certains
   des noeuds esclaves de contact (correspondant dans la méthode 'CONTINUE' à des points
   d'intégration) sont appariés avec des mailles différentes en debug et nodebug (les mailles
   maîtres sont ici des triangles quadratiques) :
   
   --nodebug--
    <CONTACT>     * MAILLE ESCLAVE M181     ( ZONE     1) AVEC     4 POINTS DE CONTACT
    <CONTACT>     ** POINT DE CONTACT   2
    <CONTACT>        SITUE EN  : < 0.600E+00, 0.200E+00> - POIDS INTEGRATION:  0.260E+00
    <CONTACT>        SE PROJETTE SUR LA MAILLE MAITRE M376     EN  < 0.120E+01, 0.000E+00>
   
   --debug--
    <CONTACT>     * MAILLE ESCLAVE M181     ( ZONE     1) AVEC     4 POINTS DE CONTACT
    <CONTACT>     ** POINT DE CONTACT   2
    <CONTACT>        SITUE EN  : < 0.600E+00, 0.200E+00> - POIDS INTEGRATION:  0.260E+00
    <CONTACT>        SE PROJETTE SUR LA MAILLE MAITRE M381     EN  < 0.200E+00, 0.600E+00>
   
   Or le maillage est parfait (faces en vis-à-vis) et les points d'intégration (ici 'NCOTES'
   correspond maladroitement à un schéma de Hammer à 4 points) sont situés à l'intérieur des
   triangles, il ne devrait donc pas y avoir d'ambiguïté par rapport à la projection.
   
   Rappelons brièvement le principe de l'appariement noeud-facette. Pour un noeud esclave
   donné, on commence par chercher son vis-à-vis maître le plus proche (distance
   euclidienne). Puis on parcourt toutes les mailles maîtres (disons n) s'appuyant sur ce
   noeud le plus proche et on projette le noeud esclave dessus. Comme en général la
   projection va s'effectuer en dehors de la maille, un mécanisme existe pour rabattre (ou
   pas) un projeté dans l'élément courant.
   Une fois ces opérations effectuées, il faut choisir parmi les n projetés celui qui
   permettra de créer l'élément de contact. Ceci est fait sur des hypothèses de distance
   entre le noeud esclave et le projeté.
   
   À l'aide d'affichages supplémentaires dans le Fortran, on finit par se rendre compte que
   la projection en debug et nodebug sur ssnp121j est quasiment la même (les différences se
   comptent au 15 ou 16ème chiffre après la virgule). Plus précisément pour un des noeuds qui
   pose problème :
   
   --nodebug--
    <MMPROJ> /   KSI1 =    1.20000000000000     
    <MMPROJ> /   KSI2 =   0.000000000000000E+000
   
   --debug--
    <MMPROJ> /   KSI1 =    1.20000000000000     
    <MMPROJ> /   KSI2 =  -4.440892098500642E-016
   
   Le rabattement donne alors ceci :
   
   --nodebug--
    <CFPROJ> /  KSI1L =    1.20000000000000     
    <CFPROJ> /  KSI2L =   0.000000000000000E+000
   
   --debug--
    <CFPROJ> /  KSI1L =    1.00000000000000     
    <CFPROJ> /  KSI2L =   0.000000000000000E+000
   
   On constate un premier problème : le rabattement dans le cas nodebug, ne marche pas
   puisque l'on se retrouve avec un projeté qui n'est pas dans l'élément de référence !
   Et pour cause : il reste encore un bug dans cfadju.f, qui gère le rabattement.
   En effet il existe deux demi-droites (KSI1>1 et KSI2=0 et vice-versa) pour lesquels les
   cas ne sont pas prévus, on sort donc de la routine sans rien faire.
   
   En corrigeant cfadju, cela suffit à rendre le test OK. Néanmoins les affichages ont montré
   un autre problème. En effet le rabattement fonctionne ainsi : dans tous les cas, les
   projetés sont ramenés dans les éléments de référence puis, si la tolérance TOLE_PROJ_EXT
   est dépassée alors on le signale par l'activation du logique LDIST.
   Or la routine qui s'occupe ensuite de faire le choix est différenciée selon méthodes
   discrètes et continue (c'est la seule qui demeure ainsi). Et dans le cas 'CONTINUE', on ne
   tient jamais compte de LDIST. Ainsi un projeté qui a été rabattu peut être sélectionné au
   détriment d'un projeté non rabattu, ce qui est inconcevable.
   
   Conclusion
   ==========
   
   On corrige cfadju.f et cfchoi.f selon les explications ci-dessus.
   Le test est devenu NOOK par le changement des fonctions de forme car on a changé de
   méthode de rabattement au profit du rabattement des méthodes discrètes qui contenait
   toujours un bug pour le cas des triangles.
   Par ailleurs le choix de la maille appariée pour la méthode 'CONTINUE' était buggé lui aussi.
   
   Un appariement faux peut entraîner des résultats légèrement erronés mais pas spécialement
   faux (ici les tests analytiques étaient vérifiés à 2% près).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.44.01
VALIDATION
   astout contact
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 012710 DU 2008-10-23 19:12:23
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW 9.3.17, le cas-test ssnv128t est NOOK sur Bull, Calibre 4, Calibre5 et Rocks.
FONCTIONNALITE
   Anomalie
   ========
   
   Suite à la restitution de la fiche 11236 sur le rétablissement des fonctions de forme
   standards de Code_Aster pour la méthode 'CONTINUE', le cas-test ssnv128t est NOOK. Les
   tests concernés sont des tests de non-régression.
   
   Analyse
   =======
   
   Ce test est cassé par une modification de dernière minute que j'ai effectuée sur les
   schémas d'intégration de la méthode 'CONTINUE'. Pour les segments à 3 noeuds, on trouvait
   ainsi comme schéma aux noeuds ceci :
   
           w1=2/3        w2=2/3
             v             v
             o------x------o
                    ^        
                  w3=2/3
   
   Or on trouve dans l'ouvrage "Abramowitz and Stegun. Handbook of Mathematical Functions" un
   schéma aux noeuds (méthode des trapèzes) différent et qui semble plus juste. Au lieu
   d'avoir des poids équi-répartis on a :
   w1 = 1/2
   w3 = 1
   w2 = 1/2
   
   Un rapide calcul permet de se convaincre que l'erreur commise sur l'intégration de la
   fonction chapeau suivante (linéaire par morceaux) :
   
    |\
    | \
   o|  \x___o
   
   est nulle avec le nouveau schéma et de l'ordre de 33% avec l'ancien schéma.
   
   Conclusion
   ==========
   
   Je modifie les valeurs de non-régression puisque les précédentes étaient basées sur un
   schéma d'intégration faux.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ssnv128t
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 012711 DU 2008-10-23 19:17:17
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW 9.3.17, le cas-test ssnv506e s?arrete en ARRET_<A> sur Bull, Calibre4, Calibre5 et Rocks.
FONCTIONNALITE
   Anomalie
   ========
   
   Suite à la restitution de la fiche 11236 sur le rétablissement des fonctions de forme
   standards de Code_Aster pour la méthode 'CONTINUE', le cas-test ssnv506e ne converge plus.
   
   Analyse
   =======
   
   Dans cette modélisation axisymétrique, le contact s'effectue entre deux surfaces composées
   de segments à 2 noeuds ('SE2'), il s'agit du seul type d'élément de peau pour lequel le
   basculement des fonctions de forme n'a rien changé du tout.
   La cause du problème est donc annexe, il s'agit du rabattement selon TOLE_PROJ_EXT.
   Méthodes 'CONTINUE' et discrètes n'adoptaient en effet pas la même définition pour les
   segments (et pour le reste d'ailleurs).
   
   Ainsi dans les méthodes discrètes le 0.5 (par défaut) de TOLE_PROJ_EXT est à comprendre
   comme une longueur. Pour les segments dont l'élément de référence est de longueur 2, cela
   signifie qu'un point se projetant à plus d'un quart(0.5=0.25*2) de la longueur d'une des
   extrémités est exclu du contact.
   Tandis que pour la méthode 'CONTINUE', la définition était bien celle de la documentation
   à savoir un pourcentage par rapport à la longueur de l'élément.
   
   En pratique cela signifie que les TOLE_PROJ_EXT de la méthode 'CONTINUE' dans le cas des
   segments auraient dû être multipliés par 2.
   
   Ici en passant à TOLE_PROJ_EXT=1.0 on retrouve en effet un test OK. Or comme l'utilisation
   de ce mot-clé pour de telles valeurs est non naturelle et comme TOLE_PROJ_EXT=-1.0 marche
   aussi, c'est cette valeur que je choisis d'ajouter au test.
   
   Conclusion
   ==========
   
   On ajoute TOLE_PROJ_EXT=-1.0 (pas de rabattement) au test qui redevient OK.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ssnv506e
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR galenne      GALENNE Erwan          DATE 03/11/2008 - 14:13:06

--------------------------------------------------------------------------------
RESTITUTION FICHE 012730 DU 2008-10-27 12:56:49
TYPE anomalie concernant Code_Aster (VERSION 9.4)
TITRE
   En NEW 9.3.18, le cas-test sslv315a est NOOK sur Rocks, Calibre 4 et Calibre 5.
FONCTIONNALITE
   Problème
   --------
   TEST_TABLE NOOK sur la valeur de K dans le cas test sslv315a. Il s'agit d'un test de
   propagation de fissure.
   
   Explication
   ------------
   On sait qu'il y a une légère différence sur le calcul de K entre plateforme (< 0,1 %).
   Cette différence fait qu'à la 2ème itération, on n'a plus exactement le même fond de
   fissure, donc un écart sur K qui devient visible.
   Plus exactement, l'écart sur K1 -qui est la valeur prépondérante- reste modéré (0,5 %),
   alors que l'écart sur K2 dépasse 10 %... mais la valeur de K2 est 10 fois plus faible (la
   fissure a justement bifurqué pour minimiser K1). Si on poursuit le calcul de propagation,
   cela n'aura donc trop pas de conséquence.
   
   Correction
   ---------
   On augmente la tolérance sur K1 et K2.
   
   Remarque : même chose pour le sslv314a
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sslv315a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 012760 DU 2008-10-31 09:40:08
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW 9.3.19, le cas-test sslv314a est NOOK sur Calibre 4.
FONCTIONNALITE
   idem 12730
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sslv314a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR lefebvre     LEFEBVRE Jean-Pierre   DATE 03/11/2008 - 14:02:02

--------------------------------------------------------------------------------
RESTITUTION FICHE 012686 DU 2008-10-22 09:18:20
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   le cas test ssnv166c plante en NEW9 sur la bull
FONCTIONNALITE
   Le test ssnv166c est exécuté en mémoire statique avec une partition de la mémoire. Au
   cours de l'exécution cette partition est supprimée pour pouvoir s'allouer une zone, le
   mécanisme en question devrait éliminer toute trace de la partition, ce n'est pas le cas .
   La mise en oeuvre récente de la vérification de la segmentation mémoire dans la commande
   FIN (appel à JXVERI) détecte une anomalie, ce qui aurait pu se produire avec l'appel à
   JEIMPM. Cette ereur n'a aucun impact sur les calculs, seules les deux routines ci-dessus
   pouvaient détecter ce défaut.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test ssnv166c
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 012676 DU 2008-10-20 12:39:10
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW 9.3.16, le cas-test ssna118a s?arrete en ERREUR_<F> sur Calibre 5.
FONCTIONNALITE
   Le test en question traite un grand nombre de numéros d'ordre (plus de 400) dans deux
   appels à STAT_NON_LINE sur un problème de petite taille (1197 noeuds) avec un paramètre
   mémoire limité (140 Mo). La routine JELGDQ évaluant l'espace disque associé aux différents
   concepts ramène en mémoire de nombreux objets systèmes de collection qui finissent par
   saturer cette dernière. C'est une pathologie propre au test, une étude réelle n'aurait pas
   le même comportement (des JEVEUO auraient déclenché le mécanisme de libération effective
   de la mémoire).
   On modifie l'appelant de JELGDQ (OP9999 commande FIN) pour libérer en début de routine
   toute la mémoire dynamique disponible (appel à JJLDYN). Cette modification permet de faire
   passer le test, changer le paramètre mémoire aurait certainement permis une exécution
   correcte.
   
   La remontée d'erreur montre que l'on s'arrête lors de la libération, or à cet endroit on a
   bloqué l'appel au mécanisme de libération de la mémoire dynamique pour éviter les appels
   récurcifs.
   
   #13 0x40000000001196c0 in u2mesg_??unw ()
   #14 0x4000000000119c50 in u2mesi_??unw ()
   #15 0x40000000000f1360 in jjalls_??unw ()
   #16 0x40000000000f7890 in jjlide_??unw ()
   #17 0x40000000001e65a0 in jelgdq_??unw ()
   #18 0x40000000001e4470 in uimpba_??unw ()
   #19 0x40000000001870f0 in op9999_??unw ()
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test ssna118a
NB_JOURS_TRAV  : 0.3
--------------------------------------------------------------------------------
RESTITUTION FICHE 012725 DU 2008-10-27 12:43:53
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW 9.3.18, les cas-tests sdns106a et ssns106d s?arretent en ERREUR_<F> sur Bull et Calibre 5.
FONCTIONNALITE
   Dans ces deux tests dont la mémoire est limitée à 64 Mo, on s'arrête dans une branche de
   programmation où il est interdit de faire appel au mécanisme de libération des objets
   jeveux alloués dynamiquement. Depuis la 9.3.19 (fiche 12683), la routine JJLDYN a été
   modifiée 
   pour ne plus faire appel aux routines JJALLC, JJVERN et JJLIDE . Il est donc possible de faire
   appel au mécanisme de libération dans tous les cas. On corrige donc JJALLS en autorisant la
   mise en oeuvre du mécanisme de libération, mais en protégeant l'appel à l'impression du
   contenu
   de la mémoire qui reste récursif. 
   Avec cette modification, les tests sdns106a et ssns106d s'exécutent correctement.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sdns106a et ssns106d
NB_JOURS_TRAV  : 0.3
--------------------------------------------------------------------------------
RESTITUTION FICHE 012299 DU 2008-07-15 10:15:10
TYPE evolution concernant Code_Aster (VERSION 7.0)
TITRE
   AR01 - message jeveux sur nombre d'enregistrements
FONCTIONNALITE
   Le message JEVEUX_42 a été modifié en version 9.3.7 :
   
   42 : _("""
        Fichier saturé, le nombre maximum d'enregistrement %(i1)d de la base %(k1)s est atteint
        il faut relancer le calcul en passant une taille maximum de base sur la ligne de
   commande 
        argument "-max_base" suivi de la valeur en Mo.
   """),
   
   De plus la valeur par défaut pour la taille maximum des fichiers associés aux bases
   stockées sous le répertoire temporaire d'exécution vaut maintenant 50 Go.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test personnel
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------
RESTITUTION FICHE 012396 DU 2008-08-26 08:51:12
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   catalogue macr_europlexus
FONCTIONNALITE
   Anomalie corrigée.
   
   A. Assire est désigné comme responsable dans le catalogue de la commande macr_europlexus.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sans objet
NB_JOURS_TRAV  : 0.001
--------------------------------------------------------------------------------
RESTITUTION FICHE 012359 DU 2008-07-31 07:05:41
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Ecrasement amont en version 8
FONCTIONNALITE
   Il s'agit d'un problème propre au gestionnaire de mémoire JEVEUX : lors de la suppression
   de la partition mémoire, la variable IDINIT(2) donnant la position de la seconde zone
   mémoire n'est pas remise à zéro. L'appel à JXVERI détecte alors une anomalie. Le problème
   existe aussi en version 9.
   La correction consiste à affecter IDINI(2) = 0 à la ligne 85.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   Sur l'xc3xa9tude fournie
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 012577 DU 2008-10-01 15:35:19
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Troncature du param?e mem_jeveux
FONCTIONNALITE
   Corrigée le 08/10/08 en version 9.3.15 par Mathieu :
   Dans memjvx la ligne suivante 
   <       MEM_JEVEUX=(INTEGER)((INTEGER)(*val)*1024*1024);
   a été remplacée par 
   >       MEM_JEVEUX=(INTEGER)((*val)*1024.*1024.);
   
   Suite à l'introduction du cast par le type INTEGER en 9.3.13
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test personnel
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------
RESTITUTION FICHE 012538 DU 2008-09-25 19:31:35
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Test ascou20a en version NEW9.3.12 sur Bull
FONCTIONNALITE
   Le test ascou20a fonctionne depuis la version 9.3.16. Fiche classée sans suite
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ascou20a en 9.3.19
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR galenne      GALENNE Erwan          DATE 03/11/2008 - 19:09:15

--------------------------------------------------------------------------------
RESTITUTION FICHE 012704 DU 2008-10-23 18:47:07
TYPE anomalie concernant Code_Aster (VERSION 9.4)
TMA : CS
TITRE
   En NEW 9.3.17, le cas-test rccm07a est NOOK sur Rocks.
FONCTIONNALITE
   Problème:
   -------------
   En NEW 9.3.17, le cas-test rccm07a est NOOK sur Rocks.
   
   Solution:
   -------------
   Suite à l'évolution réalisée dans le cadre de la fiche 12297, une variable de contrainte
   équivalente SN n'a pas été correctement initialisée dans la routine rc32sn.f. 
   De plus, le mot-clé TYPE_CHAR n'avait pas été correctement supprimé (Fiche 12367). Le
   travail est complété.  
   
   Fortran:
   rc32sn.f rcmo02.f rc32cm.f 
   rc36si.f rc36cm.f rc36rm.f
   
   Catalogue Python:
   post_rccm.capy
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   cas-tests utilisant post-rccm
--------------------------------------------------------------------------------
RESTITUTION FICHE 012745 DU 2008-10-29 09:26:53
TYPE anomalie concernant Code_Aster (VERSION 9.4)
TITRE
   POST_RCCM : erreur dans le calcul en fatigue avec UNITAIRE
FONCTIONNALITE
   Contexte
   --------
   La formulation du calcul en fatigue dans POST_RCCM a été complètement revue (fiche 12297
   restituée en 9.3.17).
   Il apparait qu'il y a deux anomalies dans la mise en oeuvre de cette nouvelle formulation :
   1/ il faut faire la combinaison des situations sur le facteur d'usage et non sur les
   contraintes alternées;
   2/ quand il n'y a pas de thermique, la programmation était trop conservative.
   
   Correction
   ----------
   1/ Il faut construire un tableau sur les facteurs d'usage et non plus sur SALT. Cela permet,
   pour les combinaisons de situations, de bien faire apparaitre la somme des FU et non la
   somme des SALT.
   
   Impact :
   -> rc32sa : on rajoute le FU en sortie
   -> rc32ac : suppression du calcul de FU pour les situations non combinables (calcul fait
   dans rc32sa)
   -> rc3201 : on transforme la matrice des SALT en matrice des FU
   -> rc32fu, rc32fp, rc32fs : en entrée on prend la matrice des FU
   
   Dans le tableau résultat (si TYPE_RESU=DETAILS), on trouve deux colonnes supplémentaires
   indiquant les Salt des deux transitoires fictifs (SALT1_IJ SALT2_IJ) pour toutes les
   combinaisons de situations 
   Dans le fichier message (si INFO=2), on trouve cette information le Sp ainsi que les
   facteurs d'usage de ces deux transitoires
   
   2/ Dans la programmation actuelle, si il n'y a pas de thermique, les 2 transitoires fictifs
   définis entre 2 situations sont identiques et égal à la combinaison la plus pénalisante.
   Cela est trop conservatif : il faut prendre les deux combinaisons maximales.
   
   Impact :
   -> rc3201 : si il n'y a pas de thermique, on fait un traitement spécifique. Le matériau
   restenu pour la suite du calcul est celui de la combinaison max.
   
   Validation
   ----------
   - validation sur un cas test informatique (2 situations sans thermique) : comparaison avec
   un calcul "à la main" (excel)
   - validation sur la base des cas test
   
   REMARQUE : on modifie les tableaux des transitoires thermiques fournis en entrée du
   rccm04a (fichier rccm04a.38). En effet, dans les tableaux actuels, un seul pas de temps
   était défini : la formulation précédente considérait en effet les contraintes max et non
   l'amplitude des contraintes. Cela revenait en fait implicitement à supposer que la
   contrainte min était nulle.
   Dans la formulation actuelle, on calcule explicitement l'amplitude des contraintes (qui
   est donc nulle s'il n'y a qu'un pas de temps). Pour retrouver des résultats cohérents avec
   la formulation précédente, on rajoute dans tous les transitoires un pas de temps à
   contrainte nulle.
   
   Avec cette modification, on observe que les facteurs d'usage sont cohérents entre STA9 et
   NEW9 (de l'ordre de +/- 10% de variation du facteur d'usage elon le segment et le point
   considéré).
   C'est aussi cette tendance que l'on retrouve dans les autres cas tests de la base (rcc07,
   rcc10, rccm11).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   rccm04,rccm07,rccm11
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR nistor       NISTOR Ionel           DATE 03/11/2008 - 14:05:56

--------------------------------------------------------------------------------
RESTITUTION FICHE 012700 DU 2008-10-23 18:21:46
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW 9.3.17, le cas-test efica01a s?arrete en ARRET_<A> sur Bull, Calibre4, Calibre5 et Rocks.
FONCTIONNALITE
   Probleme:
   ----------------------------
   Le cas-test efica01a s'arretait en erreur de syntaxe lorsqu'on arrivait
   à REST_BASE_PHYS
   
   Solution:
   ----------------------------
   En effet, la commande REST_BASE_PHYS n'existe plus depuis la NEW9.3.17 étant 
   remplacée par REST_GENE_PHYS/REST_SOUS_STRUC/REST_COND_TRAN J'ai manqué ce cas-
   test lors de la modification de syntaxe - il a plusieurs fichiers de commande 
   (.com0, .com1, .com2).
   J'opére donc la correction de syntaxe et REST_BASE_PHYS passe en REST_GENE_PHYS
   
   Validation:
   ------------------------------
   efica01a
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   efica01a
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR durand       DURAND Christophe      DATE 03/11/2008 - 18:51:30

--------------------------------------------------------------------------------
RESTITUTION FICHE 011771 DU 2008-02-18 12:49:25
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Thermique lumpee sur des elements quadratiques
FONCTIONNALITE
   Complétude de la validation pour la thermique lumpee sur des elements quadratiques :
   enrichissement des modélisations de tpna01
   
   J'en profite pour rendre ces tests beaux : maillages salomé, extraction de valeurs
   résultat par macr_lign_coupe ... 
   ajout des modélisations d et e.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V4.41.001
VALIDATION
   tests livrxc3xa9s
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 03/11/2008 - 18:51:30

--------------------------------------------------------------------------------
RESTITUTION FICHE 012091 DU 2008-05-15 14:52:41
TYPE anomalie concernant Code_Aster (VERSION 9.3)
TITRE
   FORMULE + CREA_CHAMP
FONCTIONNALITE
   L'utilisateur écrit ceci :
   
   DX  = 25.0
   RHO = 2.0
   depldx2 = FORMULE(NOM_PARA=('X','Y',),VALE = 'RHO*(DX*X/((X**2+Y**2)**0.5))',);
   
   
   Ensuite, il crée un champ de formule (CREA_CHAMP/AFFE) et évalue ce champ en fournissant
   en paramètres un champ de coordonnées CHXN (composantes X, Y, Z) et un champ de
   déplacement DEPL (composantes DX, DY, DZ).
   
   L'interprétation de la formule est faite avec DX du champ de déplacement et non 25.0 du JDC.
   
   => Lors de l'évaluation, on vérifie :
    - que tous les paramètres de la formule sont fournis
    - qu'aucun paramètre n'est fourni 2 fois
   De plus, on limite les valeurs à la liste des paramètres.
   
   Sur l'exemple :
    - on vérifie que X et Y sont fournis par les champs CHXN et DEPL
    - on vérifie que X et Y n'apparaissent qu'une fois dans la liste des composantes
    - dans le dictionnaire qui sert à l'évaluation de l'expression, on ignore Z, DX, DY, DZ.
   
   
   En cas d'erreur, on avait :
   
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   ! Erreur evaluation formule depldx1 
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   
   
   On a maintenant par exemple :
   
      !-------------------------------------------------------------------!
      !.<A>.<FONCT0_51>...................................................!
      !...................................................................!
      !...................................................................!
      !.Erreur.lors.de.l'interprétation.de.la.formule.'depldx1'...........!
      !...................................................................!
      !.Certains.paramètres.de.la.formule.ont.été.fournis.plusieurs.fois..!
      !.Paramètres.répétés.:.X,.Y.........................................!
      !...................................................................!
      !...................................................................!
      !...................................................................!
      !.Ceci.est.une.alarme..Si.vous.ne.comprenez.pas.le.sens.de.cette....!
      !.alarme,.vous.pouvez.obtenir.des.résultats.inattendus.!............!
      !-------------------------------------------------------------------!
      
      
      !----------------------------------------------------------!
      !.<EXCEPTION>.<FONCT0_9>...................................!
      !..........................................................!
      !..........................................................!
      !.Erreur.lors.de.l'interpolation.de.la.fonction.'depldx1'..!
      !..........................................................!
      !.Nombre.de.paramètres.fournis.:.9.........................!
      !.Noms.des.paramètres.fournis..:.DX.DY.DZ.X.Y.Z.X.Y.Z......!
      !..........................................................!
      !----------------------------------------------------------!
      
      
      !----------------------------------------------------------!
      !.<EXCEPTION>.<FONCT0_9>...................................!
      !..........................................................!
      !..........................................................!
      !.Erreur.lors.de.l'interpolation.de.la.fonction.'depldx1'..!
      !.sur.le.noeud.'N1'........................................!
      !..........................................................!
      !----------------------------------------------------------!
   
   
   Impact :
    - fiintf (évaluation des formules, dans B_ETAPE.py + astermodule.c) retourne maintenant 3
   valeurs : code_retour, message_erreur, resultat.
    - les appelants fointe, fointa, fointc peuvent ainsi gérer l'affichage du message d'erreur.
    - on ajoute un argument à fointc CODMES='A' ou 'F'
    - on utilise cette possibilité dans cnseve et ceseva (CREA_CHAMP) pour compléter le
   message du nom du noeud ou de la maille courante.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   zzzz130a, zzzz234a
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 012317 DU 2008-07-18 07:00:40
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Code_Aster - base - Stanley
FONCTIONNALITE
   Suite à la résolution de la fiche 11015, on a ajouté un attribut "executed" au concept
   afin de faire le tri entre les concepts présents dans un jeu de commandes.
   En effet, en PAR_LOT='OUI', tous les objets 'concept' existent mais ceux qui apparaissent
   après la commande courant n'ont pas encore été calculés/remplis. Quand on lance STANLEY,
   il faut donc faire le tri entre ceux qui sont déjà calculés et ceux qui ne le sont pas encore.
   
   Cet attribut executed est mis à 1 par lors de l'exécution de l'étape qui produit le concept.
   Or en POURSUITE, cet attribut n'était pas restauré. C'est facile car tous les concepts
   relus dans la base sont forcément "exécutés".
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   zzzz107b en poursuite
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR pellet       PELLET Jacques         DATE 03/11/2008 - 18:51:31

--------------------------------------------------------------------------------
RESTITUTION FICHE 012584 DU 2008-10-03 14:57:01
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Performance commande AFFE_CHAR_MECA
FONCTIONNALITE
   Problème:
   ---------
   Jean-Luc Fléjou a remarqué que dans un AFFE_CHAR_MECA sur un gros maillage avec beaucoup
   d'occurences du mot clé facteur CONTACT, on passe beaucoup de temps dans la routine reliem.f
                                                                                            
                  
   En essayant d'améliorer les performances de cette routine, on s'est aperçu que 2 objets
   (alloués à chaque appel à reliem) sont gros :
      '&&RELIEM.INDIC_MAILLE'   : nombre de mailles du maillage
      '&&RELIEM.INDIC_NOEUD'    : nombre de noeuds du maillage
                                                                                            
                  
   Je me suis dit que si ces vecteurs d'entiers étaient plus "petits", on pourrait gagner du
   temps CPU en diminuant le nombre de "conflits de cache".
                                                                                            
                  
   Solution:
   ---------
   On modifie ces 2 vecteurs pour en faire des vecteurs d'entiers "courts" (I4).
                                                                                            
                  
   Validation:
   -----------
   Jean-Luc a essayé cette petite modification de reliem et il a observé (en général) un gain
   CPU de l'ordre de 50%.
                                                                                            
                  
   Temps passé :
   -------------
   JP  : 0.25
   JLF : 1
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   essais par Jean-Luc Flxc3xa9jou
NB_JOURS_TRAV  : 1.25
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 03/11/2008 - 18:51:31

--------------------------------------------------------------------------------
RESTITUTION FICHE 012640 DU 2008-10-16 14:19:03
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW 9.3.16, le cas-test perf002b s?arrete en ERREUR_<F> sur Bull.
FONCTIONNALITE
   Apparemment, c'est un problème d'accès au fichier de licence quand Gibi s'arrête comme çà.
   Je vois deux causes possibles :
   - pb NFS
   - accès concurrents lors du lancement de tous les tests perf en même temps
   
   Solution : On n'arrête d'appeler GIBI dans le cas-test. On part du fichier med.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   perf*
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR pellet       PELLET Jacques         DATE 03/11/2008 - 18:51:31

--------------------------------------------------------------------------------
RESTITUTION FICHE 012643 DU 2008-10-16 14:32:23
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW 9.3.16, le cas-test yyyy104d s?arrete en ERREUR_<F> sur Bull.
FONCTIONNALITE
   Problème:
   ----------
   Le test yyyy104d est cassé sur bull en 9.3.16
                                                                                            
                     
   Solution:
   ---------
   Le plantage a lieu dans la routine modat2.f à l'occasion de l'accès à un objet de la
   collection '&CATA.TE.OPTMOD'.
                                                                                            
                     
   J'ai surchagé le code avec la nouvelle routine jjldyn.f que Jean-Pierre doit restituer
   demain et le problème a disparu !
                                                                                            
                     
   => sans suite
                                                                                            
                     
   Détail amusant :
   -----------------
   L'execution qui s'est plantée le 24/10 sur aster9 dans CALC_ELEM, avait déjà consommé 554s
   dans la commande FACTORISER.
   Aujourd'hui (avec surcharge de jjldyn.f), l'exécution totale a duré 220s !
                                                                                            
                     
   J'ai regardé l'historique des performances de ce test et j'ai obtenu les valeurs extremes
   suivantes sur l'année 2008 :
      mini=216s
      maxi=408s
                                                                                            
                     
   Si le calcul du 24/10 était allé au bout, on aurait "explosé" le maxi !
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   yyyy104d
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 012648 DU 2008-10-16 15:12:38
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW 9.3.16, le cas-test yyyy117a s?arrete en ERREUR_<F> sur Rocks.
FONCTIONNALITE
   Problème:
   ---------
   Le test yyyy117a se plante dans le te0581 sur clpaster.
                                                                                            
                         
   Solution:
   ---------
   Jean-Michel a instrumenté le source de te0581 pour en savoir plus :
                                                                                            
                         
         CALL TECACH('ONN','PEPCON1',7,JTAB1,IRET)
         CALL TECACH('ONN','PEPCON2',7,JTAB2,IRET)
         CALL TECACH('ONN','PEPCON3',7,JTAB3,IRET)
                                                                                            
                         
         IF ( JTAB1(1)*JTAB2(1)*JTAB3(1).EQ.0 ) THEN
            WRITE(6,*) ' ', JTAB1(1)    # ajout JMP
            WRITE(6,*) ' ', JTAB2(1)    # ajout JMP
            WRITE(6,*) ' ', JTAB3(1)    # ajout JMP
            VALK(1) = OPTION
            VALK(2) = NOMTE
            CALL U2MESK('F','ELEMENTS4_38', 2 ,VALK)
         ENDIF
                                                                                            
                         
   Et il a été supris de voir que, bien que leur produit soit 0 :
          JTAB1=-231864320
          JTAB2=-231919616
          JTAB3=-231974912
                                                                                            
                         
   C'est vraiment la faute à "pas de chance" : le produit de 3 adresses jeveux non nulles est
   nul grace aux propriétés de l'arithmétique entière !
                                                                                            
                        
   J'ai effectivement repris ces nombres "pas de chance" dans un petit programme fortran :
                                                                                            
                        
   -----------------------------------------------------------------------------------
          program toto
          integer*4 i1, i2, i3
          i1=-231 864 320
          i2=-231 919 616
          i3=-231 974 912
                                                                                            
                         
          write(6,*) 'i1+1=',i1+1
          write(6,*) 'i2+1=',i2+1
          write(6,*) 'i3+1=',i3+1
                                                                                            
                         
          write(6,*) 'i1*i2=',i1*i2
          write(6,*) 'i1*i2*i3=',i1*i2*i3
          write(6,*) 'i1*i2*(i3+1)=',i1*i2*(i3+1)
          write(6,*) 'i1*i2*(i3+2)=',i1*i2*(i3+2)
                                                                                            
                  
          end
   -----------------------------------------------------------------------------------
   Ce programme, exécuté sur clpaster produit le résultat suivant :
    i1+1= -231864319
    i2+1= -231919615
    i3+1= -231974911
    i1*i2= 159383552
    i1*i2*i3= 0
    i1*i2*(i3+1)= 159383552
    i1*i2*(i3+2)= 318767104
   -----------------------------------------------------------------------------------
                                                                                            
                        
   On constate que i1*i2*i3 est bien nul ! ce qui est très surprenant pour un ingénieur de la
   vieille école.
                                                                                            
                         
   Pourtant, la multiplication des "grands nombres" conserve une certaine régularité :
   i1*i2*(i3+2) = i1*i2*i3 (0) + i1*i2*2 = 318767104  !!
                                                                                            
                         
   Reste une question non élucidée :
   Pourquoi cette programmation (qui existe depuis la version 5.2.21) n'a jamais produit ce
   problème et qu'elle le fait assez systématiquement depuis 15 jours ? Est-ce parce que les
   adresses en "Jeveux dynamique" sont plus "négatives" ?
                                                                                            
                                                                                            
                                               
   Conclusion :
   ------------
   Pour tester que 3 adresses JEVEUX sont toutes non nulles, il ne faut pas utiliser l'astuce
   de tester leur produit mais il faut tester les 3 valeurs.
                                                                                            
                         
   Je modifie te0581.f en conséquence
                                                                                            
                         
   Temps passé :
   -------------
   JMP : 0.3
   JP  : 0.1
   
   Correction à reporter en NEW8 :
   -------------------------------
   te0581.f :
   67c67
   <       IF ( JTAB1(1)*JTAB2(1)*JTAB3(1).EQ.0 ) THEN
   ---
   >       IF ( (JTAB1(1).EQ.0) .OR.(JTAB2(1).EQ.0).OR.(JTAB3(1).EQ.0)) THEN
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   yyyy117a
NB_JOURS_TRAV  : 0.4
--------------------------------------------------------------------------------
RESTITUTION FICHE 012655 DU 2008-10-17 10:46:38
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   Tests de performance xc3xa0 harmoniser
FONCTIONNALITE
   Tests de performance :
   ----------------------
                                                                                            
                           
   1) Je simplifie et harmonise les fichiers .para (et .comm) des tests de performance :
       - .comm : on utilise la mémoire JEVEUX par défaut (DYNAMIQUE=1)
       - .para : on donne un seul paramètre memjob=1.15*(mémoire minimum jeveux)
                 on diminue le temps CPU (de l'ordre de 30% en plus du temps nécessaire)
                                                                                            
                           
   2) perf002b est cassé sur bull en 9.3.16 :
       Le test s'est arreté lors du finmaj du 15/10 avec un message "le fichier gibi est vide."
       J'ai fait passer 4 fois les 2 tests perf002a,b sur bull le 17/10 :
         Seul le test perf002a s'est planté 1 fois par le message "le fichier gibi est vide."
                                                                                            
                           
       Mathieu Courtois pense que ce problème aléatoire vient peut-etre d'un problème de
   licence gibi : plusieurs jobs cherchent à écrire en meme temps dans ce fichier.
                                                                                            
                           
       => je modifie tous les tests de performance :
                                                                                            
                           
          < EXEC_LOGICIEL(MAILLAGE=_F(FORMAT='GIBI', UNITE_GEOM=14, UNITE=20,
   MAILLAGE=CO('MA'),),INFO=1,)
          ---
          > MA=LIRE_MAILLAGE(FORMAT='MED')
                                                                                            
                           
       Ce qui veut dire que gibi ne sera plus exécuté à chaque fois.
       J'ai du produire les fichiers .mmed (à partir des fichiers gibi).
       Inconvénient : le volume des 17 fichiers *.mmed fait 231 Mo
                                                                                            
                           
                                                                                            
                           
   3) Utilisation de la nouvelle macro CALC_MODAL pour les tests perf003.
                                                                                            
                           
   Dernière remarque :
   Je cherche une ame charitable pour faire la restitution de cette fiche (asrest assez long !)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   tests de performance
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 03/11/2008 - 18:51:32

--------------------------------------------------------------------------------
RESTITUTION FICHE 012661 DU 2008-10-17 17:03:55
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   IMPR_TABLE FORMAT= 'TABLEAU_CROISE' et TRI
FONCTIONNALITE
   Quand on imprime une table au format TABLEAU_CROISE, l'ordre des colonnes est aléatoire
   (les lignes restent dans l'état où elles sont en arrivant).
   
   Si on fait IMPR_TABLE(FORMAT='TABLEAU_CROISE', NOM_PARA=('INST','COOR_Z','DY'),
   TRI=_F(NOM_PARA='COOR_Z')), on a :
   
   #DY.FONCTION.DE.COOR_Z.ET.INST
   .COOR_Z/INST...10.0.........50.0.........30.0
   ..0.00000E+00..1.84123E-02..3.69187E-02..5.56248E-02
   ..2.40634E+00..1.84124E-02..3.69188E-02..5.56250E-02
   
   Le tri est fait en premier, puis on construit la table croisée à imprimer. Le tri des
   colonnes n'était pas prévu.
   
   On prend le parti de trier systématiquement les lignes et les colonnes de la table croisée.
   
   Dans l'exemple, ci-dessous, les colonnes seront dans l'ordre 10, 30, 50.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   etude jointe
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR pellet       PELLET Jacques         DATE 03/11/2008 - 18:51:32

--------------------------------------------------------------------------------
RESTITUTION FICHE 012665 DU 2008-10-20 11:41:58
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   validation de la fiche 11621 : penser xc3xa0 restituer le test sdll109b
FONCTIONNALITE
   Restitution du test sdll109b pour valider l'EL sdll109b
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sdll109b
NB_JOURS_TRAV  : 0.05
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 03/11/2008 - 18:51:33

--------------------------------------------------------------------------------
RESTITUTION FICHE 012680 DU 2008-10-20 14:31:20
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   CREA_CHAMP / EVAL sur une formule
FONCTIONNALITE
   Problème:
   ---------
   L'étude fournie se plante dans CREA_CHAMP/EVAL lors de l'évaluation d'une formule.
   Dans le message d'erreur, on a le nom de la fonction mais cela ne suffit pas comprendre
   son erreur.
                                                                                            
                           
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   ! Erreur evaluation formule FTRACE                                        !
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                                                                            
                           
   Correction:
   -----------
   Mathieu a ajouté un code retour à la fonction python fiintf.
   Ce code retour est transmis à fointe.
   La routine ceseva.f qui appelle fointe peut alors émettre un message plus clair :
                                                                                            
                           
      !------------------------------------------------!
      ! <F> <FONCT0_50>                                !
      !                                                !
      ! Erreur :                                       !
      !    La fonction FTRACE n'a pas pu etre évaluée. !
      !      Maille                       : M247       !
      !      Nombre de paramètres fournis : 0          !
      !      Noms des paramètres fournis  : , ...      !
      !                                                !
      ! Cette erreur est fatale. Le code s'arrete.     !
      !------------------------------------------------!
                                                                                            
                           
   En voyant ce message, l'utilisateur comprendra qu'il cherche à évaluer une fonction (des
   variables internes) sur une maille de bord (qui ne possède aucune variable interne).
   Il modifiera alors en conséquence l'appel à CREA_CHAMP. 
   
   Travail effectué :
     JP : 0.2
     MC : 0.008
     JMP: 0.25
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   xc3xa9tude fournie
NB_JOURS_TRAV  : 0.46
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desroches    DESROCHES Xavier       DATE 03/11/2008 - 18:51:33

--------------------------------------------------------------------------------
RESTITUTION FICHE 012681 DU 2008-10-21 12:15:24
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TMA : DeltaCad
TITRE
   Problxc3xa8me avec POST_ELEM (INTEGRALE)
FONCTIONNALITE
   Anomalie
   --------
   Aster plantait dans POST_ELEM/INTEGRALE car le groupe de mailles
   fourni a l'une des occurrences de cet operateur n'etait pas support du champ sur lequel
   s'applique le calcul de l'integrale.
   En d'autres termes, l'utilisateur avait renseigne un groupe de mailles dont aucun resultat
   n'etait disponible pour le calcul de l'integrale.
   
   En detail:
   Le probleme etait localise dans peecal.f(L180): Aster calculait le rapport (VAL/VOL) avec
   VOL identiquement nulle.
   Pourquoi VOL etait nulle ?
   => car on ne rentrait pas dans la boucle 40;
   Pourquoi?
   => car toutes les mailles du groupe avaient un nombre de points nul (NBPT=0), ce qui
   signifie qu'aucun resultat n'etait disonible.
   
   Pour verifier ce propos, nous avons imprime les resultats
   restreints aux mailles du groupe fourni.
   On a constate qu'aucune valeur n'avait ete imprimee.
   
   
   Correction
   -----------
   Nous avons introduit une verification sur la variable VOL dans peecal a la ligne 177 :
   "Si VOL = 0, alors on sort en erreur fatale avec un message explicite".
   (En effet, si VOL=0, cela signifie qu'aucune valeur du champ n'a ete trouvee.)
   
   Le message specifique a ce probleme est le POST0_18:
   " Les mailles du groupe xxxx ne contiennent pas de valeur relatives au champ xxxx, ce qui
   signifie que le calcul d'integrale ne peut avoir lieu.
   Risque & Conseil:
   Veuillez verifier que le champ est defini sur les mailles du groupe specifie et que les
   composantes du champ disposent de valeurs. Vous pouvez effectuer un IMPR_RESU pour
   imprimer les valeurs du champ xxxx restreintes au mailles du groupe xxxx afin d'en
   connaitre son contenu."
   
   Validation
   ----------
   liste restreinte + etude fournie
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   xc3xa9tude jointe
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR pellet       PELLET Jacques         DATE 03/11/2008 - 18:51:33

--------------------------------------------------------------------------------
RESTITUTION FICHE 012684 DU 2008-10-21 15:14:08
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   souci avec RESOUDRE
FONCTIONNALITE
   Problème:
   ---------
   L'étude fournie se plante (salement) dans la commande FIN.
                                                                                            
                                                                                            
                                 
   Solution:
   ---------
   Si on force l'usage de la mémoire STATIQUE, on s'aperçoit que l'écrasement a lieu dans la
   commande RESOUDRE.
   En utilisant JXVERI, on peut alors trouver l'origine du problème.
   Il s'agit d'une erreur d'utilisation car la matrice n'a pas le meme nombre de ddls que le
   second membre.
                                                                                            
                         
   Cette erreur d'utilisation conduit maintenant au message (factor.py) :
   67: _("""
   Erreur d'utilisation (commande RESOUDRE) :
     La matrice et le second membre fournis à la commande RESOUDRE
     ne sont pas de meme dimension (nombre de ddls).
   Conseil: Vérifier la cohérence des arguments MATR et CHAM_NO.
   """),
   
   NEW8 :
   ------
   Corrections à reporter en version 8 :
   
   resoud.f :
   82c82
   <       CHARACTER*3 KMPIC,TYPE,TYP1
   ---
   >       CHARACTER*3 KMPIC,TYPE,TYP1,KBID
   86c86
   <       INTEGER JSLVK,JSLVR,JSLVI,IDBGAV,NEQ
   ---
   >       INTEGER JSLVK,JSLVR,JSLVI,IDBGAV,NEQ,NEQ1
   145a148,151
   >           CALL JELIRA(SECM19//'.VALE','LONMAX',NEQ1,KBID)
   >           IF (NEQ1.NE.NEQ) CALL U2MESS('F','FACTOR_67')
   >           CALL JELIRA(SECM19//'.VALE','TYPE',IBID,TYP1)
   >           IF (TYP1.NE.TYPE) CALL U2MESS('F','FACTOR_68')
   180a187  
   
   factor.py :
   263a264,277
   > 67: _("""
   > Erreur d'utilisation (commande RESOUDRE) :
   >   La matrice et le second membre fournis à la commande RESOUDRE
   >   ne sont pas de meme dimension (nombre de ddls).
   > Conseil: Vérifier la cohérence des arguments MATR et CHAM_NO.
   > """),
   >
   > 68: _("""
   > Erreur d'utilisation (commande RESOUDRE) :
   >   La matrice et le second membre fournis à la commande RESOUDRE
   >   ne sont pas du meme type (réel/complex).
   > Conseil: Vérifier la cohérence des arguments MATR et CHAM_NO.
   > """),
   >
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   xc3xa9tude fournie
NB_JOURS_TRAV  : 0.3
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 03/11/2008 - 18:51:34

--------------------------------------------------------------------------------
RESTITUTION FICHE 012688 DU 2008-10-22 10:24:12
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TMA : DeltaCad
TITRE
   Message inappropri?oncernant le mod? GLRC_DAMAGE
FONCTIONNALITE
   La réalisation est terminée.
   Le fichier de message est sur Bull dans /home/rezette/A12688/py.
   
   Histor (proposition):
   
   
   Remanier le message d'alarme ELEMENTS_33 pour le rendre plus explicite et plus rassurant.
   
   Ancien message  :
   
   33 : _("""
    la convergence locale de la loi GLRC_DAMAGE n'est pas atteinte en 1000 itérations :
    XM1 vaut %(r1)f
    XM2 vaut %(r2)f
    YM1 vaut %(r3)f
    YM2 vaut %(r4)f
   """),
   
   Nouveau message:
   
   33 : _("""
    la convergence d'un processus itératif local de la loi GLRC_DAMAGE
    n'a pas été atteinte en 1000 itérations :
    XM1 vaut %(r1)f
    XM2 vaut %(r2)f
    YM1 vaut %(r3)f
    YM2 vaut %(r4)f
    Si cette alarme n'est pas suivie d'une erreur fatale, alors le résultat
    est correct.
   """),
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   elementaire
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR pellet       PELLET Jacques         DATE 03/11/2008 - 18:51:34

--------------------------------------------------------------------------------
RESTITUTION FICHE 012736 DU 2008-10-27 17:31:04
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   mxc3xa9nage dans quelques structures de donnxc3xa9es
FONCTIONNALITE
   Problème :
   ----------
   On veut corriger les 2 fiches 10975 et 10814 concernant certains tests SDVERI='NON'.
   De plus, on souhaite donner un petit "tour de vis" dans la vérification de quelques
   structures de données.
                                                                                            
                         
                                                                                            
                         
   Modification de SD :
   --------------------
                                                                                            
                         
   SD_resultat_dyn :
    - On interdit l'objet '.PROFC.NUME.REFN' (fiche 10814)
    - On rend obligatoire l'objet .REFD  (puisque c'est lui qui différencie les sd_resultat
   des sd_resultat_dyn)
      => Dans  certaines commandes, on crée un .REFD "vierge"
         Dans  d'autres commandes, on recopie le .REFD d'une sd "in" dans le .REFD de la sd
   "out".
                                                                                            
                         
   SD_prof_chno :
    - On supprime l'objet .LPRN (pointeur de longueur maintenant inutilisé)
      =>  copisd.f  detrsd.f  nueffe.f  numer2.f  prosmo.f
                                                                                            
                         
   SD_cham_no :
    - .REFE[2] : sd_nume_equa -> sd_prof_chno
    - On profite de ce "tour de vis" pour résorber une question DISMOI qui ne fonctionnait
   pas toujours:
       DISMOI 'NOM_NUME_DDL' sur 'CHAM_NO'  :
          chnucn.f  exphgl.f  modiba.f  op0026.f  pecap1.f  pecap3.f
          cynupl.f  mecalm.f  nueqch.f  op0156.f  pecap2.f
                                                                                            
                         
   SD_squelette :
    - l'objet .INV.SKELETON  est faux après l'appel à rec110.f (fiche 10975).
      Je le supprime et le test reste OK, ce qui prouve que cet objet ne sert pas toujours.
      => l'objet devient facultatif dans le catalogue sd_squelette.py
                                                                                            
                         
                                                                                            
                         
                                                                                            
                         
   Corrections dans les routines fortran :
   ---------------------------------------
     * tran75.f :
       Cette routine crée parfois un objet .REFD incorrect : le .REFD[4] n'est pas un
   sd_nume_ddl mais un sd_prof_chno. On corrige en mettant .REFD[4]=' '.
       C'est le problème de la fiche 10814
       (meme correction pour harm75.f)
                                                                                            
                         
     * rscopi.f :
       Quand on dupplique une sd_resultat, on oublie de faire un "JECROC" sur les objets de
   la collection .TACH
       => un des problèmes de la fiche 10975
                                                                                            
                         
     * rec110.f :
       On dupplique la sd_squelette avec un JEDUPC. Du coup, la sd_l_table contenue dans la
   sd_squelette est fausse, car elle fait référence à la l_ table de la sd à l'origine de la
   copie.
       => un autre problème de la fiche 10975
       => j'enrichis les routines DETRSD et COPISD pour qu'elles traitent :
           - les sd_squelette
           - les sd_l_table
                                                                                            
                         
     * vtcrea.f :
       Cette routine suppose que son argument CREFE contient les références à un sd_maillage
   et un sd_nume_equa alors que l'objet .REFE d'un sd_cham_no fait référence à un
   sd_prof_chno. En toute rigueur, cette routine ne peut donc pas fonctionner avec le .REFE
   d'un sd_cham_no.
       J'ai écrit une nouvelle routine vtcrec.f pour vtcrea.f dans les routines :
         harm75.f tran75.f tran77.f
                                                                                            
                         
     * mecalm.f :
       Je suis tombé sur un problème curieux du coté de l'option 'SIGM_NOZ2_ELGA'.
       j'ai corrigé en simplifiant sensiblement le calcul de la variable OPTIO2 (qui était
   parfois ' ').
                                                                                            
                         
     * numddl.f :
       L'argument "BASE" (G/V) de la routine numddl.f est remplacé par BAS2='GG'/'VV'/'GV'/'VG'
         BAS2(1:1) : base pour la création du reste du nume_ddl (sauf le prof_chno)
         BAS2(2:2) : base pour la création du prof_chno
         => modification des appelants :
         ca2mam.f calmaa.f op0011.f ssrige.f
   
   
                                                                                            
                         Impact_documentaire :
   ---------------------
   D4.06.08 : sd_resultat
   D4.06.01 : sd_maillage
   D4.06.07 : sd_nume_ddl  
                                                                                            
                         
   Validation:
   -----------
    Passage de la liste complète.
                                                                                            
                         
                                                                                            
                         
   Nb jours trav:
   --------------
     4 (JP) + 1 (IN)
                                                                                            
                         
                                                                                            
                         
                                                                                            
                         
   Petit bilan tests SDVERI='NON' :
   --------------------------------
                                                                                            
                         
   Avant :
   --------
   122 tests SDVERI='NON'
                                                                                            
                         
   * dont 39 tests utilsant la sensibilité :
     hpla101a  hpla101b  hplp100b  hplp101b  sensd01a  sensd02a
     sensd03a  sensd04a  sensd05a  sensd08a  sensd08b  sensd09a
     sensd09b  sensd09c  sensd09d  sensd11a  sensd11b  sensd11c
     sensd11d  sensm01a  sensm02a  sensm03a  sensm06a  sensm06b
     sensm07a  sensm08a  sensm11a  sensm12a  senst01a  senst02a
     senst02b  senst03a  senst03b  senst04a  senst04b  senst05a
     sslp101f  sslv110c  zzzz121b
                                                                                            
                         
   * dont 17 tests feti :
     feti001a  feti001b  feti002a  feti002b  feti003a  feti003b
     feti003c  feti003d  feti004a  feti004b  feti005a  feti005b
     feti006a  feti008a  feti008b  feti009a  feti010a
                                                                                            
                         
   * 66 autres tests :
     epicu01a  fdlv112a  forma02b  sdld102a  sdld22b   sdll107a
     sdll133b  sdll503b  sdls106a  sdls112a  sdlx201a  sdnd102c
     sdnd105a  sdnl104b  sdnl105b  sdnl301a  sdnv102a  sdnv102c
     shll100a  shll100b  ssla200a  ssla200b  ssll107a  ssll107f
     ssll107g  ssll107h  ssll107i  sslp200b  sslp201a  sslp201b
     sslv200b  ssnl120a  ssnp101a  ssnp118g  ssnp15a   tplv102a
     tplv105a  tplv106a  tpna01a   tpna01b   tpna01c   tpna300c
     tpnl300a  tpnl300b  tpnv01a   tpnv01b   ttlp100b  ttna200a
     ttnl02a   ttnl02b   ttnl02c   ttnl302c  ttnl302e  ttnp01a
     ttnp200a  wtna106a  wtna106b  wtna106c  wtna106d  wtnp102a
     wtnp102c  wtnp102d  wtnp111b  zmat002b  zzzz108a  zzzz223a
                                                                                            
                         
                                                                                            
                         
   Après :
   -------
   39 tests peuvent etre basculés en SDVERI='OUI' :
     epicu01a  forma02b  sdld102a  sdll107a  sdll503b  sdls106a
     sdlx201a  sdnd102c  sdnl104b  sdnl105b  sdnv102a  sdnv102c
     shll100a  shll100b  ssnp101a  ssnp118g  tplv102a  tplv105a
     tplv106a  tpna01a   tpna01b   tpna01c   tpna300c  tpnl300a
     tpnl300b  tpnv01a   tpnv01b   ttlp100b  ttna200a  ttnl02a
     ttnl02b   ttnl02c   ttnl302c  ttnl302e  ttnp01a   ttnp200a
     wtna106c  wtna106d  wtnp111b
                                                                                            
                         
                                                                                            
                         
   Mais l'évolution présente n'en a vraiment corrigé que 6 :
     sdld102a   (fiche 10814)
     sdls106a   (fiche 10975)
     sdnl104b   (fiche 10814)
     sdnl105b   (fiche 10814)
     shll100a   (fiche 10814)
     shll100b   (fiche 10814)
                                                                                            
                         
   car les 33 autres étaient déjà OK SDVERI (sans le savoir) !
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : D4.06.08  D4.06.01  D4.06.07
VALIDATION
   liste complxc3xa8te
NB_JOURS_TRAV  : 5.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 012750 DU 2008-10-30 11:18:25
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   post_elem int?ale pour des champs 'ELEM'
FONCTIONNALITE
   Problème:
   ---------
   L'opérateur POST_ELEM / INTEGRALE ne permet pas actuellement le calcul de l'intégrale des
   cham_elem 'ELEM' ni 'ELNO'. IL ne sait traiter que les champs 'ELGA'.
                                                                                            
                           
   Cette "lacune" empêche (par exemple) de calculer l'intégrale du champ de pression que l'on
   applique sur la peau d'un solide. On ne peut donc pas vérifier que l'on a bien appliqué
   l'effort "total" voulu.
                                                                                            
                           
   Correction:
   ------------
   On modifie le fortran de peeint.f (+ peecal.f, chpond.f) pour pouvoir traiter les
   cham_elem 'ELEM' et 'ELNO'.
                                                                                            
                           
   Remarque importante :
   ---------------------
   Les cham_elem / 'ELEM' de Code_Aster sont de 2 types différents :
     - T1 : Il s'agit de la valeur du champ continu supposée constante dans l'élément (comme
   un champ ELGA avec un seul point de Gauss). C'est le cas en général lorsque le champ est
   créé par l'opérateur CREA_CHAMP avec les opérations 'AFFE' et 'DISC'.
     - T2 : La quantité discrétisée est déjà une quantité continue intégrée sur l'élément.
   C'est le cas par exemple, des champs calculés par CALC_ELEM pour les options :
   EPOT_ELEM_DEPL, ECIN_ELEM_DEPL, ...
                                                                                            
                           
   Cette distinction est très importante pour le calcul de l'intégrale sur un groupe de
   maille (il ne faut pas faire la meme "somme").
                                                                                            
                           
   Comme le code ne sait pas encore distinguer automatiquement le type du cham_elem / 'ELEM',
   on ajoute un nouveau mot-clé sous POST_ELEM / INTEGRALE :
     DEJA_INTEGRE= /'OUI' (pour les chamsp de type T2)
                   /'NON' (pour les chamsp de type T1)
   Ce mot clé est obligatoire pour les cham_elem ELEM. L'utilisateur doit donc connaitre la
   nature du champ qu'il intègre.
                                                                                            
                           
   Impact documentaire :
   ---------------------
   U4.81.22 (POST_ELEM) : documenter le nouveau mot clé DEJA_INTEGRE.
                                                                                            
                           
   Validation:
   -----------
   Ajout d'un nouveau test "informatique" ZZZZ242 (sans doc).
   Ce test calcule l'intégrale de la fonction f(x,y)=2x sur un carré [0, 2]X[0, 2].
   On trouve bien 8.
   Le test valide les 4 cas de figure : 'ELEM' (T1 et T2), 'ELNO' et 'ELGA'
   Durée du test : 3s
                                                                                            
                           
   Le principe du calcul de l'intégrale est le suivant :
   -----------------------------------------------------
     1) les éléments finis réalisent (déjà) une option COOR_ELGA qui calcule pour la famille
   de points de Gauss 'RIGI' :
       - les coordonnées de chaque point de Gauss de l'élément réel
       - le "poids" de chaque point de Gauss de l'élément réel = poids du point de Gauss de
   l'élément de référence X jacobien de la transformation géométrique.
     2) Quand on intègre un cham_elem :
        2.1) si c'est un cham_elem/ELGA :
            - si la famille est 'RIGI' :
                - prise en compte des poids de l'option COOR_ELGA pour la pondération et le
   calcul de l'intégrale
            - si la famille n'est pas 'RIGI' :
                - "Erreur <F>"_
        2.2) si c'est un cham_elem/ELEM (1 valeur par élément):
            - le poids de l'élément est la somme des poids des points de Gauss de la famille
   "RIGI"
        2.3) si c'est un cham_elem/ELNO (1 valeur par noeud de l'élément):
            - le poids d'1 noeud est le poids de l'élément divisé par le nombre de noeuds.
                                                                                            
                           
   Détails:
   --------
   1) On permet à POST_ELEM de traiter aussi les "evol_char" (catalogue de la commande)
   2) On permet à CREA_RESU de stocker les paramètres MODELE, CHAM_MATER et CARA_ELEM dans
   les sd_evol_char (routines crtype.f + utpar1.f)
   3) On ajoute l'option COOR_ELGA dans le catalogue gener_me3d_2.cata (bord de 3D) pour
   permettre le calcul d'intégrale sur la peau des modèles 3D. Pour cela, on enrichit le
   te0488.f.
                                                                                            
                           
   Remarque :
   ----------
   J'ai modifié le test sslp305 pour remplacer :
     POST_ELEM / ENER_POT
   par :
     POST_ELEM / INTEGRALE NOM_CHAM='EPOT_ELEM_DEPL'
                                                                                            
                           
   Le test reste OK, ce qui semble montrer que le mot clé ENER_POT pourrait être résorbé. (et
   peut être également ENER_ELAS, ENER_TOTALE ?)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.81.22
VALIDATION
   zzzz242a
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 03/11/2008 - 18:51:34

--------------------------------------------------------------------------------
RESTITUTION FICHE 012759 DU 2008-10-31 09:20:06
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW 9.3.19, le cas-test ssna102e est NOOK sur Rocks.
FONCTIONNALITE
   J'ai relancé le test ssna102e en interactif + batch sur clpaster.
   Il est ok sur tous les noeuds.
   J'observe le même comportement que TdS : un noeud donne des résultats légèrement différent
   (tout en validant les TEST_RESU). Dans mon essai, il s'agit du compute0-1.
   
   En passant valgrind, on voit que nmelnl utilise des variables non initialisées EPS(5,6). A
   priori, c'est sans conséquence mais on modifie nmgeom.f pour initialiser le tableau EPS
   complètement.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ssna102e
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR sellenet     SELLENET Nicolas       DATE 03/11/2008 - 13:53:28

--------------------------------------------------------------------------------
RESTITUTION FICHE 012695 DU 2008-10-23 11:06:51
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   signalement fichier vide lire_maillage MED
FONCTIONNALITE
   Problème :
   ----------
   "Je lis un maillage sans donner de fichier (oubli volontaire) :
     DEBUT()
     mail=LIRE_MAILLAGE()
     FIN()
   Le message est clair :
      ! <EXCEPTION> <MODELISA4_94>                                        !
      !   Probleme lors de la lecture du fichier maillage                 !
      !   Le fichier à lire est vide.                                     !
   
   En revanche, si je fais la même manip en format MED :
     mail=LIRE_MAILLAGE(FORMAT='MED')
   
   Au lieu de me renvoyer le mm signal indiquant un fichier vide ou absent, il plante dans
   EFFOCO :
      ! <EXCEPTION> <DVP_97>                                  !
      !    Erreur signalée dans la bibliothèque MED           !
      !      nom de l'utilitaire : EFFOCO                     !
      !              code retour : -1                         !"
   
   Solution proposée :
   -------------------
   Le message clair existait en version STA9.2 mais a été retiré.
   
   J'ai donc réintroduit ce message en version NEW9.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test unitaire
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST AJOUT perf008a                       delmas J.DELMAS           133    133      0
 CASTEST AJOUT perf008b                       delmas J.DELMAS           133    133      0
 CASTEST AJOUT perf008c                       delmas J.DELMAS           133    133      0
 CASTEST AJOUT perf008d                       delmas J.DELMAS           133    133      0
 CASTEST AJOUT tpna01d                        pellet J.PELLET           270    270      0
 CASTEST AJOUT tpna01e                        pellet J.PELLET           254    254      0
 CASTEST AJOUT zzzz242a                       pellet J.PELLET           126    126      0
 CASTEST MODIF adlv301a                     sellenet N.SELLENET         158      1      1
 CASTEST MODIF efica01a                       nistor I.NISTOR           275      1      1
 CASTEST MODIF epicu01a                       pellet J.PELLET           900      2      2
 CASTEST MODIF feti009a                       desoza T.DESOZA           213     15     15
 CASTEST MODIF perf001a                      cnguyen C.NGUYEN            67      5      4
 CASTEST MODIF perf001b                      cnguyen C.NGUYEN            67      3      2
 CASTEST MODIF perf001c                      cnguyen C.NGUYEN            67      4      3
 CASTEST MODIF perf002a                      cnguyen C.NGUYEN            99      4      3
 CASTEST MODIF perf002b                      cnguyen C.NGUYEN            99      4      3
 CASTEST MODIF perf003a                      cnguyen C.NGUYEN            52      6     17
 CASTEST MODIF perf003b                      cnguyen C.NGUYEN            54      6     15
 CASTEST MODIF perf003c                      cnguyen C.NGUYEN            54      6     15
 CASTEST MODIF perf004a                      cnguyen C.NGUYEN            89      3      2
 CASTEST MODIF perf004b                      cnguyen C.NGUYEN            89      3      2
 CASTEST MODIF perf004c                      cnguyen C.NGUYEN            89      3      2
 CASTEST MODIF perf004d                      cnguyen C.NGUYEN            89      3      2
 CASTEST MODIF perf005a                      cnguyen C.NGUYEN           131      3      2
 CASTEST MODIF perf005b                      cnguyen C.NGUYEN           131      3      2
 CASTEST MODIF perf005c                      cnguyen C.NGUYEN           131      3      2
 CASTEST MODIF perf006a                      cnguyen C.NGUYEN           245      3      2
 CASTEST MODIF perf006b                      cnguyen C.NGUYEN           245      3      2
 CASTEST MODIF rccm01a                       macocco K.MACOCCO          204      1      1
 CASTEST MODIF rccm01b                       macocco K.MACOCCO          498     10      1
 CASTEST MODIF rccm02a                       macocco K.MACOCCO          341      1      8
 CASTEST MODIF rccm02b                       macocco K.MACOCCO          342      1      8
 CASTEST MODIF rccm02c                       macocco K.MACOCCO          332      1      8
 CASTEST MODIF rccm03a                       macocco K.MACOCCO         4169      1     91
 CASTEST MODIF rccm04a                       macocco K.MACOCCO          421     12     14
 CASTEST MODIF rccm07a                       macocco K.MACOCCO          353      1      4
 CASTEST MODIF rccm10a                       macocco K.MACOCCO          364      1      1
 CASTEST MODIF rccm10b                       macocco K.MACOCCO          275      1      3
 CASTEST MODIF rccm11a                       macocco K.MACOCCO          659      5      7
 CASTEST MODIF sdld102a                       pellet J.PELLET           785      2      2
 CASTEST MODIF sdld31a                         abbas M.ABBAS            634      4      5
 CASTEST MODIF sdll107a                       pellet J.PELLET          2016      2      2
 CASTEST MODIF sdll109b                       pellet J.PELLET          1900     97      1
 CASTEST MODIF sdll112a                       boyere E.BOYERE           764      2    119
 CASTEST MODIF sdll503b                       pellet J.PELLET           363      2      2
 CASTEST MODIF sdls106a                       pellet J.PELLET           385      2      2
 CASTEST MODIF sdls139b                        bodel C.BODEL            425      2      2
 CASTEST MODIF sdlx201a                       pellet J.PELLET           670      2      2
 CASTEST MODIF sdnd100c                        abbas M.ABBAS            139      6      2
 CASTEST MODIF sdnd102c                       pellet J.PELLET           246      2      1
 CASTEST MODIF sdnl104b                       pellet J.PELLET           477      3      3
 CASTEST MODIF sdnl105b                       pellet J.PELLET           562      2      2
 CASTEST MODIF sdnv102a                       pellet J.PELLET           667      2      2
 CASTEST MODIF sdnv102c                       pellet J.PELLET            30      2      2
 CASTEST MODIF shll100a                       pellet J.PELLET           698      3      3
 CASTEST MODIF shll100b                       pellet J.PELLET           648      2      2
 CASTEST MODIF sslp305a                       pellet J.PELLET            82     14     31
 CASTEST MODIF sslv314a                      galenne E.GALENNE          202      2      2
 CASTEST MODIF sslv315a                      galenne E.GALENNE          202      3      3
 CASTEST MODIF ssnp101a                       pellet J.PELLET           268      3      1
 CASTEST MODIF ssnp118g                       pellet J.PELLET           535      2      2
 CASTEST MODIF ssnp121j                       desoza T.DESOZA           239      1      1
 CASTEST MODIF ssnv128t                       desoza T.DESOZA           202     13     12
 CASTEST MODIF ssnv129c                       desoza T.DESOZA           227      5      5
 CASTEST MODIF ssnv506e                       desoza T.DESOZA           251      2      1
 CASTEST MODIF tplv102a                       pellet J.PELLET            92      2      2
 CASTEST MODIF tplv105a                       pellet J.PELLET           184      2      2
 CASTEST MODIF tplv106a                       pellet J.PELLET           127      2      2
 CASTEST MODIF tpna01a                        pellet J.PELLET           249    223    200
 CASTEST MODIF tpna01b                        pellet J.PELLET           267    237    238
 CASTEST MODIF tpna01c                        pellet J.PELLET           247      2      2
 CASTEST MODIF tpna300c                       pellet J.PELLET           133      2      2
 CASTEST MODIF tpnl300a                       pellet J.PELLET           303      2      2
 CASTEST MODIF tpnl300b                       pellet J.PELLET           308      2      2
 CASTEST MODIF tpnv01a                        pellet J.PELLET           434      2      2
 CASTEST MODIF tpnv01b                        pellet J.PELLET           262      2      2
 CASTEST MODIF ttlp100b                       pellet J.PELLET           200      2      2
 CASTEST MODIF ttna200a                       pellet J.PELLET           606      2      2
 CASTEST MODIF ttnl02a                        pellet J.PELLET           287      2      2
 CASTEST MODIF ttnl02b                        pellet J.PELLET           175      2      2
 CASTEST MODIF ttnl02c                        pellet J.PELLET           183      2      2
 CASTEST MODIF ttnl302c                       pellet J.PELLET           457      2      2
 CASTEST MODIF ttnl302e                       pellet J.PELLET           537      2      2
 CASTEST MODIF ttnp01a                        pellet J.PELLET           155      2      2
 CASTEST MODIF ttnp200a                       pellet J.PELLET           600      2      2
 CASTEST MODIF wtna106c                       pellet J.PELLET           424      2      2
 CASTEST MODIF wtna106d                       pellet J.PELLET           424      2      2
 CASTEST MODIF wtnp111b                       pellet J.PELLET           175      2      2
 CASTEST MODIF wtnp113a                        abbas M.ABBAS            467      1      1
CATALOGU MODIF compelem/phenomene_modelisation__     pellet J.PELLET          1443     21      7
CATALOGU MODIF typelem/gener_me3d_2           pellet J.PELLET           233      6      2
CATALOPY MODIF commande/post_elem             pellet J.PELLET           486      3      2
CATALOPY MODIF commande/post_rccm            macocco K.MACOCCO          279      1      3
       C MODIF supervis/astermodule           pellet J.PELLET          4157     30     13
 FORTRAN AJOUT algeline/vtcrec                pellet J.PELLET           109    109      0
 FORTRAN AJOUT algorith/isdiri                 abbas M.ABBAS            100    100      0
 FORTRAN AJOUT algorith/ndasva                 abbas M.ABBAS            142    142      0
 FORTRAN AJOUT algorith/ndthet                 abbas M.ABBAS            208    208      0
 FORTRAN AJOUT algorith/nmasdi                 abbas M.ABBAS            144    144      0
 FORTRAN AJOUT algorith/nmequi                 abbas M.ABBAS            132    132      0
 FORTRAN AJOUT algorith/nmfcor                 abbas M.ABBAS            205    205      0
 FORTRAN AJOUT algorith/nmigno                 abbas M.ABBAS             87     87      0
 FORTRAN AJOUT algorith/nmimre                 abbas M.ABBAS            117    117      0
 FORTRAN AJOUT calculel/ajrefd                pellet J.PELLET            69     69      0
 FORTRAN MODIF algeline/op0037                pellet J.PELLET           655     22     11
 FORTRAN MODIF algeline/op0156                pellet J.PELLET           124      6      4
 FORTRAN MODIF algeline/resoud                pellet J.PELLET           282      7      3
 FORTRAN MODIF algeline/wpsorn              courtois M.COURTOIS         417      5      1
 FORTRAN MODIF algorith/ascoma                 abbas M.ABBAS            112     10      6
 FORTRAN MODIF algorith/ascova                pellet J.PELLET           208      2      3
 FORTRAN MODIF algorith/ca2mam                pellet J.PELLET           104      2      2
 FORTRAN MODIF algorith/calmaa                pellet J.PELLET            97      2      2
 FORTRAN MODIF algorith/cfadju                desoza T.DESOZA           253     18     26
 FORTRAN MODIF algorith/cfresu              courtois M.COURTOIS         490      2      1
 FORTRAN MODIF algorith/copmod                pellet J.PELLET            99     17      9
 FORTRAN MODIF algorith/crtype                pellet J.PELLET           441      1      5
 FORTRAN MODIF algorith/cynupl                pellet J.PELLET           220     15     15
 FORTRAN MODIF algorith/exphgl                pellet J.PELLET           226      6      5
 FORTRAN MODIF algorith/gefact                pellet J.PELLET           451      5      8
 FORTRAN MODIF algorith/harm75                pellet J.PELLET           252     20     24
 FORTRAN MODIF algorith/impfot                 abbas M.ABBAS             86      2      1
 FORTRAN MODIF algorith/mecgm2                 abbas M.ABBAS            142     10      3
 FORTRAN MODIF algorith/mecgme                 abbas M.ABBAS            322     13      1
 FORTRAN MODIF algorith/mmgeom                desoza T.DESOZA           167      4      4
 FORTRAN MODIF algorith/mmmab0                desoza T.DESOZA            78      1      1
 FORTRAN MODIF algorith/modiba                pellet J.PELLET           248      5      5
 FORTRAN MODIF algorith/ndassp                 abbas M.ABBAS            210     26     11
 FORTRAN MODIF algorith/ndcrdy                 abbas M.ABBAS            123      2      2
 FORTRAN MODIF algorith/ndfdyn                 abbas M.ABBAS            130     10     25
 FORTRAN MODIF algorith/ndiner                 abbas M.ABBAS            139     53     15
 FORTRAN MODIF algorith/ndnpas                 abbas M.ABBAS            513     23     14
 FORTRAN MODIF algorith/nmasfi                 abbas M.ABBAS            211     44     82
 FORTRAN MODIF algorith/nmassc                 abbas M.ABBAS            162     28     10
 FORTRAN MODIF algorith/nmassx                 abbas M.ABBAS            200     23      9
 FORTRAN MODIF algorith/nmasva                 abbas M.ABBAS            147     12     51
 FORTRAN MODIF algorith/nmbudi                 abbas M.ABBAS             93      1      2
 FORTRAN MODIF algorith/nmcere                 abbas M.ABBAS            223      4      2
 FORTRAN MODIF algorith/nmchar                 abbas M.ABBAS            413      2     58
 FORTRAN MODIF algorith/nmconv                 abbas M.ABBAS            518     54     12
 FORTRAN MODIF algorith/nmcrch                 abbas M.ABBAS            435      2      1
 FORTRAN MODIF algorith/nmdata                 abbas M.ABBAS            154      1      9
 FORTRAN MODIF algorith/nmdcex                 abbas M.ABBAS            260     20      2
 FORTRAN MODIF algorith/nmdepl                 abbas M.ABBAS            244      4     87
 FORTRAN MODIF algorith/nmdiri                 abbas M.ABBAS            113      3      2
 FORTRAN MODIF algorith/nmfext                 abbas M.ABBAS            177     34     15
 FORTRAN MODIF algorith/nmfonc                 abbas M.ABBAS            389      2      2
 FORTRAN MODIF algorith/nmgeom                pellet J.PELLET           167      4      1
 FORTRAN MODIF algorith/nmimpm                 abbas M.ABBAS            736     21      4
 FORTRAN MODIF algorith/nmprde                 abbas M.ABBAS            237     39     19
 FORTRAN MODIF algorith/nmpred                 abbas M.ABBAS            140     13     12
 FORTRAN MODIF algorith/nmrepl                 abbas M.ABBAS            364      4      3
 FORTRAN MODIF algorith/nmresi                 abbas M.ABBAS            335     26     65
 FORTRAN MODIF algorith/nmstat                 abbas M.ABBAS            290      2      1
 FORTRAN MODIF algorith/nsassp                 abbas M.ABBAS            181      9      7
 FORTRAN MODIF algorith/nueqch                pellet J.PELLET            94      5      8
 FORTRAN MODIF algorith/numecn                pellet J.PELLET            99      2      2
 FORTRAN MODIF algorith/numer2                pellet J.PELLET           130      7      8
 FORTRAN MODIF algorith/op0060                pellet J.PELLET           720      3      4
 FORTRAN MODIF algorith/op0070                 abbas M.ABBAS            563     21     21
 FORTRAN MODIF algorith/op0075                pellet J.PELLET           189      2      2
 FORTRAN MODIF algorith/op0077                pellet J.PELLET           281     14     13
 FORTRAN MODIF algorith/op0109                pellet J.PELLET           415      9      2
 FORTRAN MODIF algorith/op0110                pellet J.PELLET           126      8      4
 FORTRAN MODIF algorith/op0166                pellet J.PELLET           258      6      4
 FORTRAN MODIF algorith/op0191                pellet J.PELLET           189     10      4
 FORTRAN MODIF algorith/rbph02                pellet J.PELLET           143     20      5
 FORTRAN MODIF algorith/rec110                pellet J.PELLET           444      5      2
 FORTRAN MODIF algorith/regres                pellet J.PELLET           201     46     44
 FORTRAN MODIF algorith/semoco              courtois M.COURTOIS         399      4     19
 FORTRAN MODIF algorith/tran75                pellet J.PELLET           459     23     29
 FORTRAN MODIF algorith/tran77                pellet J.PELLET           394      8     15
 FORTRAN MODIF algorith/trprot                pellet J.PELLET           558      6      9
 FORTRAN MODIF assembla/assvec                pellet J.PELLET          1007     13     19
 FORTRAN MODIF assembla/nudeeq                pellet J.PELLET           206     36     36
 FORTRAN MODIF assembla/nueffe                pellet J.PELLET          1006     16     25
 FORTRAN MODIF assembla/numddl                pellet J.PELLET            64      7      6
 FORTRAN MODIF assembla/numero                pellet J.PELLET           429      3      3
 FORTRAN MODIF assembla/op0011                pellet J.PELLET           129      2      2
 FORTRAN MODIF calculel/chnucn                pellet J.PELLET           265      2      3
 FORTRAN MODIF calculel/meca01              courtois M.COURTOIS         719      2      1
 FORTRAN MODIF calculel/mecalm                pellet J.PELLET          2471     23     30
 FORTRAN MODIF calculel/op0026                pellet J.PELLET           396      5      5
 FORTRAN MODIF calculel/op0058                pellet J.PELLET           123      7      2
 FORTRAN MODIF calculel/sinoz2                pellet J.PELLET           468     22      9
 FORTRAN MODIF elements/mmmjac                desoza T.DESOZA           185      3      3
 FORTRAN MODIF elements/te0250                pellet J.PELLET           190      7      7
 FORTRAN MODIF elements/te0364                desoza T.DESOZA           413     27     10
 FORTRAN MODIF elements/te0447                pellet J.PELLET            96      3      3
 FORTRAN MODIF elements/te0488                pellet J.PELLET            87     17      3
 FORTRAN MODIF elements/te0581                pellet J.PELLET           105      3      2
 FORTRAN MODIF jeveux/jjalls                lefebvre J-P.LEFEBVRE       518      3      7
 FORTRAN MODIF jeveux/jjarep                lefebvre J-P.LEFEBVRE       292      3      3
 FORTRAN MODIF jeveux/jjcpsg                lefebvre J-P.LEFEBVRE        86      3      3
 FORTRAN MODIF jeveux/jjldyn                lefebvre J-P.LEFEBVRE       190      1      1
 FORTRAN MODIF modelisa/acevd2                 abbas M.ABBAS            177      5      2
 FORTRAN MODIF modelisa/caliel                pellet J.PELLET           126      2      2
 FORTRAN MODIF modelisa/lrmhdf              sellenet N.SELLENET         308     16      7
 FORTRAN MODIF modelisa/prosmo                pellet J.PELLET           383      3      4
 FORTRAN MODIF modelisa/reliem                pellet J.PELLET           345     25     21
 FORTRAN MODIF modelisa/specep                pellet J.PELLET           409      2      2
 FORTRAN MODIF modelisa/specff                pellet J.PELLET           460      2      2
 FORTRAN MODIF postrele/rc3201               macocco K.MACOCCO          647    110     49
 FORTRAN MODIF postrele/rc32ac               macocco K.MACOCCO          534     17     26
 FORTRAN MODIF postrele/rc32cm               macocco K.MACOCCO          110      3      6
 FORTRAN MODIF postrele/rc32fp               macocco K.MACOCCO          179     19     32
 FORTRAN MODIF postrele/rc32fs               macocco K.MACOCCO          123     22     47
 FORTRAN MODIF postrele/rc32fu               macocco K.MACOCCO          111     13     26
 FORTRAN MODIF postrele/rc32r1               macocco K.MACOCCO          251      6      6
 FORTRAN MODIF postrele/rc32sa               macocco K.MACOCCO          101     19      9
 FORTRAN MODIF postrele/rc32sn               macocco K.MACOCCO          255      4      1
 FORTRAN MODIF postrele/rc32sp               macocco K.MACOCCO          326      9      9
 FORTRAN MODIF postrele/rc36cm               macocco K.MACOCCO          126      3      5
 FORTRAN MODIF postrele/rc36rm               macocco K.MACOCCO          112      3      5
 FORTRAN MODIF postrele/rc36si               macocco K.MACOCCO          533      2      2
 FORTRAN MODIF postrele/rcmo02               macocco K.MACOCCO          120     15      8
 FORTRAN MODIF prepost/op0135                 pellet J.PELLET           546      6      6
 FORTRAN MODIF prepost/op0176                 pellet J.PELLET           214     10      4
 FORTRAN MODIF soustruc/op0089                pellet J.PELLET           105      8      4
 FORTRAN MODIF soustruc/ssrige                pellet J.PELLET           120      2      2
 FORTRAN MODIF supervis/op9999              lefebvre J-P.LEFEBVRE       160      1      1
 FORTRAN MODIF utilitai/calcfo                pellet J.PELLET            87      3      4
 FORTRAN MODIF utilitai/ceseva                pellet J.PELLET           213     10      6
 FORTRAN MODIF utilitai/chpond                pellet J.PELLET           195     52     11
 FORTRAN MODIF utilitai/cnseva                pellet J.PELLET           186     10      8
 FORTRAN MODIF utilitai/copisd                pellet J.PELLET           407     46     27
 FORTRAN MODIF utilitai/detrsd                pellet J.PELLET           616     44     20
 FORTRAN MODIF utilitai/dismcn                pellet J.PELLET           110      2      1
 FORTRAN MODIF utilitai/dismnu                pellet J.PELLET           137      2      8
 FORTRAN MODIF utilitai/dismpn                pellet J.PELLET           119     28      1
 FORTRAN MODIF utilitai/foc1su                pellet J.PELLET           189      2      2
 FORTRAN MODIF utilitai/foimpr                pellet J.PELLET           215      3      4
 FORTRAN MODIF utilitai/fointa                pellet J.PELLET           222      7      4
 FORTRAN MODIF utilitai/fointc                pellet J.PELLET           222     14      4
 FORTRAN MODIF utilitai/fointe                pellet J.PELLET           349     13      7
 FORTRAN MODIF utilitai/ndynlo                 abbas M.ABBAS            245     35      1
 FORTRAN MODIF utilitai/ndynre                 abbas M.ABBAS            141      4      1
 FORTRAN MODIF utilitai/op0150                pellet J.PELLET          1115     17      5
 FORTRAN MODIF utilitai/pecap1                pellet J.PELLET           332      9      8
 FORTRAN MODIF utilitai/pecap2                pellet J.PELLET           245      4      4
 FORTRAN MODIF utilitai/pecap3                pellet J.PELLET           159      4      4
 FORTRAN MODIF utilitai/peecal                pellet J.PELLET           239     47     17
 FORTRAN MODIF utilitai/peeint                pellet J.PELLET           207      8      7
 FORTRAN MODIF utilitai/rscopi                pellet J.PELLET           133      2      1
 FORTRAN MODIF utilitai/utpar1                pellet J.PELLET           492     13      5
 FORTRAN SUPPR algorith/nmassf                 abbas M.ABBAS            129      0    129
       H MODIF include/aster                  pellet J.PELLET            84      1      1
       H MODIF include/definition             pellet J.PELLET           287      5      1
  PYTHON AJOUT Utilitai/utils                 pellet J.PELLET            49     49      0
  PYTHON MODIF Build/B_ETAPE                  pellet J.PELLET           717     37     18
  PYTHON MODIF Cata/ops                       pellet J.PELLET           481      3      1
  PYTHON MODIF Execution/E_utils            courtois M.COURTOIS          91      2      1
  PYTHON MODIF Macro/macro_expans_ops         pellet J.PELLET           190      4      2
  PYTHON MODIF Macro/macr_recal_ops           assire A.ASSIRE          1039     14      2
  PYTHON MODIF Meidee/meidee_calcul_fludela      bodel C.BODEL           1674     88     47
  PYTHON MODIF Meidee/meidee_calcul_turbulent      bodel C.BODEL            447     11      5
  PYTHON MODIF Meidee/meidee_cata              bodel C.BODEL           1220      2      5
  PYTHON MODIF Meidee/meidee_fludela           bodel C.BODEL           1668     58     49
  PYTHON MODIF Meidee/meidee_test              bodel C.BODEL            351     24      4
  PYTHON MODIF Meidee/modes                    bodel C.BODEL           1355     89      1
  PYTHON MODIF Messages/algorith8              abbas M.ABBAS            264      1      5
  PYTHON MODIF Messages/elements              pellet J.PELLET           340      5      2
  PYTHON MODIF Messages/factor                pellet J.PELLET           307     17      1
  PYTHON MODIF Messages/fonct0                pellet J.PELLET           342     18      3
  PYTHON MODIF Messages/jeveux              lefebvre J-P.LEFEBVRE       304      1      9
  PYTHON MODIF Messages/mecanonline5           abbas M.ABBAS            192     23      6
  PYTHON MODIF Messages/modelisa9           sellenet N.SELLENET         415     13      1
  PYTHON MODIF Messages/prepost3            sellenet N.SELLENET         217      5      1
  PYTHON MODIF Messages/prepost             sellenet N.SELLENET         234      9      1
  PYTHON MODIF Messages/utilitai7             pellet J.PELLET            92     20      2
  PYTHON MODIF SD/sd_cham_no                  pellet J.PELLET            54      4      6
  PYTHON MODIF SD/sd_nume_ddl_com             pellet J.PELLET            38      2      2
  PYTHON MODIF SD/sd_nume_ddl_gene            pellet J.PELLET            33      2      2
  PYTHON MODIF SD/sd_nume_equa                pellet J.PELLET            30      4      4
  PYTHON MODIF SD/sd_prof_chno                pellet J.PELLET            30      5      6
  PYTHON MODIF SD/sd_resultat_dyn             pellet J.PELLET            50      2      3
  PYTHON MODIF SD/sd_squelette                pellet J.PELLET            61      4      3
  PYTHON MODIF Stanley/stanley                assire A.ASSIRE          3181     34     38
  PYTHON MODIF Utilitai/System                pellet J.PELLET           305      4      3
  PYTHON MODIF Utilitai/Table                 pellet J.PELLET          1031     13     11


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :   18        2544      2544             +2544
 MODIF :  260       97278      3143    2700      +443
 SUPPR :    1         129               129      -129
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :  279       99951      5687    2829     +2858 
