

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR bodel        BODEL Charles          DATE 10/05/2011 - 08:59:19

--------------------------------------------------------------------------------
RESTITUTION FICHE 017226 DU 2011-07-01 08:32:02
TYPE anomalie concernant Code_Aster (VERSION 11.1)
TITRE
    En NEW11.00.13, le cas-test sdnl136a s'arrete en erreur fatale sur Aster4, Rocks et Calibre 5.
FONCTIONNALITE
   En NEW11.00.13, le cas-test sdnl136a s'arrete en erreur fatale sur Aster4, Rocks et 
   Calibre 5.
   
   Diagnostic : il s'agit d'un oubli lors de la restitution de la semaine precedente :
   passage des mots-cles STOCKAGE et PROFIL de 'DIAG' a 'PLEIN' par defaut dans NUME_DDL_GENE
    et MACRO_PROJ_BASE (16577). 
   Dans les cas-tests avec fluide structure, il est indispensable de garder le stockage a
   'DIAG' sous peine de plantage (il faudra comprendre pourquoi, ce n'est pas normal). 
   La modifiction des catalogues ayant ete reportee en NEW10, il faut aussi reporter la
   modification de ce cas-test.
   
   Modifie : sdnl136a.comm
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sdnl136a
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR boiteau      BOITEAU Olivier        DATE 10/10/2011 - 05:53:00

--------------------------------------------------------------------------------
RESTITUTION FICHE 014766 DU 2010-03-10 07:51:44
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    MOD2 - Extension du critere de Sturm aux modes complexes
FONCTIONNALITE
   CONTEXTE
   ========
     Ds les opérateurs de calcul modal, on a souvent besoin de déterminer le nbre de 
     valeurs propres contenues dans une bande fréquentielle donnée. Par ordre d'importance
     on peut lister:
      1/ Contrôle de la qualité des modes en sortie du solveur modal, après tris et
        passage 'pb de travail'/ 'pb_initial' et avant basculement ds les SD aster.
      2/ Option très utilisée de MODE_ITER_SIMULT: option 'BANDE'.
      3/ Indispensable a la macro: MACRO_MODE_MECA (lorsqu'on cherche beaucoup de modes
        propres).
      4/ C'est le moteur de l'op. de calibration de spectre IMPR_STURM.
      5/ Option utile à l'heuristique de MODE_ITER_INV (option 'AJUSTE'/'SEPARE').
   
   PROBLEME
   ========
     Cette fonctionnalité de dénombrement n'est disponible qu'avec des GEPs standards
     (matrices symétriques réelles) pour lesquels les vps appartiennent à l'axe réel. 
     Quid des GEPs atypiques (amortissement hystérétiques...) ou des QEPs (amortissement
     visqueux, gyroscopie...) qui sont sollicités dans les études ?
     Dans la plupart des cas l'utilisateur Aster dispose de suffisamment d'options 
     complémentaires pour se passer de cette information, mais ce "trou" ds le périmètre
     d'utilisation pourrait s'avérer, à terme, handicapant. 
   
   OBJECTIFS DE L'ETUDE
   ====================
     * Rechercher ds la littérature et chez les codes concurrents les stratégies  
       existantes,
     * En retenir, maquetter, tester et comparer quelques unes,
     * Industrialiser autant que possible une des pistes sélectionnées,
     * Poursuivre le travail si nécessaire (en interne ou via une collaboration).
     * Tracer ces travaux ds un document de synthèse: CR-I23/2011/035 avant les 
       éventuelles doc R/U/V (si RTA OK).
   
   SOLUTION RETENUE POUR L'INSTANT
   ===============================
     Des 4 méthodes étudiées (décrites ds le CR pré-cité) nous en avons finalement 
     retenues qu'une seule, dite
                            méthode APM ('Argument Principal Method')
     que nous avons construite, en partie, en croisant des éléments algorithmiques de
     toutes les méthodes: calcul déterminant via facto LDLT scalée, heuristique de compt
     age de tour, paramétrages empiriques...
     On l'a testée ds les usages 1/ et 4/ décrits précédemment. On se propose de ne rete
     nir, pour l'industrialisation, que l'usage 4/: IMPR_STURM.
   
     Elle fonctionne relativement correctement: 1 pb d'oscillation numériques sur 22 cas-
     tests testés en aveugle, c'est-à-dire sans ajustement manuel des potards. Mais ces 
     défauts de robustesse sont difficiles à prévoir (suivi de contour, proximité d'une
     vp...) et souvent impardonnable (c'est souvent utilisé en tant que méthode de 
     contrôle !).
   
     Elle coûte cependant très cher en temps (des centaines de factorisations LDLT) par
     rapport à la solution standard (seulement 2 !) et par rapport aux solveurs modal 
     (équivalent d'une dizaine de facto au pire). Mais c'est le prix à payer: travailler
     dans le plan complexe, cela se mérite. Personne ne semble avoir fait mieux (à
     notre connaissance).
   
   OPERATEUR IMPACTE
   =================
     IMPR_STURM
   
   IMPACT FONCTIONNEL
   ==================
    Principe de l'OP.
     L'utilisateur veut "peser spectralement" un pb modal dont il fournit les matrices
     MATR_A.... Il donne des indications sur la zone de recherche et paramètre la
     méthode de comptage requise.
    
     Pour étendre le périmètre, on propose de rajouter les mot-clés/valeurs/principes 
     suivant:  
     
     * MATR_C: pour traiter les QEPs,
   
     * TYPE_RESU='MODE_COMPLEXE' (en plus de 'DYNAMIQUE' et 'FLAMBEMENT'). Par ce rensei
      gnement l'utilisateur donne l'indication: 
          mes vps sont potentiellement complexes (GEP non sym et/ou complexe ou QEP)
                 ---> MODE_COMPLEXE
           ............à coup sûrs réelles (GEP sym réels Aster)
                 ---> DYNAMIQUE ou FLAMBEMENT
      
     * Ainsi on lui demande de sélectionner sa zone de recherche:
       si DYNAMIQUE/FLAMBEMENT: par les mot-clés usuels FREQ/CHAR_CRIT_MIN/MAX,
       si MODE_COMPLEXE: par les nouveaux mot-clés:
             FREQ_TYPE_CONTOUR: pour sélectionner la zone de recherche, pour l'instant que
                        la valeur 'CERCLE'.
             FREQ_RAYON_CONTOUR: rayon du cercle (par défaut la même chose que SEUIL_FREQ
                             =0.01)
             FREQ_CENTRE_CONTOUR: centre du cercle (par défaut 0.+0j).
   
     * On finit par la méthode de comptage proprement dite:
    COMPTAGE =FACT(statut='d',
          METHODE=SIMP(statut='f',typ='TXM',defaut="AUTO",into=("STURM","APM","AUTO")),
          SEUIL_FREQ      =SIMP(statut='f',typ='R',defaut= 1.E-2 ),             
          PREC_SHIFT      =SIMP(statut='f',typ='R',defaut= 1.E-2 ),
          NMAX_ITER_SHIFT =SIMP(statut='f',typ='I',defaut= 5,val_min=0),
          NBPOINT_CONTOUR  =SIMP(statut='f',typ='I',defaut= 40,val_min=10,val_max=1000),
          NMAX_ITER_CONTOUR=SIMP(statut='f',typ='I',defaut= 3, val_min=1,val_max=5),
            ), 
   
   REGLES D'EXCLUSIONS/MSG D'ERREURS
   ==================================
    1/Si METHODE='AUTO' on choisit la méthode pour l'utilisateur suivant le pb.  
        
    2/ Si TYPE_RESU='DYNAMIQUE'/'FLAMBEMENT' et si COMPTAGE/METHODE différent 'STURM'
       ----> UTMESS_I + ALGELINE4_20   puis on change en STURM
         Idem si TYPE_RESU='MODE_COMPLEXE' et si METHODE différent 'APM'.
    
    3/ Si choix de METHODE incohérent avec le type de pb: UTMESS_F + ALGELINE4_10
   
    4/ Gestion incompatibilités (provisoires) entre METHODE et SOLVEUR
       si STURM+MATR_GENE+MF   UTMESS_A + ALGELINE5_72 + change de solveur lineaire
       si APM+MUMPS            UTMESS_A + ALGELINE4_16 + change de solveur lineaire 
       si SOLVEUR=FETI/GCPC/PETSc ALGELINE5_71 (au cas où)
   
    5/ Pb numériques liés à la méthode de comptage:
       Non cv             :  UTMESS_F + ALGELINE4_13/14
       Résultat incohérent:  UTMESS_F + ALGELINE4_22
       Erreur LAPACK      :  UTMESS_F + ALGELINE4_12
       Erreur facto       :  UTMESS_F + ALGELINE4_15
   
   TYPE DE VALIDATION
   ==================
     Informatique, fonctionnelle, numérique.
   
   CAS-TESTS (la liste peut être étoffée)
   =========
     * SDLD02A: sytème masse-ressort canonique, GEP standard
       6 IMPR_STURMs de comparaison METHODE='STURM'/'APM'
       + 2 autres avec cercle non centré en 0
       + test paramètre 'AUTO' et bascule 'MODE_COMPLEXE'/'APM'
   
     * SDLL123A: ligne d'arbre simplifiée avec gyroscopie, GEP standard + QEP 
       sur le GEP 6 IMPR_STURMs de comparaison,
       sur le QEP 5 IMPR_STURMs + METHODE='APM'
   
   DOCS IMPACTEES
   ==============
   U4.52.01
   V2.01.02, V2.02.123
   + new doc R (en dégraissant au passage celle des GEPs R5.01.01)
   
   SUPPLEMENTS
   ===========
   Jusqu'à présent, le solveur linéaire MF ne pouvait pas traiter les matrices généralisé
   es. J'avais blindé cette faille du périmètre d'utilisation via l'appel à CRSVL2 qui 
   faisait la bascule MF/LDLT ou MUMPS suivant la taille du pb.
   Elle ne sert plus à rien car cette semaine, C.Rose étend le périmètre de MF à ces 
   matrices. Comme d'autre part, je suis en conflit avec C.Rose sur les routines
     op0032, op0044.
   Je prend en compte sa restit les concernant, plus celle de op0045.f
   J'en profite aussi pour  supprimer la routine CRSVL2.
   
   SOURCES IMPACTEES
   ================= 
   F77:  apchar.f  apm012.f  apm345.f  aptest.f  crsvl3.f  op0032.f  op0044.f  vpecst.f  
         vpfopr.f, op0045.f
   CAPY: impr_sturm.capy
   PY:   algeline4.py  algeline5.py
   UNIG: crsvl2.f
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V2.01.02, V2.02.123,U4.52.01,R5.01.04
VALIDATION
    informatique, numérique, fonctionnel
NB_JOURS_TRAV  : 90.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 016966 DU 2011-05-20 07:19:44
TYPE aide utilisation concernant Code_Aster (VERSION 9.1)
TITRE
    Alarme JEVEUX1_64
FONCTIONNALITE
   PROBLEME
   ========
      Planton à l'issu d'un MODE_ITER_INV sur le mesg JEVEUX: JEVEUX1_64 (objets
     déchargés sur disque et non relus) sur machine aster4 en NEW11.
   
   ANALYSE
   =======
     Je n'arrive pas à reproduire le problème (et Nathalie non plus). Par contre, le calcul
     des modes propres incriminés est très sous-optimal (Nathalie l'a découvert depuis). Un
     MODE_ITER_INV pour calculer 400 modes ce n'est pas raisonnable !
     Il faut utiliser plusieurs MODE_ITER_SIMULT (éventuellement avec des IMPR_STURM 
      préalables pour "peser spectralement" les zones d'intérêt) ou mieux l'op. ad hoc
     MACRO_MODE_MECA (qui en plus fait de la normalisation, du tri...).
   
   SOURCES RESTITUEES
   ==================
     Aucune.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    informatique
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR rose         ROSE Christian         DATE 10/10/2011 - 05:53:01

--------------------------------------------------------------------------------
RESTITUTION FICHE 015783 DU 2010-10-21 08:13:03
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Etendre le perimetre d'utilisation de MULT_FRONT aux matrices generalisees
FONCTIONNALITE
   Probleme
   ---------
   Le perimetre de MULT_FRONT est elargi aux matrices generalisées.
   Reponse aux  fiches  11979 et 15783
   
   Dans MODE_ITER_SIMUL et MODE_ITER_INV (op0044 op0045)
   ainsi que dans op0032,
   on ne change plus de solveur " a la volee" en cas de matrice generalisee.
   On laisse le solveur initial (defaut ou utilisateur).
   
   Traitement particulier
   ----------------------
   Pour les castests comportant des liaisons, 
   MULT_FRONT plantait parfois.
   avec la renumerotation METIS uniquement,
   parfois avec tous les algorithmes de renumerotation.
   Avec les matrices generalisees, en cas de liaison
   les ddl sont a priori bien numerotes
   on ne fait donc pas de renumerotation dans ce cas
   ce n'est pas important, les matrices sont d'ordre faible.
   MULT_FRONT les traite alors comme des matrices pleines.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : u4.50.01
VALIDATION
    tous les tests MODE_ITER_xxxx
NB_JOURS_TRAV  : 6.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 014242 DU 2009-11-27 10:16:00
TYPE anomalie concernant Code_Aster (VERSION 11.2)
TITRE
    Demande d'allocation hors norme
FONCTIONNALITE
   Probleme
   ---------
   Dans MULT_FRONT, on désire supprimer l'affichage du message suivant
      JEVEUX_57 : 
       Longueur du segment de valeurs Ã  allouer invalide -1127798800.
   
   lors de l'allocation blocs de matrice de grande taille.
   
   Correction
   ----------
   
   1) lors du calcul des blocs de la matrice factorisee (MLTPRE), on détecte
   les blocs dont la longueur en octets sera supérieure à l'entier maximum en machine.
   On émetalors  une alarme
   
   2) lors de l'utilisation de ces blocs (injection des termes initiaux de la matrice),
   (MULFR8),
   on détecte que l'un des blocs a une longueur supérieure au plus grand segment mémoire
   disponible
   (conséquence logique de 1) ci-dessus ) on produit alors un message d'erreur fatale.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sans objet
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 011979 DU 2008-04-14 09:44:12
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Mult_front pour les matrices gxc3xa9nxc3xa9ralisxc3xa9es
FONCTIONNALITE
   Voir fiche 15783 (encore)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sans objet
NB_JOURS_TRAV  : 5.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desoza       DE SOZA Thomas         DATE 10/11/2011 - 11:15:15

--------------------------------------------------------------------------------
RESTITUTION FICHE 017672 DU 2011-10-07 08:18:03
TYPE express concernant Code_Aster (VERSION 9.1)
TITRE
    Nouvelle modxc3xa9lisation 3D au cas-test SSNA102
FONCTIONNALITE
   Express
   =======
   
   On ajoute une modélisation 3D au cas-test SSNA102 (contact multi-corps, 3 zones de
   contact). Le maillage est linéaire (TETRA4) et la solution de référence, une moyenne
   d'autres codes. Il s'agit de la modélisation G.
   On double de non-régression. Les résultats en force sont un poil moins bon que la
   modélisation AXIS (écart de 5% au lieu de 3% mais la moyenne qui sert de référence est
   tirée vers le bas à cause du résultat SAMCEF, tandis que ABAQUS et SYSTUS ont des
   résultats proches de ceux d'Aster).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V6.01.102
VALIDATION
    ssna102g
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 017668 DU 2011-10-06 13:57:31
TYPE express concernant Code_Aster (VERSION 9.1)
TITRE
    Message portant sur la rxc3xa9actualisation gxc3xa9omxc3xa9trique du contact pas clair
FONCTIONNALITE
   Express
   =======
   
   Le message CONTACT3_81 qui signale que le nombre maximum de réactualisations géométriques
   est atteint n'est pas clair : il conseille d'augmenter le mot-clé ITER_GEOM_MAXI sans
   préciser que ce mot-clé est dans DEFI_CONTACT (et non STAT_NON_LINE par exemple).
   
   On enrichit le message.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    nxc3xa9ant
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------
RESTITUTION FICHE 017609 DU 2011-09-27 14:53:04
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    mise au propre des TP de formation Contact
FONCTIONNALITE
   Évolution
   =========
   
   '''
   Il faudrait migrer le patrimoine pédagogique des TPs vers des objets gérés en
   configuration (doc dans la GED, tests dans astest).
   
   Il existe 1 TP d'exercices pour la formation avancée Contact :
   
   Il faudrait faire 2 choses :
   - créer le test FORMA04 pour capitaliser les fichiers de commandes et de maillage
   - créer la docs V associées à ce FORMA04 qui contiendraient le texte du document support
   actuel.
   '''
   
   Détails
   =======
   
   On restitue 3 modélisations du test FORMA04 et sa documentation associée en V10 et en V11 :
   
   - FORMA04A : maillage en triangles linéaire, formulation discrète, pression de contact
   relevée à partir des contraintes
   
   - FORMA04B : maillage en triangles quadratique, formulation continue, intégration aux
   points de Gauss, pression de contact relevée par le ddl LAGS_C
   
   - FORMA04C : maillage en quadrangles linéaire, formulation discrète, pression de contact
   relevée à partir des contraintes
   
   Les tests de validation sont fait sur la pression de Hertz (au centre). Les références
   sont analytiques et doublées d'une non-régression.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : v6.04.222
VALIDATION
    forma04
NB_JOURS_TRAV  : 1.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 017608 DU 2011-09-27 13:05:54
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    AR09 Améliorer la gestion de la résolution PETSc
FONCTIONNALITE
   Évolution
   =========
   
   '''
   Un mécanisme a été mis en place pour vérifier à la fin d'une résolution PETSc la bonne
   décroissance du résidu non-préconditionné. En linéaire, cela peut se défendre. Par contre,
   en non-linéaire, cela n'est pas pertinent car la mesure de la convergence fait office de
   garde-fou.
   Il faudrait donc supprimer cette vérification en non-linéaire.
   '''
   
   Détails
   =======
   
   Pour savoir si on est en "non-linéaire" ou "linéaire", on s'appuie sur la classification
   des commandes établies dans issue12369 (mise en place d'un catalogue commun SOLVEUR).
   Sur cette base on ajoute un mot-clé caché non documenté avec valeur par défaut différente
   selon que l'on est dans une commande typée 'LIN' ou 'NL'. Ce mot-clé prend une valeur
   réelle négative en non-linéaire, nulle en linéaire (on a choisi un argument réel pour être
   sûr d'utiliser une case inutilisée dans la sd_solveur).
   
   En linéaire, rien ne change : la vérification sur la décroissance de la norme non
   préconditionnée est toujours faite avec une tolérance de SQRT(RESI_RELA), soit 10^-3 par
   défaut.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : D4.06.11,U4.50.01
VALIDATION
    perso
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 017514 DU 2011-09-12 07:49:30
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Carton mxc3xa9moire dans contact
FONCTIONNALITE
   Anomalie
   ========
   
   '''
   L'étude réalisée ci-contre fait apparaître une erreur de segmentation variable suivant les
   run sur une exécution du contact sans surcharge.
   '''
   
   Analyse
   =======
   
   En regardant l'output du job, on voit que le plantage se produit dans MUMPS.
   
   #0  0x00000000035e9227 in __Compute2WayPartitionParams ()
   #1  0x00000000035f55da in __MlevelNodeBisectionMultiple ()
   #2  0x00000000035f728e in METIS_NodeWND ()
   #3  0x00000000035be99e in metis_nodewnd_ ()
   #4  0x00000000024178d8 in dmumps_195_ ()
   #5  0x0000000002493433 in dmumps_26_ ()
   #6  0x00000000023f5844 in dmumps_ ()
   #7  0x00000000006a3b6e in amumpd (action=Cannot access memory at address 0x36a3ee0
   
   Pourtant niveau mémoire le calcul est bien dans les clous (2,6Go consommé pour 8Go maxi).
   
   En faisant tourner le calcul :
   - en nodebug (il était en debug) : on plante dans "clone" au cours du calcul
   - en nodebug avec AFFE_CHAR_CINE : on plante dans METIS
   - avec RENUM='PORD' (au lieu de METIS) : on va jusqu'au bout
   - avec PETSc comme solveur et en passant en AFFE_CHAR_CINE : on va jusqu'au bout
   
   Il semblerait donc que le problème vient de METIS. Dans la mesure où :
   - de tels problèmes ont déjà été rencontrés sans qu'on puisse les corriger ;
   - que la version de METIS utilisée est complètement périmée et désormais obsolète (sortie
   de METIS 5.0) ;
   - que plusieurs contournements existent,
   
   on décide de classer cette fiche sans suite.
   
   Remarque sur les performances
   =============================
   
   À titre d'information, en passant le solveur en PETSC (avec préconditionneur LDLT_SP), en
   utilisant des conditions aux limites cinématiques, on obtient des performances
   exceptionnellement meilleures par rapport à MUMPS ou MULT_FRONT :
   
   Avec MUMPS (et RENUM='PORD')
   * TOTAL_JOB                :   32427.03 :     263.05 :   32690.08 :   32723.21 *
   
   Avec PETSC (et PRE_COND='LDLT_SP')
   * TOTAL_JOB                :    2697.26 :      42.26 :    2739.52 :    2756.35 *
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    test fourni
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 017482 DU 2011-09-05 17:43:17
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Plantage MUMPS - cas 3D adaptation excavation HM
FONCTIONNALITE
   Anomalie
   ========
   
   Un calcul de Sébastien M. faisant du python dans le fichier de commandes, se plante
   brutalement dans un appel à JELIRA (depuis le python et transitant par le C).
   
   Analyse (Jean-Pierre L.)
   ========================
   
   '''
   En supprimant la récupération des signaux par PETSc (ajout d'un fichier .petscrc sous le
   $HOME contenant la ligne -no_signal_handler), nous avons constaté un plantage dans le
   superviseur au moment de l'appel à jeveux_getattr dans astermodule.c (CALL_JELIRA). Les
   exécutables parallèles MPI n'utilisaient pas l'option de compilation -D_USE_INTEL_IFORT
   pour le compilateur C permettant de donner une longueur correcte pour la définition du
   type STRING_SIZE (aster_depend.h).
   
   Aprés recompilation des fonctions C et construction de nouveaux exécutables, le calcul
   s'arrête lors de l'opération d'écriture au format hdf des objets JEVEUX de la base. 
   L'erreur se produit lors de l'écriture de l'objet de type N (répertoire de nom)
   &CATA.PRESENTATION.MODL' dont la longueur du type des noms récupérée vaut 7066 ! Cette
   longueur a été écrasée par les instructions ou les commandes précédentes.
   '''
   
   Le nouveau plantage évoqué est lui corrigé dans issue17507
   
   Le problème de définition a été corrigé manuellement par recompilation (sans restitution).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    xc3xa9tude fournie
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 017430 DU 2011-08-26 08:45:07
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    SV01 Mesurer le temps de communication MPI
FONCTIONNALITE
   Évolution
   =========
   
   '''
   Dans certaines configurations d'utilisation du parallélisme (avec PETSc par exemple), des
   opérations de synchronisation de la matrice du système linéaire sont effectuées. Il en est
   de même quand on synchronise les champs calculés par STAT_NON_LINE.
   Or nous n'avons aucun moyen de mesurer ce temps de communication. Sachant que nous
   utilisons une encapsulation des routines MPI, il serait peut-être pas trop compliqué de le
   mesurer.
   '''
   
   Détails
   =======
   
   On a regroupé toutes les opérations utilisant la bibliothèque MPI dans les 3 routines
   existantes :
   - MPICM0 : donne le rang et le nombre de processeurs participant au calcul
   - MPICM1 : permet de réaliser des opérations de réduction et de diffusion avec des
   tableaux fortran
   - MPICM2 : permet de réaliser les mêmes opérations mais sur des objets JEVEUX
   
   On résorbe MUMMPI qui faisait des appels MPI et on réécrit une routine F77 SDPART qui
   répartit les sous-domaines d'une partition FETI entre les différents processeurs.
   
   Tous les codes retour des fonctions MPI sont vérifiés par la nouvelle routine MPIERR (on
   résorbe FETMER) et donnent lieu à un éventuel message d'erreur.
   
   On utilise enfin le mécanisme mis en place au niveau de DEBUT (MESURE_TEMPS/NIVE_DETAIL)
   pour compter le temps passé dans les 3 routines centralisant les opérations MPI. À cette
   occasion, on supprime l'affichage du temps passé dans le contact-frottement, on met
   l'affichage du temps passé dans le déchargement JEVEUX en position #3 et le temps passé en
   communications MPI en #4 : 
   
   #1 Resolution des systemes lineaires              :      0.86      0.00      1.11
       (moyenne    diff. procs)                      :      0.91      0.01      1.09
       (ecart-type diff. procs)                      :      0.05      0.01      0.02
   #2 Calculs elementaires et assemblages            :      3.48      0.02      3.40
       (moyenne    diff. procs)                      :     13.88      0.04     13.85
       (ecart-type diff. procs)                      :     10.40      0.02     10.45
   #3 Dechargement de la memoire sur disque          :      0.01      0.01      0.01
       (moyenne    diff. procs)                      :      0.01      0.01      0.01
       (ecart-type diff. procs)                      :      0.00      0.01      0.00
   #4 Communications MPI                             :     21.94      0.04     21.88
       (moyenne    diff. procs)                      :     11.11      0.04     11.04
       (ecart-type diff. procs)                      :     10.82      0.01     10.84
   
   Remarque
   ========
   
   Sur les premiers essais on constate que ce nouvel affichage permet de bien voir les
   déséquilibres de charge et les temps d'attente des différents processeurs (pendant les
   opérations de communication).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.11.01
VALIDATION
    astout + visuelle
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 014579 DU 2010-02-08 15:49:34
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    CTC6 - Problxc3xa8mes de performances avec DEFI_CONTACT
FONCTIONNALITE
   Anomalie
   ========
   
   '''
   Avec la création de DEFI_CONTACT, un certain nombre de cas-tests se sont pris une bonne
   claque au niveau des perfs.
   C'est le cas (par exemple) de ssnv128l (lagrangien avec frottement)
   A première vue, il y a un problème dans l'élimination automatique des pivots nuls. La
   nouvelle version voit trop de pivots nuls, les élimine à tort, ce qui rend la convergence
   deux fois plus lente (deux fois plus d'itérations de contact, trois fois plus d'itérations
   de NEwton)
   '''
   
   Analyse
   =======
   
   En 11.0.25, la dégradation des tests ne touche plus que les tests utilisant
   ALGO_FROT='LAGRANGIEN'. C'est à dire ceux qui résolvent le frottement exactement par
   dualisation.
   Ce qui a été identifié comme problématique est la perte des statuts de frottement d'un
   appariement à un autre. En effet, depuis DEFI_CONTACT, on gère 3 paquets de liaisons :
   
   - NESMAX : le nombre potentiel max de liaisons a priori
   - NBLIAI : le nombre potentiel max effectif de liaisons, c'est à dire que l'on a retiré
   les noeuds faisant partie de SANS_GROUP_NO et ceux qui se projettent en dehors des
   surfaces (TOLE_PROJ_EXT)
   - NBLIAC : le nombre de liaisons actives
   
   Avant il n'y avait pas de distinction entre le premier paquet et le second, du coup le
   transfert de l'état de frottement était naturel. Maintenant il faut gérer ce changement
   dynamique et notamment l'indirection entre ces 2 paquets.
   
   Pour éviter un coût calcul trop important, on choisit l'approche suivante :
   
   - On ajoute 2 nouveaux objets à la SD de résolution du contact '.STFR' et '.STF0'
   ==> '.STFR' le statut de frottement courant avant un nouvel appariement
   ==> '.STF0' le statut de frottement convergé à la fin d'un pas de temps
   
   - avant un appariement (routine CFSVFR appelée dans NMCOFR), on sauvegarde l'état de
   frottement dans '.STFR'
   
   - après un appariement (routine CFINAL, lorsque l'on a réactualisé), on restaure l'état de
   frottement, à partir de '.STF0' si c'est le premier appariement d'un pas de temps, à
   partir de '.STFR' sinon
   ==> cette distinction permet de gérer l'éventuel redécoupage du pas de temps et donc
   l'écrasement du contenu de '.STFR'
   
   - après convergence (routine CFSVFR appelée par CFDECO), on sauvegarde l'état de contact
   convergé dans '.STF0'
   
   Validation
   ==========
   
   Sur les 26 tests utilisant ALGO_FROT='LAGRANGIEN' :
   
   - 2 sont NOOK : ssnv128a, ssnv505h
   - 24 sont OK 
   
   ssnv128a : léger changement sur une valeur de déplacement en 'NON_REGRESSION', on change
   la valeur de référence
   
   ssnv505h : contact entre 2 poutres, sur un calcul utilisant COULOMB=0 (c'est à dire en
   fait sans contact), on trouvait une valeur différente en formulation 'DISCRETE' et
   'CONTINUE', ce n'est désormais plus le cas. On change la valeur de référence.
   
   Performances
   ============
   
   Avant
   
   sdnv104d     OK                   252.47     9.10   261.57   276.33
   sdnv105a     <A>_ALARM            698.66    17.24   715.90   738.82
   sdnv105c     <A>_ALARM            557.98    10.91   568.89   596.21
   
   Après
   
   sdnv104d     <A>_ALARM            126.08     4.26   130.34   135.26
   sdnv105a     <A>_ALARM            406.00    14.36   420.36   421.28
   sdnv105c     <A>_ALARM            570.28    13.45   583.73   604.01
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    astout
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR geniaut      GENIAUT Samuel         DATE 10/10/2011 - 04:45:29

--------------------------------------------------------------------------------
RESTITUTION FICHE 016429 DU 2011-02-16 15:22:44
TYPE evolution concernant Documentation (VERSION )
TITRE
    MN05 - Document U2 conseils d'utilisation STAT_NON_LINE
FONCTIONNALITE
   chantier ISTA 2011
   
   MN05 - Document U2 conseils d'utilisation STAT_NON_LINE
   
   Proposition : documentation U2 "chapeau", g?n?raliste qui d?taille les points communs ?
   tous les usages (gestion du pas temps, gestion de Newton, des variables de commandes ...)
   et, pour les d?tails applicatifs, servirait d'aiguillage vers les documents propres ?
   chaque famille de non-lin?arit?s : contact, mat?riau adoucissant, thm, flambage, etc...,
   quand ils existent.
   
   nouvelle doc : U2.04.01
   L'objectif de cette note est de donner quelques conseils ? un utilisateur souhaitant
   r?aliser des calculs non lin?aires avec Code_Aster en utilisant l'op?rateur STAT_NON_LINE
   [U4.51.03].
   
   Des conseils g?n?raux sont d'abord donn?s. Puis on pr?cise pour les principaux types de
   probl?mes rencontr?s les solutions ? mettre en oeuvre. On renvoie ?galement vers la
   documentation sp?cifique ? chaque probl?me.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : u2.04.01
VALIDATION
    circuit de relecture standard
NB_JOURS_TRAV  : 6.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 017555 DU 2011-09-19 13:20:13
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    mise au propre des TP de formation Mxc3xa9ca Rupture
FONCTIONNALITE
   Probl?me :
   ----------
   
   Il faudrait migrer le patrimoine p?dagogique des TPs vers des objets g?r?s en
   configuration (doc dans la GED, tests dans astest).
   
   Il existe 4 TP d'exercices pour la formation avanc?e MKRUPT :
   http://www.code-aster.org/V2/UPLOAD/DOC_EDF/Support/support_tp.zip
   
   Il faudrait faire 2 choses :
   - cr?er les 4 tests FORMA* pour capitaliser les fichiers de commandes et de maillage
   - cr?er les docs V associ?es ? ces FORMA* qui contiendraient le texte du document support
   actuel.
   
   
   Solution :
   ----------
   
   On cr?e 3 nouveaux cas-tests :
   
   [V3.02.111] -> FORMA05 : TP RUPTURE : Plaque en traction 
   mod?lisation a : FEM 2D (ex TP1)
   
   [V3.02.112] -> FORMA06 : TP RUPTURE : Plaque multi-fissur?e
   mod?lisation a : X-FEM 2D (ex TP3)
   
   [V3.04.156] -> FORMA07 : TP RUPTURE : Fissure circulaire dans un milieu infini
   mod?lisation a : FEM 3D (ex TP2)
   mod?lisation b : X-FEM 3D (ex TP4)
   
   
   Les .comm sont donc la correction des exercices.
   Pour les TPs, il faut aussi donner des fichiers .comm ? compl?ter.
   L'obtention des fichiers ? compl?ter en partant des .comm correction est expliqu?e en
   entete de chaque .comm
   
   
   Le travail est fait en STA10 et en NEW11.
   Une fiche d'anomalie a ?t? ?mise ? l'occasion (fiche 17639) : un bug ? la relecture d'une
   base contenant des objets cr??s par RAFF_XFEM a ?t? d?couvert.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V3.02.111, V3.02.112, V3.04.156
VALIDATION
    cas test livres
NB_JOURS_TRAV  : 6.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 017039 DU 2011-05-30 12:58:17
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    MN06 DEFI_LIST_INST/ METHODE AUTO/PAS_MAXI
FONCTIONNALITE
   Probl?me :
   ----------
   
   En utilisant la gestion automatique du pas de temps et PAS_MAXI, un utilisateur trouve le
   comportement de DEFI_LIST_INST bizarre :
   l'algorithme propose un pas de temps plus grand que le pas de temps maxi, le calcul
   s'arr?te en erreur fatale.
   
   C'est pourtant le comportement "normal". La doc dit :
   "L'op?rande PAS_MAXI permet de sp?cifier le pas de temps maximal. Si au cours de
   l'adaptation du
   pas de temps, on est amen? ? traiter un pas de temps sup?rieur ? pasmax, alors le calcul
   s'arr?te."
   
   L'id?e ? l'origine est de garder le m?me principe de garde-fou que pour le pas de temps mini.
   Quand le pas de temps apr?s sous-d?coupage descend en dessous de SUBD_PAS_MINI ou bien
   quand le pas de temps apr?s adaptation descend en dessous de PAS_MINI alors le calcul
   s'arrete : pas de temps trop petit.
   L?, c'est pareil, mais quand le pas de temps devient trop grand.
   
   On peut cependant remettre en question ce comportement est dire que si DT > PAS_MAXI alors
   DT = PAS_MAXI. Il me semble d'ailleurs que c'est ce comportement qui est adopt? si
   CALCUL_TPLUS = 'IMPLEX' (car IMPLEX ne plante jamais !).
   
   
   Solution :
   ----------
   
   On adopte le comportement suivant :
   si DT > PAS_MAXI alors DT = PAS_MAXI.
   une information est alors ?mise  (sauf si IMPLEX car c'est le comportement normal avec IMPLEX)
   
   
   Validation : forma03c
   le pas de temps atteint ? un certain moment 0.8s. On impose PAS_MAXI = 0.5s.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : u4.34.03
VALIDATION
    forma03c
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 015183 DU 2010-06-10 13:39:59
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    DEF2 : DEFI_LIST_INST doit accepter une liste de valeurs
FONCTIONNALITE
   Probl?me :
   ----------
   
   Suite ? la pr?sentation au club U, il manque un mot-cl? VALE 
   dans DEFI_LIST_INST pour pouvoir fournir une liste python de 
   valeurs (par exemple calcul?e ou r?cup?r?e par ailleurs).
   
   
   Solution :
   ----------
   
   On rajoute la possibilit? de fournir VALE ? DEFI_LIST_INST / DEFI_LIST :
   
    regles=(UN_PARMI('LIST_INST','VALE',),),
   
   Validation : forma03c
   on donne :              VALE=(0., 0.025, TFIN),
   au lieu de passer par DEFI_LIST_REEL.
   
   impact : 
   defi_list_inst.capy, dfllty.f
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : u4.34.03
VALIDATION
    forma03c
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR geniaut      GENIAUT Samuel         DATE 10/10/2011 - 02:09:09

--------------------------------------------------------------------------------
RESTITUTION FICHE 017610 DU 2011-09-27 15:01:37
TYPE anomalie concernant Code_Aster (VERSION 11.1)
TMA : Phimeca
TITRE
    POST_K1_K2_K3 incorrect si E et NU = f(TEMP)
FONCTIONNALITE
   Problème :
   ----------
   
   La correction de la fiche est 17322 n'est pas complète.
   
   Si on modifie le test ascou18b pour utiliser le matériau MAT2 au lieu de MAT :
                                                                                            
                           
   JP1=DEFI_FONCTION(    NOM_PARA='TEMP',
                              VALE=(  -1000.,           174700.,
                                      +1000.,           174700., ))
   JP2=DEFI_CONSTANTE(VALE=0.3)                                                             
                                                       
   MAT2=DEFI_MATERIAU(ELAS_FO     =_F( E = JP1, NU = JP2, ),);
                                                                                            
   
   Alors, on se plante encore avec une division par e=0. (comme pour la fiche 17322).
   
   Dans la programmation, on voit que si E et NU n'ont pas de prolongement constant à gauche
   et si E est une
   fonction de TEMP, mais que TEMP_DEF_ALPHA n'est pas défini, on ne calcule pas E , d'où une
   division pas zéro.   
   
   Le code n'est donc pas assez blindé : on ne sait pas quelle température utiliser pour
   évaluer les fonctions.
   
   
   
   Solution :
   ----------
   
   L'utilisateur a la possibilité de renseigner un matériau différent de celui qui lui a
   servi dans la résolution. Cette configuration n'est pas entièrement blinder. 
   Effectivement, si l'utilisateur renseigne un second matériau avec une fonction pour le
   module d'Young et une constante pour le coefficient de Poisson, le code échoue dans une
   division par 0.0. Car, si les propriétés matériaux sont des fonctions (DEFI_FONCTION) ou
   des constantes (DEFI_CONSTANTE) alors les valeurs récupérées via la commande
   sd_compor1('%-8s.%s' % (MATER.nom, phenom)) sont nulles (0.0) et leur type est réel.
   
   Ainsi on distingue plusieurs cas si EVOL_THER n'est pas renseigné:
   - le cas ou l'utilisateur a utilisé ELAS, on s'assure que le module d'Young n'est pas nul.
   - le cas où l'utilisateur a utilisé ELAS_FO, on s'assure que les deux caractéristiques E
   et nu sont:
   -- soit fonction que de la température. Dans ce cas, on demande à l'utilisateur de
   renseigner TEMP_DEF_ALPHA dans la définition du matériau afin de permettre l'évaluation de
   la caractéristique à cette température. Le message suivant est alors émis:
   
   !-------------------------------------------------------------------------!
   ! <F> <RUPTURE0_52>                                                       !
   !                                                                         !
   ! Vous avez utilisé des paramètres matériaux dépendant de la température. !
   ! Cependant, 'TEMP_DEF_ALPHA' dans DEFI_MATERIAU n'est pas renseigné.     !
   ! -> Conseil :                                                            !
   ! Renseignez une température pour 'TEMP_DEF_ALPHA',                       !
   ! ou utilisez l'otion 'EVOL_THER' de POST_K1_K2_K3.                       !
   !                                                                         !
   !                                                                         !
   ! Cette erreur est fatale. Le code s'arrête.                              !
   !-------------------------------------------------------------------------!
   
   Si l'utilisateur n'a pas correctement prolongé sa fonction le code s'arrete alors avec le
   message :
     
   !----------------------------------------------------------------------------------------------------!
      ! <E> <FONCT0_19>                                                                     
                 !
      !                                                                                     
                 !
      ! On est hors du domaine de définition de la fonction.                                
                 !
      ! On ne peut pas interpoler la fonction pour cette abscisse car le prolongement à
   gauche est exclus. !
      !    abscisse demandée              : 20.000000                                       
                 !
      !    borne inférieure des abscisses : 50.000000                                       
                 !
      !                                                                                     
                 !
      !   -> Risque & Conseil :                                                             
                 !
      !     Voir le mot-clé PROL_GAUCHE des commandes qui créent des fonctions.             
                 !
      !                                                                                     
                 !
      !                                                                                     
                 !
      ! Cette erreur sera suivie d'une erreur fatale.                                       
                 !
     
   !----------------------------------------------------------------------------------------------------!
   
   -- soit constante. Dans ce cas, on s'assure que le module d'Young n'est pas nul.
   
   
   Validation :
   ------------
   
   Le cas-test ascou18b modifie a permis de tester les developpements et les différentes
   configurations. IL n'est cependant pas restitué.
   Très prochainement, un nouveau cas test (zzzz289) dédié à la validation informatique de
   POST_K1_K2_K3 sera restitué dans la fiche 14716, et testera aussi la donnée de matériau
   fonction.
   
   Remarques:
   Si l'utilisateur prend le meme matériau que celui de la resolution, il est arrêté dans fointa.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : u4.82.05
VALIDATION
    tests POST_K1_K2_K3
--------------------------------------------------------------------------------
RESTITUTION FICHE 017476 DU 2011-09-05 12:54:52
TYPE evolution concernant Code_Aster (VERSION )
TMA : Phimeca
TITRE
    RUPT : blancs dans les noms des objets
FONCTIONNALITE
   Problème :
   ----------
   
   Certains noms d'objets créés par DEFI_FOND_FISS comportent des blancs :
   
   ex : 
   '.SUPNORM   .NOEU'
   '.FOND      .TYPE'
   
   Je n'en vois pas l'utilité, et cela nuit à la lisibilité de la doc D.
   
   Je propose de supprimer ces blancs.
   
   
   Solution : 
   ----------
   
   On supprime les blancs dans les objets suivants :
   .LEVRESUP.MAIL
   .LEVREINF.MAIL
   .FOND.NOEU
   .FOND_SUP.NOEU
   .FOND_INF.NOEU
   .FOND.TYPE
   .SUPNORM.NOEU
   .INFNORM.NOEU
   
   impact :
   fonlev.f  fonno6.f  fonnof.f  gcour2.f  gdirec.f  mecagl.f  memokg.f  op0055.f
   fonmai.f  fonnoe.f  fonnor.f  gcouro.f  gver2d.f  meficg.f  op0054.f  op0100.f
   post_gp_ops.py  post_k1_k2_k3_ops.py  sd_fond_fiss.py
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : D4.10.01
VALIDATION
    tests DEFI_FOND_FISS
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR meunier      MEUNIER Sébastien     DATE 10/11/2011 - 05:34:50

--------------------------------------------------------------------------------
RESTITUTION FICHE 013623 DU 2009-07-16 12:13:40
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Chainage H-M
FONCTIONNALITE
   Objectif :
   ==========
   
   On restitue un nouveau mode de résolution pour les problèmes THM : le chaînage. Pour
   l'instant, on se limite au chaînage pour les modélisations Hydro-Mécaniques (HM) saturées.
   
   Description :
   =============
   
   Actuellement, la résolution des problèmes HM se fait de manière totalement couplée à
   chaque instant.
   
   L'idée de la méthode par chaînage est d'enchaîner la résolution d'un problème H à
   l'instant 1 (solution P_{t1}), puis d'un problème M à l'instant 1 (solution u_{t1}) avec
   la donnée P_{t1}, puis d'un problème H à l'instant 2 (solution P_{t2}) avec u_{t0} et
   u_{t1} etc...
   
   Cette méthode pourra servir pour les modèles développés récemment dans Code_Aster qui ne
   sont pas actuellement couplés avec le kit THM. Cela concerne :
   1. le modèle de comportement endo_heterogene, non couplé avec l'hydraulique (modèle BRGM)
   2. les volumes finis hydrauliques, non couplés avec la mécanique (thèse O. Angelini)
   
   Par ailleurs, cette nouvelle méthode de résolution permet d'envisager d'avoir des
   discrétisations en espace et en temps différentes pour la mécanique et pour l'hydraulique.
   
   Développement informatique :
   ===========================
   
   Le chaînage se fait presque totalement au niveau du fichier de commandes. Les
   développements informatiques réalisés sont finalement légers.
   
   La communication des données hydraulique et mécanique respectivement aux problèmes
   mécanique et hydraulique se fait par le mécanisme des variables de commande.
   On introduit donc les variables de commande PTOT et DIVU.
   
   PTOT joue un rôle très similaire à la variable de commande température. Il sert à modifier
   le tenseur des contraintes effectives en y ajoutant le terme -biot*pression sur la
   diagonale. Il est utilisable pour toutes les lois de comportement de mécanique des sols.
   DIVU sert à modifier la loi d'évolution de la porosité par le terme faisant intervenir
   l'incrément de déformation volumique d(epsv).
   
   Une nouvelle macro-commande (CHAINAGE_THM) est introduite pour réaliser toutes les
   manipulations de champs nécessaires pour créer automatiquement les variables de commande
   en entrée de chaque problème.
   
   Cette commande a 3 modes de fonctionnement :INIT / MECA_HYDR / HYDR_MECA. La syntaxe est
   donnée ci-dessous :
   
   1. INIT
   =======
   
   CHAINAGE_THM(
                TYPE_CHAINAGE = 'INIT',
                MODELE_MECA   = MODMEC,
                MODELE_HYDR   = MODHYD,
                MATR_MH       = CO('MATMH',),
                MATR_HM1      = CO('MATHM1',),
                MATR_HM2      = CO('MATHM2',),
   );
   INIT sert à créer les 3 matrices de projection nécessaires pour gagner du temps sur les
   phases de projection entre les maillages mécanique et hydraulique (MATMH, MATHM1, MATHM2)
   
   2. MECA_HYDR
   ============
   
   DEFVHY=CHAINAGE_THM(RESU_MECA=DEPLA,
                         MODELE_HYDR=MODHYD,
                         MATR_MH=MATMH,
                         TYPE_CHAINAGE='MECA_HYDR',
                         INST=linst[k],);
   MECA_HYDR sert à créer la variable de commande DIVU pour la résolution du problème
   hydraulique, en utilisant les données du résultat du problème mécanique. Le résultat
   renvoyé DEFVHY est un evol_varc.
   
   3. HYDR_MECA
   ============
   
   REPTOT=CHAINAGE_THM(RESU_HYDR=PRELIQ,
                         MODELE_MECA=MODMEC,
                         TYPE_CHAINAGE='HYDR_MECA',
                         MATR_HM1=MATHM1,
                         MATR_HM2=MATHM2,
                         INST=linst[k],);
   
   HYDR_MECA sert à créer la variable de commande PTOT pour la résolution du problème
   mécanique, en utilisant les données du résultat du problème hydraulique. Le résultat
   renvoyé est un evol_varc ou un cham_no, si la résolution du problème mécanique est
   réalisée avec MECA_STATIQUE.
   
   On complète également les options EPVC_ELxx avec EPPTOT et VARC_ELxx avec PTOT et DIVU. 
   
   Validation :
   ============
   
   On crée 3 tests de validation. On ajoute 2 tests de validation informatique de la bonne
   création des variables de commande et 1 test de validation de la résolution par chaînage
   en comparaison de celle par couplage.
   
   1=> Validation informatique:
   
   a. On enrichit le test wtnp116 avec la modélisation c. C'est un test en modélisation
   d_plan_hm_p où le problème hydraulique est indépendant du problème mécanique. On s'en sert
   donc pour valider la communication H vers M.
   
   b. On enrichit le test wtnl avec la modélisation g. C'est un test en modélisation
   d_plan_hm. On résout donc ce problème en couplé classiquement, puis on se sert de la
   solution obtenue pour effectuer de nouveau sur tout le transitoire la résolution du
   problème H, avec la variable de commande DIVU de référence. Cela permet donc de valider la
   communication M vers H.
   
   2=> Validation de la méthode de résolution
   On crée le test wtnp129. C'est un test 2D avec une solution 1D. Le chargement est
   essentiellement une pression hydraulique imposée sur un bord. On compare la solution par
   chaînage (modélisation b) avec celle par couplage (modélisation a).
   
   Impact sources :
   ================
   fortran :
   calcco.f  comthm.f  hmlisa.f  lc0000.f  nmelnl.f  rscrsd.f  vrcpto.f
   calcva.f  epstmc.f  inithm.f  meacmv.f  nmvccc.f  te0529.f
   carcha.f  epthmc.f  kitdec.f  mestat.f  nmvcpr.f  te0530.f
   
   Catalogues :
   affe_materiau.capy     c_nom_cham_into.capy    medpqs4.cata
   chainage_thm.capy      gener_me2dsi_2.cata   
   gener_medha2.cata      grandeur_simple__.cata
   char_meca_ptot_r.cata  gener_medpl2.cata
   
   Python :
   chainage_hydr_meca.py  chainage_meca_hydr.py  chainage_thm_ops.py
   chainage_init.py       chainage.py
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : u4.81.01,u4.43.03,u4.81.04,u2.01.04,u2.04.05,v7.32.116.v7.30.100,u7.03.61
VALIDATION
    wtnp116,wtnl100,wtnp129
NB_JOURS_TRAV  : 50.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR pellet       PELLET Jacques         DATE 10/11/2011 - 09:18:00

--------------------------------------------------------------------------------
RESTITUTION FICHE 017605 DU 2011-09-27 09:17:01
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    AR01 Dxc3xa9faut de validation : DKTG + excentrement
FONCTIONNALITE
   Problème:
   ---------
   Les éléments de la modélisation DKTG peuvent etre excentrés au vu de leur catalogue.
   Mais ils ne sont pas testés avec de l'excentrement.
                                                                                            
                           
   Correction :
   ------------
   En réalité, ces éléments ne sont pas programmés pour tenir compte de l'excentrement (pas
   plus que les éléments de la modélisation COQUE_3D).
   Il n'y a donc pas lieu de vouloir étendre leur validation : la fiche est "sans suite".
                                                                                            
                           
   Un "blindage" du code a été introduit via la fiche 17666 :
    On interdit l'affectation d'un excentrement non nul sur les éléments qui ne le traitent pas.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    rien de particulier
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 017653 DU 2011-10-05 15:45:35
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    EFGE_ELNO plante avec la modxc3xa9lisation DKTG
FONCTIONNALITE
   Problème :
   ----------
   On peut faire un calcul linéaire (MECA_STATIQUE) avec la modélisation DKTG.
   Mais si l'on demande en post-traitement le calcul de l'option EFGE_ELNO, on est arreté par
   le message :
                                                                                            
                           
   !---------------------------------------------------------!
   ! <E> <CALCULEL2_70>                                      !
   !  le parametre: PNBSP_I  n'est pas un paramètre de       !
   !  l'option: EFGE_ELNO  pour le type_element:  MEDKQG4    !
   !---------------------------------------------------------!
                                                                                            
                           
   Correction :
   ------------
   Le problème vient de la routine dxefnt.f qui calcule les efforts dus à la déformation
   thermique.
   J'ai modifié cette routine pour qu'elle ne nous arrete plus lorsque le calcul ne dépend
   pas de la température.
                                                                                            
                           
   Validation :
   ------------
   J'ajoute à la fin du test ssls126a un petit calcul MECA_STATIQUE + DKTG + EFGE_ELNO.
   Les TEST_RESU sont de non-regression.
                                                                                            
                           
   Sources modifiés :
    dxefnt.f
    ssls126a.comm
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssls126a
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 017666 DU 2011-10-06 11:28:15
TYPE express concernant Code_Aster (VERSION 9.1)
TITRE
    Seules les modxc3xa9lisations DST et DKT prennent en compte l'excentrement des coques : il faut blinder le code
FONCTIONNALITE
   Problème :
   -----------
   On trouve la composante EXCENT (excentrement pour les coques) dans les catalogues :
     gener_mecq32.cata
     gener_medkg1.cata
     gener_medkt2.cata
                                                                                            
                                                                        
   Ces catalogues concernent :
                                                                                            
                                                                        
           catalogue               element      modelisation
           ---------------------------------------------------
           gener_mecq32.cata       MEC3QU9H     COQUE_3D
           gener_mecq32.cata       MEC3TR7H     COQUE_3D
    
           gener_medkg1.cata       MEDKQG4      DKTG
           gener_medkg1.cata       MEDKTG3      DKTG
    
           gener_medkt2.cata       MEDKQU4      DKT
           gener_medkt2.cata       MEDKTR3      DKT
           gener_medkt2.cata       MEDSQU4      DST
           gener_medkt2.cata       MEDSTR3      DST
           gener_medkt2.cata       MEQ4QU4      Q4G
    
   Mais en réalité, seules les modélisations DKT et DST prennent en compte un éventuel
   excentrement.
                                                                                            
                                                                        
   Comme Q4G partage le meme catalogue que DKT et DST, un blindage a été introduit dans la
   routine dktrig.f pour interdire l'usage d'un excentrement avec Q4G.
                                                                                            
                                                                        
   En revanche, si on affecte un excentrement non nul aux coques DKTG et COQUE_3D : le calcul
   va jusqu'au bout mais l'excentrement est ignoré !
                                                                                            
                                                                        
   Il faut "blinder" le code est interdire d'affecter de l'excentrement sur des coques qui
   n'en tiennent pas compte.
                                                                                            
                                                                        
                                                                                            
                                                                        
   Evolution proposée :
   ----------------------
   L'utilisateur est maintenant arreté par le message :
   !-----------------------------------------------------------------------!
   !.<F>.<CALCULEL2_30>....................................................!
   !.......................................................................!
   !.Erreur.utilisateur.dans.la.commande.AFFE_CARA_ELEM.:..................!
   !...On.a.affecté.un.excentrement.non.nul.(mot.clé.COQUE./.EXCENTREMENT).!
   !...sur.un.élément.qui.ne.sait.pas.traiter.l'excentricité.(maille.M3)...!
   !-----------------------------------------------------------------------!
                                                                                            
                                                                        
                                                                                            
                                                                        
   Détails :
   ---------
   Pour réaliser ce blindage d'AFFE_CARA_ELEM, j'ai introduit une nouvelle option de calcul
   élémentaire : VERI_CARA_ELEM.
   Cette option est appelée à la fin de la commande AFFE_CARA_ELEM.
                                                                                            
                                                                        
   Pour l'instant, seuls les éléments de coque calculent cette option et la seule
   vérification qu'ils font est la nullité de l'excentrement pour certaines modélisations.
   Mais on peut imaginer d'autres vérifications de meme nature pour les poutres, discrets, ....
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    essai perso
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 017678 DU 2011-10-10 06:15:52
TYPE express concernant Code_Aster (VERSION 9.1)
TITRE
    AR01 : CALC_CHAMP / EFGE_ELGA dans le plan du maillage pour les coques excentrxc3xa9es
FONCTIONNALITE
   Problème :
   ----------
   Quand j'ai rendu possible le calcul de l'option EFGE_ELGA pour les éléments finis de coque
   (fiche 17481), je n'ai pas pris garde aux éléments pouvant avoir de l'excentrement.
                                                                                            
                           
   Actuellement, la situation n'est pas cohérente pour les coques excentrées :
     * EFGE_ELNO est calculé dans le "plan" du maillage
     * EFGE_ELGA est calculé dans le "plan" "moyen" de la coque
                                                                                            
                           
                                                                                            
                           
   Evolutions :
   ------------
   1) Le calcul d'EFGE_ELGA est maintenant fait dans le plan du maillage (appel à la routine
   excent.f dans te0451.f)
   2) J'étends le périmètre de POST_CHAMP / COQU_EXCENT pour que la commande traite aussi
   NOM_CHAM='EFGE_ELGA'.
                                                                                            
                           
                                                                                            
                           
   Validation :
   ------------
   Dans un nouveau test à venir (qui sera restitué dans le cadre de la fiche 17604), on calcule :
     * EFGE_ELGA et EFGE_ELNO dans CALC_ELEM (plan 'MAIL')
     * EFGE_ELGA et EFGE_ELNO dans POST_CHAM (plan 'MOY')
                                                                                            
                           
   Impact documentaire :
   ---------------------
   U4.81.01 / U4.81.04 : CALC_ELEM / CALC_CHAMP : dire que le calcul de EFG_ELGAet EFGE_ELNO
   est toujours fait dans le plan du maillage.
   U4.81.05 : POST_ELEM / COQU_EXCENT : ajouter NOM_CHAM='EFGE_ELGA'
                                                                                            
                           
   sources impactés par cette fiche :
   ----------------------------------
   F: excent.f  te0451.f te0451.f te0452.f w155ce.f
   CAPY: post_champ.capy
   CATA: efge_excent.cata  gener_medkt2.cata
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.81.01  U4.81.04 U4.81.05
VALIDATION
    essais perso
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR flejou       FLEJOU Jean Luc        DATE 10/11/2011 - 09:18:01

--------------------------------------------------------------------------------
RESTITUTION FICHE 017614 DU 2011-09-27 16:44:45
TYPE anomalie concernant Code_Aster (VERSION 11.1)
TITRE
    [FORUM] Repertoire de noms sature dans AFFE_CARA_ELEM/BARRE
FONCTIONNALITE
   Dans AFFE_MODELE il existe la règle de surcharge. On peut donc faire :
   
   Si 'BARS'  =                 MAILLE3 MAILLE4 MAILLE5 MAILLE6 
   Si 'BEAMS' = MAILLE1 MAILLE2 MAILLE3 MAILLE4
   
   modl = AFFE_MODELE( AFFE = (
      _F(GROUP_MA = ('BARS',), PHENOMENE = 'MECANIQUE', MODELISATION = 'BARRE'),
      _F(GROUP_MA = ('BEAMS'), PHENOMENE = 'MECANIQUE', MODELISATION = 'POU_D_E'), ),
   )
   Les mailles MAILLE1 MAILLE2 MAILLE3 MAILLE4 sont du type 'POUTRE' 
   Les mailles MAILLE5 MAILLE6 sont du type 'BARRE'
   
   Lorsque l'on fait :
   cara = AFFE_CARA_ELEM(
      BARRE   = (_F(GROUP_MA = ('BARS'), ...)
      POUTRE  = (_F(GROUP_MA = ('BEAMS'), ...),
   )
   La commande plante, avec le message ci-dessous, sur la maille MAILLE3 qui est de type
   'POUTRE' 
   <EXCEPTION> <JEVEUX1_33>
   Le répertoire de noms cara    .BARRE est saturé, il faut le redimensionner.
   
   
   Correction :
   ------------
   Avant d'affecter les caractéristiques sur l'élément on vérifie que sa modélisation est la
   bonne.
   Si ce n'est pas la bonne, on émet le message <F> ci-dessous
   MODELISA_8 : _("""
    Vous affectez des caractéristiques de type %(k1)s à la maille %(k2)s qui est pas de ce type.
   
    Conseil :
      Vérifier le résultat de la commande AFFE_MODELE pour la maille %(k2)s.
   """),
   
   
   Impact :
   -------
   modelisa.py    : ajout du message 8
   op0019         : op d'AFFE_CARA_ELEM, modif des appels à aceaba et aceapo
   aceapo, aceaba : ajout de la vérification du type de la modélisation
   
   
   Validation :
   ------------
   Passage étude forum + test perso
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    test perso
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR proix        PROIX Jean-Michel      DATE 10/10/2011 - 04:51:21

--------------------------------------------------------------------------------
RESTITUTION FICHE 017646 DU 2011-10-05 08:27:11
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    probleme lors du re-decouapge du 1er instant dans SIMU_POINT_MAT
FONCTIONNALITE
   Problème :
   =========
   
   l'utilisation d'un POLYCRISTAL dans SIMU_POINT_MAT avec plus de 200 grains 
   provoquait un écrasement mémoire.
   
   Correction :
   ============
   dans SIMU_POINT_MAT, avec SUPPORT='POINT', donc dans op0033, on cherche à utiliser 
   l'EventDriven, comme STAT_NON_LINE.
   
   Pour faire cela, OP0033 appelle PMSTA1, qui stocke dans une table les incréments 
   DEPS, DSIG, DVARI.
   
   Cela marchait bien tant que les tables étaient de taille "raisonnable" : 99 colonnes 
   au maximum (en V10)
   
   Or dans le cas présent on cherche à stocker plus de 14000 valeurs. Or on voulait 
   stocker les incréments de variables internes dans un tableau, VR, qui n'était 
   dimensionné qu'à 9999. D'où le débordement.
   
   On corrige en prenant en compte les différents modes de stockage de la table dans
   SIMU_POINT_MAT : FORMAT_TABLE='CMP_LIGNE', et FORMAT_TABLE='CMP_COLONNE'.
   
   Deux tests : 
   
   - étude d'un polycristal à 300 grains (un peu long)
   - Ajout dans SSNV194C de DELTA_GRANDEUR pour les deux formats de table.
   
   Ne pas reporter en NEW10 : les tables étaient limitées alors à 99 colones, on en 
   pouvait avoir ce débordement de tableau.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssnv194c
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 017503 DU 2011-09-08 11:54:22
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW11.0.20, les cas-tests perfe03a et ssnv194a s'arrxc3xaatent en NO_RESU_FILE sur Rocks.
FONCTIONNALITE
   En NEW11.0.20, les cas-tests perfe03a et ssnv194a s'arrêtent en NO_RESU_FILE sur Rocks.
   
   perfe03a : TITRE : NON REGRESSION DU CALCUL D'AGREGAT DU MODULE TOUGHNESS DE PERFECT
   ssnv194a : TITRE : TRACTION SUR UN AGREGAT A 10 GRAINS, ACIER BAINITIQUE
   
   Ces tests fonctionnent à nouveau sur Rocks. Je les ai testés en DEBUG et NODEBUG.
   
   Ceci est probablement dû à la restitution en 11.0.25 de la fiche 17626.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssnv194a, perfe03a
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 017658 DU 2011-10-06 07:53:22
TYPE express concernant Code_Aster (VERSION 9.1)
TITRE
    possibilitxc3xa9 d'ajouter 5 familles de systxc3xa8mes de glissement via des tables
FONCTIONNALITE
   Suite la fiche 17531 : en fait, dans certains cas, la famille ZIRCONIUM, comprenant 
   30 systèmes de glissement, n'est pas monolithique : on veut pouvoir affecter des  
   paramètres matériau différents à certains ensembles de systèmes de glissement.
   
   Pour pouvoir effectuer tous les tests nécessaires, et donner une plus grande 
   souplesse, on permet d'utiliser dans DEFI_COMPOR une table de systèmes de glissement 
   par occurrence de MONOCRISTAL (5 au maximum). Ceci permet donc d'associer des 
   matériaux différents.
   
   Par contre la table d'interaction est unique, et permet justement une interaction sur
   l'ensemble de ces systèmes.
   
   Ceci fonctionne aussi avec POLYCRISTAL.
   
   On en profite pour faire un ménage complet dans les routines de MONOCRISTAL et 
   POLYCRISTAL. 
   
   Valdiation : tests SSNV172A, SSNV194C.
   
   Impacts doc : 
   légers changements dans D4.06.24 (sd_compor)
   v6.04.172, v6.04.194
   
   On proposera une nouvelle doc D pour faciliter la maintenance évolutive des 
   comportements cristallins : D5.04.02
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : D4.06.24, V6.04.172, V6.04.194, D5.04.02
VALIDATION
    ssnv194c, ssnv172a
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 017663 DU 2011-10-06 10:20:04
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW11.0.25, le cas-test ssnp15a sxe2x80x99arrxc3xaate en erreur fatale sur Rocks.
FONCTIONNALITE
   En NEW11.0.25, le cas-test ssnp15a s’arrête en erreur fatale sur Rocks.
   
   
   Ceci est dû à la modification de l'indicateur de décharge DERA_ELGA (fiche 17285)
   
   J'ajout 1 mn au .para
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssnp15a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR debonnieres  DE BONNIERES Philippe   DATE 10/10/2011 - 04:51:22

--------------------------------------------------------------------------------
RESTITUTION FICHE 014586 DU 2010-02-09 13:26:02
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Modele cristallin CrystalECP
FONCTIONNALITE
   Dans le cadre du projet COFAT, j'ai developpe avec Jean-Michel une 
   nouvelle loi de comportement monocristalline, MONO_DD_FAT, issue de la 
   dynamique des dislocations et donc de la meme famille que DD_CFC.
   L'ecoulement visco-plastique (plus precisement la definition de 
   l'ecrouissage isotrope) est un peu different ainsi que la loi 
   d'evolution de la densite de dislocations.
   Je modifie pour cela 12 routines fortran, essentiellement de type lcm*, 
   et les catalogues defi_materiau et defi_compor.
   Validation : 1 nouveau test ssnd110c (comparaison a des resultats 
   experimentaux extraits de la these de Julien Schwartz)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V6.08.110, U4.43.01, U4.43.06, R5.03.11
VALIDATION
    SSND110C
NB_JOURS_TRAV  : 20.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR sellenet     SELLENET Nicolas       DATE 10/11/2011 - 10:30:24

--------------------------------------------------------------------------------
RESTITUTION FICHE 017643 DU 2011-10-05 07:01:13
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Probleme avec maillage issu de SALOME MECA 6
FONCTIONNALITE
   Problème :
   ----------
   """
   j'ai réédité un maillage au format med avec SALOME MECA 6.3.0. A ma grande surprise, le
   fichier de commande 
   s'est arrété à la commande LIRE MAILLAGE. Je mets le fichier .error en PJ.
   J'ai réédité le même maillage avec la version 5.1.5 de SALOME MECA et là tout fonctionne
   correctement.
   """
   
   
   Analyse :
   ---------
   Le test du fichier MED en question montre que le plantage est dû au problème des maillages
   poutres corrigé en 11.0.14 et reporté en 10.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    unitaire
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------
RESTITUTION FICHE 017623 DU 2011-09-29 08:54:14
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    AR01 - Chantier CALC_CHAMP : CALC_CHAMP pas sympa si dependance non verifiee
FONCTIONNALITE
   Problème :
   ----------
   """
   Dans le test sdll01a, on demandait le calcul de SIGM_ELNO. Or cette option n'est pas
   disponible pour les éléments du modèle (POU_D_T). On a alors l'alarme :
   "<A> <CALCULEL2_89>
   option SIGM_ELNO non disponible sur les éléments du modèle pas de champ créé"
   
   On continue le calcul sans s'arrêter.
   
   Maintenant, pour calculer SIGM_ELNO, il faut SIGM_ELGA. Cette dernière option n'est pas
   disponible non plus pour les éléments du modèle donc on ne la calcul pas.
   
   Mais quand on arrive au calcul de SIGM_ELNO, on ne trouve pas les prérequis SIGM_ELGA et
   on s'arrête en erreur fatale :
   "<F> <UTILITAI_50>
   CHAM_ELEM inexistant:"
   
   Ce message est émis par dismce.
   
   Il faudrait ne pas s'arrêter et continuer sans rien calculer.
   """
   
   
   Analyse :
   ---------
   Le problème vient du fait qu'on demande à calculer une option sur un modèle composé
   uniquement d'éléments qui ne savent pas la calculer. Dans le post-traitement, on essaye au
   maximum de ne pas planter. C'était d'ailleurs ce qui se passait précédemment avant les
   modifications de SIGM_ELNO.
   
   Aujourd'hui SIGM_ELNO a besoin de SIGM_ELGA pour être calculée. L'utilisateur qui demande
   donc SIGM_ELNO se retrouve à déclencher le calcul de SIGM_ELGA. Cette dernière option
   n'était pas calculable non plus sur ce modèle.
   
   On avait donc l'alarme CALCULEL2_89 pour SIGM_ELGA et un plantage sale lorsqu'on cherchait
   à calculer SIGM_ELNO.
   
   
   Solution :
   ----------
   Le but est de retrouver le comportement précédent, à savoir, pas de plantage et alarme
   uniquement pour le calcul de SIGM_ELNO.
   
   Pour ce faire, il faut protéger certains DISMOI (qui n'ont pas de sens en l'absence de
   SIGM_ELGA).
   
   De plus, il faut aussi un peu modifier MECEUC. Si un champ nécessaire est absent, on ne
   peut pas déterminer son type. Si on ne peut pas déterminer son type, c'est qu'il est
   absent donc on ne doit pas appeler CALCUL.
   
   Il faut aussi modifier CALCOP pour éviter qu'il n'alarme l'utilisateur sans raison. Il
   demande SIGM_ELNO, il faut donc l'informer qu'on ne sait pas calculer SIGM_ELNO et rien
   d'autre.
   
   Remarque : Lors de la restitution de la fiche 17564, j'ai oublié de restituer le cas test
   objet de la fiche (ssnd101a), je le fais donc maintenant ainsi que la doc.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sdll01a modifie
NB_JOURS_TRAV  : 0.3
--------------------------------------------------------------------------------
RESTITUTION FICHE 017231 DU 2011-07-01 11:22:43
TYPE express concernant Code_Aster (VERSION 9.1)
TITRE
    AR01 : Verification des reperes locaux
FONCTIONNALITE
   Problème :
   ----------
   Comme dans CALC_CHAMP, il n'est plus possible de modifier le repère dans lequel un champ
   est calculé, il est nécessaire de vérifier les repères locaux lors du passage ELNO -> NOEU
   pour des champs définis sur des éléments de structures.
   
   
   Solution :
   ----------
   On ajoute une routine qui vérifie les repères locaux entourant tous les noeuds sur lequels
   on a demandé le calcul d'une option aux noeuds. Cette routine n'est appelée que si on a
   des modélisations type POUTRE, COQUE, etc. (question EXI_RDM posée à DISMOI).
   
   Cette routine se nomme CCVRRL. Elle fait appel à une nouvelle routine (MPGLCP) qui est
   chargée de calculer la matrice de passage du repère global au repère local pour le cas des
   poutres et des coques.
   
   A partir de ces matrices, on opère le changement de repère du vecteur (1,1,1) du global au
   local pour les deux mailles dont on compare les repères. On obtient donc deux vecteurs
   dont on calcul l'angle qu'ils forment (routine ANGVEC).
   
   Si les repères ne sont pas compatibles, on émet l'alarme suivante :
   """
    Vous avez demandé le calcul d'un champ aux noeuds sur des éléments
    de structure. Mais les repères locaux de certaines mailles entourant
    des noeuds sur lesquels vous avez demandés le calcul ne sont pas
    compatibles (Au maximum, on a 270 degrés d'écart entre les angles
    nautiques définissant ces repères).
   
    Risque & Conseil :
    . Il se peut que vous obteniez des résultats incohérents.
    . Il est donc recommandé de passer en repère global les champs
    . utiles au calcul du champ aux noeuds.
   """
   
   L'émission de cette alarme est testée sur le calcul de EFGE_NOEU sur des poutres, des
   coques et des coques3D.
   
   
   Validation :
   ------------
   J'ajoute 2 cas tests (zzzz297 a et b en poutres et en coques) pour valider l'émission de
   l'alarme et je modifie hpla100c pour qu'il calcul EFGE_NOEU. L'EDA me dira s'il est
   intéressant ou non que j'ajoute ces cas tests.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    unitaire
NB_JOURS_TRAV  : 5.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 017674 DU 2011-10-07 08:53:14
TYPE express concernant Code_Aster (VERSION 9.1)
TITRE
    Option DEGE_ELGA
FONCTIONNALITE
   Problème :
   ----------
   L'option DEGE_ELGA a été ajouté en 11.0.20 dans CALC_ELEM et CALC_CHAMP dans le bloc
   linéaire mais pas dans le bloc non linéaire.
   
   
   Solution :
   ----------
   On l'ajoute dans le bloc non linéaire de CALC_CHAMP.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    aucune
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR flejou       FLEJOU Jean Luc        DATE 10/11/2011 - 10:30:25

--------------------------------------------------------------------------------
RESTITUTION FICHE 017489 DU 2011-09-06 12:58:37
TYPE evolution concernant Code_Aster (VERSION )
TMA : Necs
TITRE
    AR01 Option pour les xc3xa9lxc3xa9ments qui utilisent le champ STRX_ELGA
FONCTIONNALITE
   Cette fiche a pour but de : 
   - créer l'option STRX_ELGA 
   - modifier le CALL DISMOI(EXI_PMF) en CALL DISMOI(EXI_STRX)
   - réparer les cas tests ssll111a et sdll130b
   
   Lors des développements liés à la fiche 15644, le champ STRX_ELGA a été créé. Ce nouveau
   champ est nécessaire pour calculer l'option FORC_NODA et donc REAC_NODA pour les éléments
   POU_D_EM et POU_D_TGM (mais cela sera étendu à d'autres éléments de structures). Avec les
   commandes STAT_NON_LINE et DYNA_NON_LINE ce champ est créé automatiquement, cependant pour
   les opérateurs linéaires il ne l'est pas, ce qui empêche le calcul des options FORC_NODA
   et REAC_NODA.
   
   C'est pour cette raison que les 2 cas tests sont cassés.
   
   Pour qu'ils fonctionnent à nouveau, on a ajouté le calcul du champ STRX_ELGA en utilisant
   l'option STRX_ELGA à la fin des opérateurs MECA_STATIQUE et DYNA_LINE_TRAN.
   
   Le problème se posera avec d'autres opérateurs (au moins MODE_ITER_SIMULT), mais la fiche
   17665 va résoudre cela en rendant automatique le calcul du champ STRX_ELGA (quand il est
   nécessaire) par CALC_CHAMP.
   
   DÉVELOPPEMENTS :
   ================
   
   FORTRAN :
   mecalc.f : prise en compte de l'option STRX_ELGA
   op0046.f : ajout de mecalc pour calculer l'option STRX_ELGA
   te0537.f : ajout l'option STRX_ELGA pour les POU_D_EM
   calcop.f : le message l'alarme CALCULEL2_89 n'est émis que si on n'a pas pu calculer
   l'option demandée. Et non pour les options dont elle a besoin.
   nmetcr.f, ccfnrn.f,op0106.f,dismlg.f et dismmo.f : EXI_PMF -> EXI_STRX
   
   CATALOGUE:
   gener_mepmf1.cata : ajout de l'option STRX_ELGA
   strx_elga.cata : création du fichier cata
   
   PYTHON :
   dynamique.py : ajout d'un message d'erreur DYNAMIQUE_19 équivalent à MECASTATIQUE_25
   
   
   VALIDATION:
   ===========
   Ces développements sont validés par les cas tests ssll111a et sdll130b.
   
   Il n'y a pas d'impact documentaire.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    Cas tests ssll111a , sdll130b
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR tardieu      TARDIEU Nicolas        DATE 10/10/2011 - 01:50:07

--------------------------------------------------------------------------------
RESTITUTION FICHE 017127 DU 2011-06-14 20:56:22
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Couverture de code: POST_ELEM/NORME/RESULTAT
FONCTIONNALITE
   Depuis l'émission de la fiche, le test zzzz291a utilise POST_ELEM/NORME/RESULTAT.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    zzzz291a
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 017576 DU 2011-09-22 14:27:27
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW11.0.23, le cas-test gcpc002c s'arrxc3xaate en NOOK_TEST_RESU sur Calibre 7.
FONCTIONNALITE
   Problème :
   ----------
   En NEW11.0.23, le cas-test gcpc002c s'arrête en NOOK_TEST_RESU sur Calibre 7.
   
   Solution :
   ----------
   Il s'agit d'un NOOK sur le nombre d'itérations du GCPC, les solutions restant OK.
   J'ai fait passer le test avec Valgrind qui n'a rien détecté.
   J'ai fait passer le test en debug et devient OK.
   Comme les solutions physiques du test restent OK, je propose de modifier la tolérance pour
   ce test.
   
   J'en ai profité pour : 
   - ajouter un JEMARQ/JEDEMA
   - remplacer des opérations sur les vecteurs réalisées par des boucles par des BLAS
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V1.10.104
VALIDATION
    Passage du test sur toutes les plateformes
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR torkhani     TORKHANI Mohamed       DATE 10/11/2011 - 01:39:39

--------------------------------------------------------------------------------
RESTITUTION FICHE 017505 DU 2011-09-08 13:30:59
TYPE evolution concernant Code_Aster (VERSION 9.1)
TITRE
    [FORUM] Sens de rotation des machines tournantes dans Code_Aster
FONCTIONNALITE
   CONTEXTE
      Modification de la convention sur le sens de rotation des machines tournantes dans code_Aster.
   FONCTIONNALITE
      Le sens de rotation positif est une convention de signe. 
      Actuellement, les calculs de machines tournantes dans Aster sont faits avec des rotors qui tournent 
      postivement dans le sens horaire (anti-trigo). Les cas-tests sont justes mais les résultats doivent 
      être interpretés en cohérence avec le sens de rotation imposé par la version actuelle du code. 
      Il s'agit d'une convention de rotation qui n'est pas judicieuse pour au moins 2 raisons :
      - la convention "communément" utilisée pour les machines tournantes (cadyro, Lalanne et Ferraris) consiste 
        à faire tourner les rotors dans le sens trigo.
      - le sens positif de rotation dans Code_Aster est le sens trigonométrique.
      Cette convention n'a aucune incidence sur les calculs modaux. Cependant, les calculs harmoniques, 
      transitoires et de sens de precession (pour le diagramme de Campbell par exemple) sont impactés. 
      On decide de définir le sens positif suivant l'axe du rotor comme etant le sens usuel de rotation (sens 
      trigo). Desormais, l'axe de rotation est forcement positif suivant l'axe du rotor si, bien entendu, les
      vitesses de rotation sont positives. 
      On apporte, en conséquence, les modifications suivantes :
      - te0009.f (nouvelle convention de rotation);
      - ptgy01.f (nouvelle convention de rotation);
      - impr_diag_campbell_utils.py (défintion du sens de precession selon la nouvelle convention).
      
      Aussi, on met au carré les cas-tests et on vérifie que toutes les documentations (R,U,V) ayant trait à la 
      gyroscopie sont cohérentes entre elles. 
      Pour la compéltude de l'action, on propose aussi de rajouter une version c au cas-test SDLL125 (axe de 
      rotation selon Y). 
      
   IMPACT_DOCUMENTAIRE : 
      DOC R5.05.07, DOC V2.02.124, DOC V2.02.125, DOC V2.02.126, DOC V2.02.129, DOC V2.06.102, DOC V2.06.103,  
      DOC U4.61.01, DOC U2.06.31.
   
   VALIDATION
      SDLL124, SDLL125, SDLL126, SDLL129, SHLL102, SHLL103
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : R5.05.07, V2.02.124, V2.02.125, V2.02.126, V2.02.129, V2.06.102, V2.06.103, U4.61.01, U2.06.31.
VALIDATION
    SDLL124, SDLL125, SDLL126, , SDLL129, SHLL102, SHLL103
NB_JOURS_TRAV  : 5.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR tran         TRAN Van-xuan          DATE 10/10/2011 - 02:37:12

--------------------------------------------------------------------------------
RESTITUTION FICHE 017625 DU 2011-09-29 11:30:18
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW11.0.24, les cas-tests sslv135a,b,g,i,j,n et p sxe2x80x99arrxc3xaatent anormalement sur ROCKS.
FONCTIONNALITE
   Problème:
   ========
   En NEW11.0.24, les cas-tests sslv135a,b,g,i,j,n et p s’arrêtent anormalement 
   sur ROCKS.
   
   Solution:
   =========
   Dans acancy (analyser le critere) et acgrdo (calculer les granduers) pour le 
   type de chargement periodique, on a affecté ESPAC(NBORDR+1) tandis que ESPAC 
   a été déclaré comme un array de taille ESPAC(NBORDR). 
   -->Elargir la taille d'array déclaré.
   
   Un GRAND merci à Thomas et Jean-Michel !!!
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    castests concernxc3xa9s
NB_JOURS_TRAV  : 3.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 017460 DU 2011-09-01 12:22:15
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    POST_FATIGUE : bug si chargement constant
FONCTIONNALITE
   Problème:
   =========
   En général, si le chargement est constant, il n'est pas logique de faire lo comptage du cycle. Pour cette 
   raison, on a décidé de s'arreter. Dans le cas de fatigue thermique, si on ne prendre pas en compte du 
   contact, on a mis K = G = 0. Le code donc s'arrete.
   
   Solution:
   =========
   Il semblerait plutôt logique que le considère comme un seul cycle, avec VALE_MIN = VALE_MAX = cste, i.e., 
   l'amplitude est nul.
   
   On a modifié fgrain pour le comptage "RAINFLOW", fgcota pour le comptage "NATUREL" et fgrccm pour le 
   comptage "RCCM".
   
   Validation:
   ===========
   Ajout d'un nouveau cas-test: szlz108b
   
   Impact document:
   ================
   R7.04.01, U4.83.01, V9.01.108
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : R7.04.01, U4.83.01, V9.01.108
VALIDATION
    szlz108b
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST AJOUT forma04a                       desoza T.DESOZA           178    178      0
 CASTEST AJOUT forma04b                       desoza T.DESOZA           182    182      0
 CASTEST AJOUT forma04c                       desoza T.DESOZA           181    181      0
 CASTEST AJOUT forma05a                      geniaut S.GENIAUT          172    172      0
 CASTEST AJOUT forma06a                      geniaut S.GENIAUT          192    192      0
 CASTEST AJOUT forma07a                      geniaut S.GENIAUT          218    218      0
 CASTEST AJOUT sdll125c                     torkhani M.TORKHANI         251    251      0
 CASTEST AJOUT ssna102g                       desoza T.DESOZA           251    251      0
 CASTEST AJOUT ssnd110c                        proix J-M.PROIX          277    277      0
 CASTEST AJOUT szlz108b                         tran V-X.TRAN           168    168      0
 CASTEST AJOUT wtnl100g                      meunier S.MEUNIER          412    412      0
 CASTEST AJOUT wtnp116c                      meunier S.MEUNIER          241    241      0
 CASTEST AJOUT wtnp129a                      meunier S.MEUNIER          425    425      0
 CASTEST AJOUT wtnp129b                      meunier S.MEUNIER          787    787      0
 CASTEST AJOUT zzzz299a                     sellenet N.SELLENET          89     89      0
 CASTEST AJOUT zzzz299b                     sellenet N.SELLENET          82     82      0
 CASTEST MODIF forma03c                      geniaut S.GENIAUT          157      5      9
 CASTEST MODIF gcpc002c                      tardieu N.TARDIEU          706      3      2
 CASTEST MODIF hpla100c                     sellenet N.SELLENET         638      5      2
 CASTEST MODIF sdld02a                       boiteau O.BOITEAU          392     40      3
 CASTEST MODIF sdll01a                        pellet J.PELLET           205      2      2
 CASTEST MODIF sdll01b                        pellet J.PELLET           175      3      3
 CASTEST MODIF sdll108b                       pellet J.PELLET           450      2      2
 CASTEST MODIF sdll116a                       pellet J.PELLET          4990      2      2
 CASTEST MODIF sdll123a                      boiteau O.BOITEAU          393     66      2
 CASTEST MODIF sdll125a                     torkhani M.TORKHANI         275     11     10
 CASTEST MODIF sdll125b                     torkhani M.TORKHANI         275     11     10
 CASTEST MODIF sdll126a                     torkhani M.TORKHANI         196      6      6
 CASTEST MODIF sdll126b                     torkhani M.TORKHANI         212     14      4
 CASTEST MODIF sdll126c                     torkhani M.TORKHANI         194      3      3
 CASTEST MODIF sdll126d                     torkhani M.TORKHANI         221      6      6
 CASTEST MODIF sdll129a                     torkhani M.TORKHANI         764     49     49
 CASTEST MODIF sdlv111a                       pellet J.PELLET           311      6      6
 CASTEST MODIF sdlv111b                       pellet J.PELLET           201      4      4
 CASTEST MODIF sdnl105c                       pellet J.PELLET           623      4      4
 CASTEST MODIF sdnl136a                        bodel C.BODEL            656      2      1
 CASTEST MODIF shll102a                     torkhani M.TORKHANI         421      3      3
 CASTEST MODIF shll103a                     torkhani M.TORKHANI        1474    238    234
 CASTEST MODIF ssll100a                       pellet J.PELLET           388      2      2
 CASTEST MODIF ssls126a                       pellet J.PELLET           335     25      1
 CASTEST MODIF ssnd101a                     sellenet N.SELLENET         540     18      2
 CASTEST MODIF ssnp15a                         proix J-M.PROIX          896      2      2
 CASTEST MODIF ssnv128a                       desoza T.DESOZA           509      3      3
 CASTEST MODIF ssnv172a                        proix J-M.PROIX         1300    307     16
 CASTEST MODIF ssnv194a                        proix J-M.PROIX          324      2      2
 CASTEST MODIF ssnv194c                        proix J-M.PROIX          233     43      3
 CASTEST MODIF ssnv505h                       desoza T.DESOZA           472      3      3
CATALOGU AJOUT options/char_meca_ptot_r      meunier S.MEUNIER           41     41      0
CATALOGU AJOUT options/efge_excent            pellet J.PELLET            47     47      0
CATALOGU AJOUT options/strx_elga            sellenet N.SELLENET          50     50      0
CATALOGU AJOUT options/veri_cara_elem         pellet J.PELLET            31     31      0
CATALOGU MODIF compelem/grandeur_simple__    meunier S.MEUNIER         2168     19      3
CATALOGU MODIF typelem/gener_me2dg_1         meunier S.MEUNIER          312      3      3
CATALOGU MODIF typelem/gener_me2dg_2         meunier S.MEUNIER          331      3      3
CATALOGU MODIF typelem/gener_me2dsi_2        meunier S.MEUNIER          318      9      4
CATALOGU MODIF typelem/gener_me3d_3          meunier S.MEUNIER          645      4      4
CATALOGU MODIF typelem/gener_me3dg_3         meunier S.MEUNIER          330      1      1
CATALOGU MODIF typelem/gener_meax_2          meunier S.MEUNIER          557      4      4
CATALOGU MODIF typelem/gener_meaxs2          meunier S.MEUNIER          480      3      3
CATALOGU MODIF typelem/gener_mecpl2          meunier S.MEUNIER          588      4      4
CATALOGU MODIF typelem/gener_mecq32           pellet J.PELLET           323      3      1
CATALOGU MODIF typelem/gener_medha2          meunier S.MEUNIER          157     11      2
CATALOGU MODIF typelem/gener_medkg1           pellet J.PELLET           266      3      3
CATALOGU MODIF typelem/gener_medkt2           pellet J.PELLET           414      5      3
CATALOGU MODIF typelem/gener_medpl2          meunier S.MEUNIER          598      8      7
CATALOGU MODIF typelem/gener_mepmf1         sellenet N.SELLENET         286      5      1
CATALOGU MODIF typelem/meca_hexs8            meunier S.MEUNIER          521      3      3
CATALOGU MODIF typelem/mecpqs4               meunier S.MEUNIER          473      3      3
CATALOGU MODIF typelem/medpqs4               meunier S.MEUNIER          486      6      3
CATALOGU SUPPR options/efge_elno_excent       pellet J.PELLET            36      0     36
CATALOPY AJOUT commande/chainage_thm         meunier S.MEUNIER           98     98      0
CATALOPY MODIF commande/affe_materiau        meunier S.MEUNIER          193     23      4
CATALOPY MODIF commande/calc_champ          sellenet N.SELLENET         251      3      2
CATALOPY MODIF commande/defi_compor            proix J-M.PROIX          130      7      3
CATALOPY MODIF commande/defi_list_inst       geniaut S.GENIAUT          419     11      3
CATALOPY MODIF commande/defi_materiau          proix J-M.PROIX         3462     21      1
CATALOPY MODIF commande/impr_sturm           boiteau O.BOITEAU           58     24     13
CATALOPY MODIF commande/post_champ            pellet J.PELLET           122      3      3
CATALOPY MODIF commun/c_nom_cham_into        meunier S.MEUNIER          205      3      1
CATALOPY MODIF commun/c_solveur               desoza T.DESOZA           451      9      1
 FORTRAN AJOUT algeline/apchar               boiteau O.BOITEAU          212    212      0
 FORTRAN AJOUT algeline/apm012               boiteau O.BOITEAU          321    321      0
 FORTRAN AJOUT algeline/apm345               boiteau O.BOITEAU          147    147      0
 FORTRAN AJOUT algeline/aptest               boiteau O.BOITEAU          163    163      0
 FORTRAN AJOUT algorith/cfsvfr                desoza T.DESOZA           125    125      0
 FORTRAN AJOUT algorith/crsvl3               boiteau O.BOITEAU          131    131      0
 FORTRAN AJOUT algorith/vrcpto               meunier S.MEUNIER          146    146      0
 FORTRAN AJOUT calculel/cccmcr              sellenet N.SELLENET         189    189      0
 FORTRAN AJOUT calculel/ccvrrl              sellenet N.SELLENET         280    280      0
 FORTRAN AJOUT calculel/mpglcp              sellenet N.SELLENET         110    110      0
 FORTRAN AJOUT elements/c3drep              sellenet N.SELLENET         111    111      0
 FORTRAN AJOUT elements/coqrep              sellenet N.SELLENET          86     86      0
 FORTRAN AJOUT elements/excent                pellet J.PELLET            91     91      0
 FORTRAN AJOUT elements/te0119                pellet J.PELLET            75     75      0
 FORTRAN AJOUT modelisa/op5901                 proix J-M.PROIX          253    253      0
 FORTRAN AJOUT modelisa/op5902                 proix J-M.PROIX          195    195      0
 FORTRAN AJOUT modelisa/op5903                 proix J-M.PROIX          145    145      0
 FORTRAN AJOUT utilitai/sdpart                desoza T.DESOZA           108    108      0
 FORTRAN MODIF algeline/crsvpe                desoza T.DESOZA           147      5      3
 FORTRAN MODIF algeline/gcpc                 tardieu N.TARDIEU          267     16     23
 FORTRAN MODIF algeline/mlfmlt               boiteau O.BOITEAU           70      2      3
 FORTRAN MODIF algeline/mlfmul               boiteau O.BOITEAU           70      2      3
 FORTRAN MODIF algeline/mltasa               boiteau O.BOITEAU          177     22     12
 FORTRAN MODIF algeline/mltblc               boiteau O.BOITEAU           88     16      3
 FORTRAN MODIF algeline/mltdrb               boiteau O.BOITEAU          219      5      4
 FORTRAN MODIF algeline/mltpre               boiteau O.BOITEAU          532     15      6
 FORTRAN MODIF algeline/mulfr8               boiteau O.BOITEAU          361     11      2
 FORTRAN MODIF algeline/op0032               boiteau O.BOITEAU          490    321     98
 FORTRAN MODIF algeline/op0044               boiteau O.BOITEAU          779      8     15
 FORTRAN MODIF algeline/op0045               boiteau O.BOITEAU         1222      2      7
 FORTRAN MODIF algeline/preml1               boiteau O.BOITEAU          426     59     10
 FORTRAN MODIF algeline/tldlg3               boiteau O.BOITEAU          492      1      2
 FORTRAN MODIF algeline/vpecst               boiteau O.BOITEAU          136     73     43
 FORTRAN MODIF algeline/vpfopr               boiteau O.BOITEAU          354      4      3
 FORTRAN MODIF algorith/ajlipa                desoza T.DESOZA           338      6      6
 FORTRAN MODIF algorith/calcco               meunier S.MEUNIER          164     20     11
 FORTRAN MODIF algorith/calcms                 proix J-M.PROIX           85      3      3
 FORTRAN MODIF algorith/calcva               meunier S.MEUNIER          137     27      4
 FORTRAN MODIF algorith/cfcrsd                desoza T.DESOZA           331     20      6
 FORTRAN MODIF algorith/cfdeco                desoza T.DESOZA            63     16      4
 FORTRAN MODIF algorith/cfinal                desoza T.DESOZA           233     42     16
 FORTRAN MODIF algorith/cfinig                desoza T.DESOZA            65      4     52
 FORTRAN MODIF algorith/cfinit                desoza T.DESOZA           203      7      4
 FORTRAN MODIF algorith/cfinnl                desoza T.DESOZA           108      5      6
 FORTRAN MODIF algorith/cfjein                desoza T.DESOZA           234      5      1
 FORTRAN MODIF algorith/cfliin                desoza T.DESOZA           112      6      6
 FORTRAN MODIF algorith/cfmxpo                desoza T.DESOZA           108      2      2
 FORTRAN MODIF algorith/cfprep                desoza T.DESOZA           204      2      2
 FORTRAN MODIF algorith/coeihm               meunier S.MEUNIER          386      6      5
 FORTRAN MODIF algorith/comthm               meunier S.MEUNIER          291      5      3
 FORTRAN MODIF algorith/dfllty               geniaut S.GENIAUT          195     13      5
 FORTRAN MODIF algorith/gerpas                 proix J-M.PROIX          231      7      6
 FORTRAN MODIF algorith/hmgazp               meunier S.MEUNIER          282      5      3
 FORTRAN MODIF algorith/hmladg               meunier S.MEUNIER          371      5      3
 FORTRAN MODIF algorith/hmlgat               meunier S.MEUNIER          291      5      3
 FORTRAN MODIF algorith/hmliga               meunier S.MEUNIER          353      5      3
 FORTRAN MODIF algorith/hmlisa               meunier S.MEUNIER          297      9      7
 FORTRAN MODIF algorith/hmliva               meunier S.MEUNIER          389      5      3
 FORTRAN MODIF algorith/hmlvag               meunier S.MEUNIER          377      5      3
 FORTRAN MODIF algorith/hmlvga               meunier S.MEUNIER          401      5      3
 FORTRAN MODIF algorith/inithm               meunier S.MEUNIER           69      4      3
 FORTRAN MODIF algorith/kitdec               meunier S.MEUNIER           74      8      5
 FORTRAN MODIF algorith/lc0000               meunier S.MEUNIER          717     20      2
 FORTRAN MODIF algorith/lc0050               meunier S.MEUNIER          333      8      8
 FORTRAN MODIF algorith/lccnvx                 proix J-M.PROIX           78      2      2
 FORTRAN MODIF algorith/lcdpec                 proix J-M.PROIX          208      6      6
 FORTRAN MODIF algorith/lcdpeq                 proix J-M.PROIX          102      6      6
 FORTRAN MODIF algorith/lcjacb                 proix J-M.PROIX           91      2      2
 FORTRAN MODIF algorith/lcjplc                 proix J-M.PROIX           62      2      2
 FORTRAN MODIF algorith/lcmaei                 proix J-M.PROIX          191     48     17
 FORTRAN MODIF algorith/lcmafl                 proix J-M.PROIX          166     26     14
 FORTRAN MODIF algorith/lcmate                 proix J-M.PROIX          131      9      9
 FORTRAN MODIF algorith/lcmhdd                 proix J-M.PROIX          211      4      4
 FORTRAN MODIF algorith/lcmhsr                 proix J-M.PROIX          203      5      5
 FORTRAN MODIF algorith/lcmmap                 proix J-M.PROIX          516     56     28
 FORTRAN MODIF algorith/lcmmat                 proix J-M.PROIX          385     23     12
 FORTRAN MODIF algorith/lcmmdd                 proix J-M.PROIX           97      7      7
 FORTRAN MODIF algorith/lcmmdh                 proix J-M.PROIX          155     53     14
 FORTRAN MODIF algorith/lcmmfe                 proix J-M.PROIX          140      9      9
 FORTRAN MODIF algorith/lcmmfi                 proix J-M.PROIX          145     25     14
 FORTRAN MODIF algorith/lcmmj1                 proix J-M.PROIX          135     10      9
 FORTRAN MODIF algorith/lcmmj2                 proix J-M.PROIX           94      7      6
 FORTRAN MODIF algorith/lcmmja                 proix J-M.PROIX          214     10     10
 FORTRAN MODIF algorith/lcmmjb                 proix J-M.PROIX           90     13     10
 FORTRAN MODIF algorith/lcmmjd                 proix J-M.PROIX          170     13     13
 FORTRAN MODIF algorith/lcmmjf                 proix J-M.PROIX          233      8      9
 FORTRAN MODIF algorith/lcmmjg                 proix J-M.PROIX           88      8      8
 FORTRAN MODIF algorith/lcmmji                 proix J-M.PROIX           72      6      8
 FORTRAN MODIF algorith/lcmmjp                 proix J-M.PROIX          138      2      2
 FORTRAN MODIF algorith/lcmmjs                 proix J-M.PROIX           41      9      8
 FORTRAN MODIF algorith/lcmmjv                 proix J-M.PROIX          111     12     20
 FORTRAN MODIF algorith/lcmmkr                 proix J-M.PROIX          144      5      6
 FORTRAN MODIF algorith/lcmmlc                 proix J-M.PROIX          110      9      9
 FORTRAN MODIF algorith/lcmmon                 proix J-M.PROIX          171     12     10
 FORTRAN MODIF algorith/lcmmop                 proix J-M.PROIX          334     21     28
 FORTRAN MODIF algorith/lcmmre                 proix J-M.PROIX          161      7      7
 FORTRAN MODIF algorith/lcmmsg                 proix J-M.PROIX          709      2      2
 FORTRAN MODIF algorith/lcmmvx                 proix J-M.PROIX          123      6      5
 FORTRAN MODIF algorith/lcplas                 proix J-M.PROIX          129      2      2
 FORTRAN MODIF algorith/lcplnf                 proix J-M.PROIX           79      2      2
 FORTRAN MODIF algorith/lcplnl                 proix J-M.PROIX          290      2      2
 FORTRAN MODIF algorith/lcreli                 proix J-M.PROIX          209      2      2
 FORTRAN MODIF algorith/lcresi                 proix J-M.PROIX           77      2      2
 FORTRAN MODIF algorith/meacmv               meunier S.MEUNIER          499     14      4
 FORTRAN MODIF algorith/memokg               macocco K.MACOCCO          248      2      2
 FORTRAN MODIF algorith/mestat               meunier S.MEUNIER          276      3      2
 FORTRAN MODIF algorith/nmadat               geniaut S.GENIAUT          264     14      5
 FORTRAN MODIF algorith/nmcofr                desoza T.DESOZA           149      8      1
 FORTRAN MODIF algorith/nmctcg                desoza T.DESOZA           113      3      5
 FORTRAN MODIF algorith/nmelnl               meunier S.MEUNIER          497     37     33
 FORTRAN MODIF algorith/nmetcr              sellenet N.SELLENET         284      5      5
 FORTRAN MODIF algorith/nmevdg                 proix J-M.PROIX          125     16      4
 FORTRAN MODIF algorith/nmible                desoza T.DESOZA           203      2      2
 FORTRAN MODIF algorith/nmvccc               meunier S.MEUNIER          157     18      4
 FORTRAN MODIF algorith/nmvcpr               meunier S.MEUNIER          205      6      4
 FORTRAN MODIF algorith/nmveei                 proix J-M.PROIX          424     11     15
 FORTRAN MODIF algorith/nmvprk                 proix J-M.PROIX          314     34     64
 FORTRAN MODIF algorith/op0033                 proix J-M.PROIX          383      6     10
 FORTRAN MODIF algorith/op0046              sellenet N.SELLENET         277     34     15
 FORTRAN MODIF algorith/op0048              sellenet N.SELLENET         320     83      9
 FORTRAN MODIF algorith/plasti                 proix J-M.PROIX          462     10      6
 FORTRAN MODIF algorith/pmsta1                 proix J-M.PROIX          157    108     12
 FORTRAN MODIF algorith/rdif01                 proix J-M.PROIX          112     14      8
 FORTRAN MODIF algorith/rk21co                 proix J-M.PROIX          111      7      7
 FORTRAN MODIF calculel/calcop              sellenet N.SELLENET         254     22     12
 FORTRAN MODIF calculel/calcul                pellet J.PELLET           562      2      1
 FORTRAN MODIF calculel/ccaccl              sellenet N.SELLENET         240      7      3
 FORTRAN MODIF calculel/ccbcop              sellenet N.SELLENET         229      4      2
 FORTRAN MODIF calculel/ccchno              sellenet N.SELLENET         144     43      8
 FORTRAN MODIF calculel/ccfnrn              sellenet N.SELLENET         500     31     30
 FORTRAN MODIF calculel/ccpara              sellenet N.SELLENET         120      7      9
 FORTRAN MODIF calculel/mecagl               macocco K.MACOCCO          490      2      2
 FORTRAN MODIF calculel/mecalc              sellenet N.SELLENET         531      8      3
 FORTRAN MODIF calculel/meceuc              sellenet N.SELLENET         295      8      1
 FORTRAN MODIF calculel/meficg               macocco K.MACOCCO          488      2      2
 FORTRAN MODIF calculel/op0054               macocco K.MACOCCO          271      2      2
 FORTRAN MODIF calculel/op0055               macocco K.MACOCCO          209      2      2
 FORTRAN MODIF calculel/op0100               macocco K.MACOCCO          993      3      3
 FORTRAN MODIF calculel/w155ce                pellet J.PELLET           164     39      8
 FORTRAN MODIF debug/lcjacp                    proix J-M.PROIX          184      2      2
 FORTRAN MODIF elements/cosiro              sellenet N.SELLENET         145      7      5
 FORTRAN MODIF elements/dxefnt                pellet J.PELLET           168      9      2
 FORTRAN MODIF elements/epstmc               meunier S.MEUNIER          316     50      7
 FORTRAN MODIF elements/epthmc               meunier S.MEUNIER          125      9      5
 FORTRAN MODIF elements/fonlev               macocco K.MACOCCO          332     20     20
 FORTRAN MODIF elements/fonmai               macocco K.MACOCCO          204      7      7
 FORTRAN MODIF elements/fonno6               macocco K.MACOCCO          290      5      5
 FORTRAN MODIF elements/fonnoe               macocco K.MACOCCO          223      7      7
 FORTRAN MODIF elements/fonnof               macocco K.MACOCCO          483      9      9
 FORTRAN MODIF elements/fonnor               macocco K.MACOCCO          264      7      7
 FORTRAN MODIF elements/gcour2               macocco K.MACOCCO          638      4      4
 FORTRAN MODIF elements/gcouro               macocco K.MACOCCO          424      4      4
 FORTRAN MODIF elements/gdirec               macocco K.MACOCCO          342      2      2
 FORTRAN MODIF elements/gver2d               macocco K.MACOCCO          221      2      2
 FORTRAN MODIF elements/ptgy01              torkhani M.TORKHANI         173     17     17
 FORTRAN MODIF elements/te0009              torkhani M.TORKHANI         112      2      2
 FORTRAN MODIF elements/te0443              sellenet N.SELLENET         210      5      3
 FORTRAN MODIF elements/te0451                pellet J.PELLET           222     18      6
 FORTRAN MODIF elements/te0452                pellet J.PELLET            92     25     40
 FORTRAN MODIF elements/te0529               meunier S.MEUNIER          192     11      5
 FORTRAN MODIF elements/te0530               meunier S.MEUNIER           84      7      5
 FORTRAN MODIF elements/te0537              sellenet N.SELLENET         255    108     20
 FORTRAN MODIF elements/vdrep2              sellenet N.SELLENET         174      9     36
 FORTRAN MODIF elements/vdxrep              sellenet N.SELLENET          79      3      7
 FORTRAN MODIF modelisa/aceaba                pellet J.PELLET           307     14      8
 FORTRAN MODIF modelisa/aceapo                pellet J.PELLET           399     15     10
 FORTRAN MODIF modelisa/lrmmno              sellenet N.SELLENET         221      4      1
 FORTRAN MODIF modelisa/op0019                pellet J.PELLET           492     43     24
 FORTRAN MODIF modelisa/op0059                 proix J-M.PROIX           59     23    457
 FORTRAN MODIF prepost/acancy                   tran V-X.TRAN           204      4      3
 FORTRAN MODIF prepost/acgrdo                   tran V-X.TRAN           731      2      2
 FORTRAN MODIF prepost/carcha                meunier S.MEUNIER          195      8      1
 FORTRAN MODIF prepost/fgcota                   tran V-X.TRAN           102     24      2
 FORTRAN MODIF prepost/fgrain                   tran V-X.TRAN           139     24      2
 FORTRAN MODIF prepost/fgrccm                   tran V-X.TRAN           105     25      2
 FORTRAN MODIF prepost/op0106               sellenet N.SELLENET         814      2      2
 FORTRAN MODIF utilitai/dismlg              sellenet N.SELLENET         400      3      3
 FORTRAN MODIF utilitai/dismmo              sellenet N.SELLENET         250      2      2
 FORTRAN MODIF utilitai/rscrsd               meunier S.MEUNIER          454      5      3
 FORTRAN MODIF utilitai/uttcpl                desoza T.DESOZA           102      6      6
 FORTRAN SUPPR algorith/crsvl2               boiteau O.BOITEAU          138      0    138
FORTRAN90 AJOUT utilitai/mpierr                desoza T.DESOZA            45     45      0
FORTRAN90 MODIF debug/dbgmpi                   desoza T.DESOZA            89     26     52
FORTRAN90 MODIF petsc/apets3                   desoza T.DESOZA           223     11     12
FORTRAN90 MODIF petsc/apetsr                   desoza T.DESOZA           401     16     20
FORTRAN90 MODIF utilitai/fetmpi                desoza T.DESOZA           479     20     25
FORTRAN90 MODIF utilitai/mpicm0                desoza T.DESOZA            71     31      8
FORTRAN90 MODIF utilitai/mpicm1                desoza T.DESOZA           216     62     66
FORTRAN90 MODIF utilitai/mpicm2                desoza T.DESOZA           224     50     56
FORTRAN90 SUPPR utilitai/fetmer                desoza T.DESOZA            54      0     54
FORTRAN90 SUPPR utilitai/mummpi                desoza T.DESOZA           219      0    219
  PYTHON AJOUT Macro/chainage_hydr_meca      meunier S.MEUNIER          235    235      0
  PYTHON AJOUT Macro/chainage_init           meunier S.MEUNIER           45     45      0
  PYTHON AJOUT Macro/chainage_meca_hydr      meunier S.MEUNIER          294    294      0
  PYTHON AJOUT Macro/chainage_thm_ops        meunier S.MEUNIER          141    141      0
  PYTHON AJOUT Messages/chainage             meunier S.MEUNIER           83     83      0
  PYTHON MODIF Macro/impr_diag_campbell_utils   torkhani M.TORKHANI         826     10     13
  PYTHON MODIF Macro/post_gp_ops             macocco K.MACOCCO         1462      4      4
  PYTHON MODIF Macro/post_k1_k2_k3_ops       macocco K.MACOCCO         2102     26     17
  PYTHON MODIF Messages/adaptation           geniaut S.GENIAUT           65      4      2
  PYTHON MODIF Messages/algeline2            boiteau O.BOITEAU          433      8      1
  PYTHON MODIF Messages/algeline3            boiteau O.BOITEAU          477     37     12
  PYTHON MODIF Messages/algeline4            boiteau O.BOITEAU          402     93      3
  PYTHON MODIF Messages/algeline5            boiteau O.BOITEAU          433      1     15
  PYTHON MODIF Messages/appelmpi              desoza T.DESOZA            34      3     16
  PYTHON MODIF Messages/calculel2             pellet J.PELLET           477     21      4
  PYTHON MODIF Messages/compor1                proix J-M.PROIX          372      1      5
  PYTHON MODIF Messages/compor2                proix J-M.PROIX          128     13      9
  PYTHON MODIF Messages/contact3              desoza T.DESOZA           242     25     29
  PYTHON MODIF Messages/dynamique           sellenet N.SELLENET         143      7      1
  PYTHON MODIF Messages/fatigue1                tran V-X.TRAN           409      6      1
  PYTHON MODIF Messages/modelisa              pellet J.PELLET           527     10      1
  PYTHON MODIF Messages/rupture0             macocco K.MACOCCO          580     12      1
  PYTHON MODIF Messages/utilitai            sellenet N.SELLENET         401     14      1
  PYTHON MODIF SD/sd_fond_fiss               macocco K.MACOCCO           38      9      9


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :   45        8104      8104             +8104
 MODIF :  246       86795      4076    2688     +1388
 SUPPR :    4         447               447      -447
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :  295       95346     12180    3135     +9045 
