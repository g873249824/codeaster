

-----------------------------------------------------------------------
--- AUTEUR adbhhvv V.CANO   DATE  le 24/10/2005 a 11:05:58

-------------------------------------------------------------------------------------
CORRECTION AL 2005-276
   NB_JOURS_TRAV  : 1
   INTERET_UTILISATEUR : NON
   TITRE TOLERANCES SOUS LINUX DES TESTS SSNP130A ET B
   FONCTIONNALITE
    Quatre cas tests (SSNP130a à d) ont été restitués avec l'EL 2005-083
    qui introduit dans CALC_ELEM une nouvelle option. Cette option permet d'une part
    de détecter si un noeud est singulier ou non et d'autre part de calculer une carte
    de taille pour une précision sur l'erreur souhaitée.
    Ces cas tests sont des cas tests de non regression et passe en NOOK sous Linux.
    On modifie 3 choses dans cette restitution:
      1) Changement des valeurs de références pour que cela passe sous Linux
      2) On passe les valeurs selon un critère relatif au lieu d'absolu
      3) On ajoute également une carte RESPONSABLE dans les 4 cas tests

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
      Concerne les cas tests : SSNP130A, B, C et D

-------------------------------------------------------------------------------------
CORRECTION AL 2005-401
   NB_JOURS_TRAV  : 0.5
   INTERET_UTILISATEUR : NON
   TITRE :  CALC_META CATALOGUE NON CONFORME A LA DOC ASTER
   FONCTIONNALITE
    Pour introduire l'état métallurgique initial, on utilise sous ETAT_INIT
    soit l'option EVOL_THER en précisant NUME_INIT ou INST_INIT
    soit l'option META_INIT_ELNO
    Le catalogue python n'est pas clair à ce niveau.

   DETAIL
      Changement du catalogue calc_meta.capy
      AVANT
         ETAT_INIT       =FACT(statut='o',
           regles=(UN_PARMI('NUME_INIT', 'INST_INIT', 'META_INIT_ELNO',),),
           EVOL_THER       =SIMP(statut='f',typ=evol_ther ),
           NUME_INIT       =SIMP(statut='f',typ='I' ),
           INST_INIT       =SIMP(statut='f',typ='R'),
             b_inst     =BLOC(condition="(INST_INIT != None)",
               PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-3),
               CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
                             ),
           META_INIT_ELNO       =SIMP(statut='f',typ=carte_var2_r ),),

      MAINTENANT
         ETAT_INIT       =FACT(statut='o',
            regles=(UN_PARMI('EVOL_THER', 'META_INIT_ELNO'),),
            EVOL_THER       =SIMP(statut='f',typ=evol_ther ),
            META_INIT_ELNO  =SIMP(statut='f',typ=carte_var2_r ),
            b_etat     =BLOC(condition="EVOL_THER != None",
               regles=(UN_PARMI('NUME_INIT', 'INST_INIT',),),
               NUME_INIT       =SIMP(statut='f',typ='I'),
               INST_INIT       =SIMP(statut='f',typ='R'),
               b_inst     =BLOC(condition="INST_INIT != None",
                  PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-3),
                  CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") )
               ),),),

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   OUI
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION


-----------------------------------------------------------------------
--- AUTEUR boiteau O.BOITEAU   DATE  le 24/10/2005 a 10:27:20

------------------------------------------------------------------------------
REALISATION EL 2005-174
   NB_JOURS_TRAV  : 3
   INTERET_UTILISATEUR : OUI
   TITRE :  Extension du perimetre d utilisation du solveur FETI
            en sequentiel comme en parallele (part IV)

   FONCTIONNALITE  SOLVEUR='FETI' dans MECA_STATIQUE
   --------------
   Extension au parallelisme en 64-bit de FETI parallele 32-bit.
   En collaboration avec JPL.

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON

   VALIDATION
   -----------
   Sur le cube diverses combinaisons en  variant nbre de sous-domaines
   et nbre de proc sur la CLPASTER et la CLAYASTR.

   Exemple du cube decoupe en 10 SD (90 000 DDLs) avec RESI_RELA=10-8
   ---------------------------------
                         Encombrement     /  Temps     / Iterations
                           memoire (Mo)      CPU(s)
     CLPASTER (machine dediee et un proc par noeud)
     FETI_10 SD NB_PROC=1             400 /     73       65
     FETI_10 SD NB_PROC=2             400 /     40       65
     FETI_10 SD NB_PROC=5             400 /     20       65

     CLAYASTR (temps a titre indicatif car machine occupee par d'autres
     jobs et sur parallelisme sur un seul noeud)
     FETI_10 SD NB_PROC=1             400 /     87       76
     FETI_10 SD NB_PROC=2             400 /     50       76
     FETI_10 SD NB_PROC=5             400 /     23       76

     Le nombre d iterations est different entre les deux machines car
     le decoupage METIS l est.

   DETAILS
   --------
   Passage en I4 des arguments de controle des routines MPI et tests
   des longueurs des entiers pour determiner la longueur des entiers
   a transferer dans les routines MPI: MPI_INTEGER ou MPI_INTEGER8
   Ajout de la carte TOLE CRP_4 dans FETGGT.
   routines modifiees <M>, nouvelles <N>
   <M> fetggt.f, fetam.f.


-----------------------------------------------------------------------
--- AUTEUR cibhhlv L.VIVAN   DATE  le 24/10/2005 a 19:24:10

--------------------------------------------------------------------------
REALISATION EL 2005-239
   NB_JOURS_TRAV  : 0,5
   POUR_LE_COMPTE_DE   : A.ASSIRE
   INTERET_UTILISATEUR : OUI
   TITRE : création d'EVOL_CHAR par formule analytique
   FONCTIONNALITE
     On lit aujourd'hui des evol_char venant d'ailleurs (Saturne-med, ideas ...).
     On pourrait vouloir les définir analytiquement.
     L'objet de la fiche est de restituer les évolutions decrites et de
     mettre au point un cas test avec calcul mécanique (flexion de poutre
     encastrée avec jet de pression mobile par ex).
   DETAIL
     dans accas.capy, ajout
       class cham_elem_pres_f(cham_elem_sdaster):pass
       class cham_no_pres_f(cham_no_sdaster)    :pass
     syntaxe:
     cc = CREA_RESU( TYPE_RESU='EVOL_CHAR',
                     NOM_CHAM='PRES',
                     OPERATION='AFFE',
                     AFFE=_F( CHAM_GD=gg,
                              LIST_INST=CAT,
                              MODELE=MODEL,
                              CHAM_MATER=MATER, ) )

   RESU_FAUX_VERSION_EXPLOITATION    : NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   : NON
   RESTITUTION_VERSION_EXPLOITATION  : NON
   RESTITUTION_VERSION_DEVELOPPEMENT : OUI
   IMPACT_DOCUMENTAIRE : OUI
     DOC_U : U4.44.12  commande CREA_RESU
       EXPL_ : prise en compte d'un EVOL_CHAR
   VALIDATION
     validation dans le cas test SSNA302A
     on a remplacé
        PRES = AFFE_CHAR_MECA_F( MODELE=MODEL,
                                 PRES_REP=_F( GROUP_MA = 'FACE',
                                              PRES = PRES_FO,    )
     par
        gg = CREA_CHAMP( TYPE_CHAM='NOEU_PRES_F',
                         ...
        evol_gg = CREA_RESU( OPERATION='AFFE',
                             TYPE_RESU='EVOL_CHAR',
                             ...
        PRES=AFFE_CHAR_MECA( MODELE=MODEL,
                             EVOL_CHAR=evol_gg, );

--------------------------------------------------------------------------
CORRECTION AL 2005-321
   NB_JOURS_TRAV  : 0.5
   POUR_LE_COMPTE_DE   : N.TARDIEU
   INTERET_UTILISATEUR : OUI
   TITRE :  AFFE_CHAR_MECA et ORIEMA
   FONCTIONNALITE
     L'utilisateur, avec crea_maillage, a dupliqué des mailles et affecté
     dessus d'autres éléments finis, qui partagent tous leurs noeuds avec
     les mailles d'origine. L'utilisateur ne veut charger que l'un des deux
     éléments finis superposés.
     En affectant le PRES_REP sur la maille de bord MA17 (group_MA=' FACE_SUP'),
     le code émet un message Fatal :
     <F> <AFFE_CHAR_MECA> <ORIEMA> LA MAILLE DE PEAU MA17 S'APPUIE SUR PLUS
         D'UNE MAILLE VOLUMIQUE
         MAILLE VOLUMIQUE 1 :  >MA16    <
         MAILLE VOLUMIQUE 2 :  >M9MA16  <
   DETAIL
     On assouplit le traitement :
     Si la maille de peau s'appuie sur plusieurs mailles de volume, le code
     verifie que les noeuds des mailles de volume ont les memes coordonnées.
     (récupération de AR_MIN dans le maillage, test en relatif)
     Si c'est le cas, le code émet un message d'Alarme,
     Sinon le code s'arrete en Fatal.
     Pour l'étude jointe, le code émet maintenant un message d'Alarme:
     <A> <AFFE_CHAR_MECA> <ORIEMA> LA MAILLE DE PEAU MA17 S'APPUIE SUR PLUS
         D'UNE MAILLE VOLUMIQUE
         MAILLE VOLUMIQUE 1 :  >MA16    <
         MAILLE VOLUMIQUE 2 :  >M9MA16  <

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  OUI
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
     passage de l'étude associée

--------------------------------------------------------------------------
CORRECTION AL 2005-134
   NB_JOURS_TRAV  : 2
   POUR_LE_COMPTE_DE   : X.DESROCHES
   INTERET_UTILISATEUR : NON
   TITRE :  objet .DESR des éléments de COQUE
   FONCTIONNALITE
     - Pour les éléments de la famille DKT (JNI079), l'objet .DESR est créé
       sur la base globale, ce qui est anormal.
     - Pour les éléments de la famille COQUE_3D, des valeurs stockées dans
       l'objet .DESR sont transmises d'une option à une autre.
   DETAIL
     - en v7 :
       * pour les éléments de la famille DKT, l'objet .DESR est créé
         sur la base volatile.
       * pour les éléments de la famille COQUE_3D, voir fiche AL2004-440
     - en v8 :
       * pour les éléments de la famille DKT, l'objet .DESR est supprimé
         voir fiche EL 2005-260
       * pour les éléments de la famille COQUE_3D, voir fiche AL2004-440

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  OUI
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION

--------------------------------------------------------------------------
CORRECTION AL 2004-440
   NB_JOURS_TRAV  : 3
   POUR_LE_COMPTE_DE   : X.DESROCHES
   INTERET_UTILISATEUR : NON
   TITRE :  ssls129b en mode debugjeveux
   FONCTIONNALITE
     En mode debugjeveux, ce test ne converge pas.
     Sans mode debugjeveux, ce test converge en 3 itérations.
   DETAIL
     correction liée à la fiche AL 2005-134
     On écrit un coefficient dans le .DESR lors du calcul de l'option RIGI_MECA_TANG
     On lit ce coefficient pour le calcul de l'option RAPH_MECA
     En mode debugjeveux, ce coefficient est égal à 0.
     Sans mode debugjeveux, ce coefficient est égal à la valeur calculée
     pour la dernière maille quelle que soit la maille. Ceci provoque une
     convergence en 3 itérations car ce coefficient dépend de la topologie
     de la maille.
   SOLUTION:
     - dans le catalogue d'élément GENER_MECQ32 on ajoute un mode local
       CCACO3D  = CACO3D   ELEM__         (CRF      )
       CRF : Coefficient de Rotation Fictive
     - dans les catalogues d'options FULL_MECA, RAPH_MECA, RIGI_MECA_TANG
       et RIGI_MECA on ajoute ce champ afin qu'il soit transmis à CALCUL
     - dans merimo, on crée un champ local afin de stocker ce coefficient.
     - dans vdxnlr, si l'option est egale à RAPH_MECA, on lit le coefficient
       dans le champ, sinon pour les autres options on ecrit ce coefficient
       dans le champ.

     Suite à ces corrections, le cas test passe en 1 itération

     On a supprimé les instructions suivantes
     dans caurtg, forngr, pk2cau, vdgnlr, vdpnlr :
       IF (ZR(LZR+1550-1).LE.SQRT(R8PREM())) THEN
          ZR(LZR+1550-1) = UN
       ENDIF

     Dans jni080, on initilise
       ZR(LZR+1550-1) = R8NNEM()

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  OUI
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
     passage des 90 tests validant COQUE_3D


-----------------------------------------------------------------------
--- AUTEUR galenne E.GALENNE   DATE  le 24/10/2005 a 11:24:53

------------------------------------------------------------------------------
CORRECTION AL 2005-390
   NB_JOURS_TRAV  : 0.5
   INTERET_UTILISATEUR : NON
   TITRE :  Mémoire cas test aspic08a
   FONCTIONNALITE
   Le cas test aspic08a s'arrête pour un problème de mémoire. On modifie les paramètres:
      mémoire :  900 Mo --> 1000 Mo
      temps : 5000s --> 1500 s

   RESU_FAUX_VERSION_EXPLOITATION   :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION

------------------------------------------------------------------------------
CORRECTION AL 2005-377
   NB_JOURS_TRAV  : 0.5
   INTERET_UTILISATEUR : NON
   TITRE :  Plantage cas test CALC_G
   FONCTIONNALITE
   Suite à la restititution EL2005-073 (8.1.17) sur la forme bilinéaire de G, plusieurs
   cas test ont planté :
   - sslv134e/f : l'option G_BILINEAIRE n'avait pas été correctement modifiée suite à
     la restit précédente. On corrige mebilg, op0053 et te0095.
   - ssnv185b,c,d,e : problème pour récupérer les propriétés matériaux sur les mailles
     (surfaciques) des lèvres de la fissure. Ces données matériaux sont indispensables pour
     identifier les fonctions singulières en fond de fissure, qui servent à calculer le
     terme de G bilinéaire associé aux chargements surfaciques.
     Il est donc indispensable d'associer des propriétés matériaux aux mailles surfaciques
     des lèvres de la fissure. (Remarque : c'est déjà ce qui est prescrit pour les mailles
     linéiques des lèvres pour des modélisations 2D).
     On modifie en conséquence les fichiers de commande des cas test.

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   VALIDATION
   IMPACT_DOCUMENTAIRE : OUI
      DOC_U : U4.82.04  (CALC_G_LOCAL_T)
         EXPL_ : Propriétés matériaux nécessaires sur les lèvres de la fissure
      DOC_U : U4.82.03  (CALC_G_THETA_T)
         EXPL_ : Propriétés matériaux nécessaires sur les lèvres de la fissure
      DOC_U : U4.43.03  (AFFE_MATERIAU)
         EXPL_ : Signaler qu'il faut affecter des propriétés matériaux aux lèvres de la
         fissure si on veut faire un calcul de K par la méthode théta (option CALC_K_G)
         aussi bien en 2D qu'en 3D.

------------------------------------------------------------------------------
RESTITUTION HORS AREX
   NB_JOURS_TRAV : 0.5
   INTERET_UTILISATEUR : NON
   FONCTIONNALITE
     On modifie légèrement les te associés à CALC_G* pour ne récupérer (call jevech) les
     données matériau, déplacements, forces... que sur les éléments où theta est non nul.
   DETAILS
    liste des TE modifiés :
    * option CALC_K_G :
      te0295 (3D), te0311 (3D-bords), te0297 (3D-xfem), te0299 (2D), te0300 (2D-bords)
    * option CALC_G_BILI
      te0095 (3D), te0298 (3D-bords)
    * option K_G_MODA
      te0461 (3D), te0399 (2D)
    * option CALC_G
      te0027 (3D), te0280 (3D-bords), te0096 (2D), te0282 (2D-bords)

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION


-----------------------------------------------------------------------
--- AUTEUR geniaut S.GENIAUT   DATE  le 24/10/2005 a 10:50:15

----------------------------------------------------------------------
CORRECTION AL 2005-361
   NB_JOURS_TRAV  : 1.0
   INTERET_UTILISATEUR : NON
   TITRE :  problème d'ELREF pour les éléments X-FEM TE10
   FONCTIONNALITE
     suite à la restit de jacques pour pouvoir se passer des elrefe X20, X15 et X10.
     Il y a un problème concernant les TETRA10
     car les autres élements H20 et P15 ont 2 ELREFE alors que le T10 n'a plus que TE4.

ENTETE__ ELEMENT__ MECA_XT_HEXA8       MAILLE__ HEXA20
   ELREFE__  HE8       GAUSS__  RIGI=FPG8   XFEM=XFEM540
   ELREFE__  TE4       GAUSS__  RIGI=FPG15  FPG4=FPG4    FPG5=FPG5

ENTETE__ ELEMENT__ MECA_XT_PENTA6      MAILLE__ PENTA15
   ELREFE__  PE6       GAUSS__  RIGI=FPG6   XFEM=XFEM270
   ELREFE__  TE4       GAUSS__  RIGI=FPG15  FPG4=FPG4    FPG5=FPG5

ENTETE__ ELEMENT__ MECA_XT_TETRA4      MAILLE__ TETRA10
   ELREFE__  TE4       GAUSS__  RIGI=FPG1   XFEM=XFEM90

     Pour le MECA_XT_TETRA4 , Jacques a été obligé de définir la famille TE4/'RIGI'
     comme il faut pour que les champs ELGA soient bien dimensionnés => FPG1.
     En revanche, dans les TE00IJ, j'utilise une famille FPG15 avec le TE4/RIGI
     Donc ca ne devrait plus marcher pareil sur les TETRA10 !

   DETAILS
     on définit une nouvelle famille 'XINT' :
ENTETE__ ELEMENT__ MECA_XT_HEXA8       MAILLE__ HEXA20
   ELREFE__  HE8       GAUSS__  RIGI=FPG8   XFEM=XFEM540
   ELREFE__  TE4       GAUSS__  XINT=FPG15

ENTETE__ ELEMENT__ MECA_XT_PENTA6      MAILLE__ PENTA15
   ELREFE__  PE6       GAUSS__  RIGI=FPG6   XFEM=XFEM270
   ELREFE__  TE4       GAUSS__  XINT=FPG15

ENTETE__ ELEMENT__ MECA_XT_TETRA4      MAILLE__ TETRA10
   ELREFE__  TE4       GAUSS__  RIGI=FPG1   XINT=FPG15

     fortran modifié :     xkel3d.f   xsif3d.f et xxbsig.f
     il suffit de  remplacer le CALL ELREF5('TE4','RIGI',.... par CALL ELREF5('TE4','XINT',...

     catalogues modifiés :     gener_me_xt.cata, gener_me_xh.cata et gener_me_xht.cata

     concernant le cas test ssnv186E : permet de valider un calcul X-FEM avec un
     maillage libre de TETRAs (avec gmsh) dans le cas du contact.
     Ce test valide aussi l'algorithme de choix de l'espace des
     multiplicateurs de lagrange pour les TETRAs pour paser la LBB condition.
     ATTENTION : alarme légitime car la structure est entièrement coupée
    (donc pas de fond de fissure)

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : OUI
     DOC_V : V6.04.186 LBB condition et contact frottant avec X-FEM
       EXPL_ :            ajout de ssnv186e
   VALIDATION
     ssnv186e

------------------------------------------------------------------------------
RESTITUTION HORS AREX
   NB_JOURS_TRAV : 0.5
   INTERET_UTILISATEUR : NON
   FONCTIONNALITE
     Test de non regression rajouté dans ssnv186b.
     Dans ce test, on cherchait à mettre en évidence des oscillations parasites.
     Le test avait une précision relative de 97% par rapport à la valeur analytique
     (puisque la solution analytique ne fait pas apparaitre d'oscillations).

     Je rajoute donc un test de non-regression par rapport à la version 8.1.20 afin de
     vérifier qu'on ne s'éloigne pas trop (0.1%) de la valeur des pressions de contact
     avec oscillations.
   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : OUI
     DOC_V : V6.04.186 LBB condition et contact frottant avec X-FEM
       EXPL_ :     test de non-regression ssnv186b
   VALIDATION
      ssnv186b


-----------------------------------------------------------------------
--- AUTEUR kham M.KHAM   DATE  le 24/10/2005 a 14:22:42

--------------------------------------------------------------------------
REALISATION EL 2005-269
   NB_JOURS_TRAV : 7
   INTERET_UTILISATEUR : OUI
   TITRE :  "Contact entre éléments de poutre par la Methode Continue"
   FONCTIONNALITE
     Le contact entre deux poutres est implémenté pour la méthode continue de contact.
     Il s'agit pour l'instant d'un contact très simplifié: contact plan dans un univers 3D
     entre poutres de section constante, sans torsion et en petites transformations (RELATION='ELAS').
   DETAILS
     On crée d'abord des éléments de contact SEG2 dans un univers 3D sous-tendant le contact
     inter-poutre: modification des catalogues d'éléments.
     Se pose ensuite la question de la définition de la normale de contact, puisqu'en 3D
     celle-ci est calculée à partir des deux vecteurs tangents. Or, le SEG2 n'en offre qu'un.
     On fournit le deuxième dans le fichier de commande via le mot-clé VECT_Y sous
     le mot-clé CONTACT, comme cela existe déjà dans la méthode LAGRANGIENNE.
     Ce vecteur VECT_Y est perpendiculaire au plan de contact,
     et comme il reste constant au cours du calcul, le contact reste nécessairement plan.
     Enfin, comme les SEG2 coicident avec la fibre neutre de la poutre, on définit un jeu
     supplémentaire sur chaque poutre se soustrayant au jeu réel entre fibres neutres.
     Par ce biais, on tient compte de l'épaisseur effective de chaque poutre à l'extremité
     desquels se situe en effet le lieu du contact. Ce jeu supplémentaire est renseigne
     par les mots-clés DIST_MAI et DIST_ESC sous le mot-clé CONTACT, comme pour la
     méthode LAGRANGIENNE.

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : OUI
     DOC_U : U4.53.01
       EXPL_:
     DOC_V : V6.04.505
   VALIDATION
      Cas-test SSNV505: contact entre poutres en grandes rotations.
      Ce cas-test est réalisé abusivement
      en petites transformations (COMP_INCR(RELATION='ELAS')),
      et comparés à la "solution vraie" en grandes rotations.
      - SSNV505F: comparaison des méthodes LAGRANGIENNE et CONTINUE
                  en petites rotations

--------------------------------------------------------------------------
CLASSEMENT SANS SUITE EL 2004-215
   NB_JOURS_TRAV : 0
   INTERET_UTILISATEUR : NON
   TITRE :  "Contact entre éléments de structure par la Methode Continue"
   FONCTIONNALITE
     Le contact méthode continue entre elements de structure.
     Cette EL sera reprise dans des EL plus précises précisant à
     chaque fois le type d'élément créé et les applications visées.
   IMPACT_DOCUMENTAIRE : NON

--------------------------------------------------------------------------
CLASSEMENT SANS SUITE AL 2005-253
   NB_JOURS_TRAV : 0
   INTERET_UTILISATEUR : NON
   TITRE   "Fonctions de forme pour la Methode Continue"
   FONCTIONNALITE
     Les routines CALFFD.F et CALFFX.F donnent les fonctions de forme
     des éléments tardifs de contact. L'ordre de definition des points
     (pour un element quadratique) est G-D-M.
     L'AL a été émise en croyant avoir noté une erreur sur cet ordre
     de definition des noeuds d'après celui de leur traitement dans mmmres.f:
     En effet, dans mmmres.f, on récupère les solutions aux points de gauss
     qui sont définis dans un ordre different G-M-D (voir gauss2.f) pour les afficher aux noeuds.
     La confusion venait de ce qu'on ne s'etait pas aperçu de cette difference d'ordonnancement.
     Aussi pour un element quadratique (SEG3 par ex.), il y avait bien une
     confusion dans l'ordre de traitement lors du passgae des points de gauss aux noeuds.
     On a alors pensé à une erreur de numérotation des noeuds dans les deux susdites routines d'interpolation.
     Cette defaillance n'était pas apparente, tant qu'on se limitait à des éléments linéaires (SEG2) et à un
     shéma d'intégration aux noeuds, car alors l'ordre des noeuds et celui des points de
     gauss se confondent.
     Comme on le voit, cette confusion venait de l'ignorance où l'on était de l'odre respectif de
     definition des points degauss et noeuds, et non d'une erreur proprement dite dans CALFFD.F et CALFFX.F
     Cette ambiguité est désormais levée.
     Classement de l'AL sans suite.
   IMPACT_DOCUMENTAIRE : NON

--------------------------------------------------------------------------
CLASSEMENT SANS SUITE EL 2004-191
   NB_JOURS_TRAV  : 0.0
   INTERET_UTILISATEUR : NON
   TITRE "Resorption des routines de fonctions de forme"
   FONCTIONNALITE
     Les routines CALFFD.F et CALFFX.F donnent les fonctions de forme
     des éléments tardifs de contact. L'AL propose la resorption de ces
     routines par rapport aux routines existantes.
     Les derniers developpements de la methode continue nous inclinent
     au contraire à les conserver, car ils sont amenés à evoluer et
     à s'enrichir (je pense par ex. aux stratégies de traitement des
     incompatibilités de maillage).
     Classement de l'EL sans suite.
   IMPACT_DOCUMENTAIRE : NON


-----------------------------------------------------------------------
--- AUTEUR lebouvie F.LEBOUVIER   DATE  le 19/10/2005 a 08:33:28

-----------------------------------------------------------------------
RESTITUTION HORS AREX
   Cette dernière restitution partielle est effectuée dans le cadre
   de la fiche EL2004-212
   NB_JOURS_TRAV  : 7.5
   POUR_LE_COMPTE_DE : E. GALENNE
   INTERET_UTILISATEUR : OUI
   TITRE : MACR_ASCOUF_MAIL / Extension du domaine Rm/e
   FONCTIONNALITE : MACR_ASCOUF_MAIL
   DETAILS :
   Objectifs
   ---------
   La macro-commande MACR_ASCOUF_MAIL est aujourd'hui largement utilisée par les
   différentes unités d'EDF pour mailler rapidement des tubes/coudes fissurés
   ou présentant une ou plusieurs sous-épaisseurs. La gamme de géométrie autorisée
   est aujourd'hui limitée à des valeurs de Rayon moyen/Epaisseur comprises entre
   5 et 12. Ce qui correspond à la majorité des géométries rencontrées dans le
   CPP et le CSP des REP.
   L'objectif de cette évolution est d'étendre cette gamme jusqu'à une valeur
   de Rm/e de 50 afin de pouvoir utiliser cette macro-commande pour du matériel
   de l'îlot conventionnel.

   Modifications
   -------------
   Les travaux effectués dans le cadre de cette restitution concernent l'extension
   du domaine de validité dans le cas ou le défaut est de type fissure.
   Les principales modifications effectuées dans la procédure ascouf_fiss_v4.datg
   concerne :
   - le raffinement du maillage dans les embouts afin que la qualité (étirement
     et distorsion) des mailles dans ces zones soit satisfaisantes. Le problème
     vient principalement de la longueur des embouts qui doit respecter une
     longueur minimum :
      L > 3/2(Rm**3/e)**0.5 ce qui conduit a des longueurs de :
        * Rm/e=21 => L= 921.mm
        * Rm/e=35 => L=2014.mm
        * Rm/e=47 => L=3114.mm
   - le rafinnement du maillage dans le sens circonférentiel, qui actuellement est
     fixé en dur a 40. On impose pour Rm/e > 12 les valeurs suivantes:
        * Rm/e=21 => 40 éléments
        * Rm/e=35 => 50 éléments
        * Rm/e=47 => 60 éléments
   - Le rafinnement du maillage dans le coude, sens longitudinal de part et d'autre
     de la fissure est modifié, par rapport a celui utilisé pour Rm/e <12 le nouveau
     rafinnement est:
        * Rm/e=21 => doublé
        * Rm/e=35 => doublé
        * Rm/e=47 => triplé

   Remarques:
   ----------
   Ces remarques font suite aux différents tests effectués.
   - Les caractéristiques géométriques de la fissure, combinés aux dimensions
     géométriques du coude (Rm/e=21,35 et 47) nécessite un maillage fin et de plus
     en plus fin lorsque Rm/e augmente.
   - Rm/e =21: le maillage de ce coude a été obtenu sans trop de difficulté.
     53346 Noeuds,18805 Mailles.
   - Rm/e=35 et 47 : le maillage de ces coudes est plus difficile a obtenir voir
     impossible (mémoire GIBI, erreur dans la procédure lorsque l'on essai d'augmenter
     le nombre d'éléments dans le sens circonférentiel problème du au rapport
     taille fissure/taille de maille). Un maillage plus grossier, de qualité
     inférieur a été obtenu. En conséquence, pour les Rm/e > 21, une alarme a été
     mise dans la procédure GIBI pour informer l'utilisateur d'un problème de maillage
     potentiel (maillage impossible à obtenir, qualité du maillage,...)
   - Les modifications apportées n'ont pas d'impact sur les coudes dont le
     rapport Rm/e < 12.

   Validation
   ----------
   Pour mettre au point de la procédure GIBI "ascouf_fiss_v4.datg" trois tests,
   avec des rapports Rm/e = 21,35 et 47, basés sur le cas-test de référence
   suivant ont été créés :

    - ascou19 : Coude avec fissure longue circonférentielle débouchant
                en peau interne

   Les vérifications suivantes ont été effectuées :
    - Maillage: analyse avec IDEAS de la qualité des mailles volumiques
                (Distorsion, étirement, bords libres)
    - Résultat : analyse des déplacements et des contraintes

   Le cas-test restitué est le suivant:
     - ascou23a (basé sur le cas-test ascou19a) Rm/e = 21,

   REMARQUE : ne pas oublier de mettre à jour le datg lors de la restitution

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : OUI
     DOC_U : U4.CF.10
       EXPL_ : Macro commande MACR_ASCOU_MAIL
     DOC_V : V1.01.212
       EXPL_ : Description du cas-test ascou23a
   VALIDATION
       cas-test ascou23a


-----------------------------------------------------------------------
--- AUTEUR mcourtoi M.COURTOIS   DATE  le 24/10/2005 a 17:17:48

---------------------------------------------------------------------------
CORRECTION AL 2005-397
   NB_JOURS_TRAV  : 1
   INTERET_UTILISATEUR : NON
   TITRE :   Risque d'encombrement de la mémoire
   FONCTIONNALITE
      En cas garde inutilement des objets en mémoire dans plusieurs cas :
      1. En cas de levée d'exception car on arrête la commande en cours
         sans être passer par les JEDEMA prévus dans la programmation.
      => le correction consiste à faire des JEDEMA dans UTFINM (juste avant
         de lever l'exception) pour ramener la marque à 1.
         (restitué la semaine dernière)
       2. getvectjev retourne la copie d'un vecteur JEVEUX dans une liste
         Python. Un objet temporaire est créé en cas de recopie d'un répertoire
         de noms (pour en faire un vecteur contigu). Je le détruis depuis
         getvectjev ; et pour simplifier la lecture, je remplace
         CALL_JELIBE(nomsd) par CALL_JEMARQ() et CALL_JEDEMA() autour de
         l'appel à la routine fortran.
         Rem : contrairement à ce que j'ai mis dans la fiche, le vecteur
               à recopier est bien libéré.
      3. Même type de "ménage" autour des routines qui appellent du JEVEUX
         au moins pour le principe de précaution (!) : getcolljev, putvectjev,
         putcolljev, aster_GetResu.
         Je pense que mettre CALL_JEMARQ/CALL_JEDEMA dans les routines C
         qui appellent du fortran devrait être systématique (exception les
         GETxxx et OPSEXE...).

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   OUI
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
      zzzz180a (getvectjev sur '.VALE'), zzzz189a (getvectjev sur '.NOMA')


-----------------------------------------------------------------------
--- AUTEUR rezette C.REZETTE   DATE  le 24/10/2005 a 14:35:09

------------------------------------------------------------------------------
CORRECTION AL 2005-369
   NB_JOURS_TRAV  : 1.5
   POUR_LE_COMPTE_DE : E.GALENNE
   INTERET_UTILISATEUR : NON
   TITRE : sslv134b en mode debugjeveux
   FONCTIONNALITE
   DETAILS :
   1)Anomalie
   ----------
    En version 8.1.15 sur alphaserveur, le test sslv134b, en mode d'execution
    dbgjeveux, plantait avec le message suivant :
    <DEFI_FOND_FISS> <GVERIF> <MELANGE SEG2 ET SEG3 : LES MAILLES DU FOND DE
     FISSURE DOIVENT ETRE DU MEME TYPE>.
    2)Cause
    -------
    L'anomalie était du à la précence d'un pointeur non initialisé (IATYMA) dans la
    routine gverif.f.
    Ce pointeur n'était pas initialisé lorsque le fond de fissure est défini par des
    noeuds ou groupes de noeuds, pourtant il était utilisé.
    Remarque : 3 commandes DEFI_FOND_FISS sont présentes dans le fichier de
    commandes sslv134b.comm. L'anomalie n'apparait pas dans les 2 premières car le
    fond de fissure est défini par des groupes de mailles.
    3) Corrections (dans gverif.f)
    --------------
    - initialisation de la variable IATYMA
    - suppression de deux lignes consécutives inutiles, présentes dans 2 blocs:
      Les lignes:
           NUMB = ZI(ACNCIN+ADRB-1+K-1)
           CALL JENUNO(JEXNUM(OBJ2,NUMB),MAILLE)
           CALL JENONU(JEXNOM(OBJ2,MAILLE),IBID)
           ITYP = IATYMA-1+IBID
      sont remplacées par:
           NUMB = ZI(ACNCIN+ADRB-1+K-1)
           ITYP = IATYMA-1+NUMB
     Remarque: Lorsque le fond de fissure est défini par des noeuds ou groupes de
     noeuds, l'objet OBJ2 fait référence aux noms des noeuds du maillage.
     Or NUMB correspond au numéro d'une maille!
     La modification ci-dessus ne fait plus intervenir OBJ2, sinon on aurait remplacé
     OBJ2 par NOMA//'.NOMMAI'
     3) Validation
     -------------
     Le passage en mode debugjeveux d'une liste de 65 cas-tests (contenant la commande
     DEFI_FOND_FISS) avec la surcharge a revélé deux plantages:
     - SSLV134E: ERREUR_<F>
     - SSLV134F: ERR_NUMERIQUE
     Le passage de ces 2 cas-tests en mode debugjeveux avec la version de référence
     aboutit au même code retour.
     Passage des cas-tests ascou07a et ascou08a comme convenu dans le rex: retour OK.
     Source modifiée  : gverif.f

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION : passage en mode debugjeveux d'une liste de 65 cas-tests contenant
    la commande DEFI_FOND_FISS.


========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

       C MODIF supervis/astermodule         mcourtoi M.COURTOIS        4082     33     34
 CASTEST AJOUT ascou23a                     lebouvie F.LEBOUVIER        272    272      0
 CASTEST AJOUT ssnv186e                      geniaut S.GENIAUT          175    175      0
 CASTEST AJOUT ssnv505f                         kham M.KHAM             279    279      0
 CASTEST MODIF aspic08a                      galenne E.GALENNE          154      2      2
 CASTEST MODIF ssna302a                      cibhhlv L.VIVAN            607     46     28
 CASTEST MODIF ssnp130a                      adbhhvv V.CANO             270     44     43
 CASTEST MODIF ssnp130b                      adbhhvv V.CANO             269     42     41
 CASTEST MODIF ssnp130c                      adbhhvv V.CANO             229     32     31
 CASTEST MODIF ssnp130d                      adbhhvv V.CANO             249     38     37
 CASTEST MODIF ssnv185b                      galenne E.GALENNE          191      3      3
 CASTEST MODIF ssnv185c                      galenne E.GALENNE          205      3      3
 CASTEST MODIF ssnv185d                      galenne E.GALENNE          188      3      3
 CASTEST MODIF ssnv185e                      galenne E.GALENNE          223      3      3
 CASTEST MODIF ssnv186b                      geniaut S.GENIAUT          172     23      2
CATALOGU MODIF compelem/grandeur_simple__    cibhhlv L.VIVAN            576      4      1
CATALOGU MODIF compelem/phenomene_modelisation__       kham M.KHAM             941      2      1
CATALOGU MODIF options/full_meca             cibhhlv L.VIVAN             86      8      7
CATALOGU MODIF options/full_meca_elas        cibhhlv L.VIVAN             80      8      7
CATALOGU MODIF options/raph_meca             cibhhlv L.VIVAN             84      2      1
CATALOGU MODIF options/rigi_meca             cibhhlv L.VIVAN             47      3      3
CATALOGU MODIF options/rigi_meca_elas        cibhhlv L.VIVAN             82      2      1
CATALOGU MODIF options/rigi_meca_tang        cibhhlv L.VIVAN             87      5      4
CATALOGU MODIF typelem/gener_cmcfz1             kham M.KHAM              66      2      2
CATALOGU MODIF typelem/gener_cmcfz2             kham M.KHAM             154      6      2
CATALOGU MODIF typelem/gener_me_xh           geniaut S.GENIAUT          271      4      4
CATALOGU MODIF typelem/gener_me_xht          geniaut S.GENIAUT          263      4      4
CATALOGU MODIF typelem/gener_me_xt           geniaut S.GENIAUT          229      4      4
CATALOGU MODIF typelem/gener_mecq32          cibhhlv L.VIVAN            259      8      7
CATALOGU MODIF typelem/gener_mect32             kham M.KHAM              43      3      1
CATALOPY MODIF commande/affe_char_meca          kham M.KHAM             958      3      3
CATALOPY MODIF commande/calc_meta            adbhhvv V.CANO              50      9      6
CATALOPY MODIF commande/crea_resu            cibhhlv L.VIVAN            139      3      2
CATALOPY MODIF entete/accas                  cibhhlv L.VIVAN           1115      4      1
    DATG MODIF ascouf_fiss_v4.datg        F.LEBOUVIER 12990              162      9      0
 FORTRAN AJOUT modelisa/oriem0               cibhhlv L.VIVAN            102    102      0
 FORTRAN MODIF algorith/crtype               cibhhlv L.VIVAN            388      8      1
 FORTRAN MODIF algorith/fetggt               boiteau O.BOITEAU          351     12      8
 FORTRAN MODIF algorith/frapp2                  kham M.KHAM             717     26     10
 FORTRAN MODIF algorith/lissag                  kham M.KHAM             291     20      3
 FORTRAN MODIF algorith/mappar                  kham M.KHAM             340     13      8
 FORTRAN MODIF algorith/merimo               cibhhlv L.VIVAN            462     55     54
 FORTRAN MODIF algorith/mmmbca                  kham M.KHAM             274     15     15
 FORTRAN MODIF algorith/xcalfe               geniaut S.GENIAUT          157      2      3
 FORTRAN MODIF algorith/xkel3d               geniaut S.GENIAUT          370      4      4
 FORTRAN MODIF algorith/xrell1               geniaut S.GENIAUT          188      5      5
 FORTRAN MODIF algorith/xrell2               geniaut S.GENIAUT          306      3      3
 FORTRAN MODIF calculel/contex               cibhhlv L.VIVAN            197      9      7
 FORTRAN MODIF calculel/jevecd               cibhhlv L.VIVAN             70      2      2
 FORTRAN MODIF calculel/mebilg               galenne E.GALENNE          293    134     21
 FORTRAN MODIF calculel/op0053               galenne E.GALENNE          795     11      5
 FORTRAN MODIF elements/calffj                  kham M.KHAM             363     11      4
 FORTRAN MODIF elements/caurtg               cibhhlv L.VIVAN            176      1      7
 FORTRAN MODIF elements/forngr               cibhhlv L.VIVAN            527      1      7
 FORTRAN MODIF elements/gverif               rezette C.REZETTE          770     10     14
 FORTRAN MODIF elements/jni080               cibhhlv L.VIVAN           1072      2      1
 FORTRAN MODIF elements/pk2cau               cibhhlv L.VIVAN            334      1      5
 FORTRAN MODIF elements/te0027               galenne E.GALENNE          556      1      1
 FORTRAN MODIF elements/te0095               galenne E.GALENNE          327     17     16
 FORTRAN MODIF elements/te0096               galenne E.GALENNE         1200      1      1
 FORTRAN MODIF elements/te0280               galenne E.GALENNE          330     23     22
 FORTRAN MODIF elements/te0282               galenne E.GALENNE          542      1      1
 FORTRAN MODIF elements/te0295               galenne E.GALENNE          553     13     15
 FORTRAN MODIF elements/te0297               galenne E.GALENNE          151     13     14
 FORTRAN MODIF elements/te0298               galenne E.GALENNE          300     20     19
 FORTRAN MODIF elements/te0299               galenne E.GALENNE          339     22     19
 FORTRAN MODIF elements/te0300               galenne E.GALENNE          323     17     20
 FORTRAN MODIF elements/te0311               galenne E.GALENNE          450     26     25
 FORTRAN MODIF elements/te0364                  kham M.KHAM            1111     21     20
 FORTRAN MODIF elements/te0365                  kham M.KHAM             736     25     32
 FORTRAN MODIF elements/te0399               galenne E.GALENNE          285     14     14
 FORTRAN MODIF elements/te0414               cibhhlv L.VIVAN            145     34     37
 FORTRAN MODIF elements/te0461               galenne E.GALENNE          479     14     14
 FORTRAN MODIF elements/utelvf               cibhhlv L.VIVAN             94      3      2
 FORTRAN MODIF elements/vdgnlr               cibhhlv L.VIVAN           1125      3     20
 FORTRAN MODIF elements/vdpnlr               cibhhlv L.VIVAN           1324      3      9
 FORTRAN MODIF elements/vdxnlr               cibhhlv L.VIVAN            489     38     34
 FORTRAN MODIF elements/vdxrig               cibhhlv L.VIVAN            167      6      3
 FORTRAN MODIF elements/xsif3d               geniaut S.GENIAUT          360      5      5
 FORTRAN MODIF elements/xxbsig               geniaut S.GENIAUT          203      3      4
 FORTRAN MODIF from_c/fetam                  boiteau O.BOITEAU          328     50     36
 FORTRAN MODIF modelisa/cazocc                  kham M.KHAM             269     27     18
 FORTRAN MODIF modelisa/mode18                  kham M.KHAM             369      2      2
 FORTRAN MODIF modelisa/oriema               cibhhlv L.VIVAN            401     60     33
 FORTRAN MODIF modelisa/xrelco               geniaut S.GENIAUT          144      1      7


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :    4         828       828              +828
 MODIF :   81       34072      1173     921      +252
 SUPPR :    0           0                 0        +0
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :   85       34900      2001     921     +1080 
