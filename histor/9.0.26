

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR bodel        BODEL Charles          DATE 22/05/2007 - 12:59:17

--------------------------------------------------------------------------------
RESTITUTION FICHE 010868 DU 2007-05-16 11:56:04
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TITRE
   Anomalie Macro OBSERVATION
FONCTIONNALITE
   Problème corrigé : l'importation des commandes se fait désormais sous le "def"
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sdlv125a
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR cano         CANO Valérie           DATE 21/05/2007 - 11:36:13

--------------------------------------------------------------------------------
RESTITUTION FICHE 010002 DU 2006-09-07 11:14:23
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TMA : CS
TITRE
   bug dans la routine nzcizi.f (mxc3xa9tallurgie du zircaloy)
FONCTIONNALITE
   DETAILS
   
      ROUTINE NZISFW.F : Ecrouissage isotrope en HPP pour 
   l'acier
         
         1) modification de la présentation générale pour 
   que les 6 routines sur les
         lois de comportement avec métallurgies soient 
   identiques
            - supprimer l'appel des déclarations JEVEUX
            - calcul de SEUIL changé de place
            - DVIN(5) devient DVIN
            - des noms de variables ont changé
            - changé la manière de calculer la contrainte 
   élastique 
              car très compliquée pour rien
            - ajout de la variable VI(5)         
            - pour ne pas modifier VIM(1) à VIM(5), on fait
              avant VIM(I)=VIM(I)+DVIN(I)-DS
              maitenant VIM(I) reste VIM(I) et VI(I)=VIM(I)
   +DVIN(I)-DS
         
         2) bug sans conséquence         
            - modification de la routine pour que le calcul 
   de la matrice tangente
              RIGI_MECA_TANG soit avec les coefficents pris 
   à l'instant moins  
         
         3) bug avec conséquence
            - dans le cas d'un modèle visqueux, on peut 
   également activer la restauration
              d'écrouissage. Les coefficients C et M ne sont 
   pas obligatoires et dans le cas
              où ils ne sont pas présents dans le fichier de 
   commande, on choisit C=0 et M=20
              ce qui implique que la restauration n'est pas 
   prise en compte.
              Lorsque on appelle la routine RCVALA, le code 
   retour est 'F ' 
              ce qui implique que si ces 2 coefficients sont 
   absents, le fichier s'arrête 
              en erreur fatale ce qui n'a pas lieu d'être.
            - Test sur les variables qui donnent la 
   proportion de phases 
              (renvoi à la modification faite par jean-
   michel Proix fiche)
            - 2 Erreurs dans le calcul de DVIN(5) :
              pas de sommation sur les 4 autres phases
              pour calculer VIM(5), on utilise les 4 VIM(K). 
   Or ceux-ci ont été modifiés
              avant et valent VIM(K)=VIM(K)+DVIN(K) ce qui 
   est faux.
            - dans le cas d'un écrouissage non linéaire, on 
   ne prenait pas en compte le nombre
              de point de la courbe pour la perlite.
            - le calcul de l'écrouissage moyen VIP(7)=(1-
   FMEL)*R(5)+FMEL/ZALPHA*(Z(K)*R(K)) 
              est faux car R(I) n'est pas recalculée pour la 
   variable r(K) 
              de chaque phase correspondant à l'instant plus
   
      ROUTINE NZEDGA.F : Ecrouissage isotrope en HPP pour le 
   Zircaloy
         
         1) modification de la présentation générale pour 
   que les 6 routines sur les
         lois de comportement avec métallurgies soient 
   identiques
            - supprimer l'appel des déclarations JEVEUX
            - calcul de SEUIL changé de place
            - DVIN(3) devient DVIN
            - des noms de variables ont changé
            - changé la manière de calculer la contrainte 
   élastique 
              car très compliquée pour rien
            - ajout de la variable VI(3)         
            - pour ne pas modifier VIM(1) à VIM(3), on fait
              avant VIM(I)=VIM(I)+DVIN(I)-DS
              maitenant VIM(I) reste VIM(I) et VI(I)=VIM(I)
   +DVIN(I)-DS
         
         2) bug sans conséquence         
            - Tableau mal dimensionné
              VALRES(14),NOMRES(14) et CODRET(14) => VALRES
   (12),NOMRES(12),CODRET(12)
              KPT(3) => KPT(2)
              NOMCLE(5) => NOMCLE(3) 
            - modification de la routine pour que le calcul 
   de la matrice tangente
              RIGI_MECA_TANG soit avec les coefficents pris 
   à l'instant moins  
         
         3) bug avec conséquence
            - dans le cas d'un modèle visqueux, on peut 
   également activer la restauration
              d'écrouissage. Les coefficients C et M ne sont 
   pas obligatoires et dans le cas
              où ils ne sont pas présents dans le fichier de 
   commande, on choisit C=0 et M=20
              ce qui implique que la restauration n'est pas 
   prise en compte.
              Lorsque on appelle la routine RCVALA, le code 
   retour est 'F ' 
              ce qui implique que si ces 2 coefficients sont 
   absents, le fichier s'arrête 
              en erreur fatale ce qui n'a pas lieu d'être.
            - Test sur les variables qui donnent la 
   proportion de phases 
              (renvoi à la modification faite par jean-
   michel Proix fiche)
            - 2 Erreurs dans le calcul de DVIN(3) :
              pas de sommation sur les 2 autres phases
              pour calculer VIM(3), on utilise les 2 VIM(K). 
   Or ceux-ci ont été modifiés
              avant et valent VIM(K)=VIM(K)+DVIN(K) ce qui 
   est faux.
            - le calcul de l'écrouissage moyen VIP(5)=(1-
   FMEL)*R(3)+FMEL/ZALPHA*(Z(K)*R(K)) 
              est faux car R(I) n'est pas recalculée pour la 
   variable r(K) 
              de chaque phase correspondant à l'instant plus
      
      ROUTINE LCGDPM.F : Ecrouissage isotrope en grande 
   déformation pour l'acier
        
         1) modification de la présentation générale pour 
   que les 6 routines sur les
         lois de comportement avec métallurgies soient 
   identiques
            - J => JP
            - calcul de SEUIL changé de place
            - MAXVAL+2 => MAXVAL
            - DVIN(5) devient DVIN
            - des noms de variables ont changé
            - pour ne pas modifier VIM(1) à VIM(5), on fait
              avant VIM(I)=VIM(I)+DVIN(I) et VI(I)=VIM(I)-DS
              maitenant VIM(I) reste VIM(I) et VI(I)=VIM(I)
   +DVIN(I)-DS
         
         2) bug sans conséquence
            - tableau mal dimensionné
               DZ(5) devient DZ(4)
               DZ1(5) => DZ1(4)
               DZ2(5) => DZ2(4)
               KPT(5) => KPT(4)
            - erreur lorque qu'on calcule la pente 
   d'écrouissae à l'instant t-
              (conséquence uniquement sur la matrice 
   tangente avec RIGI_MECA)
              pour la phase 4 : PHASP au lieu de  PHASM  
         
         3) bug avec conséquence
            - dans le cas d'un modèle visqueux, on peut 
   également activer la restauration
              d'écrouissage. Les coefficients C et M ne sont 
   pas obligatoires et dans le cas
              où ils ne sont pas présents dans le fichier de 
   commande, on choisit C=0 et M=20
              ce qui implique que la restauration n'est pas 
   prise en compte.
              Lorsque on appelle la routine RCVALA, le code 
   retour est 'F ' 
              ce qui implique que si ces 2 coeffcients sont 
   absents, le fichier s'arrête 
              en erreur fatale ce qui n'a pas lieu d'être.
            - Test sur les variables qui donnent la 
   proportion de phases 
              (renvoi à la modification faite par jean-
   michel Proix fiche)
            - Lorsqu'on calcule VIM(K) K=1,4, on utilise VIM
   (5). Or celui-ci a été modifié
              avant et vaut VIM(5)=VIM(5)+DVIN(5) ce qui est 
   faux.
            - dans le cas d'un écrouissage non linéaire, on 
   ne prenait pas en compte le nombre
              de point de la courbe pourla perlite.
            - dans le cas non linéaire, une fois calculé 
   l'incrément de déformation plastique,
              on vérifie si on a pris la bonne pente 
   d'écrouissage pour chacune des phases.
              Programation actuelle
              TEST=1
              Si Z(5) > 0 : Si Pente=OK TEST=0, Si PENTE=NO 
   OK TEST=1
              Boucle sur les 4 autres phases
               Si Z(K) > 0 : Si Pente=OK TEST=0, Si PENTE=NO 
   OK TEST=1
              Faux car pour recalculer Dp, il faut au plus 
   qu'un seul TEST soit égal à 1  
              
      ROUTINE NZGDZI.F : Ecrouissage isotrope en grande 
   déformation pour le Zircaloy
         
         1) modification de la présentation générale pour 
   que les 6 routines sur les
         lois de comportement avec métallurgies soient 
   identiques
            - J => JP
            - calcul de SEUIL changé de place
            - MAXVAL+2 => MAXVAL
            - DVIN(3) devient DVIN
            - des noms de variables ont changé
            - pour ne pas modifier VIM(1) à VIM(3), on fait
              avant VIM(I)=VIM(I)+DVIN(I) et VI(I)=VIM(I)-DS
              maitenant VIM(I) reste VIM(I) et VI(I)=VIM(I)
   +DVIN(I)-DS
         
         2) bug sans conséquence
            - tableau mal dimensionné
              VALRES(14),NOMRES(14) et CODRET(14) => VALRES
   (12),NOMRES(12) et CODRET(12)  
            - lorqu'on récupère les coefficients de 
   plasticité de transformation, il traine
              dans l'appel de RCVALA un CODRET(9)
            
         3) bug avec conséquence
            - dans le cas d'un modèle visqueux, on peut 
   également activer la restauration
              d'écrouissage. Les coefficients C et M ne sont 
   pas obligatoires et dans le cas
              où ils ne sont pas présents dans le fichier de 
   commande, on choisit C=0 et M=20
              ce qui implique que la restauration n'est pas 
   prise en compte.
              Lorsque on appelle la routine RCVALA, le code 
   retour est 'F ' 
              ce qui implique que si ces 2 coeffcients sont 
   absents, le fichier s'arrête 
              en erreur fatale ce qui n'a pas lieu d'être.
            - Test sur les variables qui donnent la 
   proportion de phases 
              (renvoi à la modification faite par jean-
   michel Proix fiche)
            - Lorsqu'on calcule VIM(K) K=1,2, on utilise VIM
   (3). Or celui-ci a été modifié
              avant et vaut VIM(3)=VIM(3)+DVIN(3) ce qui est 
   faux.
            - dans le cas non linéaire, une fois calculé 
   l'incrément de déformation plastique,
              on vérifie si on a pris la bonne pente 
   d'écrouissage pour chacune des phases.
              Programmation actuelle
              TEST=1
              Si Z(3) > 0 : Si Pente=OK TEST=0, Si PENTE=NO 
   OK TEST=1
              Boucle sur les 2 autres phases
               Si Z(K) > 0 : Si Pente=OK TEST=0, Si PENTE=NO 
   OK TEST=1
              Faux car pour recalculer Dp, il faut 
   uniquement qu'un seul TEST vale 1  
    
   
      ROUTINE NZCIFW.F : Ecrouissage cinématique linéaire en 
   HPP pour l'acier
         
         1) modification de la présentation générale pour 
   que les 6 routines sur les
         lois de comportement avec métallurgies soient 
   identiques
            - supprimer l'appel des déclarations JEVEUX
            - calcul de SEUIL changé de place
            - DVIN(30) devient DVIN
            - des noms de variables ont changé
            - changé la manière de calculer la contrainte 
   élastique 
              car très compliquée pour rien
            - appel parfois de comportement isotrope 
   linéaire ou non (donc on supprime)        
            - pour ne pas modifier VIM(1) à VIM(30), on fait
              avant VIM(I)=VIM(I)+DVIN(I)-DS
              maitenant VIM(I) reste VIM(I) et VI(I)=VIM(I)
   +DVIN(I)-DS
              donc ajout de la variable VI(30) 
         
         2) bug sans conséquence
            - Tableau mal dimensionné
              VIMT(37) => VIMT(30)    
            - modification de la routine pour que le calcul 
   de la matrice tangente
              RIGI_MECA_TANG soit avec les coefficents pris 
   à l'instant moins  
         
         3) bug avec conséquence
            - Tableau mal dimensionné
              KPT(3) => KPT(4)
            - dans le cas d'un comportement élastique, on 
   met à jour les variables
              d'écrouissage VIM(1) à VIM(30) en ajoutant un 
   racine de 2 (pour I=4,6) 
              et on appelle PLASTI=VIM(37). Or ces variables 
   n'existent pas en élasticité. 
            - dans le cas d'un modèle visqueux, on peut 
   également activer la restauration
              d'écrouissage. Les coefficients C et M ne sont 
   pas obligatoires et dans le cas
              où ils ne sont pas présents dans le fichier de 
   commande, on choisit C=0 et M=20
              ce qui implique que la restauration n'est pas 
   prise en compte.
              Lorsque on appelle la routine RCVALA, le code 
   retour est 'F ' 
              ce qui implique que si ces 2 coefficients sont 
   absents, le fichier s'arrête 
              en erreur fatale ce qui n'a pas lieu d'être.
            - Test sur les variables qui donnent la 
   proportion de phases 
              (renvoi à la modification faite par jean-
   michel Proix fiche)
            - 3 Erreurs dans le calcul de DVIN(24+I) 
   (I=1,2*NDIM) :
              pas de sommation sur les 4 autres phases
              pour calculer DVIN(24+I), on utilise les 4 VIM
   (K). Or ceux-ci ont été modifiés
              avant et valent VIM(K)=VIM(K)+DVIN(K) ce qui 
   est faux.
              dans la formule de DVIN, il y a un VIM(J*K) a 
   remplacé par VIM(L) avec
              L=I+(K-1)*6
            - Erreur dans le calcul de VIM
              on a VIM=VIM+DVIN-2*DS au lieu d'avoir 
   VIM=VIM+DVIN-DS (en dehors du 3/2)
            - Remise au format de X mais erreur si 
   comportement élastique
            - pas de remise au format de XMOYK=Somme Z(i)*XK
   (I) pour K=4 * 2*NDIM
          
          4) Erreur du modèle
            - a mon avis, erreur pour modéliser la 
   restauration d'écrouissage d'origine
              visqueuse 
              ce qui est programmé d(alpha)/dt=d(epsp)/dt -
   (C*alphaeq)**m * alpha/alphapeq
              avec alpha=Somme Z(I)*alpha(I) (à mon avis il 
   manque le 3/2)
              ce qui est écrit dans le Lemaitre -Chaboche
              d(alpha)/dt=d(epsp)/dt -1.5*(C*Xeq)**m * X/Xeq
              
      ROUTINE NZCIZI.F : Ecrouissage cinématique linéaire en 
   HPP pour le Zircaloy
        
         1) modification de la présentation générale pour 
   que les 6 routines sur les
         lois de comportement avec métallurgies soient 
   identiques
            - supprimer l'appel des déclarations JEVEUX
            - calcul de SEUIL changé de place
            - DVIN(37) devient DVIN
            - des noms de variables ont changé
            - changé la manière de calculer la contrainte 
   élastique 
              car très compliquée pour rien
            - appel parfois de comportement isotrope 
   linéaire ou non (donc on supprime)        
            - pour ne pas modifier VIM(1) à VIM(18), on fait
              avant VIM(I)=VIM(I)+DVIN(I)-DS
              maitenant VIM(I) reste VIM(I) et VI(I)=VIM(I)
   +DVIN(I)-DS
              donc ajout de la variable VI(18) 
         
         2) bug sans conséquence
            - Tableau mal dimensionné
              VIMT(37) => VIMT(18)
              PHASM(4) et PHASP(4) => PHASM(3) et PHASP(3) 
              Pratiquement toutes les données matériaux sont 
   dimensionnées pour l'acier   
            - modification de la routine pour que le calcul 
   de la matrice tangente
              RIGI_MECA_TANG soit avec les coefficents pris 
   à l'instant moins 
            - lorqu'on récupère les coefficients de 
   plasticité de transformation, il traine
              dans l'appel de RCVALA un CODRET(9) 
         
         3) bug avec conséquence
            - dans le cas d'un comportement élastique, on 
   met à jour les variables
              d'écrouissage VIM(1) à VIM(30) en ajoutant un 
   racine de 2 (pour I=4,6) 
              et on appelle PLASTI=VIM(37). Or ces variables 
   n'existent pas en élasticité. 
            - dans le cas d'un modèle visqueux, on peut 
   également activer la restauration
              d'écrouissage. Les coefficients C et M ne sont 
   pas obligatoires et dans le cas
              où ils ne sont pas présents dans le fichier de 
   commande, on choisit C=0 et M=20
              ce qui implique que la restauration n'est pas 
   prise en compte.
              Lorsque on appelle la routine RCVALA, le code 
   retour est 'F ' 
              ce qui implique que si ces 2 coefficients sont 
   absents, le fichier s'arrête 
              en erreur fatale ce qui n'a pas lieu d'être.
            - Test sur les variables qui donnent la 
   proportion de phases 
              (renvoi à la modification faite par jean-
   michel Proix fiche)
            - 1 erreur dans le calcul de DVIN pour les 2 
   phases. On utilise VIM(24+J)
              or il s'agit de VIM(12+J)
            - 4 Erreurs dans le calcul de DVIN(12+I) 
   (I=1,2*NDIM) :
              on calcule VIM(24+J) au lieu de VIM(12+J)
              pas de sommation sur les 2 autres phases
              pour calculer DVIN(12+I), on utilise les 2 VIM
   (K). Or ceux-ci ont été modifiés
              avant et valent VIM(K)=VIM(K)+DVIN(K) ce qui 
   est faux.
              dans la formule de DVIN, il y a un VIM(J*K) a 
   remplacé par VIM(L) avec
              L=I+(K-1)*6
            - autre erreur liée au calcul de VIM => on prend 
   THETA(4+K) au lieu de THETA(2+K)
            - Erreur dans le calcul de VIM
              on a VIM=VIM+DVIN-2*DS au lieu d'avoir 
   VIM=VIM+DVIN-DS (en dehors du 3/2)
            - 2 erreurs dans le calcul de SYK
              SYALPH=PHASP(1)*SY(1)+PHASP(2)*SY(2)+PHASP(3)
   *SY(3) => mis la phase chaude
              SYK=(1-FMEL)*SY(5)+FMEL*SYALP/ZALPHA au lieu 
   de SY(3)
            - Remise au format de X mais erreur si 
   comportement élastique
            - pas de remise au format de XMOYK=Somme Z(i)*XK
   (I) pour K=4 * 2*NDIM
          
          4) Erreur du modèle
            - a mon avis, erreur pour modéliser la 
   restauration d'écrouissage d'origine
              visqueuse 
              ce qui est programmé d(alpha)/dt=d(epsp)/dt -
   (C*alphaeq)**m * alpha/alphapeq
              avec alpha=Somme Z(I)*alpha(I) (à mon avis il 
   manque le 3/2)
              ce qui est écrit dans le Lemaitre -Chaboche
              d(alpha)/dt=d(epsp)/dt -1.5*(C*Xeq)**m * X/Xeq
         
         5) Cas test HSNV126A (test de non regression)
         Je chande des valeurs de TEST_RESU
   
   Test Hsnv126a
   Il manquait dans le fichier de commande la laeur de 
   reférence VALE_REF=20
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V7.22.126,R4.04.02
VALIDATION
   hsnv126a
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR elgharib     EL-GHARIB Joumana      DATE 22/05/2007 - 15:32:45

--------------------------------------------------------------------------------
RESTITUTION FICHE 010854 DU 2007-05-14 06:19:44
TYPE anomalie concernant Code_Aster (VERSION 9.4)
TITRE
   Anomalies dans le comportement Kocks-Rauch (monocristal)
FONCTIONNALITE
   Les changements amenés par cette restitution sont :
   
   - La récupération du coefficient de cisaillement dans le 
   cas orthotrope,
   
   - La formulation pour l'écrouissage identique à Zmat, 
   Castem et Abaqus : Racine (somme des dislocations) au 
   lieu de Somme (racines des dislocations)
   
   - La récupération de la famille de glissement: une façon 
   de faire a été adoptée à l'implantation de la loi qui 
   donnait  des résultats correctes mais une optimisation 
   de ce point serait à envisager.
   
   Les tests ssnv172a et ssnv171c sont impactés par cette 
   modification.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : R5.03.11-A, V6.04.172-A, V6.04.171-A
VALIDATION
   test de comparaison avec Zmat et Castem,ssnv171c, ssnv172a
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR fernandes    FERNANDES Roméo        DATE 21/05/2007 - 13:09:06

--------------------------------------------------------------------------------
RESTITUTION FICHE 009703 DU 2006-04-24 11:22:23
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   Regularisation dans le cadre de problemes couplees
FONCTIONNALITE
   Le but de ce travail est d'étudier une modélisation de 
   régularisation des phénomènes mécaniques qui s'inspire des 
   formulations second gradient (cf Chambon, Caillerie, 
   Matsushima : "Plastic continuum with microstructure, local second 
   gradient theories for geomaterials : localization studies". 
   International Journal of Solids and Structures Vol38, pp 8503-
   8527 - 2001) en diminuant le nombre d'inconnues nodales pour des 
   questions de temps CPU essentiellement.
   
   
   Modélisation "second gradient complet" :
   --------------------------------------
   Dans ce cadre j'ai tout de même développé la modélisation second 
   gradient complète - il s'agit là d'une modélisation de référence 
   à partir de laquelle nous pourrons faire des comparaisons. Le 
   développement que je propose ici découle directement de la 
   formulation proposée par (Matsushima, Chambon, Caillerie : "Large 
   strain finite element analysis of a local second gradient model : 
   application to localization" International Journal for Numerical 
   Methods in Engineering, vol 54, pp 499-521 - 2002). La 
   formulation proposée est P2-P1-P0 (P2 sur le champ de 
   déplacements macroscopiques, P1 sur le champ des déformations 
   microstructurales et P0 sur les multiplicateurs de Lagrange). 
   
   Dans le développement que je propose ici, la modélisation second 
   gradient vient surcharger une modélisation premier 
   gradient "INDEPENDANTE". Pour l'activer il faut donc appliquer 
   sur le maillage une modélisation premier gradient classique (par 
   exemple D_PLAN en mécanique ou D_PLAN_HM en couplé) puis 
   appliquer la modélisation : D_PLAN_2DG sur le même maillage (il 
   faut pour cela dupliquer les mailles - cf exemples).
   
   Avantage de cette programmation :
   - Il n'y a qu'un seul développement associé à la partie second 
   gradient quelle que soit la modélisation premier gradient.
   
   Inconvénient de cette programmation :
   - Les variables définies aux points d'intégrations ne 
   communiquent pas d'une modélisation à l'autre.
   
   Validation (nouveaux cas-tests) :
   -----------
   ssll117f,ssll117h
   
   
   Modélisation "à gradient de déformation volumique" :
   ----------------------------------------------------
   Cette modélisation s'inspire de la précédente mais ne 
   régularise qu'à partir de la déformation volumique. Le but étant 
   de réduire le nombre de ddls on passe de 4 ddls de déformations 
   microstructurales par noeud sommet à 1 ddl, et de 4 ddls de 
   multiplicateurs de Lagrange à 1 ddl également.
   
   Je considère aujourd'hui 2 formulations : P2-P1-P0 et P2-P1
   (sur le champ de déplacements macroscopiques, sur le champ des 
   déformations volumiques microstructurales et sur les 
   multiplicateurs de Lagrange) avec pénalisation.
   
   Dans le cadre d'études que j'ai pu mener la formulation AVEC multiplicateur
   de Lagrange est plus stable dès lors que le terme de pénalisation n'est
   pas trop contraignant. Je conserve une formulation SANS multiplicateur de
   Lagrange plus rapide.
   
   Validation (nouveaux cas-tests) :
   -----------
   ssll117a,ssll117b,ssll117c,ssll117d,ssll117e,ssll117g
   
   REMARQUES :
   
   1/  AJOUT DE PARAMETRE MATERIAU SOUS ELAS_2NDG DANS DEFI_MATERIAU
       POUR LES PARAMETRES DE L'ELASTICITE SECOND GRADIENT (CF RD Mindlin,
       1965, "Second gradient strain surface tension linear elasticity",
       International Journal of Solids and Structures Vol.1, 4, pp417-438
   
   2/  AVEC CES DEVELOPPEMENTS JE CORRIGE EGALEMENT LA ROUTINE IRDECA
       QUI DIMENSIONNE LES VECTEURS A IMPRIMER LORSQU'ON UTILISE LA COMMANDE
       IMPR_RESU AU FORMAT CASTEM. DANS CETTE ROUTINE IL Y A UN VECTEUR
       QUI EST DIMENSIONNE EN DUR A 150 ALORS QUE LE NOMBRE DE COMPOSANTES
       A IMPRIMER PEUT-ETRE SUPERIEUR (157 DANS LE CAS DU CHAMP SIEF_ELGA
       AVEC LE DEVELOPPEMENT QUE JE RESTITUE). J'INCREMENTE DONC EN DUR
       A 180 LA DIMENSION DE CE VECTEUR ET J'EMET UNE FICHE D'EVOLUTION
       POUR QUE LE DIMENSIONNEMENT SOIT FAIT VIA UN WKVECT.
   
   3/  COMME EN 2/ JE CORRIGE LA ROUTINE IRGAGS QUI EST APPELE DANS LE CAS
       D'UN IMPR_RESU AU FORMAT IDEAS. LE PROBLEME VIENT DU TEST :
       ...IF (NOMCMP(ICMAS)(1:4).EQ.'PRES') THEN...
       EN INTRODUISANT UNE NOUVELLE COMPOSANTE AU CHAMP DE CONTRAINTE
       DE NOM PRES11 JE RENTRE DANS CE TEST QUI EST PREVU UNIQUEMENT
       POUR LA COMPOSANTE PRES. JE MODIFIE DONC LE TEST PAR :
       ...IF (NOMCMP(ICMAS).EQ.'PRES') THEN...
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V3.01.117, R5.04.03, U4.41.01
VALIDATION
   ssll117
NB_JOURS_TRAV  : 61.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR granet       GRANET Sylvie          DATE 21/05/2007 - 13:09:06

--------------------------------------------------------------------------------
RESTITUTION FICHE 010642 DU 2007-03-13 15:45:08
TYPE evolution concernant Code_Aster (VERSION )
TMA : DeltaCad
TITRE
   Modélisations HH et HH2
FONCTIONNALITE
   HISTOR :
   
   1. Objectif
   ------------
   Disposer de modelisations hydrauliques non saturees de type HH et HH2.
   
   2. Modifications 
   ----------------
   2.1 Catalogue des commandes
    - c_comp_incr.capy : introduction de la nouvelle relation KIT_HH asscocié 
   aux nouvelles
   modélisations
   
   2.2 Catalogue des elements
    a) Type d?element
       On creer 12 nouveaux catalogues d'elements pour les modelisations HH et 
   HH2
   
        - 3D:      .gener_me3a61.cata, gener_me3a63.cata: elements de bord
                   .gener_me3a62.cata, gener_me3a64.cata: elements "rigides"?
        - AXIS     .gener_meaa61.cata, gener_meaa63.cata: elements de bord
                   .gener_meaa62.cata, gener_meaa64.cata: elements "rigides"?
        - D_PLAN   .gener_meda61.cata, gener_meda63.cata: elements de bord
                   .gener_meda62.cata, gener_meda64.cata: elements "rigides"?
   
   b) phenomene_modelisation__.cata : 
      on ajoute les nouvelles modelisations avec les d?elements asscociés.
         - 3D_HHS, 3D_HHD, 3D_HH2S, 3D_HH2D,
         - AXIS_HHS, AXIS_HHD, AXIS_HH2S, AXIS_HH2D,
         - D_PLAN_HHS, D_PLAN_HHD, D_PLAN_HH2S, D_PLAN_HH2D,
      
   Ces modélisations concernent les lois de comportement :
       - D_PLAN_HHS, D_PLAN_HHD, AXIS_HHS, AXIS_HHD, 3D_HHS, 3D_HHD 
   => 'liqu_gaz' ou
   'liqu_vape_gaz'
       - D_PLAN_HH2S, D_PLAN_HH2D, AXIS_HH2S, AXIS_HH2D, 3D_HH2S, 3D_HH2D
   	=> 'liqu_ad_gaz_vape'
   
   2.2 Fortran
   -----------
     Ajout : hh0018, hh2018
     Modification :
       dimthm, dismmo, grdthm, mode18
       nmdorc, nmthmc, te0466, te0472, te0600
   
   2.3 Cas-tests
   ------------
   Les cas tests traitant de problemes physique HH sans mecanique ni thermique 
   existent deja, 
   ils traitent tous un ou plusieurs DDL inutiles, on les decline dans une 
   version KIT_HH :
   
     - WTNP106 - Chauffage d'un milieu poreux desature avec air dissous
          modelisation A (D_PLAN_HH2D) et B (D_PLAN_HH2S)
     - WTNP130 - Chauffage d'un milieu poreux desature avec air dissous (3D)
          modelisation A (3D_HH2D) et B (3D_HH2S)
     - WTNA102 - Diffusion d'air dissous
          modelisation A (AXIS_HH2D) et B (AXIS_HH2S)
     - WTNP112 - Resaturation d'une colonne
          modelisation E (D_PLAN_HHD) et F (D_PLAN_HHS) 
     - WTNA100 - Essai triaxail non draine avec le modee CJS (Niveau 1) 
          modelisation A (AXIS_HHD) et B (AXIS_HHS)
     - WTNV125 - Calcul de resaturation d'un BO par une BG sur un bimateriau 
   BO - BG
          modelisation A (3D_HHD) et B (3D_HHS)
   
   4. Documentation
   ----------------------
   4.1 Mise a jour des Doc U 
     - U2.04.05 : « notice d?utilisation du modele THM »
     - U4.51.11 : « Comportement non-lineaires »
     - U3.13.08 : Modelisations D_PLAN_HM, D_PLAN_HHM, D_PLAN_THM, D_PLAN_THH, 
   D_PLAN_THHM,
                  AXIS_HM, AXIS_HHM,AXIS_THM, AXIS_THH, AXIS_THHM
     - U3.14.07-C1 : Modelisations 3D_HM, 3D_HHM, 3D_THM, 3D_THH, 3D_THHM
   
   4.2 Mise a jour des Doc V
     - V7.36.106 : WTNP106 - Chauffage d?un milieu poreux desature avec air 
   dissous
     - V7.31.130 : WTNP130 - Chauffage d?un milieu poreux desature avec air 
   dissous (3D)
     - V7.33.102 : WTNA102 - Diffusion d?air dissous
     - V7.32.112 : WTNP112 - Resaturation d?une colonne
     - V7.31.100 : WTNA100 - Essai triaxail non draine avec le modee CJS 
   (Niveau 1) 
     - pas de Doc: WTNV125 - Calcul de resaturation d'un BO par une BG sur un 
   bimateriau BO - BG
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V7.36.106 V7.31.130 V7.33.102 V7.32.112 V7.31.100
VALIDATION
   création de nouveau cas test
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR galenne      GALENNE Erwan          DATE 22/05/2007 - 15:14:10

--------------------------------------------------------------------------------
RESTITUTION FICHE 010592 DU 2007-03-01 09:09:10
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
   CALC_G, option CALC_K_G et comportement non-linxc3xa9aire
FONCTIONNALITE
   Problème : 
   le calcul de K et de G en 3D avec X-FEM n'a été développé que pour les lois de
   comportement linéaires (opérateur CALC_G, option CALC_K_G).
   Les vérification ne sont pas sufisantes dans le fortran, et un calcul avec une loi de type
   ELAS_VMIS_LINE est possible mais donne des résultats faux !
   
   Correction :
   On vérifie dans le TE0295 quelle est la loi de comportement et on s'arrete en erreur si
   elle n'est pas linéaire.
   
   Perspectives : 2 fiches d'évolution émises
   - développement du calcul de G pour les modélisations X-FEM pour les lois de comportement
   élastiques non linéaires (fiche 10870)
   - vérification de la cohérence entre la loi de comportement utilisée pour le calcul et
   celle définie par l'utilisateur pour le post-traitement (fiche 10869)
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 8.0
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 9.0
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.82.03
VALIDATION
   cas test perso
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 010531 DU 2007-02-12 17:05:42
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TITRE
   Anomalie dans MACR_LIGN_COUPE
FONCTIONNALITE
   Classement sans suite
   
   Problème : la projection de champ avec PROJ_CHAM est imprécise lorsque les bords des
   éléments sont courbes.
   C'est un problème qui était connu, et qui a été mis en évidence dans cette fiche lors de
   l'utilisation de MACR_LIGN_COUPE.
   
   La correction d'une telle anomalie représenterait une évolution très importante de
   PROJ_CHAM ; une détection pertinente d'une telle situation -pour émettre une alarme-
   serait aussi assez compliquée.
   Dans l'attente d'une éventuelle évolution de PROJ_CHAM, on propose donc de classer sans
   suite cette fiche et de compléter la doc de PROJ_CHAM et MACR_LIGN_COUPE.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : U4.72.05, U4.81.13
VALIDATION
   /
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 010863 DU 2007-05-15 08:05:42
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
   NEW9.0.22, le test rccm09b s'arrete en ERREUR
FONCTIONNALITE
   Problème : plantage dans rccm09b depuis l'évolution de syntaxe de MACR_LIGN_COUPE (9.0.22)
   
   La syntaxe à utiliser pour les lignes de coupe circulaires est la suivante :
   TAB = MACR_LIGN_COUPE( RESULTAT=RESU1,
   .                      NOM_CHAM='SIGM_NOEU_DEPL',
   .                      LIGN_COUPE=_F(TYPE='ARC',
   .                      NB_POINTS= 16,
   .                      COOR_ORIG= (Xr, 0.),
   .                      CENTRE= (Xo, 0.),
   .                      DNOR = (0, 0,1),
   .                      ANGLE=360.,
   .                      REPERE= /'GLOBAL' (repère global du calcul) 
   .                              /'LOCAL'  (repère cylindrique associé à la ligne de coupe)
                                             ),);
   
   Corrections :
   - dans le catalogue on interdit VECT_Y si TYPE='ARC' (car si on ne peut exprimer les
   résultats en repère LOCAL que dans le repère cylindrique défini par le centre de la ligne
   de coupe et le vecteur normal DNOR);
   - dans la macro python, on corrige le changement de repère qui n'était pas valide pour
   TYPE='ARC';
   - on corrige la syntaxe du cas test
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.81.13
VALIDATION
   rccm09b
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR kham         KHAM Marc              DATE 22/05/2007 - 10:34:39

--------------------------------------------------------------------------------
RESTITUTION FICHE 010811 DU 2007-04-24 13:05:56
TYPE evolution concernant Code_Aster (VERSION 2.x)
TITRE
   hujeux: subdivision locale du pas de temps
FONCTIONNALITE
   dans le cadre de l'affaire codhybar, on cherche à modéliser 
   la construction par couche d'une digue avec la loi de 
   hujeux. Les premiers tests sur une colonne de sol 1D font 
   apparaitre la nécessité de certaines améliorations de 
   l'algorithme.
   
   *** $1 ***
   Cette fiche inaugure une série de fiches à venir permettant 
   d'ajouter des mécanismes de blindage de l'algorithme de 
   résolution. Pour l'heure, on commence par introduire et 
   valider un mécanisme de subdivision locale du pas de temps. 
   Il consiste à résoudre le comportement local sur des 
   subdivisions linéaires de l'incrément de déplacement 
   proposé par la résolution globale.
   
   De façon classique, la subdivision locale est activée dans 
   STAT_NON_LINE/COMP_INCR par le mot-clé ITER_INTE_PAS:
   
    + si ITER_INTE_PAS = -1,0 ou 1, pas de subdivison (defaut)
    + si ITER_INTE_PAS = n > 1, on impose n subdivisions à
      chaque incrément de Newton
    + si ITER_INTE_PAS = n < -1, on ne fait n subdivisions
      d'un incrément de Newton que s'il y a échec de
      l'intégration locale
   
   *** $2 ***
   Le fait d'utiliser les deux mécanismes de subdivision 
   conjointement permet de réduire significativement les 
   situations de non-convergence, et d'économiser des pas de 
   temps: pour preuve, le cas-test ssnv197c qui passait 313s 
   sur BULL passe maintenant en 115s avec ce double mécanisme.
   
   *** $3 ***
   On en profite également pour corriger différents bugs dans 
   la programmation de hujeux.
   
   *** $4 ***
   On modifie légèrement les cas-tests ssnv197a,b,c pour tenir 
   des nouvelles marges d'erreur.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V6.04.197
VALIDATION
   ssnv197
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR greffet      GREFFET Nicolas        DATE 22/05/2007 - 11:42:57

--------------------------------------------------------------------------------
RESTITUTION FICHE 010748 DU 2007-04-04 06:55:47
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TMA : DeltaCad
TITRE
   Version 9.0.16 - Nouvelle syntaxe DYNA_NON_LINE
FONCTIONNALITE
   Réalisations :
   a) Cas-tests : miss06a, elsa01b, sdnl103a
   - Mise a jour de ces cas-tests suite a l'evolution de la syntaxe de l'operateur
   DYNA_NON_LINE (Fiche 9985).
   
   b) Cas-tests : ssnv128n,ssnv504i,ssnv504j: ces cas-tests ne sont pas concernes 
   par
   l'evolution de la syntaxe de DYNA_NON_LINE
   - Les cas-tests ssnv504i,ssnv504j ont ete corriges dans le cadre de la fiche 
   10631,
   restituee en 9.0.19.
   - Le cas-test ssnv128n est corrige (suppression de MODL_AXIS dans
   AFFE_CHAR_MECA), fiche 10777.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   miss06a,elsa01b,sdnl103a
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST MODIF elsa01b                       rezette C.REZETTE          230      3      2
 CASTEST MODIF hsnv126a                         cano V.CANO             382      4      3
 CASTEST MODIF miss06a                       rezette C.REZETTE          641      3      2
 CASTEST MODIF rccm09b                       galenne E.GALENNE          255      3      3
 CASTEST MODIF sdlv125a                        bodel C.BODEL            195      1      3
 CASTEST MODIF sdnl103a                      rezette C.REZETTE          195      3      3
 CASTEST MODIF ssnv171c                     elgharib J.EL-GHARIB        358      3      3
 CASTEST MODIF ssnv172a                     elgharib J.EL-GHARIB       1108      7      7
 CASTEST MODIF ssnv197a                         kham M.KHAM             529     10     10
 CASTEST MODIF ssnv197b                         kham M.KHAM             530      8      8
 CASTEST MODIF ssnv197c                         kham M.KHAM             530     14     14
CATALOGU AJOUT typelem/d_depl_r_pres11     fernandes R.FERNANDES         64     64      0
CATALOGU AJOUT typelem/d_depl_r_pres12     fernandes R.FERNANDES         64     64      0
CATALOGU AJOUT typelem/d_depl_r_pres13     fernandes R.FERNANDES         64     64      0
CATALOGU AJOUT typelem/d_depl_r_pres21     fernandes R.FERNANDES         64     64      0
CATALOGU AJOUT typelem/d_depl_r_pres22     fernandes R.FERNANDES         64     64      0
CATALOGU AJOUT typelem/d_depl_r_pres23     fernandes R.FERNANDES         64     64      0
CATALOGU AJOUT typelem/d_depl_r_pres31     fernandes R.FERNANDES         64     64      0
CATALOGU AJOUT typelem/d_depl_r_pres32     fernandes R.FERNANDES         64     64      0
CATALOGU AJOUT typelem/d_depl_r_pres33     fernandes R.FERNANDES         64     64      0
CATALOGU AJOUT typelem/d_depl_r_v11        fernandes R.FERNANDES         64     64      0
CATALOGU AJOUT typelem/d_depl_r_v12        fernandes R.FERNANDES         64     64      0
CATALOGU AJOUT typelem/d_depl_r_v13        fernandes R.FERNANDES         64     64      0
CATALOGU AJOUT typelem/d_depl_r_v21        fernandes R.FERNANDES         64     64      0
CATALOGU AJOUT typelem/d_depl_r_v22        fernandes R.FERNANDES         64     64      0
CATALOGU AJOUT typelem/d_depl_r_v23        fernandes R.FERNANDES         64     64      0
CATALOGU AJOUT typelem/d_depl_r_v31        fernandes R.FERNANDES         64     64      0
CATALOGU AJOUT typelem/d_depl_r_v32        fernandes R.FERNANDES         64     64      0
CATALOGU AJOUT typelem/d_depl_r_v33        fernandes R.FERNANDES         64     64      0
CATALOGU AJOUT typelem/gener_2d2g          fernandes R.FERNANDES        145    145      0
CATALOGU AJOUT typelem/gener_2dilp0        fernandes R.FERNANDES        133    133      0
CATALOGU AJOUT typelem/gener_2dilsl        fernandes R.FERNANDES        128    128      0
CATALOGU AJOUT typelem/gener_me3a61        fernandes R.FERNANDES         53     53      0
CATALOGU AJOUT typelem/gener_me3a62        fernandes R.FERNANDES        150    150      0
CATALOGU AJOUT typelem/gener_me3a63        fernandes R.FERNANDES         53     53      0
CATALOGU AJOUT typelem/gener_me3a64        fernandes R.FERNANDES        153    153      0
CATALOGU AJOUT typelem/gener_meaa61        fernandes R.FERNANDES         48     48      0
CATALOGU AJOUT typelem/gener_meaa62        fernandes R.FERNANDES        136    136      0
CATALOGU AJOUT typelem/gener_meaa63        fernandes R.FERNANDES         48     48      0
CATALOGU AJOUT typelem/gener_meaa64        fernandes R.FERNANDES        139    139      0
CATALOGU AJOUT typelem/gener_meda61        fernandes R.FERNANDES         49     49      0
CATALOGU AJOUT typelem/gener_meda62        fernandes R.FERNANDES        136    136      0
CATALOGU AJOUT typelem/gener_meda63        fernandes R.FERNANDES         49     49      0
CATALOGU AJOUT typelem/gener_meda64        fernandes R.FERNANDES        139    139      0
CATALOGU MODIF compelem/grandeur_simple__  fernandes R.FERNANDES        684     61     12
CATALOGU MODIF compelem/phenomene_modelisation__  fernandes R.FERNANDES       1150     83      1
CATALOPY MODIF commande/affe_char_cine     fernandes R.FERNANDES        156     22      2
CATALOPY MODIF commande/affe_char_meca     fernandes R.FERNANDES       1094     22      2
CATALOPY MODIF commande/affe_modele        fernandes R.FERNANDES        227     15      1
CATALOPY MODIF commande/defi_materiau      fernandes R.FERNANDES       2761     10      3
CATALOPY MODIF commande/macr_lign_coupe      galenne E.GALENNE          115      2      2
CATALOPY MODIF commande/observation            bodel C.BODEL            149      1      1
CATALOPY MODIF commun/c_comp_incr          fernandes R.FERNANDES        348      3      1
 FORTRAN AJOUT algorith/cabr2g             fernandes R.FERNANDES        170    170      0
 FORTRAN AJOUT algorith/cabrp0             fernandes R.FERNANDES        153    153      0
 FORTRAN AJOUT algorith/cabrsl             fernandes R.FERNANDES        151    151      0
 FORTRAN AJOUT algorith/dil2gr             fernandes R.FERNANDES         66     66      0
 FORTRAN AJOUT algorith/dilcge             fernandes R.FERNANDES         61     61      0
 FORTRAN AJOUT algorith/dilder             fernandes R.FERNANDES         58     58      0
 FORTRAN AJOUT algorith/dilele             fernandes R.FERNANDES        120    120      0
 FORTRAN AJOUT algorith/dilini             fernandes R.FERNANDES        125    125      0
 FORTRAN AJOUT algorith/dilopt             fernandes R.FERNANDES         58     58      0
 FORTRAN AJOUT algorith/dilpen             fernandes R.FERNANDES         40     40      0
 FORTRAN AJOUT algorith/dilsga             fernandes R.FERNANDES         34     34      0
 FORTRAN AJOUT algorith/dimp0              fernandes R.FERNANDES         69     69      0
 FORTRAN AJOUT algorith/dimsl              fernandes R.FERNANDES         67     67      0
 FORTRAN AJOUT algorith/epsdil             fernandes R.FERNANDES         64     64      0
 FORTRAN AJOUT algorith/epsreg             fernandes R.FERNANDES         56     56      0
 FORTRAN AJOUT algorith/equdil             fernandes R.FERNANDES         55     55      0
 FORTRAN AJOUT algorith/equreg             fernandes R.FERNANDES         56     56      0
 FORTRAN AJOUT algorith/fnodil             fernandes R.FERNANDES         92     92      0
 FORTRAN AJOUT algorith/fnoreg             fernandes R.FERNANDES         74     74      0
 FORTRAN AJOUT algorith/hh0018             fernandes R.FERNANDES         51     51      0
 FORTRAN AJOUT algorith/hh2018             fernandes R.FERNANDES         51     51      0
 FORTRAN AJOUT algorith/reg2gr             fernandes R.FERNANDES         92     92      0
 FORTRAN AJOUT algorith/regcge             fernandes R.FERNANDES         54     54      0
 FORTRAN AJOUT algorith/regder             fernandes R.FERNANDES         64     64      0
 FORTRAN AJOUT algorith/regele             fernandes R.FERNANDES        106    106      0
 FORTRAN AJOUT algorith/regini             fernandes R.FERNANDES        147    147      0
 FORTRAN AJOUT elements/dilcar             fernandes R.FERNANDES        116    116      0
 FORTRAN AJOUT elements/te0005             fernandes R.FERNANDES        117    117      0
 FORTRAN AJOUT elements/te0006             fernandes R.FERNANDES        117    117      0
 FORTRAN MODIF algorith/calcme                  kham M.KHAM             429      4      4
 FORTRAN MODIF algorith/dimthm             fernandes R.FERNANDES         98     13      1
 FORTRAN MODIF algorith/grdthm             fernandes R.FERNANDES        328     23      1
 FORTRAN MODIF algorith/hujci1                  kham M.KHAM             195      1      1
 FORTRAN MODIF algorith/hujcri                  kham M.KHAM              57      2      2
 FORTRAN MODIF algorith/hujddd                  kham M.KHAM             319     28      8
 FORTRAN MODIF algorith/hujela                  kham M.KHAM             111      6      8
 FORTRAN MODIF algorith/hujiid                  kham M.KHAM             371     13     13
 FORTRAN MODIF algorith/hujjid                  kham M.KHAM             642      8      8
 FORTRAN MODIF algorith/hujksi                  kham M.KHAM             103     29      7
 FORTRAN MODIF algorith/hujmid                  kham M.KHAM             248     37     19
 FORTRAN MODIF algorith/hujpla                  kham M.KHAM             287     51     31
 FORTRAN MODIF algorith/hujtel                  kham M.KHAM              86      7      8
 FORTRAN MODIF algorith/hujtid                  kham M.KHAM             279      8      9
 FORTRAN MODIF algorith/lcgdpm                  cano V.CANO             933    463    507
 FORTRAN MODIF algorith/lcmaei              elgharib J.EL-GHARIB        113      8      5
 FORTRAN MODIF algorith/lcmmfe              elgharib J.EL-GHARIB        227     22     16
 FORTRAN MODIF algorith/lcmmfi              elgharib J.EL-GHARIB         99      5      4
 FORTRAN MODIF algorith/lcmmjf              elgharib J.EL-GHARIB        242     16     12
 FORTRAN MODIF algorith/lcmmji              elgharib J.EL-GHARIB         67      7      6
 FORTRAN MODIF algorith/nmdorc             fernandes R.FERNANDES        604      4      5
 FORTRAN MODIF algorith/nmhuj                   kham M.KHAM             330     12     10
 FORTRAN MODIF algorith/nmthmc             fernandes R.FERNANDES        455      7      1
 FORTRAN MODIF algorith/nzcifw                  cano V.CANO             739    502    503
 FORTRAN MODIF algorith/nzcizi                  cano V.CANO             715    499    492
 FORTRAN MODIF algorith/nzedga                  cano V.CANO             741    518    497
 FORTRAN MODIF algorith/nzgdzi                  cano V.CANO             907    449    495
 FORTRAN MODIF algorith/nzisfw                  cano V.CANO             766    523    508
 FORTRAN MODIF calculel/trigd              fernandes R.FERNANDES        192      2      2
 FORTRAN MODIF elements/te0295               galenne E.GALENNE          560      4      2
 FORTRAN MODIF elements/te0466             fernandes R.FERNANDES        566     58      3
 FORTRAN MODIF elements/te0472             fernandes R.FERNANDES        423     35      2
 FORTRAN MODIF elements/te0600             fernandes R.FERNANDES        550      2      2
 FORTRAN MODIF modelisa/corr18             fernandes R.FERNANDES         96     11      1
 FORTRAN MODIF modelisa/mode18             fernandes R.FERNANDES        379      7      1
 FORTRAN MODIF prepost/irdeca              fernandes R.FERNANDES        264      3      3
 FORTRAN MODIF prepost/irgags              fernandes R.FERNANDES        623      5      5
 FORTRAN MODIF utilitai/dismmo             fernandes R.FERNANDES        316      3      1
 FORTRAN MODIF utilitai/uttgel             fernandes R.FERNANDES        137     13      7
  PYTHON MODIF Macro/macr_lign_coupe_ops     galenne E.GALENNE          869      4      4
  PYTHON MODIF Macro/observation_ops           bodel C.BODEL            585     37     41
  PYTHON MODIF Messages/elements3            galenne E.GALENNE          418      3      2


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :   62        5195      5195             +5195
 MODIF :   62       28106      3730    3340      +390
 SUPPR :    0           0                 0        +0
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :  124       33301      8925    3340     +5585 
