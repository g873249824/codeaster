

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR abbas        ABBAS Mickael          DATE 03/07/2011 - 01:50:19

--------------------------------------------------------------------------------
RESTITUTION FICHE 016408 DU 2011-02-14 07:01:30
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En 10.3.12, le cas-test zzzz159b s'arrete en erreur fatale sur Rocks.
FONCTIONNALITE
   Probleme
   ========
   
   Le cas-test zzzz159b s'arrete en erreur fatale
   
   Solution
   ========
   
   J'ai oublié de modifier la syntaxe d'ARCHIVAGE dans les fichiers esclaves zzzz159b.3
   Il restait un ARCH_ETAT_INIT.
   C'est corrigé
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    zzzz159b
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 016438 DU 2011-02-17 09:34:19
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.3.14, le cas-test sdnv107a, sdnv107b, sdnv107c et miss06b s'arretent en erreur fatale sur Aster4 et Calibre 5. Problxc3xa8me avec ARCH_ETAT_INIT
FONCTIONNALITE
   Problème
   ========
   
   Les cas-test sdnv107a, sdnv107b, sdnv107c et miss06b s'arretent en erreur fatale sur
   Aster4 et Calibre 5. 
   
   Problème avec ARCH_ETAT_INIT
   
   Solution
   ========
   
   
   La commande REST_COND_TRAN ne prend pas pas bien en compte les résultats qui ont un numéro
   d'ordre nul (qui correspond à l'état initial).
   En effet, dans OP0078, on récupère la longueur du résultat EVOL_NOLI. S'il y a les numéros
   d'ordre 0,1,2,3, la variable LONVEC va valoir 4.
   Ensuite, on fait une boucle de 1 à LONVEC. Donc, boum, le NUME_ORDRE 4 n'existe pas.
   Correction de Georges Devesa (merci à lui !)
   
   Dans REST_COND_TRAN, les listes des numéros d'ordre et des 
   instants sont obtenues par un appel à RSTRAN.
   Or, on utilisait mal RSTRAN. 
   
   En fait cette routine renvoie non pas une liste de numéros 
   d'ordre du résultat de départ "resu" à restituer, mais les 
   indices de rangement de ces numéros d'ordre dans 
   l'objet "resu"//'.ORDR'. En pratique, cela revenait au même 
   quand "resu" était de type EVOL_NOLI et il fallait retrancher 1 
   aux indices de rangement quand "resu" était de type DYNA_TRANS, 
   car on y stockait déjà le numéro 0 initial.
   En conséquence, on ne touche plus maintenant à RSTRAN mais on 
   récupère les numéros d'ordre dans les routines appelantes MACR78 
   et BAMO78 à partir de l'objet "resu"//'.ORDR'. On n'a pas non 
   plus à tester le type de "resu" dans MACR78 quand celui-ci est 
   de type DYNA_TRANS afin de retrancher 1 aux indices de rangement.
   La nouvelle correction permet de faire tourner les tests 
   sdnv107a, sdnv107b, sdnv107c, miss06b ainsi que miss06c (afin de 
   vérifier si ce dernier, où "resu" est de type DYNA_TRANS, n'est 
   pas cassé).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sdnv107abc,miss06bc
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 016491 DU 2011-02-25 09:55:41
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.3.14, le cas-test ssnv204a s'arrete en erreur fatale sur Aster4 et Calibre 5.
FONCTIONNALITE
   Probleme
   ========
   
   Le cas-test ssnv204a s'arrête en erreur fatale sur Aster4 et Calibre 5.
   
   Solution
   ========
   
   Il marche très bien maintenant
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssnv204a
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 016457 DU 2011-02-22 12:34:08
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Problxc3xa8me affichage .mess avec DEBORST
FONCTIONNALITE
   Idem issue16150
   
   Le problème a été corrigé en 10.3.16
   
   Je classe sans suite
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    rien
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------
RESTITUTION FICHE 016526 DU 2011-03-03 09:38:39
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.3.16, le cas-test ssnv128a est NOOK sur Rocks.
FONCTIONNALITE
   Il s'agit d'un test de non-régression.
   On fixe la tolérance à 1.e-9.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssnv128a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR flejou       FLEJOU Jean Luc        DATE 03/07/2011 - 05:48:18

--------------------------------------------------------------------------------
RESTITUTION FICHE 016430 DU 2011-02-16 16:09:14
TYPE anomalie concernant Code_Aster (VERSION 10.3)
TITRE
    Poutre PMF (POU_D_EM) Erreur numxc3xa9rique
FONCTIONNALITE
   L'erreur numérique FPE est une division par 0.
   
   Cette erreur se produit lorsque la raideur tangente de la section devient nulle. Cela peut
   arriver dans 2 cas :
   - non convergence de la loi de comportement. Ce cas a été traité par la fiche 15648.
   - le matériau est par exemple elasto-plastique parfait et toutes les fibres sont plastifiées.
   
   C'est le 2nd cas qui arrive dans SSNL106C : poutre en traction avec un matériau
   élasto-plastique parfait.
   
   
   Correction : ajout dans te0535 d'un test sur la raideur tangente et message <F>
   ------------
   La raideur tangente de la section est nulle.
   Vérifier votre matériau, vous avez peut être défini un matériau élasto-plastique parfait.
   Risque & Conseil : mettre un léger écrouissage peut permettre de passer cette difficulté.
   ------------
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    passage cas test ssnl106c
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR foucault     FOUCAULT Alexandre     DATE 03/08/2011 - 09:16:22

--------------------------------------------------------------------------------
RESTITUTION FICHE 013196 DU 2009-03-10 14:40:22
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    BETON_UMLV en contraintes planes
FONCTIONNALITE
   Fiche a relier a la nouvelle fiche 16504 qui montre que la modelisation C_PLAN en mode
   analytique est erronée.
   Elle est donc retirer de la liste des modelisations autorisées pour le modèle UMLV.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 7.0.4
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 7.0.4
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V6.04.169
VALIDATION
    SSNV169
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 016504 DU 2011-02-28 16:54:16
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    BETON_UMLV_FP en C_PLAN a interdire
FONCTIONNALITE
   Fiche d'anomalie emise par Jean-Michel Proix:
   ---------------------------------------------
   La modelisation C_PLAN est fausse si on n'utilise pas l'algorithme de DEBORST.
   
   Solutions avancées:
   -------------------
   Suppression de la modélisation C_PLAN 'analytique' pour le modele UMLV_FP
   
   Impact source: beton_umlv_fp.py
   
   Impact les cas-tests SSNV169F et SSNV169I, qui sont établis sur des valeurs de non
   régression pour une modelisation C_PLAN.
   
   Fiche jumelée à la fiche 13196
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 7.0.4
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 7.0.4
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V6.04.169
VALIDATION
    CAS-TEST
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 012519 DU 2008-09-23 16:48:04
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    R7.01.06 - BETON_UMLV_FP : doc R diffxc3xa9rente du fortran
FONCTIONNALITE
   I)Révision Doc R: Anomalies relevées
   -----------------------------------
   -)eq.4.1-5: des exposants "d" apparaissent alors qu'il s'agit de la partie sphérique du
   modèle. Il suffit de remplacer les exposants "d" par "s" et les équations du système
   redeviennent correctes
   
   -)eq.4.1-7: Il faut supprimer l'opérateur de Mac Cauley "<f(x)>+" et ajouter un signe "+"
   entre le terme "(k_i^s)*(%epsilon_i^s)" et "(%sigma_n)*(h_n)
   
   -) eq.4.1-9: le terme a_ir^s est à modifier et est égal à 2*(k_r^s)/(%êta_i^s)   
   
   -) eq.4.1-12: il faut modifier le signe "-" en "+" entre t_n et 1/%lambda_k
   
   -) eq.4.1-14: La détermination des constantes %mu_i s'établit à l'instant t_n et non
   t_{n+1}. Remplacer t_{n+1} par t_n pour l'indice d'évaluation des déformations sphériques
   réversibles et irréversibles.
   
   -)eq.4.1-17: Remplacer le signe "-" en "+" entre les deux termes mis en jeu dans l'expression.
   
   II) Résultats différents entre solution analytique et code_Aster:
   ----------------------------------------------------------------
   L'essai consistant à imposer une pression sur la paroi interne d'un tube conduit aux états
   de contraintes suivants:
   -) compression dans la direction de chargement %sigma_rr <0
   -) traction dans la direction orthogonale (hors-plan en axisymétrique) %sigma_%theta%theta > 0
   -) Contrainte nulle dans la direction axiale
   
   La trace des contraintes conduit à une pression hydrostatique positive.
   Les équations du modèle analytique doivent donc être adaptées en conséquence.
   Les résultats sont alors en très bon accord entre la solution analytique et Code_Aster.
   
   Néanmoins il existe une différence sur l'évolution de la déformation sphérique
   irréversible lors de cet essai, remarquée initialement par JLF (H-T64-2008-04592). 
   
   III) Traitement proposé pour lever l'anomalie des sources
   ---------------------------------------------------------
   III.1) Probleme relevé
   ----------------------
   Sous un chargement de traction, le modèle UMLV prédit anormalement une évolution négative
   (compression) de la déformation sphérique irréversible. Cette évolution se stabilise
   rapidement et se limite à des valeurs de déformation de 10^-6 (pour l'exemple considéré
   (Béton de Civaux sous charge de 1MPa)).
   
   III.2) Mise en défaut des sources actuelles
   -------------------------------------------
   Le seuil de déclenchement des déformations sphériques irréversibles est piloté
   actuellement dans les sources uniquement par un test sur le signe de cette évolution
   discrétisée. La précision du schéma numérique est mise en défaut et converge vers une
   valeur non nulle des déformations sphériques irréversibles - solution contraire à la théorie.
   
   III.3) Solution proposée
   ------------------------
   Au delà du signe de l'évolution de la déformation sphérique irréversible, c'est la prise
   en compte d'un fluage irréversible en état de contraintes de traction qui pose question.
   En effet, le modèle original de Benboudjema apparaît adapté uniquement pour les
   chargements conduisant à un état de compression. 
   Je suis donc partisan de restreindre l'évolution des déformations sphériques irréversibles
   aux états de contraintes en compression seulement. 
   On se prémunit ainsi de toute dérive de cette quantité dans le cas d'un chargement alterné
   par exemple.
   
   III.4) Impact source
   --------------------
   Impact source limité à lcumsf.f - ligne 230 
             IF ((SIGFSP/VISP.GT.-R8PREM()).AND.
        &        (SIGISP/VISP.GT.-R8PREM())) THEN
               ISPH = 2
               GOTO 60
             ENDIF
   avec normalisation des contraintes par la viscosité sphérique irréversible.
   
   N.B.:Les développements futurs portés par CIWAP conduisent à revoir complètement cette
   partie du modèle, ce qui permettra à terme de revoir le schéma d'intégration.
   
   En PJ, je rajoute la comparaison des solutions Aster et analytiques pour l'étude de JLF,
   le cas-test ssnv163 sous modélisations AXIS et 3D, et un essai de traction pure . Les
   solutions de Aster sont très proches des solutions analytiques (Solutions Aster obtenues
   avec les développements précisés ci-dessus).
   
   III.5) Validation
   -----------------
   -)Restitution cas-test SSNA121A: Tube en béton soumis à une pression interne avec le
   modèle UMLV (issu de l'étude de JLF avec propriétés béton modifié pour publication externe)
   
   -)Impact sur les tests SSNV169D,E,F,G,H,I - Essais de traction en fluage avec prise en
   compte d'un couplage avec le modele de Mazars. Les resultats de non-regression sont tous
   modifies dans le cadre de ce couplage pour les etats de traction.
   Il n'existe pas de solutions de reference pour ces tests.
   Les temps physiques obtenus lors de ces essais de fluage avant rupture sont modifies comme
   suit :
   Modelisation D,G: 5960000 sec. -> 5593000 sec. (3D)
   Modelisation E,H: 7200000 sec. -> 6957000 sec. (D_PLAN)
   Modelisation F,I: 2500000 sec. -> 5250000 sec. (C_PLAN)
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 7.0.4
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 7.0.4
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : R7.01.06, V6.04.169, V6.01.121
VALIDATION
    SSNA121, SSNV169
NB_JOURS_TRAV  : 10.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 016470 DU 2011-02-24 08:33:27
TYPE anomalie concernant Documentation (VERSION *)
TITRE
    v3.04.147: Page de titre - Fascicule prxc3xa9cisxc3xa9 erronxc3xa9
FONCTIONNALITE
   Anomalie Doc V3.04.147:
   -----------------------
   Référence Fascicule erronée sur la page de titre
   
   Impact doc V: 
   -------------
   Suppression de la référence au fascicule
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V3.04.147
VALIDATION
    Documentaire
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR greffet      GREFFET Nicolas        DATE 03/07/2011 - 05:00:59

--------------------------------------------------------------------------------
RESTITUTION FICHE 016415 DU 2011-02-15 08:40:47
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    fdlv102a, fdlv104a plantage alxc3xa9atoire lors des restitutions
FONCTIONNALITE
   Cette fiche est résolue grâce à la fiche 16481.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    fdlv102a, fdlv104a
NB_JOURS_TRAV  : 0.05
--------------------------------------------------------------------------------
RESTITUTION FICHE 016481 DU 2011-02-25 08:39:01
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.3.15, le cas-test fdlv110a s'arrete anormalement sur Aster4.
FONCTIONNALITE
   Contexte
   --------
   
   Plantages aléatoires de fdlv110a et d'autres cas-tests type fdlv102a et 
   fdlv104a (cf. fiche 16415). Ces cas-test plantent dans CALC-MATR_AJOU.
   Sur fdlv110a on sait que le problème se produit dans l'arbre :
   TRPROT < VTCMBL < JEEXIN... Comme on le voit dans le traceback.
   Pas de résultat faux : ça marche ou ça plante.
   
   
   Analyse
   -------
   
   Si on veut reproduire l'erreur c'est assez dur, car ce cas-test plante 
   environ une fois sur 20 sur aster4 (que ce soit en batch ouy interactif). Le 
   mode debug ne change pas grand chose.
   Debug jeveux ne montre rien.
   J'ai ensuite tenté de vérifier les valeurs des variables transmises entres 
   les routines suspects et j'ai vu que certaines fois, la variable du nom de 
   champ en entrée de VTCMBL comportait des caractères bizarres après les 8 
   premiers caractères.
   J'ai ensuite tenté un valgrind qui a produit les messages suivants :
   ==31983== Use of uninitialised value of size 8
   ==31983==    at 0x7D51B6: jjcren_ (jjcren.f:79)
   ==31983==    by 0x7DC326: jjvern_ (jjvern.f:60)
   ==31983==    by 0x7CAFE0: jeexin_ (jeexin.f:59)
   ==31983==    by 0x50FDD7: vtcmbl_ (vtcmbl.f:141)
   ==31983==    by 0x50C46F: trprot_ (trprot.f:489)
   ==31983==    by 0x14FC320: calmdg_ (calmdg.f:227)
   ==31983==    by 0xFEC6DD: op0152_ (op0152.f:285)
   ...
   
   Ces deux indicateurs m'ont fait penser à une chaîne de caractères de 
   longueur incorrecte. Effectivement, VTCMBL attend un nom de champ de type 
   K19 :
   C IN  : NOMCH  : K19 : NOMS DES CHAM_GDS
   Alors que TRPROT lui fournit une variable K8 :
   CALL VTCMBL(2,TYPCST,CONST,TYPECH,NOMCH,'R',CHCOMB) avec NOMCH de type K8
   J'ai donc corrigé cela en passant en K19 dans TRPROT :
   CHARACTER*19  NOMCH(2)
   Suite à cette modification, le valgrind sur fdlv110a ne montre plus aucun 
   erreur dans CALC_MATR_AJOU.
   
   Pour valider j'ai lancé tous les cas-tests qui utilisent TRPROT (par le 
   biais des deux seules routines CALC_MATR_AJOU ou CALc_FORC_AJOU) :
   fdlv100a
   fdlv101a
   fdlv102a
   fdlv102b
   fdlv102c
   fdlv103a
   fdlv104a
   fdlv105a
   fdlv106a
   fdlv107a
   fdlv108a
   fdlv109a
   fdlv110a
   fdlv112a
   sdls105a
   sdls105b
   sdls107a
   
   Et j'ai relancé fdlv110a quelques dizaines de fois sans plantage.
   Cette fiche permet donc de clore la fiche 16415.
   
   Cette correction de TRPROT est à reporter en version 9 et c'est exactement 
   la même modification : passage de CHARACTER*8 à  CHARACTER*19 pour NOMCH(2).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    fdlv110a
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR lefebvre     LEFEBVRE Jean-Pierre   DATE 03/07/2011 - 01:48:14

--------------------------------------------------------------------------------
RESTITUTION FICHE 016476 DU 2011-02-24 10:44:11
TYPE express concernant Code_Aster (VERSION 9.1)
TITRE
    Rxc3xa9tablir la fonctionnalitxc3xa9 d'impression des catalogues d'xc3xa9lxc3xa9ments
FONCTIONNALITE
   En doublon avec la 16477
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    non
NB_JOURS_TRAV  : 0.001
--------------------------------------------------------------------------------
RESTITUTION FICHE 016416 DU 2011-02-15 10:35:13
TYPE evolution concernant agla (VERSION )
TITRE
    Bâton sur les cas-tests
FONCTIONNALITE
   Un message d'alarme est ajouté dans asverif/pre_eda/asrest lors de 
   la phase de vérification des fichiers de commandes, on compte le 
   nombre de lignes (hors commentaires et lignes blanches) et si ce 
   dernier dépasse 1000 on émet un message sur le modèle suivant :    
   
       (A/U-345): zzzz234a.comm contient plus de 1000 lignes, il faut 
   le reduire !
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    asverif sur zzzz234a
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 016394 DU 2011-02-10 09:36:11
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.3.12, le cas-test ssna117b n'est pas executxc3xa9 en MPI
FONCTIONNALITE
   Le test a été rajouté à la liste MPI (I) en version NEW10.3.15
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssna117b
NB_JOURS_TRAV  : 0.001
--------------------------------------------------------------------------------
RESTITUTION FICHE 016393 DU 2011-02-10 09:21:56
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.3.12, le cas-test wtnv136c s'arrete en erreur fatale sur Calibre 5.
FONCTIONNALITE
   Le test wtnv136c s'arrete en erreur fatale sur Calibre 5, c'est un test qui fait appel à
   PETSc, il ne peut donc fonctionner avec la version séquentielle. On le supprime de la
   liste de lancement des tests en filtrant la liste de tests dans le script astout_calibre5.sh.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sans objet
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------
RESTITUTION FICHE 016358 DU 2011-02-03 10:41:33
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW9.8.2, le cas-test sdld102a s'arrete en erreur fatale sur aster 4.
FONCTIONNALITE
   L'erreur obsvervée n'est pas reproductible, même en faisant varier la mémoire allouée à
   l'exécution, je propose donc de mettre sans suite cette fiche. 
   Effectivement, il reste des scories dans le répertoire des tests sous le nom sdld102a_pb
   (fichier du 03/12/2008), 
   ce fichier contient une version du fichier de commande sans les cartes copyright et modif.
   Il est présent dans toutes les versions du code (8,9 et 10), je le détruis.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sdld102a
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR colombo      COLOMBO Daniele        DATE 03/08/2011 - 02:03:37

--------------------------------------------------------------------------------
RESTITUTION FICHE 015271 DU 2010-06-30 09:51:45
TYPE evolution concernant Code_Aster (VERSION 9.1)
TITRE
    X-FEM: lissage des vitesses d'avancée de la fissure aux points du domaine dans PROPA_FISS
FONCTIONNALITE
   PROBLEME
   --------
   
   Dans le cas des méthodes upwind et simplexe de l'opérateur PROPA_FISS, souvent la
   simulation s'arrête en erreur fatale (XFEM_61) avant la mise à jour des level sets.
   L'erreur est émise par la routine xprls0.f, qui cherche les intersections entre l'iso-zéro
   de la level set et les éléments du maillage ou de la grille auxiliaire. Selon cette
   routine, une face d'un élément contient au moins 3 points d'intersection, ce qui ne peut
   pas être géré par X-FEM.
   
   Le problème viens du fait que le champ vitesse obtenu par extension de la vitesse de
   propagation de la fissure du fond aux points du domaine de calcul n'est pas toujours
   lisse.  Ce problème se manifeste seulement dans les cas 3D où le fond de la fissure est
   géométriquement compliqué (typiquement si le fond n'est pas une droite ou une ligne plane).
   
   On propose un changement de la routine xprvit.f qui s'occupe de cette extension de façon à
   lisser les vecteurs vitesse de propagation au long du fond de la fissure.
   
   
   METHODE ACTUELLE
   ----------------
   
   Le fond de la fissure est représenté par morceaux en connectant par des arêtes les points
   d'intersection du fond de la fissure (lsn=0 intersectée avec lst=0) avec les faces des
   éléments. En chacun de ces points on connaît la base locale (directions tangente et
   normale), la vitesse d'avancée de la fissure (calculée par CALC_G) et l'angle de
   bifurcation (calculé par CALC_G).
   
   À l'état actuel (voir doc R7.02.12), chaque point M du domaine est projeté en direction
   normale à chaque arête du fond et le point P projeté le plus proche au point M est
   sélectionné. La base locale au point P est calculée par une rotation d'Euler à partir des
   bases locales aux points d'extrémité de l'arête à laquelle le point P appartient. Le
   vecteur vitesse est interpolé au long de la même arête.
   
   
   PROBLEMES DANS LA VERSION ACTUELLE DE XPRVIT
   --------------------------------------------
   
   Dans ce processus, il y a trois erreurs (ils ne sont pas des «bugs» du code):
   
   1. la base locale au point P obtenue par la rotation d'Euler est différente de la base
   locale utilisée par le calcul du projeté P.
   Dans ce dernier cas, la direction tangente (axe t dans la doc R7.02.12) est normale à
   l'arête du fond considérée. Par contre, l'axe t de la base locale calculée au point P
   n'est pas forcement normale à l'arête. Cela signifie que le point P n'est pas le bon
   projeté du point M du domaine! En effet, la base locale est utilisée pour tous les calculs
   suivants et c'est elle qui donne la bonne direction tangente. L'algorithme de projection
   est donc incompatible avec la rotation d'Euler considérée pour le calcul de la base locale.
   
   2. l'algorithme de projection utilisé suppose que l'axe tangente de la base locale est
   toujours normale à l'arête considérée.
   Cela signifie que la direction tangente n'est pas continue entre deux arêtes consécutives
   en conséquence de l'angle que les deux forment. Pour chaque point S d'extrémité des arêtes
   du fond, on peut donc sélectionner une partie du domaine de calcul, qui s'ouvre à la façon
   d'un éventail à partir du point S, dans laquelle tombent tous les points qui ont le point
   S comme projection sur le fond. À ces points, la base locale et le vecteur vitesse de
   propagation du point S sont affectés. On retrouve donc dans le domaine de calcul des
   sous-domaines où la vitesse de propagation est constante. Cela n'a pas de sens physique.
   
   3. si on considère que la base locale obtenue par la rotation d'Euler est la bonne base au
   point projeté P, on s'attende que le vecteur vitesse au point P, qui est interpolé à
   partir des vecteurs vitesse aux points d'extrémité de l'arête, soit contenu dans le plan
   n-t défini par les axes normal et tangent de la base au point P. 
   Cela est actuellement obtenu en calculant les composantes Vn et Vt de la vitesse au point
   P par un produite scalaire entre le vecteur vitesse interpolé et les axes n et t de la
   base. À priori, si l'interpolation du vecteur vitesse est cohérente avec la rotation
   d'Euler de la base, les deux produits scalaires calculés ne sont pas nécessaire parce que
   le vecteur est déjà dans le plan n-t. Toutefois, l'interpolation utilisée est arbitraire
   (comme j'ai déclaré dans la doc R7.02.12) et elle n'est pas liée à la rotation d'Euler.
   
   
   SOLUTION
   --------
   
   On change l'algorithme de extension de la vitesse de la manière suivante:
   
   1.  on utilise toujours la rotation d'Euler déjà implémentée pour définir la base locale à
   chaque point du fond (discrétisé par arêtes). 
   Cela permet d'avoir un changement continu au long du fond de la fissure
   
   2. on utilise la direction de l'axe tangente de la base locale (obtenue par une rotation
   d'Euler) pour projeter un point M du domaine sur le fond.
   On dira donc que le point P sur une des arêtes qui forment le fond est le projeté du point
   M seulement si le point M est dans le plan formé par les axes tangent et normal de la base
   locale au point P obtenue par une rotation d'Euler.
   
   3. l'interpolation de la vitesse de propagation est faite indépendamment sur l'angle de
   bifurcation et sur la valeur de la vitesse et non plus sur le vecteur vitesse.
   En effet, aux points d'extrémité des arêtes du fond on connait seulement l'angle de
   bifurcation et la vitesse d'avancée. Une fois que l'angle et la vitesse ont été calculés
   au point P projeté, on utilisera la base locale au point (obtenue par une rotation
   d'Euler) pour calculer les composantes tangente et normale du vecteur vitesse de propagation.
   
   Le problème numérique lié à l'implémentation de cette solution est que le calcul de la
   projection du point P (point 2 ci-dessus) doit être fait par itérations successives. Une
   méthode de bissection est utilisée pour la recherche du point projeté à partir du point
   projeté en direction normale. Ce dernier est toujours proche à la solution cherchée, ce
   qui fait que la convergence de la méthode est toujours atteinte dans quelques itérations.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : R7.02.12
VALIDATION
    tests X-FEM+test SEB article publie'
NB_JOURS_TRAV  : 40.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 015649 DU 2010-09-30 17:29:01
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    X-FEM: amélioration de l'ergonomie et de la performance d'utilisation de la grille auxiliaire dans PROPA_FISS
FONCTIONNALITE
   Après la lecture du compte rendu AMA du stage de Laure Chappé (CR-AMA-10.222), je me suis
   rendu compte que la grille auxiliaire (opérateur PROPA_FISS) n'a pas été correctement
   utilisée. Cela est probablement causé à la fois d'un problème de clarté de la doc U de
   PROPA_FISS mais, au même temps, d'une mauvaise implémentation, au niveau utilisateur, de
   l'option grille auxiliaire pour les méthodes upwind et simplexe de PROPA_FISS.
   
   Je propose donc des évolutions du code pour rendre plus simple et logique pour
   l'utilisateur l'adoption d'une grille auxiliaire. Ces évolutions permettront aussi
   d'éviter mauvaises utilisations de la grille et d'améliorer la performance du code.
   
   
   ANALYSE DU PROBLEME
   -------------------
   
   Au présent, l'utilisation d'une grille auxiliaire doit forcement passer par les étapes
   suivantes:
   1. lecture/création du maillage de la grille, par exemple par LIRE_MAILLAGE
   2. création d'un modèle grille auxiliaire (par AFFE_MODELE)
   3. définition sur la grille (par DEFI_FISS_XFEM) de la même fissure initiale déjà  définie
   sur le modèle de la structure
   4. affectation au modèle du point 2 de la fissure définie au point 3 (par MODI_MODELE_XFEM)
   5. quand on propage la fissure par PROPA_FISS, on doit forcement passer la grille dans
   l'opérande GRILLE_AUX
   
   L'utilisateur ne comprends pas pourquoi il doit passer par toutes ces phases. De plus, il
   ne comprend pas où est le lien entre la fissure de la structure et la fissure de la
   grille. Cela est un problème si on utilise un modèle différent à chaque pas de
   propagation, comme dans le cas d'utilisation d'Homard. En conséquence, l'utilisateur peut
   commettre des erreurs dans l'utilisation de la grille et obtenir des résultats faux.
   
   De plus, chaque fissure doit utiliser forcement une grille différente, ce qui rende la
   chose encore moins claire.
   
   
   SOLUTION
   --------
   
   La grille auxiliaire est définie à partir d'un maillage par la nouvelle commande
   DEFI_GRILLE (op0082.f). Cette grille est utilisée pour la création d'un modèle grille par
   AFFE_MODELE en utilisant le nouveau mot-clé GRILLE. Le modèle grille est puis utilisé dans
   DEFI_FISS_XFEM pour associer univoquement la grille à la fissure en utilisant le nouveau
   mot-clé MODELE_GRILLE. L'utilisateur ne doit plus donner la grille dans PROPA_FISS (c'est
   Aster qui se prend en charge de récupérer la grille auxiliaire éventuellement associée à 
   la fissure à propager).
   
   Voici la séquence des commandes à utiliser:
   
   MaiGri = LIRE_MAILLAGE(...)
   Grille = DEFI_GRILLE(MAILLAGE=MaiGri)
   ModGri = AFFE_MODELE(GRILLE=Grille, ...)
   Fiss = DEFI_FISS_XFEM(MODELE=..., MODELE_GRILLE=ModGri, ...)
   
   Dans AFFE_MODELE, le mot-clé GRILLE est à utiliser à la place de MODELE quand on veut
   définir un modèle de grille. Rien change dans le fortran de AFFE_MODELE.
   Cette solution est plus claire pour l'utilisateur et permet de gagner en performance du
   code et de limiter la consommation de mémoire:
   a. la création d'un modèle X-FEM pour la grille auxiliaire (point 4 ci-dessus) n'est plus
   nécessaire
   b. actuellement PROPA_FISS analyse la grille auxiliaire pour établir la connexion des
   points de la grille selon trois directions d'une base locale. Cela est fait à chaque appel
   de l'opérateur, c'est-à-dire à chaque pas de propagation. Ces informations sont maintenant
   stockées dans la structure de données de la grille par DEFI_GRILLE.
   
   
   NOUVELLES SD
   -----------
   
   On a introduit une nouvelle sd_grille qui hérite la sd_maillage et ajoute en plus les
   informations de connexion des points de la grille:
   
   co_grille.py:
   class grille_sdaster(maillage_sdaster,sd_grille):
      pass
   
   sd_grille.py
   class sd_grille(sd_maillage):
        nomj = SDNom(fin=8)
        
        GRLR = AsVR()
        GRLI = AsVI()
   
   SD MODIFIEES
   ------------
   
   Les level sets et leur gradients sont stockés dans la sd_fiss_xfem de la fissure. Le
   modèle de la grille sur laquelle les level sets ont été calculées est stocké de la même
   manière.
   On modifie donc la sd_xfem en ajoutant les objets suivants:
   
       GRILLE_MODELE  = Facultatif(AsVK8(SDNom(nomj='.GRI.MODELE'),lonmax=1,))
       GRILLE_LNNO    = Facultatif(sd_cham_no(SDNom(nomj='.GRI.LNNO')))
       GRILLE_LTNO    = Facultatif(sd_cham_no(SDNom(nomj='.GRI.LTNO')))
       GRILLE_GRLNNO  = Facultatif(sd_cham_no(SDNom(nomj='.GRI.GRLNNO')))
       GRILLE_GRLTNO  = Facultatif(sd_cham_no(SDNom(nomj='.GRI.GRLTNO')))
   
   
   NOUVEAUX CAS-TEST
   -----------------
   
   Les cas-test X-FEM existants permettent de vérifier que la nouvelle séquence d'opérations
   marche bien. Toutefois, dans DEFI_FISS_XFEM on doit vérifier que chaque méthode disponible
   pour définir une fissure marche bien en présence d'une grille.
   Un nouveau cas test informatique zzzz282a a été introduit. Chaque méthode est utilisée
   pour définir une fissure en présence d'une grille. Le maillage de la grille est le même
   que celui de la structure. Cela signifie que à chaque noeuds, les level sets (et leur
   gradients) définies sur la grille sont les même que celles définies sur la structure. On
   compare donc les level sets et leur gradients entre maillage structure et grille en chaque
   noeuds: si la différence est égale à zéro, on passe le test.
   La même chose est faite pour les interfaces.
   
   IMPACT DOCUMENTATION
   --------------------
   
   DEFI_GRILLE: U4.24.02
   AFFE_MODELE: U4.41.01
   DEFI_FISS_XFEM: U4.82.08
   PROPA_FISS: U4.82.11
   
   SD_GRILLE: D4.06.01
   SD_FISS_XFEM: D4.10.02
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.41.01, U4.82.08, U4.82.11, D4.10.02
VALIDATION
    test X-FEM+zzzz282a
NB_JOURS_TRAV  : 15.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 015650 DU 2010-09-30 17:32:15
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    X-FEM: utilisation pour un modele 3D de Homard et PROPA_FISS avec grille auxiliaire
FONCTIONNALITE
   À l'état actuel l'utilisation d'Homard n'est pas possible pour un maillage sur lequel une
   fissure X-FEM avec grille auxiliaire est définie. 
   
   Homard permet de interpoler les level sets de la fissure sur le maillage raffiné. Ces
   level sets (champ_no) sont en suite utilisées dans DEFI_FISS_XFEM pour redéfinir la
   fissure sur le maillage raffiné. Toutefois on peut rien faire pour les level sets de la
   grille auxiliaire (la grille n'est pas raffiné par Homard).
   
   Après la restitution de la fiche 15649, le problème a été partiellement résolu:
   
   FissRaf=DEFI_FISS_XFEM(MODELE=ModRaf,
                          MODELE_GRILLE=ModGri,
   DEFI_FISS=_F(CHAM_NO_LSN=LSNraf,
                CHAM_NO_LST=LSTraf),
   …)
   
   Dans ce cas les champs level set LSNraf et LSTraf, défini sur le modèle raffiné ModRaf,
   sont projetées automatiquement par DEFI_FISS_XFEM sur la grille. Toutefois cette opération
   de projection est à la fois coûteux en temps de calcul et inutile.
   
   
   SOLUTION
   --------
   
   Les level sets de la grille auxiliaire ne changent pas avec le raffinement. De plus, le
   raffinement ne ajoute pas de précision à la représentation des level sets sur le maillage
   de la structure parce que les nouvelles level sets sont obtenues par interpolation. Avec
   la solution montrée ci-dessus on perde donc de précision dans la représentation des level
   sets sur la grille quand on va projeté les level sets du modèle raffiné à la grille parce
   que cette dernière est habituellement plus raffinée que le maillage initiale.
   Il faut donc garder les level sets de la grille entre le modèle grossier et celui raffiné.
   On modifie DEFI_FISS_XFEM pour donner la possibilité de maintenir la même grille et d'en
   copier les level sets entre la fissure initiale et celle définie sur le modèle raffiné.
   
   L'utilisateur a deux possibilités:
   
   1. il donne la fissure initiale (avant raffinement):
   
   FissRaf=DEFI_FISS_XFEM(MODELE=ModRaf,
                          DEFI_FISS=_F(CHAM_NO_LSN=LSNraf,
                                       CHAM_NO_LST=LSTraf),
                          DEFI_FISS_GRILLE=_F(FISSURE=fissure initiale),
                          …)
   
   Les level sets et leur gradients sont copiés de la fissure initiale à FissRaf. On garde la
   même grille auxiliaire que celle de la fissure initiale.
   
   2. il donne les champs level sets et gradients de la grille et le modèle grille:
   
   FissRaf=DEFI_FISS_XFEM(MODELE=ModRaf,
                          MODELE_GRILLE=ModGri,
                          DEFI_FISS=_F(CHAM_NO_LSN=LSNraf,
                                       CHAM_NO_LST=LSTraf),
                          DEFI_FISS_GRILLE=_F(CHAM_NO_LSN_GRILLE=LSNgr,
                                              CHAM_NO_LST_GRILLE=LSTgr,
                                              CHAM_NO_GRLSN_GRILLE=GLSNgr,
                                              CHAM_NO_GRLST_GRILLE=GLSTgr,),
                          …)
   
   Les champs LSNgr, LSTgr, GLSNgr et GLSTgr sont copié dans la sd_fiss_xfem de la nouvelle
   fissure FissRaf. La grille utilisée est ModGri.
   On vérifie que les champs passés sont défini sur ModGri.
   
   
   CAS-TEST
   --------
   
   Un nouveau cas test informatique zzzz283a a été introduit pour vérifier que les level sets
   de la grille sont bien préservées entre le modèle grossier et le modèle raffiné. La grille
   auxiliaire est toujours la même. Il suffit donc de vérifier que à chaque noeud de la
   grille les level sets et leur gradients ne changent pas entre modèle grossier et raffiné.
   
   
   IMPACT DOCUMENTATION
   --------------------
   
   DEFI_FISS_XFEM: U4.82.08
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.82.08
VALIDATION
    zzzz283a
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desroches    DESROCHES Xavier       DATE 03/08/2011 - 02:03:38

--------------------------------------------------------------------------------
RESTITUTION FICHE 016372 DU 2011-02-07 12:44:51
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Renommer la modelisation SHB8 en SHB
FONCTIONNALITE
   On renomme la modelisation SHB8 en SHB, du fait du développement d'autres 
   éléments que SHB8 pour cette modélisation.
   
   Réalisation : renommage dans affe_modele et dans le catalogue phenmode.
                 renommage dans  12 cas-tests (44 modélisations)
   sdls109h  ssls101c  ssls105c ssls108c ssls123a ssls124a 
   ssls125a  ssls129c  ssls133a ssns101a sns102a  ssns109a        
   
   Documentation : U3.12.05 U4.41.01 U4.81.01 U4.53.02
   V2.03.109 V3.03.101 V3.03.105 V3.03.108 V3.03.123 V3.03.124
   V3.03.125 V3.03.129 V3.03.133 V6.05.101 V6.05.102 V6.05.100
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U3.12.05 U4.41.01 U4.81.01 U4.53.02 V2.03.109 V3.03.101 V3.03.105 V3.03.108 V3.03.123 V3.03.124
VALIDATION
    liste restreinte
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 016236 DU 2011-01-20 10:44:31
TYPE anomalie concernant Code_Aster (VERSION 10.3)
TITRE
    Concept apparement existant signalé comme détruit/inexistant lors d'un MODI_REPERE
FONCTIONNALITE
   MODI_REPERE REPERE 'CYLINDRIQUE' on a l'erreur suivante :
   
   ! Objet JEVEUX inexistant dans les bases ouvertes : >&&MANOPG.CELMOD    .CELD< !
   !      l'objet n'a pas été créé ou il a été détruit                            
   
   En fait il n'y a pas d'erreur, mais simplement une incompatibilité de version 
   entre le job du début de l'étude (version 10.3.5) et le job poursuite (version 
   10.3.7).
   Or, entre les deux, il y a eu des changements de syntaxe d'options. En 
   particulier, l'option SIEF_ELGA_DEPL est devenue SIEF_ELGA.
   C'est pourquoi le job plante : il ne trouve pas l'option SIEF_ELGA sur les 
   éléments HEXA20 puisqu'elle n'était pas définie en 10.3.5.
   
   Il faut donc repasser l'étude depuis le début.
   
   A noter que l'utilisateur est prévenu par une alarme :
   
      !----------------------------------------------------------------!
      ! <A> <JEVEUX_08>                                                !
      !                                                                !
      ! La base  GLOBALE  a été constituée avec la version  10.03.05   !
      !  et vous utilisez la version  10.03.07                         !
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sans
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 016340 DU 2011-02-01 14:43:23
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Message alarme/erreur AFFE_CHAR_MECA
FONCTIONNALITE
   Demande : 
   
   Dans AFFE_CHAR_MECA mot-clé EPSI_INIT, si on utilise un mauvais mot clé  pour 
   désigner les composantes sur lesquelles on applique le chargement(EPXX à la 
   place de EXX par exemple sur des DKT), le calcul continue sans émettre de 
   message d'alarme ou d'erreur.
    Il pourrait être bien de créer un message du type : "la composante précisée 
   n'existe pas pour la modélisation considérée".
   
   Réponse :
   
   On pourrait émettre un message du type : "la composante précisée n'existe pas
   pour la modélisation considérée", à condition que la modélisation soit unique 
   sur tout le modèle. Dans le cas de plusieurs modélisations (cas de la fiche), 
   on ne sait pas faire dans AFFE_CHAR_MECA.
   
   Plus généralement, ce genre de vérification n'est actuellement pas fait dans 
   AFFE_CHAR_MECA (on peut se tromper de composantes dans les mot-clés sans 
   qu'Aster ne dise rien). Ces vérifications, si on décide de les faire, devraient 
   être faites au niveau des te, dans un cadre qui reste à définir, et ce pour 
   tous les mot-clés.
   
   Jacques ajoute : 
   "Je pense donc qu'il ne faut pas faire une vérification "dédiée" au mot clé 
   EPSI_INIT mais qu'il faudrait plutot réfléchir à un mécanisme général de 
   vérification des données d'une charge"
   
   On peut ajouter que dans le cas de EPSI_INIT, la doc de AFFE_CHAR_MECA est très 
   claire au sujet des composantes autorisées pour chaque modélisation. Il n'y a 
   donc pas urgence.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sans
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR mahjoubi     MAHJOUBI Najib         DATE 03/08/2011 - 02:03:39

--------------------------------------------------------------------------------
RESTITUTION FICHE 016492 DU 2011-02-25 10:06:25
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    X-FEM : Echec du contact pxc3xa9nalisxc3xa9 avec un maillage conforme xc3xa0 la fissure.
FONCTIONNALITE
   Anomalie :
   ---------
   Echec du contact pénalisé X-FEM avec un maillage conforme à 
   la fissure.
   
   Description :
   -------------
   Le test ssnv209k valide la formulation pénalisée du contact-frottement
   avec une interface X-FEM conforme au maillage. Si on utilise le stockage des
   DDL de contact aux noeuds sommets au lieu du stockage aux arêtes actuel, 
   le calcul échoue à la première itération en NEW10 sur Aster4 et Calibre5,
   sur un CALL ASSERT(.FALSE.)
   
   
   Explication :
   ------------
   La routine X-FEM xteddl.f, qui met à 0 les DDL enrichis à 
   tort, n'est implémentée que pour les matrices symétriques, 
   ce qui n'est pas le cas de la matrice de contact pénalisé. 
   On implémente donc cette mise à 0 pour le stockage
   non symétrique également. Le test tourne alors et produit
   les mêmes résultats qu'avec Lagranges aux arêtes.
   
   Validation :
   ------------
   Pour assurer la couverture de code de cette modification,
   on modifie le test ssnv209k pour utiliser un stockage des DDL
   de contact aux noeuds sommets.
   
   
   Impact sources :
   ---------------
   xteddl.f
   
   Impact documentaire :
   --------------------
   V6.04.209
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V6.04.209
VALIDATION
    autre aster
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR massin       MASSIN Patrick         DATE 03/08/2011 - 02:03:39

--------------------------------------------------------------------------------
RESTITUTION FICHE 014042 DU 2009-10-14 15:58:47
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    X-FEM : Crxc3xa9er le GROUP_MA contenant les xc3xa9lxc3xa9ments X-FEM coupxc3xa9s
FONCTIONNALITE
   Les développements envisagés dans cette fiche concernaient 
   la récupération du groupe des mailles intersectées au sens 
   large par une interface X-FEM, ce afin de pouvoir 
   renseigner le mot-clé GROUP_MA du pilotage par prédiction
   élastique en modélisation X-FEM.
   Ces développements ont été déjà effectués dans la fiche 
   13676. On modifie donc les tests ssnp133e,f,g et h afin que 
   le groupe de mailles pilotées ne soit plus défini 
   directement  dans le maillage mais extrait par 
   l'OPTION 'FISS_XFEM' et le TYPE_GROUP 'HEAVISIDE' de
   la commande DEFI_GROUP.
   
   On rend égalements les autres tests cohésifs X-FEM 
   (ssnp144) plus génériques en  extrayant le saut de 
   déplacement à patrir du maillage de visualisation, 
   à l'aide du groupe de noeuds créé par PREF_GROUP_CO sous le 
   mot-clé POST_MAIL_XFEM.
   
   Impact sources :
   ----------------
   
   CASTEST MODIF ssnp144a-l, ssnp133e-h
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    cas-test
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR meunier      MEUNIER Sébastien     DATE 03/07/2011 - 03:12:34

--------------------------------------------------------------------------------
RESTITUTION FICHE 016461 DU 2011-02-22 14:44:32
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    mxc3xa9nage arlequin
FONCTIONNALITE
   Le nom 'ARLEQUIN' est encore mentionné à plusieurs endroits dans le fortran.
   
   op0100.f:C 2.3. ==> ON VERIFIE QU'IL N'Y A PAS DE CHARGE ARLEQUIN DANS LE
   pjligr.f:C INSPIREE DES ROUTINES ARLEQUINS (ROUTINE ARLMOL)
   pjtyma.f:C CETTE ROUTINE EST INSPIREE DES ROUTINES ARLEQUIN
   
   Je supprime les commentaires et j'en profite pour nettoyer toutes les variables inutiles
   de ces routines.
   
   J'enlève également au passage le message XFEM_9 qui est inutilisé.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    liste restreinte
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 016425 DU 2011-02-15 16:26:48
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Plantage (segmentation fault) dans CREA_CHAMP
FONCTIONNALITE
   Anomalie
   ========
   
   On a un plantage en "segmentation fault" dans le CREA_CHAMP/ASSE suivant :
   
   SG_IN = CREA_CHAMP(
   	INFO = 2,
   	TYPE_CHAM = 'ELGA_SIEF_R',
          		OPERATION = 'ASSE',
          		MODELE    = MODELC,
          		ASSE      =( _F(
               GROUP_MA = ('ROCHE_2','HAUT','DERRIERE','GAUCHE','DROITE',), 
   		      #TOUT='OUI',
               CHAM_GD  = SG_NE,),),);
   
   Solution :
   ==========
   Le champ à assembler SG_NE s'appuie sur un maillage différent (HOM_4) du modèle
   courant (MODELC), qui s'appuie sur le maillage HOM_5. On avertit l'utilisateur de son erreur
   
      !----------------------------------------------------------------------------------------!
      ! <EXCEPTION> <CALCULEL4_59>                                                             !
      !                                                                                        !
      ! Erreur utilisateur :                                                                   !
      !  Les maillages associés aux concepts SG_NE et MODELC sont différents : HOM_4 et HOM_5. !
      !----------------------------------------------------------------------------------------!
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    Etude jointe + liste restreinte
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 016547 DU 2011-03-04 13:14:08
TYPE anomalie concernant Code_Aster (VERSION 10.3)
TITRE
    Anomalie PROJ_CHAMP('ELGA') - plantage sale dans pjcorr
FONCTIONNALITE
   Problème :
   =========
   
   J'ai eu sur ma machine un plantage sale dans le calcul de PJSIEF=PROJ_CHAMP('ELGA') au
   niveau de pjcorr l.113 sur l'instruction :
   
   CALL DETRSD('CHAM_ELEM',CEL2)
   
   CEL2 est un nom de SD qui n'est pas initialisé, ce qui peut engendrer des choses très
   bizarres : on ne sait pas ce qu'on détruit !
   
   Solution :
   ==========
   
   Je revois la programmation de la routine pjcorr.f. L'instruction l.113 est remplacé par
   les commandes :
   
   CEL2 = '&&PJCORR.CEL2'
   CALL ALCHML(LIGREL,OPTION,NOMPAR,'V',CEL2,IRET,' ')
   CALL CELCES(CEL2,'V',CES2)
   CALL DETRSD('CHAM_ELEM',CEL2)
   
   J'en profite pour enlever les variables inutiles et les arguments de pjcoor inutiles.
   
   Impact :
   ========
   pjcorr.f et pjelga.f
   
   Validation :
   ============
   Test joint
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    test joint
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR pellet       PELLET Jacques         DATE 03/08/2011 - 01:14:32

--------------------------------------------------------------------------------
RESTITUTION FICHE 016186 DU 2011-01-12 08:32:15
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    PROJ_CHAMP - suite fiche 16110
FONCTIONNALITE
   Problème:
   ==========
   Dans le test joint, l'utilisateur ne comprend pas l'alarme émise par la commande
   PROJ_CHAMP / COLLOCATION.
   Dans cette commande, on projette un résultat d'un maillage sur lui-même. Comment peut-on
   projeter des noeuds "un peu loin" ?
                                                                                            
                                                                                           
   PROJ_CHAMP (ou LIAISON_MAILLE) :
     Le noeud N487 de coordonnées (9.905300,0.014292,0.685500) est projeté à la distance 0.103962
     ...
                                                                                            
                                                                                           
   Comme on projette un maillage sur lui-meme, on s'attend à retrouver le champ initial.
                                                                                            
                                                                                           
                                                                                            
                                                                                           
   Analyse :
   =========
   Dans ce calcul (issu du test sslv200a), il y a en réalité 3 problèmes différents :
   PB1) Il y a un problème d'affichage : certains messages d'alarme ne sont pas justifiés.
   PB2) Il y a un problème de précision pour la projection sur certains noeuds milieux des
   éléments quadratiques du bord.
   PB3) Le maillage n'est pas "conforme" par endroits, ce qui entraine une imprécision de la
   projection.
                                                                                            
                                                                                           
   PB1 :
   =====
   Le problème vient du fait que les "alarmes" concernant la projection "un peu loin" sont
   émises lors de la 1ère étape de l'appariemment entre les noeuds du maillage "2" et les
   mailles du maillage "1" linéarisées et découpées en TRIA3 ou TETRA4.
                                                                                            
                                                                                           
   Si les mailles sont courbes, il peut arriver qu'un noeud "milieu" soit détecté à
   l'extérieur de l'élément linéarisé, ce qui peut entrainer l'émission du message d'alarme.
                                                                                            
                                                                                           
   Un autre cas est possible avec les HEXA27 :
   l'HEXA8 sous-jacent est découpé en 2 PENTA6. Puis ces 2 PENTA6 sont découpés chacun en 3
   TETRA4. Le découpage de ces 2 PENTA6 est indépendant et il y a une chance sur deux que le
   QUAD4 qui sépare les 2 PENTA6 soit découpé par les 2 diagonales différentes. Si le QUAD4
   est "gauche", ses 4 sommets déterminent un TETRA4 non dégénéré. Si le 27eme noeud de
   l'HEXA27 se retrouve à l'intérieur de ce TETRA4, il peut etre considéré comme extérieur
   aux 6 TETRA4 du découpage de HEXA27.
   On émet alors une alarme pour dire qu'un point est "extérieur" alors qu'en réalité, il est
   au coeur de l'HEXA27 !
                                                                                            
                                                                                           
   PB2 :
   =====
   Si on oublie les alarmes précédentes, on s'aperçoit qu'après la projection, certains
   noeuds ont "changé" de valeur.
   La raison est encore liée à l'appariemment en 2 étapes :
                                                                                            
                                                                                           
   étape 1 :
      linéarisation et découpage des mailles du maillage 1 en TETRA4
      boucle sur les noeuds INO2 :
        Choix du TETRA4 ima1T le plus proche de INO2
        Calcul des coordonnées barycentriques "grossières" (XG) de INO2 dans ima1V la "Vraie"
   maille "1" dont l'un des TETRA4 est ima1T
        Si INO2 est "extérieur" à ima1T => émission d'un message d'alarme
                                                                                            
                                                                                           
   étape 2 :
      boucle sur les noeuds INO2 :
        Si INO2 est bien "interieur" à ima1T :
          résolution du problème non linéaire pour trouver les coordonnées barycentriques
   "précises" (XP) de INO2 dans ima1V
        Sinon :
          on renonce à "affiner" les coordonnées barycentriques : (XP) = (XG)
                                                                                            
                                                                                           
   Les points pour lesquels la projection est imprécise sont ceux qui ont été considérés (à
   tort) comme extéreurs et pour lesquels on n'a pas "affiné" la position.
                                                                                            
                                                                                           
   PB3 :
   =====
   Après correction de PB2 (expliqué plus bas), on trouve encore 2 noeuds (N181 et N259) pour
   lesquels la projection est imprécise.
   Cette erreur est liée au fait que le maillage "1" est incorrect au sens des éléments
   finis. Il est "non-conforme".
                                                                                            
                                                                                           
   Par exemple, pour le noeud N181 :
    Topologiquement, ce noeud est un milieu d'arrete partagé par 2 PYRAM13 (M218 et M220).
    Mais il se trouve que 2 faces triangulaires de ces 2 PYRAM13 forment un quadrilatère qui
   sert de "base carrée" à un autre PYRAM13 (M213).
                                                                                            
                                                                                           
    Si l'on oublie la légère courbure des éléments, le quadrilatère peut etre représenté en
   "plan" par le dessin suivant :
                                                                                            
                                                                                           
   A.....B.....C
   !........./.!
   !......./...!
   D.....E.....F
   !.../.......!
   !./.........!
   G.....H.....I
                                                                                            
                                                                                           
     Les 2 triangles ABCEGD et GHIFCE sont les faces triangulaires de 2 pyramides maillant
   l'espace "derrière" le carré.
     Le quadrilatère GHIFCBAD est la base d'une pyramide maillant le "devant" du carré.
                                                                                            
                                                                                           
     L'incompabilité vient du fait que le déplacement de la face quadrangle n'a aucune raison
   d'etre le meme que celui des 2 faces triangles.
     Il s'agit donc d'un "mauvais" maillage pour faire des éléments finis.
                                                                                            
                                                                                           
     Concernant la projection, le problème vient du fait que le noeud E (N181) a été détecté
   comme inclus dans la pyramide M213 (ce qui est vrai à cause de la courbure des arretes).
   Il est meme légèrement "intérieur" à M213.
     Après projection, la valeur portée par ce noeud est donc interpolée à partir de celles
   de M213. Elle est donc incorrecte.
                                                                                            
                                                                                           
                                                                                            
                                                                                           
   Corrections :
   ==============
                                                                                            
                                                                                           
   PB3 :
   -----
   il n'y a rien à faire : il faut corriger le maillage pour le rendre conforme.
                                                                                            
                                                                                           
   PB2 :
   -----
   La correction proposée consiste à charcher à calculer (XP) systématiquement. Le risque est
   que la routine reereg.f ne converge pas lorsque le point est réellement extérieur à la
   maille ima1V. Mais comme on peut dire à la routine reereg de ne pas s'arreter en cas de
   non-convergence, le seul risque est de perdre du temps de calcul.
                                                                                            
                                                                                           
   A la sortie de reereg, on détermine (dans la nouvelle routine pjefmi) si la nouvelle
   estimation (XP) est meilleure que l'estimation grossière (XG). On poursuit les calculs
   avec la meilleure estimation (XG) ou (XP).
   Remarque : En réalité, comme on s'interdit d'extrapoler au dehors d'une maille, on ne
   considère le point (XP) que si il est réellement intérieur à la maille.
                                                                                            
                                                                                           
   PB1 :
   -----
   La correction consiste à ne pas émettre d'ALARME lors de la 1ere étape d'appariemment
   quand on sait que l'on va ensuite "raffiner" la position des points (c'est le cas des
   routines pj2dco.f et pj3dco.f).
   En revanche, dans les routines pj2dtr.f et pj3dtr.f, après avoir cherché les coordonnées
   (XP), il est facile de savoir si le noeud INO2 est extérieur à la maille IMA1 et si il est
   "loin" de IMA1.
   On émet alors une nouvelle alarme (CALCULEL5_7).
                                                                                            
                                                                                           
   Validation :
   ------------
   J'ai refait passer tous les tests qui "passent" dans les routines pj2dtr.f et pj3dtr.f.
   Pour certains tests "de Marie-Ange", je dois modifier les valeurs de référence
   (non-régression) car la projection a été un peu améliorée (prise en compte des points (XP)
   au lieu des (XG).
                                                                                            
                                                                                           
   Impact documentaire :
   ---------------------
   D4.06.30 : sd_corresp_2_mailla : suppression de l'objet .PJEF_AM devenu inutile.
                                                                                            
                                                                                           
                                                                                            
                                                                                           
                                                                                            
                                                                                           
   Liste des fichiers impactés par la correction de la fiche:  16186
     copisd.f  detrsd.f  pj2dco.f  pj2dtr.f  pj3dco.f  pj3dtr.f
     pj4dco.f  pjeflo.f  pjefmi.f
     calculel5.py            sd_corresp_2_mailla.py
     sslv200a.comm  sslv200b.comm   sslp200a.comm
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : D4.06.30
VALIDATION
    xc3xa9tude jointe + essais perso
NB_JOURS_TRAV  : 3.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 016187 DU 2011-01-12 09:15:38
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    PROJ_CHAMP - Erreur avec MATR_PROJECTION
FONCTIONNALITE
   Problème :
   ----------
   L'utilisateur écrit :
                                                                                            
                                                                                
     TEMP2=PROJ_CHAMP( PROJECTION='OUI', RESULTAT=RESU_00,
                      NOM_CHAM='SIEF_ELNO', MATR_PROJECTION=MATPROJ,
                      );
                                                                                            
                                                                                
   et le code s'arrete brutalement (erreur jeveux dans la routine cescel.f).
                                                                                            
                                                                                
   Analyse :
   ---------
   Le problème est que l'on cherche à projeter des champs par éléments.
   Pour cela, il faut disposer du nom du "modèle 2".
                                                                                            
                                                                                
   Malheureusement, meme si l'utilisateur a renseigné le mot clé MODELE_2 lors de la
   construction de la matrice de projection :
     MATPROJ=PROJ_CHAMP(METHODE='COLLOCATION',  MODELE_1=MODE_00, MODELE_2=MODE_00,
   PROJECTION='NON')
                                                                                            
                                                                                
   Cette information a été perdue (on stocke dans la sd MATPROJ le nom des maillages, mais
   pas le nom des modèles).
                                                                                            
                                                                                
   Du coup, il n'y a pas d'autre solution que de rajouter le mot clé MODELE_2 dans le 2eme
   appel à PROJ_CHAMP.
                                                                                            
                                                                                
   Corrections :
   -------------
   1) J'ajoute le mot clé MODELE_2 dans le catalogue de la commande lorsqu'on est en mode
   "réutilisation d'une matrice de projection".
   2) Si l'utilisateur veut projeter des cham_elem et qu'il a oublié de renseigner MODELE_2,
   on émet le message :
       !------------------------------------------------------------------------------!
       !.<F>.<CALCULEL4_73>...........................................................!
       !..............................................................................!
       !.Erreur.utilisateur.dans.la.commande.PROJ_CHAMP.:.............................!
       !....On.veut.projeter.des.champs.aux.éléments.(cham_elem),.le.mot.clé.MODELE_2.!
       !....est.alors.obligatoire.....................................................!
       !------------------------------------------------------------------------------!
   3) Je vérifie que le modele_2 fourni est cohérent avec le maillage_2 fourni lors de la
   création de la matrice de projection.
                                                                                            
                                                                                
   Validation :
   ------------
   J'ai vérifié que cela fonctionne bien sur l'étude fournie (y compris les messages d'erreurs).
                                                                                            
                                                                                
   Impact documentaire :
   ---------------------
   Mettre à jour la syntaxe de PROJ_CHAMP (U4.72.05).
    
    
   Liste des fichiers impactés par la correction de la fiche:  16187
     op0166.f  pjefch.f
     calculel4.py
     proj_champ.capy
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.72.05
VALIDATION
    xc3xa9tude fournie
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 016188 DU 2011-01-12 09:38:00
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    PROJ_CHAMP - Erreur avec MATR_PROJECTION (2)
FONCTIONNALITE
   Problème :
   ==========
    
   Dans le fichier joint, j'utilise PROJ_CHAMP de la manière suivante :
    
   MATPROJ=PROJ_CHAMP(METHODE='COLLOCATION',  MODELE_1=MODE_01, MODELE_2=MODE_01,
   PROJECTION='NON')
   S_0=CREA_CHAMP( OPERATION='EXTR', TYPE_CHAM='ELNO_SIEF_R',
                   RESULTAT=RESU_01, INST=400000.,
                            NOM_CHAM='SIEF_ELNO_ELGA' )
    
   TEMP2=PROJ_CHAMP(CHAM_GD=S_0, MATR_PROJECTION=MATPROJ)
    
   Je plante dans le calcul de TEMP2 de la manière suivante :
    
    
      !-----------------------------------------------------------------------!
      ! <F> <CALCULEL5_37>                                                    !
      !                                                                       !
      ! PROJ_CHAMP (ou LIAISON_MAILLE) :                                      !
      !   Vous cherchez à projeter un champ par élément (ELNO, ELEM ou ELGA). !
      !   Pour cela, il vous faut renseigner le mot-clé MODELE_2.             !
      !                                                                       !
      !                                                                       !
      ! Cette erreur est fatale. Le code s'arrete.                            !
      !-----------------------------------------------------------------------!
    
   Je ne comprends pas pourquoi et il est de toute façon impossible de renseigner le mot-clef
   MODELE_2
   dans le calcul de TEMP2.
                                                                                            
                           
                                                                                            
                           
   Réponse :
   ==========
   La réponse est la meme que pour la fiche 16187 : le nom du modèle 2 fourni lors de la
   création de la matrice de projection n'est pas conservé dans la matrice.
                                                                                            
                           
   Il faut donc redonner ce mot clé (MODELE_2) lors de la projection.
   Le mot clé est maintenant autorisé (réalisé dans le cadre de 16187).
                                                                                            
                           
   Cette fiche est donc sans suite.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    essai perso
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 016275 DU 2011-01-24 15:38:38
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Renommer hpla101c
FONCTIONNALITE
   Problème :
   ----------
   la modélisation C du cas test hpla101 n'a rien à voir avec les autres modélisations ; il
   faudrait en faire un cas test indépendant.
                                                                                            
                           
   Correction :
   ------------
   Le test est renommé zzzz284a
                                                                                            
                           
   Impact documentaire :  V1.01.284
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V1.01.284
VALIDATION
    zzzz184a
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 016480 DU 2011-02-24 15:52:27
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Plantage MACR_ECLA_PG sur plusieurs champs
FONCTIONNALITE
   Problème :
   -----------
   Dans le fichier joint, on utilise un seul MACR_ECLA_PG sur trois champs : EPSP_ELGA,
   VARI_ELGA et EPMG_ELGA.
                                                                                            
                           
   On plante salement avec l'erreur :
                                                                                            
                           
      !-------------------------------------------------------------------!
      ! <F> <JEVEUX_10>                                                   !
      !                                                                   !
      ! Erreur de programmation :                                         !
      !                                                                   !
      !  Le nom demandé existe déjà dans la base &&ECLPGM.CHAM_ELEM .CELD !
      !-------------------------------------------------------------------!
                                                                                            
                           
   Correction :
   ------------
   Il s'agit d'un bug de la routine eclpgm.f :
   On crée un cham_elem dans la boucle 30 mais on le détruit en dehors de la boucle.
   Ce problème est donc rencontré à chaque fois que l'on traite plusieurs champs dans
   MACR_ECLA_PG.
                                                                                            
                           
   La correction consiste à déplacer la destruction dans la boucle.
                                                                                            
                           
   Validation :
   ------------
   L'étude jointe va au bout
                                                                                            
                           
   NEW9 :  On peut reporter facilement cette correction en NEW9
   ------
    
    
   Liste des fichiers impactés par la correction de la fiche:  16480
     eclpgm.f
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    xc3xa9tude fournie
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 016534 DU 2011-03-03 13:38:32
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Utlisation de EVOL_IMPO en dehors de son intervalle de dxc3xa9finition
FONCTIONNALITE
   Problème rencontré par R. Fernandes :
   ---------------------------------------
   Quand on utilise AFFE_CHAR_CINE / EVOL_IMPO dans un calcul mécanique (ou thermique), le
   fortran de la routine calvci.f doit interpoler la valeur des ddls imposés pour les
   instants du calcul.
                                                                                            
                         
   Par prudence, le fortran interdit d'extrapoler en dehors de l'intervalle (tmin, tmax) de
   l'EVOL_IMPO. Pour cela, on utilise la routine rsinch.f avec PROLDR=PROLG1='EXCLU'
                                                                                            
                         
   Malheureusement, un bug de la routine rsinch.f laisse passer les extrapolations si
   l'EVOL_IMPO n'a qu'un seul instant de calcul.
                                                                                            
                         
                                                                                            
                         
   Corrections proposées :
   -----------------------
   1) On corrige rsinch.f pour interdire d'extrapoler meme s'il n'y a qu'un seul instant.
   2) Modification de calvci.f :
      * Si EVOL_IMPO a au moins 2 instants :
        on interdit les prolongements à gauche et à droite (EXCLU)
      * Si EVOL_IMPO n'a qu'un seul instant :
        on choisit PROLGA = PROLDR = 'CONSTANT' et on émet une alarme.
                                                                                            
                         
   Détails :
   ---------
   Je retire un "CALL IMPRSD" laissé par erreur dasn la routine charci.f
                                                                                            
                         
   Validation :
   ------------
   Essais perso pour vérifier les messages d'erreur ou d'alarme.
                                                                                            
                         
   Impact documentaire :
   ---------------------
   U4.44.03 : Dans la doc U de AFFE_CHAR_CINE / EVOL_IMPO, ajouter quelques précisions :
   1) Attention à ne pas utiliser plusieurs EVOL_IMPO sur des zones communes (sinon : cumul
   des valeurs imposées)
   2) Attention à l'usage de FONC_MULT avec EVOL_IMPO : le résultat n'est peut etre pas ce
   que l'on attend.
   3) L'EVOL_IMPO sera utilisé pour toute valeur du temps comprise entre tmin et tmax
   (valeurs extremes des instants du transitoire EVOL_IMPO). En dehors de cet intervalle, on
   émet une erreur fatale (extrapolation interdite).
      Mais si l'EVOl_IMPO n'a qu'un instant, on permet le prolongement "constant" et on émet
   une alarme.
    
    
   Liste des fichiers impactés par la correction de la fiche:  16534
     calvci.f  charci.f  rsinch.f
     calculel.py
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.44.03
VALIDATION
    essai perso
NB_JOURS_TRAV  : 0.4
--------------------------------------------------------------------------------
RESTITUTION FICHE 016552 DU 2011-03-07 06:59:10
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.3.16, les cas-tests sdld104a sdld104b et sdls112a s'arretent en erreur fatale sur Aster4, Calibre5 et Rocks.
FONCTIONNALITE
   C'est le meme problème que la fiche 16433.
   Quand j'ai "corrigé" la fiche 16433, j'ai oublié de restituer le catalogue des grandeurs
   modifié !
   
   Je recommence donc.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    tests incriminés
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 016525 DU 2011-03-03 09:35:31
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.3.16, le cas-test ssdlv125a et sdlv122a s'arretent en erreur fatale sur Aster4, Rocks et Calibre 5.
FONCTIONNALITE
   Problème :
   ----------
   En NEW10.3.16, le cas-test sdlv125a et sdlv122a s'arretent en erreur fatale sur toutes les
   plateformes.
   
   Analyse :
   ---------
   Il s'agit d'une conséquence de la fiche 16107 : on vérifie maintenant que le prof_chno
   utilisé dans LIRE_RESU est cohérent avec la grandeur du champ lu. Pour les 2 tests
   incriminés, ce n'est pas le cas, car on cherche à utiliser un prof_chno de "depl_r" pour
   "epsi_r" (ou "sief_r").
   
   
   Corrections :
   ------------
   Pour sdlv125a, j'ai commencé par corriger le test pour qu'il n'impose plus le NUME_DDL
   (comme je l'avais fait pour sdlv128a,b dans la fiche 16107).
   Mais cela ne suffit pas car la routine lrrefd.f retourne un prof_chno dès que l'on
   renseigne MATR_B (même si on n'utilise pas NUME_DDL).
   
   Je modifie lridea.f pour que le prof_chno obtenu par lrrefd ne soit utilisé que pour les
   champs DEPL, VITE et ACCE (puisqu'il provient d'un NUME_DDL)
   
   
   Validation :
   ------------
   Les 2 tests sont réparés.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    tests cassés
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR proix        PROIX Jean-Michel      DATE 03/07/2011 - 03:34:24

--------------------------------------------------------------------------------
RESTITUTION FICHE 016407 DU 2011-02-14 06:58:10
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.3.12, le cas-test ssna110a est NOOK sur Aster4, Rocks et Calibre5.
FONCTIONNALITE
   En NEW10.3.12, le cas-test ssna110a est NOOK sur Aster4, Rocks et Calibre5.
   Les tests NOOK sont les suivants:
   --------------------------------------------------------------------------------
          REFERENCE        LEGENDE          VALE_REF         VALE_CAL         ERREUR           
    NOOK NON_REGRESSION   XXXX             3.8732           3.8905           0.4%           
          REFERENCE        LEGENDE          VALE_REF         VALE_CAL         ERREUR    
    NOOK NON_REGRESSION   XXXX             466.56900        466.75805        0.0% 
   
   Ceci est dû à une petite modification en 10.3.12 dans le catalogue de COMP_INCR :
   la valeur par défaut de ITER_INTE_MAXI est maintenant de 20 au lieu de 10 auparavant.
   Il y a donc moins de redécoupages du pas de temps, d'où la légère variation sur les valeurs.
   Pour retrouver les anciennes valeurs, j'ajoute ITER_INTE_MAXI=10 dans ssna110a.3
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssna110a
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR geniaut      GENIAUT Samuel         DATE 03/07/2011 - 03:34:25

--------------------------------------------------------------------------------
RESTITUTION FICHE 016486 DU 2011-02-25 09:22:11
TYPE anomalie concernant Code_Aster (VERSION 10.4)
TITRE
    En NEW10.3.14, le cas-test sslp319c s'arrete en erreur fatale sur Aster4 et Calibre 5.
FONCTIONNALITE
   Problème :
   ---------
   
   En NEW10.3.14, le cas-test sslp319c s'arrete en erreur fatale sur Aster4 et Calibre 5.
   Dans CALC_G, pour le calcul de G à l'instant 0 car on cherche à calculer la fonction F0
   (FONC_MULT appliqué au chargement) alors que cette fonction n'est défini qu'à partir de
   l'instant 0,5.
   
   Cela est dû à l'archivage automatique de l'instant 0 dans STAT_NON_LINE.
   
   
   Solution :
   ----------
   
   En fait, on ne voit pas trop l'intérêt (à part une validation purement informatique de la
   gestion d'une liste d'instants pour PROPA_FISS) de faire un calcul STAT_NON_LINE sur les
   instants 0,5 et 1 puis un calcul de G sur tous les instants.
   En linéaire, il suffit de faire un seul calcul et d'utiliser dans PROPA_FISS             
       COMP_LINE=_F(COEF_MULT_MINI=0.,
                COEF_MULT_MAXI=1.),  
   
   De plus, à cause du coef multiplicateur, la charge à l'instant final est 2 fois pas grande
   que celle spécifiée dans la doc du cas test (§ réf).
   Du coup, cette modélisation a des valeurs de K 2 fois plus grandes que les autres
   modélisations, sans que cela soit expliqué dans la doc.
   
   C'est ce que l'on propose :
   - surpression de la fonction et de son application au chargement
   - restriction du calcul de G à l'instant 1s.
   - ajout de COMP_LINE dans PROPA_FISS      
   - mise en conformité avec les autres modélisations de la charge max appliquée (1 MPa) et
   utilisation de cette charge pour le calcul de la valeur de réf.
   
   
   Remarque : la gestion d'une liste d'instant pour le calcul du cycle dans PROPA_FISS n'est
   plus validée par aucun test. 
   
   Du coup, on fait au final les modifs suivantes :
   - surpression de la fonction et de son application au chargement
   - pas restriction du calcul de G (calcul aux instants 0 et 1s)
   - pas d'ajout de COMP_LINE dans PROPA_FISS      
   - mise en conformité avec les autres modélisations de la charge max appliquée (1 MPa) et
   utilisation de cette charge pour le calcul de la valeur de réf.
   
   Ainsi, on calcule G aux instants 0 et 1s, et PROPA_FISS reçoit en entrée une table
   contenant une liste d'instants. Le calcul du cycle est validé pour la méthode MAILLAGE.
   
   
   impact :
   sslp319c.comm
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V3.02.119
VALIDATION
    sslp319c
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR sellenet     SELLENET Nicolas       DATE 03/08/2011 - 01:21:18

--------------------------------------------------------------------------------
RESTITUTION FICHE 016512 DU 2011-03-02 07:42:33
TYPE express concernant Code_Aster (VERSION 9.1)
TITRE
    Cartes responsable routines MED
FONCTIONNALITE
   Restitution :
   -------------
   Etant donné qu'il a été décidé de repousser l'introduction de MED3.0, je vais dors et déjà
   restituer les routines MED en modifiant la carte responsable afin de pouvoir suivre les
   modifications éventuelles des routines.
   
   Je note donc les routines IMPR_RESU et LIRE_RESU au format MED ainsi que les routines
   fortran 90 enveloppes des routines MED.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    aucune
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------
RESTITUTION FICHE 016310 DU 2011-01-27 15:02:07
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Erreur bibilothxc3xa8que MED (NEW10_mpi)
FONCTIONNALITE
   La fiche issue16092 traite effectivement du même problème. Il n'est pas possible
   d'utiliser MED en MPI sur Calibre 5. De mon côté je n'ai pas les droits pour modifier le
   config.txt de la version MPI Calibre5 et recompiler.
   
   Je classe donc la fiche. Le problème devrait être résolu dans le cadre de la fiche issue16092.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    test unitaire perso
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST AJOUT ssna121a                     foucault A.FOUCAULT         240    240      0
 CASTEST AJOUT zzzz282a                       massin P.MASSIN           478    478      0
 CASTEST AJOUT zzzz283a                       massin P.MASSIN           534    534      0
 CASTEST AJOUT zzzz284a                       pellet J.PELLET           219    219      0
 CASTEST MODIF miss06b                         abbas M.ABBAS            820      1      1
 CASTEST MODIF miss06c                         abbas M.ABBAS            818      1      1
 CASTEST MODIF sdls109h                       massin P.MASSIN           179      4      4
 CASTEST MODIF sdlv125a                       pellet J.PELLET           509      1      2
 CASTEST MODIF sdnv107a                        abbas M.ABBAS            660      2      2
 CASTEST MODIF sdnv107b                        abbas M.ABBAS            470      2      2
 CASTEST MODIF sdnv107c                        abbas M.ABBAS            927      1      1
 CASTEST MODIF sslp200a                       pellet J.PELLET          1469     13     13
 CASTEST MODIF sslp315c                       massin P.MASSIN           306     17     23
 CASTEST MODIF sslp315e                       massin P.MASSIN           306     17     23
 CASTEST MODIF sslp319c                        proix J-M.PROIX          284     16     15
 CASTEST MODIF sslp320c                       massin P.MASSIN           250      5     16
 CASTEST MODIF ssls101c                       massin P.MASSIN           451      2      2
 CASTEST MODIF ssls101d                       massin P.MASSIN           392      3      3
 CASTEST MODIF ssls101k                       massin P.MASSIN           359      2      2
 CASTEST MODIF ssls101l                       massin P.MASSIN           419      2      2
 CASTEST MODIF ssls105c                       massin P.MASSIN            88      2      2
 CASTEST MODIF ssls108c                       massin P.MASSIN           116      2      2
 CASTEST MODIF ssls108d                       massin P.MASSIN           115      2      2
 CASTEST MODIF ssls108e                       massin P.MASSIN           132      2      2
 CASTEST MODIF ssls108f                       massin P.MASSIN           113      2      2
 CASTEST MODIF ssls108g                       massin P.MASSIN           112      2      2
 CASTEST MODIF ssls108h                       massin P.MASSIN           113      2      2
 CASTEST MODIF ssls123a                       massin P.MASSIN            87      2      2
 CASTEST MODIF ssls123c                       massin P.MASSIN            97      2      2
 CASTEST MODIF ssls123d                       massin P.MASSIN            85      2      2
 CASTEST MODIF ssls124a                       massin P.MASSIN           530      6      6
 CASTEST MODIF ssls124b                       massin P.MASSIN           341      8      8
 CASTEST MODIF ssls124c                       massin P.MASSIN           290      5      5
 CASTEST MODIF ssls124d                       massin P.MASSIN           289      5      5
 CASTEST MODIF ssls124e                       massin P.MASSIN           231      5      5
 CASTEST MODIF ssls124f                       massin P.MASSIN           289      5      5
 CASTEST MODIF ssls124g                       massin P.MASSIN           253      4      4
 CASTEST MODIF ssls125a                       massin P.MASSIN           156      2      2
 CASTEST MODIF ssls125b                       massin P.MASSIN           155      2      2
 CASTEST MODIF ssls125c                       massin P.MASSIN           155      2      2
 CASTEST MODIF ssls125d                       massin P.MASSIN           139      2      2
 CASTEST MODIF ssls129c                       massin P.MASSIN           707      3      3
 CASTEST MODIF ssls133a                       massin P.MASSIN           162      2      2
 CASTEST MODIF ssls133b                       massin P.MASSIN           101      2      2
 CASTEST MODIF ssls133c                       massin P.MASSIN           103      2      2
 CASTEST MODIF ssls133d                       massin P.MASSIN            95      2      2
 CASTEST MODIF sslv200a                       pellet J.PELLET          1101     16     16
 CASTEST MODIF sslv200b                       pellet J.PELLET          1061      4      4
 CASTEST MODIF sslv316b                       massin P.MASSIN           297     14     46
 CASTEST MODIF sslv316d                       massin P.MASSIN           297     14     46
 CASTEST MODIF sslv316f                       massin P.MASSIN           298     14     46
 CASTEST MODIF sslv316h                       massin P.MASSIN           298     14     46
 CASTEST MODIF ssna110a                        proix J-M.PROIX         2117      2      2
 CASTEST MODIF ssnp133e                       massin P.MASSIN           296     17      8
 CASTEST MODIF ssnp133f                       massin P.MASSIN           305     10      2
 CASTEST MODIF ssnp133g                       massin P.MASSIN           309      9      2
 CASTEST MODIF ssnp133h                       massin P.MASSIN           294     15      8
 CASTEST MODIF ssnp144a                       massin P.MASSIN           516     93     65
 CASTEST MODIF ssnp144b                       massin P.MASSIN           519    103     73
 CASTEST MODIF ssnp144c                       massin P.MASSIN           536    102     63
 CASTEST MODIF ssnp144d                       massin P.MASSIN           535    103     63
 CASTEST MODIF ssnp144e                       massin P.MASSIN           527    105     66
 CASTEST MODIF ssnp144f                       massin P.MASSIN           529    107     68
 CASTEST MODIF ssnp144g                       massin P.MASSIN           524    105     67
 CASTEST MODIF ssnp144h                       massin P.MASSIN           526    105     79
 CASTEST MODIF ssnp144i                       massin P.MASSIN           519    107     74
 CASTEST MODIF ssnp144j                       massin P.MASSIN           520    103     74
 CASTEST MODIF ssnp144k                       massin P.MASSIN           512    103     73
 CASTEST MODIF ssnp144l                       massin P.MASSIN           318     46     35
 CASTEST MODIF ssns101a                       massin P.MASSIN           351      4      4
 CASTEST MODIF ssns101b                       massin P.MASSIN           245      3      3
 CASTEST MODIF ssns101c                       massin P.MASSIN           311      2      2
 CASTEST MODIF ssns101d                       massin P.MASSIN           309      2      2
 CASTEST MODIF ssns101e                       massin P.MASSIN           308      2      2
 CASTEST MODIF ssns101f                       massin P.MASSIN           309      2      2
 CASTEST MODIF ssns101g                       massin P.MASSIN           307      2      2
 CASTEST MODIF ssns102a                       massin P.MASSIN           324      2      2
 CASTEST MODIF ssns102b                       massin P.MASSIN           311      2      2
 CASTEST MODIF ssns109a                       massin P.MASSIN           333      3      3
 CASTEST MODIF ssns109b                       massin P.MASSIN           332      3      3
 CASTEST MODIF ssns109c                       massin P.MASSIN           332      3      3
 CASTEST MODIF ssns109d                       massin P.MASSIN           332      3      3
 CASTEST MODIF ssnv128a                        abbas M.ABBAS            497      2      2
 CASTEST MODIF ssnv169d                     foucault A.FOUCAULT         224     12     12
 CASTEST MODIF ssnv169e                     foucault A.FOUCAULT         243     12     17
 CASTEST MODIF ssnv169f                     foucault A.FOUCAULT         242     14     12
 CASTEST MODIF ssnv169g                     foucault A.FOUCAULT         230     12     12
 CASTEST MODIF ssnv169h                     foucault A.FOUCAULT         246     11     17
 CASTEST MODIF ssnv169i                     foucault A.FOUCAULT         241     13     12
 CASTEST MODIF ssnv204a                        abbas M.ABBAS            627      1      1
 CASTEST MODIF ssnv209k                       massin P.MASSIN           498     13     28
 CASTEST MODIF zzzz159b                        abbas M.ABBAS            120      1      1
 CASTEST SUPPR hpla101c.comm                  pellet J.PELLET           185      0    185
CATALOGU MODIF compelem/grandeur_simple__     pellet J.PELLET          2121     17     11
CATALOGU MODIF compelem/phenomene_modelisation__     massin P.MASSIN          1727      2      2
CATALOPY AJOUT commande/defi_grille           massin P.MASSIN            27     27      0
CATALOPY MODIF commande/affe_modele           massin P.MASSIN           276      5      4
CATALOPY MODIF commande/crea_champ            massin P.MASSIN           210      9      4
CATALOPY MODIF commande/defi_fiss_xfem        massin P.MASSIN           191     25      2
CATALOPY MODIF commande/lire_resu             pellet J.PELLET           296      4      3
CATALOPY MODIF commande/proj_champ            pellet J.PELLET           288      8      5
CATALOPY MODIF commande/propa_fiss            massin P.MASSIN           157      1      3
CATALOPY MODIF commande/propa_xfem            massin P.MASSIN            69      2      4
CATALOPY MODIF entete/accas                   massin P.MASSIN           226      3      2
 FORTRAN AJOUT calculel/pjeflo                pellet J.PELLET           242    242      0
 FORTRAN AJOUT calculel/pjefmi                pellet J.PELLET           107    107      0
 FORTRAN AJOUT modelisa/op0082                massin P.MASSIN           112    112      0
 FORTRAN MODIF algorith/bamo78                 abbas M.ABBAS            402     11     10
 FORTRAN MODIF algorith/lcumsf              foucault A.FOUCAULT         292     11      3
 FORTRAN MODIF algorith/macr78                 abbas M.ABBAS            268     26      6
 FORTRAN MODIF algorith/op0010                massin P.MASSIN           843    157    305
 FORTRAN MODIF algorith/op0041                massin P.MASSIN           567    227      9
 FORTRAN MODIF algorith/op0078                 abbas M.ABBAS             94      9     24
 FORTRAN MODIF algorith/op0166                pellet J.PELLET           389     15      3
 FORTRAN MODIF algorith/pjelga               meunier S.MEUNIER          127      7     28
 FORTRAN MODIF algorith/trprot               greffet N.GREFFET          561      4      4
 FORTRAN MODIF algorith/xgrals                massin P.MASSIN           112      9      8
 FORTRAN MODIF algorith/xinils                massin P.MASSIN           270     59     13
 FORTRAN MODIF algorith/xls2d                 massin P.MASSIN           278     19     13
 FORTRAN MODIF algorith/xls3d                 massin P.MASSIN           350     31     24
 FORTRAN MODIF algorith/xprcnu                massin P.MASSIN           592     51     24
 FORTRAN MODIF algorith/xprdom                massin P.MASSIN           447      4      6
 FORTRAN MODIF algorith/xprini                massin P.MASSIN           271     26     17
 FORTRAN MODIF algorith/xprls                 massin P.MASSIN           316      4      5
 FORTRAN MODIF algorith/xprls0                massin P.MASSIN           770      4      5
 FORTRAN MODIF algorith/xprrei                massin P.MASSIN           577      5      6
 FORTRAN MODIF algorith/xprreo                massin P.MASSIN           585      4      5
 FORTRAN MODIF algorith/xprtor                massin P.MASSIN           678     39     24
 FORTRAN MODIF algorith/xprupw                massin P.MASSIN           626     14     16
 FORTRAN MODIF algorith/xprvit                massin P.MASSIN           827    163     97
 FORTRAN MODIF calculel/eclpgm                pellet J.PELLET           400      2      2
 FORTRAN MODIF calculel/op0100               meunier S.MEUNIER         1100      3     17
 FORTRAN MODIF calculel/pj2dco                pellet J.PELLET           316      9     31
 FORTRAN MODIF calculel/pj2dtr                pellet J.PELLET           260     39     25
 FORTRAN MODIF calculel/pj3dco                pellet J.PELLET           403      6     30
 FORTRAN MODIF calculel/pj3dtr                pellet J.PELLET           321     32     27
 FORTRAN MODIF calculel/pj4dco                pellet J.PELLET           343      6      6
 FORTRAN MODIF calculel/pjcorr               meunier S.MEUNIER          205     19     27
 FORTRAN MODIF calculel/pjefch                pellet J.PELLET           131      3      2
 FORTRAN MODIF calculel/pjligr               meunier S.MEUNIER          209      7     13
 FORTRAN MODIF calculel/pjma2p               meunier S.MEUNIER          269      5     10
 FORTRAN MODIF calculel/pjtyma               meunier S.MEUNIER          108      6     28
 FORTRAN MODIF elements/te0535                flejou J-L.FLEJOU         334     72    105
 FORTRAN MODIF elements/xteddl                massin P.MASSIN           279     12      5
 FORTRAN MODIF modelisa/charci                pellet J.PELLET           309      1      2
 FORTRAN MODIF modelisa/chprec                massin P.MASSIN           306     30      3
 FORTRAN MODIF modelisa/lrmdes              sellenet N.SELLENET         148      3      3
 FORTRAN MODIF modelisa/lrmhdf              sellenet N.SELLENET         309      3      3
 FORTRAN MODIF modelisa/lrmmdi              sellenet N.SELLENET         184      3      3
 FORTRAN MODIF modelisa/lrmmeq              sellenet N.SELLENET          77      3      3
 FORTRAN MODIF modelisa/lrmmf1              sellenet N.SELLENET         209      3      3
 FORTRAN MODIF modelisa/lrmmf2              sellenet N.SELLENET         144      3      3
 FORTRAN MODIF modelisa/lrmmf3              sellenet N.SELLENET         462      3      3
 FORTRAN MODIF modelisa/lrmmfa              sellenet N.SELLENET         284      3      3
 FORTRAN MODIF modelisa/lrmmma              sellenet N.SELLENET         311      3      3
 FORTRAN MODIF modelisa/lrmmno              sellenet N.SELLENET         230      3      3
 FORTRAN MODIF modelisa/op0018                massin P.MASSIN           611      3      2
 FORTRAN MODIF prepost/desgfa               sellenet N.SELLENET         150      3      3
 FORTRAN MODIF prepost/ircam1               sellenet N.SELLENET         367      3      3
 FORTRAN MODIF prepost/irceme               sellenet N.SELLENET         129      3      3
 FORTRAN MODIF prepost/irchme               sellenet N.SELLENET         293      2      2
 FORTRAN MODIF prepost/ircmcc               sellenet N.SELLENET         131      3      3
 FORTRAN MODIF prepost/ircmec               sellenet N.SELLENET         217      3      3
 FORTRAN MODIF prepost/ircmpf               sellenet N.SELLENET         287      3      3
 FORTRAN MODIF prepost/ircmpn               sellenet N.SELLENET         246      3      3
 FORTRAN MODIF prepost/ircnme               sellenet N.SELLENET         128      3      3
 FORTRAN MODIF prepost/irmhdf               sellenet N.SELLENET         293      3      3
 FORTRAN MODIF prepost/irmmeq               sellenet N.SELLENET          83      3      3
 FORTRAN MODIF prepost/irmmf1               sellenet N.SELLENET         216      3      3
 FORTRAN MODIF prepost/irmmf2               sellenet N.SELLENET         389      3      3
 FORTRAN MODIF prepost/irmmfa               sellenet N.SELLENET         221      3      3
 FORTRAN MODIF prepost/irmmma               sellenet N.SELLENET         337      3      3
 FORTRAN MODIF prepost/irmmno               sellenet N.SELLENET         209      3      3
 FORTRAN MODIF prepost/irmpg1               sellenet N.SELLENET         457      3      3
 FORTRAN MODIF prepost/irmpga               sellenet N.SELLENET         303      3      3
 FORTRAN MODIF prepost/lrcame               sellenet N.SELLENET         622      3      3
 FORTRAN MODIF prepost/lrceme               sellenet N.SELLENET         302      3      3
 FORTRAN MODIF prepost/lrchme               sellenet N.SELLENET         126      3      3
 FORTRAN MODIF prepost/lrcmle               sellenet N.SELLENET         118      3      3
 FORTRAN MODIF prepost/lrcmpr               sellenet N.SELLENET         137      3      3
 FORTRAN MODIF prepost/lrcmva               sellenet N.SELLENET         282      3      3
 FORTRAN MODIF prepost/lrcmve               sellenet N.SELLENET         339      3      3
 FORTRAN MODIF prepost/lrcnme               sellenet N.SELLENET         162      3      3
 FORTRAN MODIF prepost/lrfmed               sellenet N.SELLENET         316      3      2
 FORTRAN MODIF prepost/lridea                 pellet J.PELLET           533     13      8
 FORTRAN MODIF prepost/lrmpga               sellenet N.SELLENET         323      3      2
 FORTRAN MODIF prepost/lrrefd                 pellet J.PELLET           111     14     13
 FORTRAN MODIF prepost/lrvcpg               sellenet N.SELLENET         270      3      2
 FORTRAN MODIF prepost/mdchii               sellenet N.SELLENET         294      3      3
 FORTRAN MODIF prepost/mdchin               sellenet N.SELLENET          97      3      3
 FORTRAN MODIF prepost/mdexcc               sellenet N.SELLENET         247      3      3
 FORTRAN MODIF prepost/mdexch               sellenet N.SELLENET         141      3      3
 FORTRAN MODIF prepost/mdexcv               sellenet N.SELLENET         124      3      3
 FORTRAN MODIF prepost/mdexma               sellenet N.SELLENET         178      3      3
 FORTRAN MODIF prepost/mdexpm               sellenet N.SELLENET         143      3      3
 FORTRAN MODIF prepost/mdnoch               sellenet N.SELLENET         154      3      3
 FORTRAN MODIF prepost/mdnofa               sellenet N.SELLENET         150      3      3
 FORTRAN MODIF prepost/mdnoma               sellenet N.SELLENET         115      3      3
 FORTRAN MODIF prepost/op0039               sellenet N.SELLENET        1009      3      2
 FORTRAN MODIF supervis/ib0mai              sellenet N.SELLENET         115      2      2
 FORTRAN MODIF utilitai/copisd                pellet J.PELLET           425      2      3
 FORTRAN MODIF utilitai/detrsd                pellet J.PELLET           660      2      3
 FORTRAN MODIF utilitai/op0150                pellet J.PELLET           472      4      4
 FORTRAN MODIF utilitai/op0195               meunier S.MEUNIER          324     12      4
 FORTRAN MODIF utilitai/rsinch                pellet J.PELLET           268     20      3
 FORTRAN MODIF utilitai/uteref              sellenet N.SELLENET         326      2      2
FORTRAN90 MODIF echange/mfchac               sellenet N.SELLENET          43      3      2
FORTRAN90 MODIF echange/mfchai               sellenet N.SELLENET          44      3      2
FORTRAN90 MODIF echange/mfchre               sellenet N.SELLENET          60      3      2
FORTRAN90 MODIF echange/mfchrl               sellenet N.SELLENET          60      3      2
FORTRAN90 MODIF echange/mfcone               sellenet N.SELLENET          62      3      2
FORTRAN90 MODIF echange/mfconl               sellenet N.SELLENET          71      3      2
FORTRAN90 MODIF echange/mfcooe               sellenet N.SELLENET          58      3      2
FORTRAN90 MODIF echange/mfcool               sellenet N.SELLENET          54      3      2
FORTRAN90 MODIF echange/mffamc               sellenet N.SELLENET          50      3      2
FORTRAN90 MODIF echange/mffame               sellenet N.SELLENET          45      3      2
FORTRAN90 MODIF echange/mffami               sellenet N.SELLENET          61      3      2
FORTRAN90 MODIF echange/mffaml               sellenet N.SELLENET          53      3      2
FORTRAN90 MODIF echange/mfferm               sellenet N.SELLENET          40      3      2
FORTRAN90 MODIF echange/mffide               sellenet N.SELLENET          41      3      2
FORTRAN90 MODIF echange/mffien               sellenet N.SELLENET          42      3      2
FORTRAN90 MODIF echange/mffoco               sellenet N.SELLENET          39      3      2
FORTRAN90 MODIF echange/mfgaue               sellenet N.SELLENET          48      3      2
FORTRAN90 MODIF echange/mfgaui               sellenet N.SELLENET          44      3      2
FORTRAN90 MODIF echange/mfgaul               sellenet N.SELLENET          43      3      2
FORTRAN90 MODIF echange/mflfde               sellenet N.SELLENET          41      3      2
FORTRAN90 MODIF echange/mfmaac               sellenet N.SELLENET          44      3      2
FORTRAN90 MODIF echange/mfmaai               sellenet N.SELLENET          45      3      2
FORTRAN90 MODIF echange/mfnatt               sellenet N.SELLENET          43      3      2
FORTRAN90 MODIF echange/mfncha               sellenet N.SELLENET          42      3      2
FORTRAN90 MODIF echange/mfnema               sellenet N.SELLENET          49      3      2
FORTRAN90 MODIF echange/mfnfam               sellenet N.SELLENET          43      3      2
FORTRAN90 MODIF echange/mfngau               sellenet N.SELLENET          41      3      2
FORTRAN90 MODIF echange/mfngro               sellenet N.SELLENET          43      3      2
FORTRAN90 MODIF echange/mfnmaa               sellenet N.SELLENET          41      3      2
FORTRAN90 MODIF echange/mfnome               sellenet N.SELLENET          50      3      2
FORTRAN90 MODIF echange/mfnoml               sellenet N.SELLENET          50      3      2
FORTRAN90 MODIF echange/mfnpdt               sellenet N.SELLENET          44      3      2
FORTRAN90 MODIF echange/mfnpfl               sellenet N.SELLENET          42      3      2
FORTRAN90 MODIF echange/mfnpro               sellenet N.SELLENET          41      3      2
FORTRAN90 MODIF echange/mfnume               sellenet N.SELLENET          52      3      2
FORTRAN90 MODIF echange/mfnval               sellenet N.SELLENET          52      3      2
FORTRAN90 MODIF echange/mfouvr               sellenet N.SELLENET          42      3      2
FORTRAN90 MODIF echange/mfpdti               sellenet N.SELLENET          56      3      2
FORTRAN90 MODIF echange/mfpfle               sellenet N.SELLENET          45      3      2
FORTRAN90 MODIF echange/mfpfll               sellenet N.SELLENET          45      3      2
FORTRAN90 MODIF echange/mfproi               sellenet N.SELLENET          43      3      2
FORTRAN90 MODIF echange/mfveco               sellenet N.SELLENET          40      3      2
FORTRAN90 MODIF echange/mfvedo               sellenet N.SELLENET          44      3      2
FORTRAN90 MODIF echange/mfveli               sellenet N.SELLENET          45      3      2
  PYTHON AJOUT SD/co_grille                   massin P.MASSIN            29     29      0
  PYTHON AJOUT SD/sd_grille                   massin P.MASSIN            29     29      0
  PYTHON MODIF Comportement/beton_umlv_fp   foucault A.FOUCAULT          39      3      3
  PYTHON MODIF Macro/propa_fiss_ops           massin P.MASSIN           955      1     15
  PYTHON MODIF Messages/calculel              pellet J.PELLET           409     10     16
  PYTHON MODIF Messages/calculel4             pellet J.PELLET           385     12      1
  PYTHON MODIF Messages/calculel5             pellet J.PELLET           387      9      1
  PYTHON MODIF Messages/elements              flejou J-L.FLEJOU         362      9      1
  PYTHON MODIF Messages/xfem                 meunier S.MEUNIER          419      1      6
  PYTHON MODIF Messages/xfem2                 massin P.MASSIN           587     20     46
  PYTHON MODIF SD/sd_corresp_2_mailla         pellet J.PELLET            45      2      3
  PYTHON MODIF SD/sd_xfem                     massin P.MASSIN           148     10      3


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :   10        2017      2017             +2017
 MODIF :  251       76920      3260    2762      +498
 SUPPR :    1         185               185      -185
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :  262       79122      5277    2947     +2330 
