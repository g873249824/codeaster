

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR berard       BERARD Alexandre       DATE 09/06/2010 - 03:14:55

--------------------------------------------------------------------------------
RESTITUTION FICHE 015430 DU 2010-08-17 15:36:55
TYPE anomalie concernant Documentation (VERSION *)
TITRE
    Coquilles dans la documentation U4.72.04
FONCTIONNALITE
   Descriptif
   ==========
   
   Certains exemples de la documentation U4.72.04 contiennent des mots-clés obsolètes.¨
   Plus précisément, le mot-clé CHAMP n'a pas été remplacé par le mot-clé CHAM_GD.
   
   
   Solution
   ========
   
   On corrige deux coquilles.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : U4.72.04
VALIDATION
    Sans objet
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 015420 DU 2010-08-10 09:29:39
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
    Erreur MACR_ECLA_PG dans l'xc3xa9clatement d'un TETRA comportant 15 points de Gauss
FONCTIONNALITE
   Problème
   ========
   
   En jouant avec la commande MACR_ECLA_PG, je me suis aperçu que l'éclatement d'un tétraèdre comportant 15 
   points de Gauss est incorrect : en effet, deux mailles s'interpénètrent dans le maillage éclaté.
   
   
   
   Résolution
   ==========
   
   L'erreur provient d'une connectivité erronée pour deux noeuds d'un des hexaèdres éclatés.
   Dans ecla3d.f, on effectue le remplacement suivant.
   
   <<<   CALL ECLACO(10,MXNBN2,CONNX,NBNO2, 16,26,28,17,19,32,31,18)
   
   >>>   CALL ECLACO(10,MXNBN2,CONNX,NBNO2, 16,26,28,17,19,32,30,20)
   
   
   
   Validation
   ==========
   
   On visualise le nouveau maillage éclaté sous Salome ; il ne semble plus y avoir de problèmes.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    Visualisation perso
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR boiteau      BOITEAU Olivier        DATE 09/06/2010 - 02:01:03

--------------------------------------------------------------------------------
RESTITUTION FICHE 015218 DU 2010-06-16 07:24:27
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
    mumps02a NOOK en 10.1.27 version mpi_calibre5
FONCTIONNALITE
   Probleme
   ========
      Dans le cas-test MUMPS02A, un calcul STAT_NON_LINE utilisant MUMPS + l'option
      MIXER_PRECISION donne une solution NOOK sur Calibre 5 + NEW10_MPI
   
   Analyse
   =======
      Dans ce cas-test, ce calcul STAT_NON_LINE est uniquement a finalite informatique et
      didactique. Ce cas-test est tres special puisqu'il s'agit d'une modelisation 
      D_PLAN_INCO sur laquelle on impose un deplacement a tous les ddls DX et DY, puis
      dans TEST_RESU on verifie que cette contrainte a bien ete respectee par le calcul
      non lineaire.
      L'ecart est rigoureusement de 0.0% sur Bull (mpi+seq), Rocks (seq) et calibre5 
     (seq).
      En calibre 5 mpi on a un ecart de 1.2E-5% qqe soit le nbre de procs (2, 4 ou 8).
      J'ai (trop longuement) cherche la raison de ces ecarts. 
      On les constate deja en sequentiel entre calibre 5 et Bull: ecart a la 4 ou 5ieme
      decimale des normes de la matrice, du second membre... d'ou leger ecart du meme ordre
      sur la solution. Par contre cela produit des ecarts plus consequents sur les residus
      (jusqu'à 10%). Je ne constate rien d'anormal lorsque je fais tourner MUMPS en 
      stand-alone sur une des matrices tangente.
      Bref, par grand chose a chercher cote Aster et MUMPS. Peut-etre est-ce du aux librai
      ries de communication MPI en simple precision de la souche C5 (puisque le pb dispa
      rait en seq et/ou en double precision std avec MUMPS): PBLAS, BLASC, MPI. 
   
   Solution
   =========
      J'assoupli le TEST_RESU de la valeur 1.E-8 à 5.E-7.
      J'introduit cette fonctionnalite MIXER_PRECISION ds un cas-test plus pertinent. En
      effet il est preferable que le conditionnement soit le plus faible possible pour
      limiter l'effet des approximations de la simple precision. Avec MUMPS02A il est de
      10E+6 ce qui est faible pour un pb méca mais limite pour cette fonctionnalite.
      Je l'insere ds les calculs THER_NON_LINE du cas-test MTLP103 (cond=10, N=4300).
   
   Sources restituees
   ==================
      Modif: cas-tests mumps02a et mtlp103a.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    informatique, non-rxc3xa9gression
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 015050 DU 2010-05-07 17:09:59
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
    Mumps imprime-t-il le "vrai" conditionnement des matrices ?
FONCTIONNALITE
   Problème
   =========
     Sur un petit pb modèle (N=252) symétrique réel, le calcul de conditionnement fourni par 
     MUMPS est très différent de celui calculé avec d'autres outils. N'est il pas buggé ou
     licite qu'asymptotiquement ?
   
   Analyse
   =======
    Avec MUMPS 4.9.2, qqes soient les potards, on trouve invariablement la même solution (le
    coté invariable est rassurant !): cond1=61.9 (la deuxième estimée donnée par MUMPS =0).
    Alors que MATLAB et PYTHON donnent tous les 2 une autre valeur (c'est rassurant ils sont
    basés sur les mêmes routines LAPACK !): cond(en norme L2)=1.6 E+9
    Pour info ils trouvent aussi cond(en norme L1/Linf)=5.82 E+9 (normal matrice sym).
   
    Je précise que les 3 outils (MUMPS, Python et matlab) donnent des solutions très proches du
     système linéaire.
   
    En fait, après qqes discussions avec l'équipe MUMPS et en me replongeant ds le papier
    fondateur de l'estimation d'erreur ds MUMPS (Arioli, Demmel et Duff 1989), je crois avoir
    compris pourquoi:
   
    * Tout d'abord, même ds le cadre très précis de la résolution de système linéaire,il existe 
     de nombreuses façons de définir le calcul du conditionnement et celui de la backward erreur
   (en norme ou par composante, prise en compte du caractère creux, du RHS....). Aucune n'est
     plus fausse ou vrai que les autres. Certaines sont justes plus pessimistes que d'autres !
   
    * Justement, l'objectif de MUMPS c'est de fournir des indicateurs d'erreur sur la solution:
       - qui tiennent compte du RHS (ce qu'on n'a pas fait ici avec Python/Matlab). C'est le   
      pb complet que MUMPS veut résoudre, pas étudier la matrice !
       - qui tiennent compte du caractère CREUX de la matrice. En effet, ce n'est pas la peine
      de prendre en compte d'éventuelles perturbations sur des erreurs d'arrondis sur des termes
      matriciels qui n'existent pas (les ddls correspondant n'ont pas à se causer !). Bref, ce
      conditionnement MUMPS respecte la physique du pb discrétisé, il ne se replonge pas dans
      l'espace trop riche des matrices pleines de taille N.
   
     * MUMPS fournit donc des calculs de conditionnements qui sont licites ds le cadre de la 
     théorie décrite ds la papier. Ils peuvent être beaucoup plus realistes et beaucoup moins
     pessimistes que ceux fournis par d'autres outils (c'est assumé ds la papier). Stricto
     censu, ils n'ont d'autres intérêts que de nourrir les posttraitements de MUMPS et ne 
     peuvent se comparer qu'avec d'autres runs de MUMPS (on retrouve le même débat avec les 
     indicateurs d'erreurs et la maillage adaptatif).
   
     * Dans le pb qui nous occupe, le conditionnement calculé par MUMPS (u sol du pb)
                cond1(A,b) = norme_inf ( |A|-1 * (|A|*|x| + |b|) ) / norme_inf (u)
       est bien licite (il n'y a pas de bug). On retrouve bien le 61.9
       Il minore énormément celui fournit par MATLAB/PYTHON car certaines colonnes de la matrice
       sont mal équilibrée (leurs termes varient sur une vingtaine d'ordre de magnitude).
       Le principale est d'avoir une bonne backward erreur (erreur commise par l'algo): 10E-16
       D'où une incertitude sur la solution EXCELLENTE en 10E-16 * 10 = 10E-15 (précision 
        machine !)
   
   Solution
   =========
      On peut utiliser les estimations de conditionnements fournies par MUMPS mais uniquement
      en terme de comparaison avec d'autres études faites avec MUMPS. Il ne faut donc pas trop
      comparer avec des estimateurs classiques basés sur des matrices pleines. Ils peuvent être 
      beaucoup plus pessimistes.
      A contrario, si un estimateur MUMPS clignote (via le mot-clé RESI_RELA)
      il faut vraiment s'inquièter !!
   
      Je vais annoter la réçente doc U2.08.03 (Notice d'utilisation des solveurs linéaires) pour
      tenir compte de ce post.
   
   Restitution
   ============
      Aucune
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : U2.08.03
VALIDATION
    informatique
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 014934 DU 2010-04-12 16:21:06
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
    Problxc3xa8me VmData/VmSize sur la version parallxc3xa8le ?
FONCTIONNALITE
   Probleme
   ========
     Sur la Bull en NEW10_mpi, les valeurs VMPeak/VmData/VMSize dans le .mess 
     parfois enflent considerablement entre deux appels a MUMPS. Ces valeurs corres
     pondent, respectivement, au pic de memoire virtuelle, au volume de donnees 
     allouees et a la taille totale allouee par les processus actifs du job.
     On a fait ce constat lors de l'analyse de la fiche AL14513.
     Puisque MUMPS est appele en tant que librairie, on peut suspecter une fuite 
     memoire ds le produit ou ds nos drivers internes (AMUMP..). Et donc, au bout de
     quelques appels successifs, un planton du job, faute de memoire disponible. 
     A moins que cela soit les thermometres VMPeak/VmData/VMSize qui donnent des
     valeurs inexploitables ds cette conf ?
   
   Analyse
   =======
     TEST EFFECTUE SUR LE CAS-TEST MUMPS05A (N=0.2M). NEW10 ou NEW10_MPI 
     NODEBUG avec config std. Les calculs // ont ete fait sur 8 procs.
   
     Le pb constate se produit
        - qqes soient les versions de MUMPS 4.8.4 et 4.9.2,
        - aussi avec MULT_FRONT,
        - uniquement en NEW10_MPI sur BULL (pas en NEW10 BULL, en NEW10/NEW10_MPI
          sur Calibre 5 et sur Clamart2)
          Avec ces 10 cas de figures, que ce soient MUMPS ou MULT_FRONT, les tailles
          des donnees reservees par les processus avant et apres le premier
          MECA_STATIQUE, ne varient que de qqes % (dizaines de Mo).
          Les chiffres sont mentionnes pour memoire ds le tableau ci-dessous.
          On note **_AV la taille avant le MECA_STATIQUE
                  **_APR la taille apres le MECA_STATIQUE
   
   ___VMSIZE_AV/VMSIZE_APR ___|_______ MF _________|_________ MUMPS ______
   ___VMDATA_AV/VMDATA_APR
   
   ________BULL_MPI___________|_____1026/4518(!)___|_________1026/1725(!)
   ___________________________|______830/4312(!)___|_________830/1530 (!)
   
   ________BULL_SEQ___________|_____283/293________|_________283/394
   ___________________________|______97/108________|_________97/208
   
   ____CALIBRE5_MPI___________|_____280/292________|_________280/326
   ___________________________|______99/111________|_________99/146
   
   ____CALIBRE5_SEQ___________|_____268/279________|_________268/272
   ___________________________|____145/146_________|_________145/149
   
   ____CLAMART2_MPI___________|_____320/330________|_________321/401
   ___________________________|_____146/176________|_________166/247
   
   ____CLAMART2_SEQ___________|_____306/316________|_________306/303
   ___________________________|____158/168_________|_________158/155   
   
          
      On verifie bien que:
            - Que suivant qu'on linke une partie des librairies, ou non, en statique
              l'executable est plus ou moins gros (celui de C5 > celui de la Bull).
            - Que la couche reseau ELAN de la Bull coute tres cher en DATA et en EXEC.
              (d'ou les 700 Mo minimum requis en MPI sur Bull meme avec 1 maille)
            - Les exec // sont plus lourds que les seqs (MPI, couche reseau, BLASC
               PBLAS pour MUMPS).
            - Dans les configurations qui ont l'air de fournir des chiffres coherents
              (Bull seq et Calibre5/Clamart 2 mpi/seq), on perd un reliquat de quelques
              10aines de Mo avec MUMPS uniquement en // par rapport a MF
              Peut-être est-ce du au chargement en memoire des librairies et/ou qu'elles
              sont comptees plusieurs fois suivant le nbre de procs ? Ou a une fuite
              memoire ds MUMPS ou un des drivers Aster/MUMPS.
             
     RQ1. Pour memoire sur BULL les libs ont les tailles suivantes
                                          BLAS_MKL__________1 M    
                                          MKL_LAPACK________18 M
                                          QXELAN____________1 M
                                          MPI_______________1 M
                                          SCALAPACK_________16 M
                                          BLASC_____________1 M
                                          MUMPS_____________18 M
     RQ2. Certaines librairies sont toujours linkees en statique (MUMPS, METIS, SCOTCH,
          MED, HDF5...) qqes soient les plate-formes.
   
     
    1ere tentative (Merci Aimery/JPL)
   ================
     Construire une version BULL_MPI allegee en librairie dynamique (flag au link
     -static-intel). Seules LAPACK et BLAS MKL sont devenues statiques.
     Cela ne change rien aux chiffres NEW10_MPI BULL. Ils sont toujours tres eleves !!!
   
    2nd tentative
   ===============
     Regarder du point de vue des allocations memoires F77 si cette inflation des
     chiffres mesure reellement une fuite memoire. FINALEMENT C'EST LA SEULE CHOSE QUI
     NOUS INTERESSE VRAIMENT. PEUT-ON CONTINUER A ALLOUER UN OBJET GROSSO-MODO DE MEME
     TAILLE (PROCHE DE LA LIMITE ASTK) EN FIN DE CHAQUE OPERATEUR D'UN RUN ASTER.
   
     Avant et apres l'appel au solveur lineaire (MF et MUMPS) on appel la routine 
     MEMRES de JP. Celle-ci, par des appels MALLOC au sein d'une boucle dichotomique,
     determine approximativement la taille maximale admissible vue du fortran.
     Oh surprise ! En surchargeant RESOUD avec MEMRES, les 2 lignes du tableau precedent
     deviennent correctes (avec Astk=7Go, RMS_MEMLIMIT=7.4 Go, lancement batch)
       MEMRES: est la quantite de memoire dispo en F77,
       MAX_JEVEUX: maximum atteint par JEVEUX (objet liberable ou non)
   
   ___VMSIZE_AV/VMSIZE_APR ___|_______ MF _________|________MUMPS ______|
   ___VMDATA_AV/VMDATA_APR
   
   ________BULL_MPI_STD_______|_____1026/4518(!)___|_______1026/1725(!)_|
   ___________________________|______830/4312(!)___|_______830/1530 (!)_|
   
   ________BULL_MPI_MEMRES____|_______283/294______|_______283/395______|
   ___________________________|_______97/109 ______|________97/209______|
   __________MEMRES___________|_______4597_________|_________6929_______|
   __________VMPEAK___________|_______7399_________|_________7399_______|
   __________MAX JEVEUX_______|_______3427_________|__________294_______|
   
   Par contre, si on fait des MEMRES que sur le proc 0, patatras ! Les bons
   chiffres Vmpeak... redeviennent n'importe quoi ! Heureusement, la valeur dispo
   depuis le F77 reste toujours a un bon niveau !
   
   __BULL_MPI_MEMRES_PROC0____|____________________|_______1027/7377_(!)|
   ___________________________|____________________|________830/7179_(!)|
   __________MEMRES___________|____________________|_________6350_______|
   __________VMPEAK___________|____________________|_________7377_______|
   __________MAX JEVEUX_______|____________________|__________294_______|
   
   
     On retrouve bien le bon vieux principe d'Heisenberg: toute mesure perturbe les
     valeurs mesurees !
     On constate qu'avec cette manip de mesure
         - Lorsque la mesure est effectuee en meme temps sur les 8 procs, les 
          VmSize/VmData deviennent très proches sur Bull entre version // et Seq
          (ce qui est le cas des autres plate-formes) et le max memoire dispo apres la 
          facto, MEMRES, est "grosso-modo" de  
                              RMS_MEMLIMIT - MAX_JEVEUX
         - Dans tous les ces, la valeur de Vmpeak butte bien sur le max dispo 
        (RMS_MEMLIMIT)
   
    RQ3. Si en NEW10_MPI_BULL, on lance plusieurs MECA_STATIQUE successifs avec 
         MEMRES on tombe sur un edifiant 
                         ELAN_EXCEPTION @ 1: 5 (Memory exhausted)
         et le calcul plante !
   
   Donc, sur Bull MPI il semble bien que ce soit le thermometre qui soit casse !
   Le calcul n'a pas la fievre ! Le fait de faire des mallocs oblige parfois le systeme (et la
   couche ELAN) a nettoye ses buffers et on retrouve, parfois, des valeurs coherentes.
   
    3ieme tentative: As-t-on une fuite memoire au niveau de MUMPS ou du driver Aster/MUMPS ?
   ================
     Maintenant on lance 5 MECA_STATIQUE+MUMPS identiques au sein d'un meme run sur Bull
     en NEW10 et en NEW10_MPI. A l'issu de chaque resolution de systeme lineaire on mesure
     la memoire disponible vue de la lorgnette F77.
     Dans les 2 configurations cette valeur est stable: MEMRES=6350 Mo
     A noter que les valeurs VmPeak/VmSize/VmData sont elles aussi stables, MECA_STATIQUE
     apres MECA_STATIQUE.
     Donc, nos craintes n'etaient pas justifiees, tout va bien de ce cote la.
   
    
   CONCLUSIONS
   ===========
   
    Sur le PB 1: la pertinence des chiffres Vmpeak/Vmdata/Vmsize ?
   
    1/ Il ne faut pas tenir compte de ces chiffres actuellement sur la Bull MPI.
      Comme la machine arrive en fin de course, on ne soumet pas le pb a l'infogerance.
    
    2/ Excepte sur la Bull en MPI, les valeurs Vmpeak/Vmdata/Vmsize sont globalement
      semblables qqes soient les machines et les versions du code et de ses dependances.
      Pour un meme cas-test, on peut donc comparer qualitativement leur evolutions au cours du
      calcul. Par contre, bien sur, les comparaisons quantitatives precises ne peuvent etre 
      menees que pour un point de fonctionnement donne (machine, librairie, version Aster, nbre 
      de procs, limite memoire, variable d'env...) ou en connaissance de cause.
   
    3/ De la meme maniere qu'on trace hebdomadairement, les evolutions des temps consommes par
      les cas-tests de la base, pourquoi ne pas faire la meme chose avec 1 ou 2 potards memoire.
      C'est tout aussi important (et souvent lie au temps consomme) et c'est souvent LE parame
      tre limitatif d'une etude.
      Par exemple, pour la derniere commande du cas-test:
        La valeur max atteinte en memoire utilisee JEVEUX: c'est le chiffre plancher avec lequel
                    JEVEUX fonctionne a fond en OOC. Il peut refleter des allocations anormale
                    ment elevees d'objets JEVEUX dues un developpement recent.
        Le Vmpeak de la derniere cmde: il reprendra l'eventuel ecart precedent plus celui dû a
                    la plate-forme et a la construction de l'executable. Il peut refleter des
                    pbs d'installation/utilisation de package, de modif du noyau, de couche
                     reseau...
       Avec ces 2 potards on peut ainsi tracer les ecarts et dissocier les pbs:
               - programmation ds JEVEUX,
               - package/middleware/systeme/reseau.
       JE SOUMET CETTE PROPOSITION DANS UNE EL POUR INSTRUIRE LA QUESTION.
   
     4/ J'annote la doc U1.03.03 'Indicateur de performance' pour prendre en compte les rqs
      precedentes.
   
    Sur le PB 2: Fuite memoire au niveau de MUMPS ou du driver Aster/MUMPS ?
   
     5/ Cela ne semble pas être le cas ds la config actuelle sur la Bull NEW10/NEW10_MPI.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : U1.03.03
VALIDATION
    informatique, non-regression
NB_JOURS_TRAV  : 4.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 09/06/2010 - 03:45:33

--------------------------------------------------------------------------------
RESTITUTION FICHE 015431 DU 2010-08-17 15:51:09
TYPE anomalie concernant Eficas (VERSION 1.7)
TITRE
    Pas la bonne version du catalogue d'Eficas
FONCTIONNALITE
   La dernière version d'eficas n'avait été installée sur Bull et 
   Calibre 5.
   
   Remarque : la version Qt ne fonctionne pas sur Calibre 5 
   (comme avant d'ailleurs), l'environnement n'étant pas 
   correctement positionné.
   
   NB : Il faut supprimer le répertoire ~/.Eficas_install avant 
   de lancer la nouvelle version, sinon les catalogues ne seront 
   pas les bons.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    lancement eficas
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 015490 DU 2010-09-02 15:20:23
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
    Echec de la mise a jour en 10.2.13
FONCTIONNALITE
   La mise à jour en 10.2.13 s'arrête avec l'erreur 
   <F>_BUILD_ERROR.
   
   En fait, la mise à jour, la compilation et la construction 
   de l'exécutable se passe bien. C'est le test après la 
   construction de l'exécutable qui échoue.
   
   On cherche à lancer l'exécutable après avoir positionner 
   l'environnement pour détecter un problème de chargement de 
   bibliothèque dynamique par exemple.
   Ensuite, on importe un module standard de Python, puis le 
   module aster.
   
   Or depuis 10.2.13, les exceptions sont définies dans un 
   module Python externe. Mais le PYTHONPATH est positionné 
   lors d'une exécution par E_SUPERV.py via sys.path. D'où 
   l'impossibilité d'importer E_Exception.
   
   Certes, on ne fera pas grand chose du module aster si les 
   modules Python associés ne sont pas accessibles.
   Cependant, le test de l'exécutable est bien pratique.
   On remplace donc l'arrêt avec le message d'erreur par un 
   avertissement :
   
   WARNING:
       ImportError of Execution.E_Exception module!
       No exception defined in the aster module.
       It may be unusable.
   
   
   Signalé sur la page du site Support/Version NEW.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    lancement de l'exxc3xa9cutable hors contexte d'exxc3xa9cution
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 015493 DU 2010-09-03 08:26:02
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
    En NEW 10.2.13, le cas-test zzzz159f s'arrete anormalement sur Bull, Rocks et Calibre 5
FONCTIONNALITE
   Le test zzzz159f s'arrête sur toutes les machines.
   
   Ceci est lié à issue15490. Dans ce test, on valide le mode 
   externe de MACR_RECAL et pour cela, on exécute des scripts 
   Python en utilisant l'exécutable Aster, puis 'import aster'...
   
   Après correction de la fiche cité, le test fonctionne de 
   nouveau correctement.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    zzzz159f
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 015482 DU 2010-09-01 16:20:23
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
    Interrompre USR1 crxc3xa9e une base illisible
FONCTIONNALITE
   Problème
   ========
   
   Suite à un arrêt par envoi du signal USR1 (via le suivi des 
   jobs), la base produite par le calcul n'est pas relisible.
   
   
   Correction
   ==========
   
   Rappel du principe :
   - Une variable globale stocke si le signal USR1 a été reçu 
   (=1) ou non (=0).
   - Quand le signal est reçu, on met cette variable à 1.
   - On interroge ce statut entre deux commandes ou bien dans 
   les opérateurs itératifs.
   - S'il vaut 1, on arrête le calcul avec une erreur <S>
   
   
   Quand une erreur est récupérée par le superviseur, pour 
   arrêter proprement le calcul, on appelle la commande FIN[*].
   
   Sauf que l'exécution de la commande passe par EXECOP, qui 
   interroge le statut... On déclenche alors une 2ème erreur 
   <S>. La commande FIN n'est pas exécutée.
   Effectivement, on constate dans l'output que la commande FIN 
   n'a pas été appelée (donc la base mal fermée, donc la 
   poursuite impossible).
   
   
   La solution consiste à réinitialiser le statut (appel à 
   CLRUSR, CLeaR USR1) juste avant l'arrêt par l'erreur <S> 
   SUPERVIS_39 pour que la fermeture se passe bien.
   D'où l'intérêt de passer par SIGUSR() pour émettre ce 
   message et ne pas appeler directement U2MESS comme c'était 
   le cas dans EXECOP.
   
   
   
   
   .. [*] l'appel à FIN est dans ce cas de figure différent en 
   PAR_LOT='OUI' et en PAR_LOT='NON'. On appelle soit le FIN 
   présent dans le jdc, soit un FIN issu directement du 
   catalogue. D'où l'apparition ou non, d'un traceback de 
   E_ETAPE en PAR_LOT='OUI'.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssnp125a + kill -USR1
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desoza       DE SOZA Thomas         DATE 09/07/2010 - 05:13:10

--------------------------------------------------------------------------------
RESTITUTION FICHE 015487 DU 2010-09-02 12:26:03
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
    En NEW10.2.13, les cas-tests ssna102f, ssnv129d, ssnv209f et zzzz237a s'arretent en fatal erreur sur Bull
FONCTIONNALITE
   Anomalie
   ========
   
   '''
   En NEW10.2.13, les cas-tests ssna102f, ssnv129d, ssnv209f et zzzz237a s'arretent en fatal
   erreur sur Bull.
   '''
   
   Il s'agit d'un plantage en ASSERT dans VTCMBL
   
   Analyse
   =======
   
   Suite à la fiche issue15451, on a blindé VTCMBL pour vérifier la cohérence des dimensions
   des objets d'un CHAM_NO entrant (.DESC, .REFE et .VALE) avec celui sortant fourni
   (facultativement) par l'utilisateur.
   
   Les tests qui font du AFFE_CHAR_CINE et du contact continu déclenchent cet ASSERT.
   
   En effet pour assembler le chargement cinématique on fait une combinaison linéaire entre
   U_imp_+ et U_imp_- et on demande le résultat dans un cham_no créé par VTCREB.
   
   U_imp_- le premier champ fourni avec VTCMBL et créé par duplication de DEPMOI. On va donc
   comparer les dimensions de DEPMOI et d'un cham_no créé par VTCREB. Elles ne sont pas
   identiques lorsque l'on fait du contact continu !
   
   C'est parce que en contact continu, on annule à chaque début de pas de temps les lagranges
   de C/F, par des appels successifs à CNSRED/CNSFUS et finalement CNSCNO.
   
   Or CNSCNO ne crée par un cham_no en accord avec la nomenclature des SD ! Les .DESC et
   .REFE n'ont pas les mêmes dimensions.
   
   Correction
   ==========
   
   On corrige CNSCNO et on ajoute une fonction check_ dans sd_cham_no.py pour vérifier le bon
   dimensionnement des cham_no (la taille des .DESC et .REFE dépend du type de représentation
   : variable ou constante).
   
   À faire en V9.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    tests cassxc3xa9s
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 015432 DU 2010-08-18 09:41:41
TYPE aide utilisation concernant Code_Aster (VERSION 7.0)
TITRE
    Convergence: modxc3xa8le fissurxc3xa9, comportement Chaboche
FONCTIONNALITE
   AOM
   ===
   
   '''
   Fiche émuse dans le cadre de l'AT (Minh-Bao LÊ,CDD à EDF SEPTEN, groupe ThermoMécanique,
   division RE): 
   
   Il modélise en 2D un essai avec fissuration utilisant le comportement d'écrouissage
   cinématique non linéaire de Chaboche.
   Il effectue plusieurs cycles de montée et de descente de chargement. Le calcul se déroule
   bien mais quand il arrive à la fin d'un cycle, il ne converge plus.
   Le problème a été reproduit en STA9 (après ajout du paramètre R_I=0 dans DEFI_MATERIAU).
   Les fichiers sont été déposés sur Bull dans /home/rezette/Le.
   '''
   
   Il s'agit d'un calcul 2D sur une éprouvette fissurée chargée de manière cyclique en force
   avec avancée de la fissure (manuelle par déboutonnage) à chaque cycle.
   
   Actuellement à la fin du second cycle, on n'arrive pas à converger.
   
   L'utilisateur fait remarquer que le retrait de la liaison unilatérale visant à interdire
   l'interpénétration au niveau des lèvres permet au calcul de converger
   
   Analyse
   =======
   
   L'analyse qui suit résulte du travail successif de EG, JMP et TdS. Elle est découpée en
   différents aspects.
   
   ** Aspect temporel
   
   Ludovic I. nous fait très justement remarquer que les unités choisies étant le Mpa et le
   mm, l'unité de temps est donc la milliseconde.
   On s'aperçoit alors que les vitesses de déformation atteintes dans ce calcul sont de
   l'ordre de 0.1 s^-1. C'est déjà beaucoup trop pour se placer en quasi-statique.
   À l'utilisateur de faire en sorte que son modèle reste valable.
   
   ** Aspect contact
   
   Le fait de retirer la liaison unilatérale (LIAISON_UNILATER) change complètement le calcul
   (il n'y a plus vraiment de fond de fissure, plus de singularité) ce n'est donc pas la
   bonne voie pour comprendre la non-convergence.
   
   ** Aspect numérique (paramètre de STAT_NON_LINE)
   
   Ni la recherche linéaire, ni une prédiction 'ELASTIQUE' n'améliorent le comportement en
   fin de cycle : le résidu ne décroît pas et on n'arrive pas à converger.
   Pire, utiliser une matrice 'ELASTIQUE' ne fait pas non plus décroître le résidu.
   On en déduit donc comme l'avait supposé EG au début que la difficulté est dans l'aspect
   cyclique et que la LdC a son rôle à jouer.
   
   ** Aspect loi de comportement
   
   La loi utilisée est VISC_CIN1_CHAB : il s'agit d'une loi associant un écrouissage isotrope
   non-linéaire (débrayable) à un écrouissage cinématique non-linéaire et qui prend en compte
   la viscosité.
   
   On utilise l'algorithme de De Borst pour satisfaire les contraintes planes avec la loi
   utilisée. On peut confirmer que De Borst ne pose pas de problème : tout d'abord il est
   efficace. Par ailleurs bien que le chargement extérieur devient quasi-nul, les contraintes
   ne le sont pas et donc le critère de CV de De Borst n'est pas mis en défaut.
   
   Telle qu'utilisée(*) la loi de comportement n'active pas l'écrouissage isotrope
   non-linéaire : la première conséquence est que l'on atteint très vite un palier
   parfaitement plastique. Comme les déformations plastiques atteignent en fond de fissure
   autour de 8% à l'instant de divergence, on pressent un problème.
   
   (*) : une fiche est émise pour améliorer le catalogue de la loi, la doc et former les
   utilisateurs qui ne lisent pas la dite doc. 
   
   Après simulation sur un point matériel (SIMU_POINT_MAT), nous avons décidé de relancer le
   calcul avec les mêmes paramètres mais avec en plus un écrouissage non-linéaire (paramètre
   b=2, R_infini=2*R_0, écrouissage en exponentielle). Cf. image jointe.
   
   Avec ces paramètres, le calcul converge et passe le second cycle mais finit par échouer
   .... à la fin du 3ème cycle !
   Ce n'est pas très étonnant étant donné qu'avec l'augmentation du nombre de cycles, on tend
   de plus en plus vers une loi à palier parfaitement plastique.
   
   Si on étude comment s'est fait la convergence à l'instant 2.0 on voit ceci :
   
   --------------------------------------------------------------------------------------
    
   INSTANT DE CALCUL :  2.000000000E+00
    
   --------------------------------------------------------------------------------------
   |   ITERATIONS   |     RESIDU     |     RESIDU     |     DEBORST    |     OPTION     |
   |     NEWTON     |     RELATIF    |     ABSOLU     |                |   ASSEMBLAGE   |
   |                | RESI_GLOB_RELA | RESI_GLOB_MAXI |                |                |
   --------------------------------------------------------------------------------------
   |     0        X | 2.53204E-01  X | 1.39110E-01    |                |ELASTIQUE       |
   |     1        X | 2.15858E-02  X | 1.66395E-02    |                |TANGENTE        |
   |     2        X | 5.92119E-05  X | 4.43207E-05    |                |TANGENTE        |
   |     3        X | 1.61791E-03  X | 1.17041E-03    |                |TANGENTE        |
   |     4        X | 1.49477E-04  X | 1.04852E-04    |                |TANGENTE        |
   |     5        X | 1.40723E-04  X | 9.55237E-05    |                |TANGENTE        |
   |     6        X | 1.42751E-04  X | 9.36861E-05    |                |TANGENTE        |
   |     7        X | 1.44901E-04  X | 9.18532E-05    |                |TANGENTE        |
   |     8        X | 1.47477E-04  X | 9.02040E-05    |                |TANGENTE        |
   |     9        X | 1.50160E-04  X | 8.85220E-05    |                |TANGENTE        |
   |    10        X | 1.53078E-04  X | 8.68733E-05    |                |TANGENTE        |
   |    11        X | 9.81084E-04  X | 5.35304E-04    |                |TANGENTE        |
   |    12        X | 1.59526E-04  X | 8.35527E-05    |                |TANGENTE        |
   |    13        X | 1.63513E-04  X | 8.20902E-05    |                |TANGENTE        |
   |    14        X | 1.67727E-04  X | 8.05830E-05    |                |TANGENTE        |
   |    15        X | 1.72362E-04  X | 7.91058E-05    |                |TANGENTE        |
   |    16        X | 1.77481E-04  X | 7.76604E-05    |                |TANGENTE        |
   |    17        X | 1.83153E-04  X | 7.62463E-05    |                |TANGENTE        |
   |    18        X | 1.89464E-04  X | 7.48630E-05    |                |TANGENTE        |
   |    19        X | 1.96517E-04  X | 7.35099E-05    |                |TANGENTE        |
   |    20        X | 2.04436E-04  X | 7.21864E-05    |                |TANGENTE        |
   |    21        X | 2.13379E-04  X | 7.08919E-05    |                |TANGENTE        |
   |    22        X | 2.23542E-04  X | 6.96258E-05    |                |TANGENTE        |
   |    23        X | 2.35176E-04  X | 6.83875E-05    |                |TANGENTE        |
   |    24        X | 2.48606E-04  X | 6.71765E-05    |                |TANGENTE        |
   |    25        X | 2.64257E-04  X | 6.59916E-05    |                |TANGENTE        |
   |    26        X | 2.83514E-04  X | 6.50177E-05    |                |TANGENTE        |
   |    27        X | 3.12243E-04  X | 6.52644E-05    |                |TANGENTE        |
   |    28        X | 3.46906E-04  X | 6.54944E-05    |                |TANGENTE        |
   |    29        X | 3.89597E-04  X | 6.57089E-05    |                |TANGENTE        |
   |    30        X | 4.43514E-04  X | 6.59086E-05    |                |TANGENTE        |
   |    31        X | 5.13819E-04  X | 6.60949E-05    |                |TANGENTE        |
   |    32        X | 6.09391E-04  X | 6.62680E-05    |                |TANGENTE        |
   |    33        X | 7.46950E-04  X | 6.64294E-05    |                |TANGENTE        |
   |    34        X | 9.62104E-04  X | 6.65796E-05    |                |TANGENTE        |
   |    35        X | 1.34657E-03  X | 6.67181E-05    |                |TANGENTE        |
   |    36        X | 2.23078E-03  X | 6.68503E-05    |                |TANGENTE        |
   |    37        X | 3.82248E-01  X | 3.99903E-03    |                |TANGENTE        |
   |    38        X |-1.00000E+00  X | 3.61645E-05    |                |TANGENTE        |
   
     -> Le chargement extérieur est nul (à la précision près).
        Or vous avez demandé une convergence avec le critère relatif (RESI_GLOB_RELA). 
        Pour éviter une division par zéro, le code est passé automatiquement en mode de
   convergence
        de type absolu (RESI_GLOB_MAXI)
     -> Risque & Conseil : Vérifier bien que votre chargement doit etre nul à cet instant 
        Dans le cas des problèmes de type THM, penser à utiliser éventuellement un 
        critère de type référence (RESI_REFE_RELA).
        La valeur automatique prise pour RESI_GLOB_MAXI est égale à 1E-6 fois la dernière valeur
        de résidu maximum à l'instant précédent. 
   |    39          |-1.00000E+00    | 1.51906E-06    |                |TANGENTE        |
   --------------------------------------------------------------------------------------
    
   <*> ATTENTION : CONVERGENCE ATTEINTE AVEC
   CRITERE RESI_GLOB_MAXI= 0.000000000E+00
   POUR CAUSE DE CHARGEMENT PRESQUE NUL
   RESIDU RESI_GLOB_RELA   VAUT -1.000000000E+0
   
   
   La convergence est atteinte mais c'est par un biais détourné : l'activation automatique de
   RESI_GLOB_MAXI.
   Le problème se situe à mon avis dans la détection du chargement qui doit poser problème à
   cause des forces auto-équilibrées autour de la fissure : ces forces sont dues à la ligne
   d'iso-VonMises nulle qui "coupe" la pièce en 2.
   
   
   Conclusion
   ==========
   
   Fort de ces essais, nous faisons les remarques suivantes : 
   
   -  il faut signaler à l'utilisateur qu'il n'y a pas d'écrouissage dans sa loi et que pour
   les niveaux de déformation atteints cela peut poser des problèmes de convergence
   -  il faut aussi lui demander de regarder les unités car les vitesses de déformation
   impliquées sont beaucoup trop fortes
   -  le chargement extérieur est presque nul : il l'est sur quasiment toute la structure. Il
   ne l'est pas vraiment autour du fond de fissure mais dans cette zone on peut difficilement
   avoir une bonne solution (singularité). Une solution si la détection automatique a du mal
   à se déclencher est de passer en RESI_GLOB_MAXI.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    xc3xa9tude jointe
NB_JOURS_TRAV  : 1.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 015476 DU 2010-08-30 16:42:23
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
    SUIVI_DDL/VALE_{MAX,MIN} impossible si la composante n'est pas porté sur tout le modèle
FONCTIONNALITE
   Anomalie
   ========
   
   Christelle C. a constaté que SUIVI_DDL échouait lorsqu'on lui demandait d'afficher la
   valeur max (ou min) de SIZZ sur le cas-test SSNS106 constitué de plaques (DKT) et de
   grilles (GRILLE_EXCENTRE).
   
   Correction
   ==========
   
   Cela se produit car SIZZ n'est pas porté par le champ de contraintes (SIEF_ELGA) des
   grilles qui ne portent que SIXX. Ce cas où une composante n'existe que sur une partie du
   modèle avait semble-t-il était partiellement prévu dans la programmation.
   
   Le seul problème c'est que l'on appelle CESEXI pour récupérer l'adresse de la composante
   dans le mode 'S' qui sort en message d'erreur alors que l'on veut le mode 'C' (on continue).
   
   Impact : dyobar.f
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ras
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR idoux        IDOUX Ludovic          DATE 09/07/2010 - 01:58:54

--------------------------------------------------------------------------------
RESTITUTION FICHE 015347 DU 2010-07-16 09:27:13
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
    QUA03 couverture de code MEOBG1,MEOBG2 et LCEOBB
FONCTIONNALITE
   Problème :
   Trois sources de Code_Aster sont non couvertes par les cas-tests : LCEOBB.F, MEOBG1.F et
   MEOBG2.F
   
   Solution :
   Ces trois sources sont utilisées par la loi ENDO_ORTH_BETON. 
   Les deux routines MEOBG1 et MEOBG2 sont utilisées en endommagement non local uniquement.
   La routine LCEOBB.F est une routine de redécoupage de l'incrément de déformation lorsqu'on
   est proche de la saturation de l'endommagement. 
   
   Je restitue une nouvelle modélisation (indicée B) du cas-test SSNV217. La modélisation A
   est en endommagement local. La nouvelle modélisation B est en endommagement non local. On
   modifie légèrement le chargement par rapport à la modélisation A pour rentrer dans un cas
   de redécoupage et couvrir la source LCEOBB.
   
   Synthèse :
   ajout du cas-test : SSNV217B
   impact documentaire : V6.04.217
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V6.04.217
VALIDATION
    Cas-test lui mxc3xaame
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR lefebvre     LEFEBVRE Jean-Pierre   DATE 09/07/2010 - 07:19:38

--------------------------------------------------------------------------------
RESTITUTION FICHE 012614 DU 2008-10-09 16:28:53
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Pour xc3xa9viter l'usage abusif de gcncon.f
FONCTIONNALITE
   But de la fiche
   ===============
   
   Emettre une alarme lorsque dans une commande on effectue de nombreux accès en écriture sur
   la base Volatile sans effectuer de relecture.
   Cette alarme est destinée aux développeurs, elle indique un mauvais usage du gestionnaire
   de mémoire tel que celui décrit par Jacques : on alloue des vecteurs Jeveux dans une
   boucle sans jamais les utiliser, ils sont déchargés sur disque car on sature la mémoire
   mais ne sont jamais relus.
   
   Réalisation
   ===========
   
   Le nombre d'accès en écriture et en lecture pour chaque enregistrement du fichier d'accès
   direct associé à une base est comptabilisé. Il n'existe pas de compteur au niveau de
   chaque objet (objet simple ou objet de collection), et ce développement serait
   trop lourd par rapport à cette demande.
   On se contente donc de comparer les volumes de données en écriture et en lecture entre
   chaque commande et éventuellement émettre une alarme. La routine JEDETV, qui ne traite que
   la base VOLATILE, est instrumentée à cette fin. on choisit comme critère un rapport 100 en
   terme de volume écrit / volume lu (quand le volume lu est non nul). 
   Le message émis est le suivant :
     
   !--------------------------------------------------------------------------------------------------!
      ! <A> <JEVEUX1_64>                                                                    
               !
      !                                                                                     
               !
      ! Le volume des données temporaires (objets de la base Volatile) écrites sur disque
   (3493.75 Mo)   !
      !  est plus de 100.00 fois supérieur au volume de données lues (0.78 Mo).             
               !
      !                                                                                     
               !
      !                                                                                     
               !
      ! Ceci est une alarme. Si vous ne comprenez pas le sens de cette                      
               !
      ! alarme, vous pouvez obtenir des résultats inattendus !                              
               !
     
   !--------------------------------------------------------------------------------------------------!
   
   L'émission d'un message d'alarme dans une routine JEVEUX peut poser des problèmes de
   récursivité, notamment lorsque l'on traite une exception. La routine U2MESG est modifiée,
   en concertation avec Mathieu, dans le cas du traitement des messages A et I pour écrire le
   message et sortir immédiatement.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    Test personnel reprenant les appels GCNCON
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 015058 DU 2010-05-10 13:10:21
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
    boucle sur IMPR_RESU dans un fichier avec la mxc3xaame UL
FONCTIONNALITE
   Dans l'exemple fourni par Samuel, on traite un fichier MED et on cherche à utiliser
   l'unité logique "80" successivement pour des noms de fichier incrémentés sur un indice et
   déposés sous REPE_OUT, le nom de fichier est de la forme : 
        ./REPE_OUT/resu_iter_'+str(i_propa)+'.med
   
   i_propa étant l'indice variant de 1 à n (2 dans l'exemple).
   
   En reprenant le fichier de commande, sans la destruction os.remove, je constate que l'on
   s'arrête en erreur dès la première commande DEFI_FICHIER(ACTION='ASSOCIER' avec un message
   indiquant que l'unité 80 est déjà associée au fichier MED. 
   Ce qui est logique car l'unité 80 est associée par défaut à cette valeur dès le début de
   l'exécution (routine IBIMPR appelée dans la commande DEBUT). Il est donc nécessaire de
   faire un appel du type :
   DEFI_FICHIER(ACTION='LIBERER',UNITE=80)
   avant le premier appel à : 
   DEFI_FICHIER(ACTION='ASSOCIER',UNITE=80,FICHIER='./REPE_OUT/resu_iter_'+str(i_propa)+'.med')
   
   En modifiant ainsi le fichier de commande, l'exécution se déroule normalement et produit
   bien les deux fichiers 
   ./REPE_OUT/resu_iter_0.med
   ./REPE_OUT/resu_iter_1.med
   (cf fichier output joint)
   
   Je propose donc de compléter le paragraphe 3 de la documentation U4.12.03 de DEFI_FICHIER
   pour préciser que l'on peut réutiliser l'unité logique 80.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : U4.12.03
VALIDATION
    L'xc3xa9tude fournie par l'utilisateur
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 011755 DU 2008-02-14 10:38:38
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    tests FETI en parallele
FONCTIONNALITE
   Résolu par la fiche 13013. Les tests suivants concernant la méthode FEIT ont été déposés
   avec la version parallèle sous /aster/NEW10/mpi/astest et sont exécutés à chaque incrément
   de version :
   feti001a
   feti001b
   feti002a
   feti002b
   feti003a
   feti003b
   feti003c
   feti003d
   feti004a
   feti004b
   feti005a
   feti005b
   feti006a
   feti007a
   feti007b
   feti008a
   feti008b
   feti009a
   feti010a
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    tests FETI de /aster/NEW10/mpi/astest
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------
RESTITUTION FICHE 009366 DU 2006-01-18 09:24:29
TYPE evolution concernant agla (VERSION )
TITRE
    Exxc3xa9cuter sans soucis un fichier de commandes venant de windows
FONCTIONNALITE
   Le caractère de terminaison de ligne des fichiers produits sous Windows pose problème pour
   certains traitements sous unix. C'est le cas des fichiers de commandes, mais aussi des
   maillages.
   
   Pour éviter les problèmes avec ASTK_REF, on modifie les deux fichiers
   /aster/ASTK/ASTK_SERV/lib/FileCopyD.msk et /aster/ASTK/ASTK_SERV/lib/FileCopy.csh pour
   traiter les fichiers à l'aide de la commande dos2unix lorsque l'on détecte la présence de
   caractères CRLF à l'aide de la commande file. 
   
   Au final, le script batch lancé contient une expression du type suivant après recopie
   locale des fichiers :
   
   if ( `file fort.20  | grep -c 'CRLF' ` > 1) then
      dos2unix fort.20
   endif
   
   
   Dans asrun (en interactif sur Bull ou autres machines), cela avait été fait puis retiré
   car posait problème sur les bases (ou plutôt le pick.1). On le fait uniquement pour les
   fichiers identifiés comme étant de type texte et contenant des CR.
   Sera disponible dans asrun 1.9.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    test avec .msh contenant des CR windows
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 014773 DU 2010-03-10 11:39:49
TYPE evolution concernant astk (VERSION )
TITRE
    Alarme si erreur d'enregistrement de base
FONCTIONNALITE
   But de la fiche:
   ================
   A la fin d'une exécution d'une étude aster correcte, il peut se produire différentes
   erreurs qui empêchent la recopie des fichiers de résultats vers les cibles désignées par
   l'utilisateur dans l'interface astk. On met en place un mécanisme permettant de recopier
   dans l'espace temporaire /tmp du noeud d'exécution.
   
   Réalisation :
   =============
   On recopie les fichiers de résultats sous /tmp en cas d'erreur de la recopie vers la cible
   désignée dans astk. On crée le répertoire /tmp/{user}@{node}-save_results.{numjob}
   où {user} est le nom du compte utilisateur,
      {node} est le nom du noeud de calcul,
      {numjob} est le numéro du job affecté par le gestionnaire de batch ou le numéro de
   processus.
   On fera mettre en place une politique adéquate de nettoyage de ces répertoires par
   l'exploitant du serveur. 
   
   Le cas des bases à déjà été traité lorsque le quota est atteint, on étend le mécanisme à
   chaque fois que la recopie échoue (machine distante éteinte, nom de cible invalide , etc.)
   
   Un message est émis par les scripts pour préciser le nom du répertoire d'accueil et le nom
   du noeud de calcul. 
   
   Le diagnostic de l'exécution vaut : <A>_COPY_RESULTS
   
   exécution n'ayant pu recopier un fichier message :
   ==================================================
   -----------------------------------------------------------------------------
   --- <A>_COPY_RESULTS : Problème de copie de fichier 
   ---     Une copie de fort.6 a été déposée sous le répertoire
   /tmp/user@aster7-save_results.857419       
   ---     dans le fichier mess 
   ---     sur le noeud de calcul aster7 
   -----------------------------------------------------------------------------
   
   ------------------------------------------------------------
   --- DIAGNOSTIC JOB : <A>_COPY_RESULTS
   ------------------------------------------------------------
   
   
   exécution n'ayant pu recopier la base Globale :
   ===============================================
   
   -----------------------------------------------------------------------------
   --- <A>_COPY_RESULTS : il n'a pas été possible de recopier la base dans le 
   ---     répertoire /work/userXX/rep_base_nc spécifié.
   ---		
   ---     Une copie a été déposée sous /tmp/user@aster7-save_results.857434
   ---     sur le noeud de calcul aster7 .
   -----------------------------------------------------------------------------
   ------------------------------------------------------------
   --- DIAGNOSTIC JOB : <E>_MKDIR_ERROR
   ------------------------------------------------------------
   
   
   
   fichiers impactés :
   -------------------
   
   /aster/ASTK/ASTK_SERV/lib/FileCopyR.msk
   /aster/ASTK/ASTK_SERV/lib/RepeCopyR.msk
   /aster/ASTK/ASTK_SERV/lib/BaseCopyR.msk
   
   /aster/agla/tool/rcp_bases
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sur des lancements astk batch
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 013481 DU 2009-06-05 09:52:09
TYPE anomalie concernant agla (VERSION *)
TITRE
    as.tout en parallxc3xa8le MPI avec surcharge
FONCTIONNALITE
   But de la fiche
   ===============
   Eclaircir la documentation wiki concernant la construction d'un exécutable surchargé et le
   lancement des tests en version MPI.
   
   Réponse apportée :
   ==================
   En batch et sur le serveur de référence BULL, le lancement d'un astout avec ou sans
   surcharge est conforme à la documentation wiki. J'ai tout de même modifié ce dernier pour
   indiquer qu'il fallait utiliser la version séquentielle pour construire les catalogues (en
   batch).
   J'ai testé la surchage des sources et des fichiers de tests sans problème. Il faut juste
   bien indiquer la version NEW10_mpi dans l'interface astk.
   Suite à cette réponse, Jacques est favorable à la cloture de la fiche.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    astout avec NEW10_mpi
NB_JOURS_TRAV  : 0.3
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR massin       MASSIN Patrick         DATE 09/07/2010 - 10:05:34

--------------------------------------------------------------------------------
RESTITUTION FICHE 015447 DU 2010-08-23 12:41:47
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TMA : CS
TITRE
    X-FEM : quadratique 3D sans contact
FONCTIONNALITE
   Objectif : 
   ---------
   Suite à la remontée d'erreur et aux remarques faites en EDA sur 
   la fiche 15330, il est proposé d'enrichir la base de cas tests 
   d'un test permettant de
   protéger le cheminement d'un calcul avec des éléments X-FEM 
   quadratiques 3D sans  contact.
   
   Dans la base les cas tests suivants :  
   
   le ssnv203 vérifie l’imposition de conditions de Neumann sur 
   des lèvres d’une fissure par
   la méthode X-FEM , 
   
   le ssnv191 valide la prise en compte de conditions aux limites 
   de type Neumann sur des éléments de peau X-FEM.
   
   Pour le moment les cas tests ne valident pour le moment que le 
   3D linéaire et les modélisations C_PLAN et D_PLAN.
   
   Proposition :
   ------------
   Dans le cas test ssnv191 : 
   - Ajouter une modélisation 3D quadratique.
   - Mettre à jour la doc V (i.e. v6.4.191) :
     o ajout la nouvelle modélisation
   
   Dans le cas test ssnv203 : 
   - Une fiche d'anomalie sur le REX pour le cas test  
   ssnv203 avec une modélisation
   3D quadratique (cause absence de convergence) existe déjà
   : c'est la fichez 15361 mais pas spécifique à ce cas test mais 
   sur le même problème. 
   Concernant la fiche 15474, la seule charge est la pression  
   appliquée sur les lèvres. Or
   cette charge n'est pas calculée 
   sur les lèvres en 3D quadratique. Donc le résidu est infini.
   Tout cela est expliqué dans l'AL 15361
   On propose donc de classer sans suite la fiche AL 15474 qui 
   fait doublon.
   
   Pas besoin de supprimer les DDL DCX et DCY dans les doc V, car 
   les documents qui ont été envoyés par monsieur Massin sont à 
   jour.
   
   La documentation V6.04.191 a été restituée dans le circuit de  
   relecture code_aster sur
   claut681. 
   
   Les développements seront sans doute réalisés par Axelle Caron
   (mettre la fiche en évolution pour garder une trace).
   
   Presentation de la fiche faite par S. Géniaut le lundi 6 
   septembre.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : v6.04.191
VALIDATION
    ssnv191d
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR pellet       PELLET Jacques         DATE 09/06/2010 - 02:39:22

--------------------------------------------------------------------------------
RESTITUTION FICHE 015223 DU 2010-06-16 12:46:20
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TMA : DeltaCad
TITRE
    Affichage des TEST_RESU
FONCTIONNALITE
   A] Objectifs
   ============
   L'objectif de cette fiche est de:
   1) supprimer un decallage dans l'affichage des TEST_RESU, 
   2) afficher le nom de la composante lorsque l'utilisateur renseigne NOM_CMP dans
   l'operateur TEST_RESU,
   3) supprimer la possibilite de fournir plusieurs composantes a NOM_CMP dans l'operateur
   TEST_RESU.
   
   
   B] Developpement
   ================
   
   1) Le decallage de l'affichage se produit lorsque le nombre de decimales de VALE_CAL est
   superieur a 9.
   Exemple (extrait de wtnp123a) :
   
   AVANT:
   
    ---- RESULTAT         NUME_ORDRE       NOM_CHAM         NOM_CMP          NOEUD
         CAL1             30               DEPL             PRE2             NT566
         REFERENCE        LEGENDE          VALE_REF                 VALE_CAL                
   ERREUR        TOLE            
    OK   NON_REGRESSION   XXXX             4.66788E-14              2.9016658585711E-16     
   4.6E-14       1.0E-12         
   
   APRES:
   
    ---- RESULTAT         NUME_ORDRE       NOM_CHAM         NOM_CMP          NOEUD
         CAL1             30               DEPL             PRE2             NT566
         REFERENCE        LEGENDE          VALE_REF         VALE_CAL                 ERREUR 
            TOLE            
    OK   NON_REGRESSION   XXXX             4.66788E-14      2.9016658585711E-16      4.6E-14
            1.0E-12         
   
   Routine impactee : utites.f
   Avant, le nombre de decimale de la valeur calculee determinait a la fois le nombre de
   caracteres de VALE_CAL et de 
   VALE_REF. Desormais, on prend en compte le nombre de decimale de la valeur de reference
   pour l'affichage de VALE_REF.
   
   2) La composante n'est pas affichee lorsque l'on teste le min ou le max d'un champ.
   
   Exemple (extrait de wtnp123a):
   
   AVANT:
   
    ---- RESULTAT         NUME_ORDRE       NOM_CHAM         TYPE_TEST    
         CAL1             30               DEPL             MAX          
         REFERENCE        LEGENDE          VALE_REF         VALE_CAL         ERREUR         
    TOLE            
    OK   NON_REGRESSION   XXXX             68858.4358       68858.435813224  1.3E-05        
    1.0E-03         
   
   APRES:
   
   
    ---- RESULTAT         NUME_ORDRE       NOM_CHAM         TYPE_TEST        NOM_CMP
         CAL1             30               DEPL             MAX              PRE2
         REFERENCE        LEGENDE          VALE_REF         VALE_CAL         ERREUR         
    TOLE            
    OK   NON_REGRESSION   XXXX             68858.4358       68858.435813224  1.3E-05        
    1.0E-03         
   
   Routines impactees:
   trresu.f, trchel.f, trchno.f, utest4.f.
   On construit une chaine de caracteres par ligne d'affichage. On passe les chaines de
   caracteres relatives a la 3eme et 
   4eme ligne a utest4.f dont la contribution est d'y ajouter le nom de la composante en
   fonction de l'option choisie 
   (min,max,somm,somm_abs).
   
   
   3/ Avant, on pouvait fournir plusieurs nom de composantes a NOM_CMP. Cette fonctionnalite
   est desormais resorbee.
   Il faut donc tester composante par composante.
   
   Exemple (extrait de sdnl112b):
   
   AVANT :
   
   TEST_RESU(RESU=_F( RESULTAT = MODES,  NOM_CHAM='DEPL',
                      TYPE_TEST = 'SOMM_ABS',  NUME_ORDRE = 1,
                      NOM_CMP   = ('DX','DY','DZ','DRX','DRY','DRZ',),
                      REFERENCE = 'NON_REGRESSION',
                      VALE = 1.4379212881693E+02,
                      PRECISION = 1.E-09 ),)
   APRES:
     
   TEST_RESU(RESU=(
              _F(  RESULTAT = MODES,  NOM_CHAM='DEPL',
                     TYPE_TEST = 'SOMM_ABS',  NUME_ORDRE = 1,
                     NOM_CMP   = ('DX',),
                     REFERENCE = 'NON_REGRESSION',
                     VALE =  3.2781186275527E+01,
                     PRECISION = 1.E-09),
              _F(  RESULTAT = MODES,  NOM_CHAM='DEPL',
                     TYPE_TEST = 'SOMM_ABS',  NUME_ORDRE = 1,
                     NOM_CMP   = ('DY',),
                     CRITERE   = 'ABSOLU',
                     REFERENCE = 'NON_REGRESSION',
                     VALE =  0. ,
                     PRECISION = 1.E-08),
              _F(  RESULTAT = MODES,  NOM_CHAM='DEPL',
                     TYPE_TEST = 'SOMM_ABS',  NUME_ORDRE = 1,
                     NOM_CMP   = ('DZ',),
                     CRITERE   = 'ABSOLU',
                     REFERENCE = 'NON_REGRESSION',
                     VALE =  0. ,
                     PRECISION = 1.E-09),
              _F(  RESULTAT = MODES,  NOM_CHAM='DEPL',
                     TYPE_TEST = 'SOMM_ABS',  NUME_ORDRE = 1,
                     NOM_CMP   = ('DRX',),
                     CRITERE   = 'ABSOLU',
                     REFERENCE = 'NON_REGRESSION',
                     VALE =  0. ,
                     PRECISION = 1.E-07),
              _F(  RESULTAT = MODES,  NOM_CHAM='DEPL',
                     TYPE_TEST = 'SOMM_ABS',  NUME_ORDRE = 1,
                     NOM_CMP   = ('DRY',),
                     REFERENCE = 'NON_REGRESSION',
                     VALE =  9.6039266778993E+01,
                     PRECISION = 1.E-09),
              _F(  RESULTAT = MODES,  NOM_CHAM='DEPL',
                     TYPE_TEST = 'SOMM_ABS',  NUME_ORDRE = 1,
                     NOM_CMP   = ('DRZ',),
                     REFERENCE = 'NON_REGRESSION',
                     VALE =  1.4971675757379E+01,
                     PRECISION = 1.E-09),),)
   
   Impact: cas-tests sdnl112b, sdnl112c
   
   C] Validation
   =============
   - cas-tests sdnl112b,sdnl112c,wtnp123a
   - cas-test interne base sur wtnp123a pour tester les differentes possibilites
   - liste restreinte
   
   D] Documentation
   ================
   Mise a jour de la documentation U4.92.01 (Operateur TEST_RESU)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.92.01
VALIDATION
    sdnl112b,sdnl112c,wtnp123a
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR sellenet     SELLENET Nicolas       DATE 09/06/2010 - 02:26:34

--------------------------------------------------------------------------------
RESTITUTION FICHE 015443 DU 2010-08-23 07:10:28
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
    SV01 - temps de calcul POST_ELEM : peu de ddl, bcp de pas de temps
FONCTIONNALITE
   Problème :
   ----------
   """
   Dans l'étude jointe, on a un pb à très faible nombre de ddl (5 éléments) mais à grand
   nombre de pas de temps 
   (20000). On constate que POST_ELEM prend un temps très important. Un profiling nous
   permettrait-il 
   d'envisager des améliorations (algorithme, parallélisme)?
   """
   
   
   Analyse :
   ---------
   Un profiling de POST_ELEM a été réalisé. Il a révélé deux problèmes.
   
   La première concerne DEBCAL qui fait trop de JENUNO. Cette routine alloue deux vecteurs
   JEVEUX ('&&CALCUL.NOMOP' et '&&CALCUL.NOMTE') créant un lien entre d'une part un numéro et
   un nom d'option et d'autre part entre un numéro et un nom de TE. Or à chaque appel à
   CALCUL, ces tableaux sont créés et détruits et c'est inutile puisqu'ils n'ont aucune
   raison de changer entre 2 appels. La modif consiste donc à les créer une fois pour toute
   pour chaque commande qui utilise CALCUL.
   
   Le deuxième point concerne le JEDETC qui se trouve en deuxième position du profiling. En
   fait, il ne sert à rien. Sur ses 20004 appels, 20001 sont dus à MECALC. Or MECALC n'alloue
   que très rarement la carte dont on demande la destruction à tous les coups. De plus la
   routine d'allocation des cartes se charge en entrée de supprimer une carte déjà existante.
   Ce JEDETC est donc totalement inutile.
   
   Au delà de ça, on sait que CALCUL a un coup fixe important qui devient très visible
   lorsqu'on a qu'un petit nombre d'éléments.
   
   
   Solution :
   ----------
   Modification de DEBCAL pour qu'il n'alloue qu'une fois par commande les tableaux
   '&&CALCUL.NOMOP' et '&&CALCUL.NOMTE'.
   
   Suppression d'un JEDETC sur '&&MECALC.NOVARI' dans MECALC.
   
   En mettant en oeuvre ces modifications, le temps du POST_ELEM profilé passe de 175
   secondes à 145.
   
   
   Validation :
   ------------
   Liste restreinte.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    Liste restreinte
NB_JOURS_TRAV  : 0.7
--------------------------------------------------------------------------------
RESTITUTION FICHE 014625 DU 2010-02-15 07:01:24
TYPE evolution concernant Code_Aster (VERSION 7.0)
TMA : CS
TITRE
    Suivi des perfs
FONCTIONNALITE
   Demande :
   ---------
   Cette fiche à pour but de suivre l'expérimentation de l'analyse de l'évolution des
   performances d'aster sur 2 mois.
   
   
   Travail réalisé :
   -----------------
   Une page web de suivi des performances et un mail hebdomadaire ont été mis en place :
   http://aster-rex.der.edf.fr/arbres/standard/castest/perf.html
   
   Le but de cette fiche était de déterminer la faisabilité d'un suivi fin de l'évolution des
   performances.
   
   A l'issu des deux mois, le constat est mitigé.
   
   Dans le détail, il a été mis en place :
   - un suivi cas test par cas test des temps CPU et système sur calibre 5 (claut682),
   - une détection chaque semaine des cas tests dépassant la limite, ie 3 fois l'écart-type
   constaté pour le cas test considéré,
   - pour ces cas test, on réalise une analyse commande par commande des variations des temps
   CPU.
   
   Néanmoins, on a essayé d'aller plus loin. Le but affiché était de trouver une liste
   restreinte de routines (2 ou 3) qui pouvaient être responsables de la dégradation des
   performances.
   
   Quelques tests infructueux ont été ménés :
   - profiling des cas tests,
   - utilisation des arbres d'appels et de la couverture de code,
   - analyse de l'histor,
   - et combinaison de ces idées...
   
   Au final, la seule chose qui soit réalisable c'est relancer des astouts sur les cas tests
   pour s'assurer qu'il y a vraiment un problème.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    aucune
DEJA RESTITUE DANS : 10.1.22
--------------------------------------------------------------------------------
RESTITUTION FICHE 015278 DU 2010-07-01 08:07:41
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    QUA03 Couverture des fonctionnalitxc3xa9s
FONCTIONNALITE
   Demande :
   ---------
   """
   Chaque semaine, Jacques envoie un courriel informant les développeurs de la couverture des
   fonctionnalités 
   du code par les tests. Ne serait-il pas intéressant de capitaliser ce scriptajaco dans une
   page web sur 
   clpwdev et d'en conserver l'historique?
   """
   
   
   Solution :
   ----------
   On rajoute 2 éléments à la page intranet http://aster-rex.der.edf.fr/arbres/standard/ :
   - l'historique des mails de Jacques qui vérifient semaine après semaine les différences de
   validation des mots-clés entre 2 versions NEW,
   - et pour chaque capy, on ajoute une page pointant les défauts de validation des mots-clés.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    aucune
NB_JOURS_TRAV  : 1.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR tardieu      TARDIEU Nicolas        DATE 09/06/2010 - 05:37:20

--------------------------------------------------------------------------------
RESTITUTION FICHE 015461 DU 2010-08-26 11:42:43
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
    En NEW10.2.12, le cas-test petsc01e s'arrete en <F>_ERROR sur Bull MPI
FONCTIONNALITE
   Lors de l'utilisation du préconditionneur simple précision LDLT_SP avec PETSc, il se
   posait un problème avec STAT/DYNA_NON_LINE quand REAC_ITER!=1. En effet, à la sortie de la
   résolution pour ACTION='RESOUD', on détruisait les vecteurs de travail qui ne sont créés
   que pour ACTION='PRERES'. DOnc pour la deuxième résolution, ces vecteurs de travail
   étaient inexistants.
   Je corrige le problème en détruisant ces vecteurs pour ACTION='DETR_MATR'.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    Passage du test
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 015491 DU 2010-09-03 06:54:55
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
    Mauvaises initialisations dans nmrelp.f
FONCTIONNALITE
   Je corrige les initialisations.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ftncheck
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST AJOUT ssnv191d                      mahfouz D.MAHFOUZ          679    679      0
 CASTEST AJOUT ssnv217b                        idoux L.IDOUX            223    223      0
 CASTEST MODIF mtlp103a                      boiteau O.BOITEAU          864      3      1
 CASTEST MODIF mumps02a                      boiteau O.BOITEAU          182      5      5
 CASTEST MODIF sdnl112b                      rezette C.REZETTE          550    109     15
 CASTEST MODIF sdnl112c                      rezette C.REZETTE          620    147     13
 CASTEST MODIF wtnp123a                      rezette C.REZETTE          750    157      1
CATALOPY MODIF commande/test_resu            rezette C.REZETTE          175      4      4
       C MODIF supervis/astermodule         courtois M.COURTOIS        3957      7      2
       C MODIF utilitai/inisig              courtois M.COURTOIS         162     16      2
FORTRAN90 MODIF petsc/apets3                  tardieu N.TARDIEU          203      2      1
FORTRAN90 MODIF petsc/apetsr                  tardieu N.TARDIEU          374      8      4
 FORTRAN MODIF algeline/op0144                desoza T.DESOZA           388      5      6
 FORTRAN MODIF algeline/vpstor                desoza T.DESOZA           357      5      2
 FORTRAN MODIF algeline/vtcrea                desoza T.DESOZA           107      2      3
 FORTRAN MODIF algeline/vtcreb                desoza T.DESOZA           124      3      4
 FORTRAN MODIF algorith/cla110                desoza T.DESOZA           528      4      4
 FORTRAN MODIF algorith/cyc110                desoza T.DESOZA           346      3      4
 FORTRAN MODIF algorith/dyobar                desoza T.DESOZA           528      3      3
 FORTRAN MODIF algorith/gcour3                desoza T.DESOZA           353      9     16
 FORTRAN MODIF algorith/mdallc                desoza T.DESOZA           152     17     12
 FORTRAN MODIF algorith/mdallr                desoza T.DESOZA           136      8      8
 FORTRAN MODIF algorith/nmrelp               tardieu N.TARDIEU          377      4      4
 FORTRAN MODIF algorith/op0060                desoza T.DESOZA           740      7      3
 FORTRAN MODIF assembla/assmiv                desoza T.DESOZA           384      4      4
 FORTRAN MODIF calculel/calvci                desoza T.DESOZA           256      4      6
 FORTRAN MODIF calculel/chnucn                desoza T.DESOZA           264      3      4
 FORTRAN MODIF calculel/cnscno                desoza T.DESOZA           344      5      3
 FORTRAN MODIF calculel/crchno                desoza T.DESOZA           103      4      4
 FORTRAN MODIF calculel/crcnct                desoza T.DESOZA           136      3      4
 FORTRAN MODIF calculel/debcal              sellenet N.SELLENET         408     11      6
 FORTRAN MODIF calculel/ecla3d                berard A.BERARD          1027      2      3
 FORTRAN MODIF calculel/mecalc              sellenet N.SELLENET         580      1      2
 FORTRAN MODIF calculel/op0100                desoza T.DESOZA          1082      3      3
 FORTRAN MODIF calculel/rdtmai                desoza T.DESOZA           424      2      2
 FORTRAN MODIF calculel/trchel               rezette C.REZETTE          271     27     11
 FORTRAN MODIF calculel/trchno               rezette C.REZETTE          226     29      9
 FORTRAN MODIF calculel/trresu               rezette C.REZETTE          480     13     15
 FORTRAN MODIF calculel/utest4               rezette C.REZETTE          430    128     12
 FORTRAN MODIF elements/gban2d                desoza T.DESOZA           186      3      3
 FORTRAN MODIF elements/gcou2d                desoza T.DESOZA           223      2      2
 FORTRAN MODIF elements/gcour2                desoza T.DESOZA           622     13     14
 FORTRAN MODIF elements/gcouro                desoza T.DESOZA           415     10     12
 FORTRAN MODIF elements/vtcre1                desoza T.DESOZA           127      7     16
 FORTRAN MODIF jeveux/jedetv                lefebvre J-P.LEFEBVRE       228     18      2
 FORTRAN MODIF modelisa/asmaco                desoza T.DESOZA           640      2      3
 FORTRAN MODIF modelisa/asmasu                desoza T.DESOZA           333      3      3
 FORTRAN MODIF modelisa/lrmast                desoza T.DESOZA           711      3      3
 FORTRAN MODIF modelisa/lrmmno                desoza T.DESOZA           224      2      2
 FORTRAN MODIF prepost/xpodim                 desoza T.DESOZA           317      2      2
 FORTRAN MODIF soustruc/ssdein                desoza T.DESOZA           246      6     12
 FORTRAN MODIF soustruc/ssdmte                desoza T.DESOZA           258      3      4
 FORTRAN MODIF supervis/execop              courtois M.COURTOIS         136      2      2
 FORTRAN MODIF supervis/sigusr              courtois M.COURTOIS          28      2      1
 FORTRAN MODIF utilitai/inimai                desoza T.DESOZA           157      2      2
 FORTRAN MODIF utilitai/utites               rezette C.REZETTE          363     42      3
 FORTRAN SUPPR calculel/crchn2                desoza T.DESOZA           105      0    105
  PYTHON MODIF Execution/E_Exception        courtois M.COURTOIS         141     17      5
  PYTHON MODIF Execution/E_JDC              courtois M.COURTOIS         361      5      5
  PYTHON MODIF Messages/jeveux1             lefebvre J-P.LEFEBVRE       413      8      1
  PYTHON MODIF SD/sd_cham_no                  desoza T.DESOZA            80     34      8
  PYTHON MODIF SD/sd_util                     desoza T.DESOZA           195      6      2
  PYTHON MODIF Utilitai/Table               courtois M.COURTOIS        1049      4      4


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :    2         902       902              +902
 MODIF :   60       25841       963     316      +647
 SUPPR :    1         105               105      -105
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :   63       26848      1865     421     +1444 
