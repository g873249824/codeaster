

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 08/01/2008 - 15:27:11

--------------------------------------------------------------------------------
RESTITUTION FICHE 011579 DU 2007-12-19 16:21:51
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TITRE
   Probleme de performance CALC_TABLE sur une grosse table
FONCTIONNALITE
   Le problème concerne le post-traitement d'une table obtenue avec OBSERVATION dans
   DYNA_NON_LINE. Il y a 4000 pas de temps, plusieurs noeuds et composantes de champs: soit
   au total une table de 350.000 lignes.
   
   J'ai reproduit le problème en repartant de la table imprimée au format ASTER. LIRE_TABLE
   prend environ 80 s (contre 11 s pour une table de 50.000 lignes).
   
   L'opération coûteuse est l'intersection de deux tables activée par le mot-clé FILTRE. Il
   faut pour chaque ligne de la table 2 regarder si une ligne identique existe dans la table
   1, et si oui, on ajoute cette ligne dans la table intersection.
   Pour le test "est-ce qu'une ligne est dans la table ?", on fait "if ligne in tab2.rows" en
   o(n).
   Donc l'intersection était en o(n^2).
   
   Je modifie l'algo pour qu'il reste en o(n) :
   - fonction qui retourne un tuple ordonné des valeurs d'une ligne (_tuplevalues)
   - construction d'un dictionnaire : dico = { _tuplevalues(ligne) : 1}
   - le test "est-ce qu'une ligne est dans la table ?" devient dico.get(_tuplevalues(ligne))
   == 1 qui est immédiat.
   
   
   Sur la table de 50.000, CALC_TABLE( 3 FILTREs ) passe de 43 s à 1.15 s.
   Sur la table de 350.000, çà passe de 2900 s à 9.6 s.
   
   NB : il faut environ 100 Mo hors jeveux pour CALC_TABLE avec la plus grosse table.
   
   Au passage, une anomalie a été corrigée dans la méthode SansColonneVide (qui comme son nom
   l'indique permet de supprimer les colonnes vides d'une table).
   
   
   Modif reportée en version 8 (Table.py).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   tests CALC_TABLE
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 011591 DU 2008-01-03 16:08:54
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   Probleme de memoire
FONCTIONNALITE
   Petite explication sur le pourquoi du "dont Aster" :
   Jusqu'à récemment, on donnait une seule valeur de mémoire pour un calcul, elle était
   disponible pour les objets jeveux (fortran). La partie Python (superviseur, analyseur du
   jeu de commandes) se contentait de prendre "à côté" et il n'y avait pas de mécanisme pour
   limiter ce surplus de mémoire. Un job pouvait alors prendre 4 Go de mémoire jeveux et 200
   Mo en plus sans qu'on l'en interdise (ce qui pose des problèmes ensuite d'exploitation des
   serveurs de calcul).
   
   Depuis la version 9, un mécanisme interdit de prendre beaucoup plus de mémoire que ce qui
   est demandé dans le champ "Mémoire totale". Dans certains cas d'utilisation, on peut avoir
   besoin de beaucoup de mémoire hors de jeveux : solveur externe (Mumps), manipulation
   Python importante...On peut alors répartir finement la mémoire totale entre ce qui sera
   donné à Jeveux et ce qui sera libre pour le reste.
   Le "reste" peut être du python (dans une macro ou dans le fichier de commandes), un
   solveur (para exemple MUMPS) ou un outil (Miss, Gibi) appelés en externe qui alloue leurs
   propres objets en mémoire.
   
   
   Problème remonté dans la fiche :
   Il y a 120.000 lignes de DEFI_FONCTION dans le fichier de commandes.
   - le VALE est un tuple python qu'il faut bien alloué : perte de mémoire
   - chacune des valeurs du VALE des fonctions sont analysées et vérifiées : inutile, cela
   peut coûter en temps à la longue.
   
   La solution naturelle est d'utiliser LIRE_FONCTION qui est fait pour çà : lire des
   colonnes de chiffres dans un fichier pour en faire des fonctions. Le jeu de commandes sera
   beaucoup plus facile à lire.
   
   Sinon on peut aussi ajuster les paramètres pour laisser un peu plus de mémoire pour Python.
   Le cas passe (batch sur Bull) avec 96 Mo dont 32 Mo pour Aster (soit un max de 64 Mo pour
   python, ce qui ne semble pas aberrant avec un jeu de commandes qui fait 3.5 Mo de texte).
   Ce qui donne dans astk : Mémoire totale = 96 Mo, dont Aster = 32 Mo.
   
   
   Emission d'un message plus clair :
   Quand la limite mémoire est atteinte en Python, on s'arrête normalement avec MemoryError.
   Dans ce cas, l'exception est récupérée et on émet un message plus détaillé :
   
      """
      En général, cette erreur se produit car la mémoire utilisée hors du fortran
      (jeveux) est importante.
   
      Causes possibles :
         - le calcul produit de gros objets Python dans une macro-commande ou
           dans le jeu de commande lui-même,
         - le calcul appelle un solveur (MUMPS par exemple) ou un outil externe
           qui a besoin de mémoire hors jeveux,
         - utilisation de jeveux dynamique,
         - ...
   
      Solution :
         - distinguer la mémoire limite du calcul (case "Mémoire totale" de astk)
           de la mémoire réservée à jeveux (case "dont Aster"), le reste étant
           disponible pour les allocations dynamiques.
      """
   
   Cependant, il arrive souvent que l'arrêt soit plus brutal : "Memory fault" ou "Cannot
   allocate memory" et on ne récupère pas la main pour imprimer le message.
   
   A noter qu'à l'avenir (a priori avant la 9.3), jeveux dynamique sera activé par défaut et
   donc seul le paramètre "Mémoire totale" (borne sup) sera à renseigner par l'utilisateur
   (suppression de "dont Aster").
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   tests en erreur
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desoza       DE SOZA Thomas         DATE 08/01/2008 - 11:14:30

--------------------------------------------------------------------------------
RESTITUTION FICHE 011533 DU 2007-12-04 17:58:33
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TITRE
   MISS09A : temps CPU insuffisant sur Calibre et Rocks : problxc3xa8mes de performances dans DYNA_LINE_HARM
FONCTIONNALITE
   Problème
   ========
   
   Variabilité des temps d'exécution sur les différentes machines de validation du cas-test
   MISS09A utilisant DYNA_LINE_HARM.
   
   ==> La référence est ici la Bull (Itanium II 1.6Ghz, RAM illimitée)
   
    ********************************************************************************
    * COMMAND                  :       USER :     SYSTEM :   USER+SYS :    ELAPSED *
    ********************************************************************************
    * DYNA_LINE_HARM           :     234.43 :       8.87 :     243.30 :     243.64 *
    * DYNA_LINE_HARM           :     231.46 :       8.29 :     239.75 :     239.89 *
   
   Dans chaque DYNA_LINE_HARM, il y a deux inversions de systèmes linéaires (taille de la
   liste de fréquences : 2). Le solveur utilisé est MULT_FRONT (sélectionné indirectement par
   le NUME_DDL des matrices en entrée).
   
   
   ==> Sur une machine Linux (claut617, Bi Intel Xeon 3.4 GHz, 3,5 Go de RAM), on obtient ceci :
    * DYNA_LINE_HARM           :     880.84 :      14.77 :     895.61 :     900.45 *
   
   ==> Sur une machine Linux (claut625, Intel Quad Xeon 2.33 GHz, 3 Go de RAM)
    * DYNA_LINE_HARM           :     653.90 :      12.41 :     666.31 :     822.11 *
    * DYNA_LINE_HARM           :     650.34 :      10.95 :     661.29 :     817.27 *
   
   ==> Sur Rocks (Clpaster, Bi Opteron 2.2 Ghz, 4 Go de RAM)
    * DYNA_LINE_HARM           :     864.73 :      19.18 :     883.91 :     885.11 *
    * DYNA_LINE_HARM           :     862.62 :      16.47 :     879.09 :     880.29 *
   
   
   Plus de 3 fois plus longs en moyenne.
   
   Analyse
   =======
   
   a/ La première idée est d'essayer comme pour la fiche 11443 d'utiliser des bibliothèques
   mathématiques plus optimisées sur les machines dont les temps sont mauvais.
   On obtient alors :
   
   ==> Sur une machine Linux (claut617, Bi Intel Xeon 3.4 GHz, 3,5 Go de RAM)
    * DYNA_LINE_HARM           :     304.60 :      15.58 :     320.18 :     322.33 *
    * DYNA_LINE_HARM           :     301.25 :      11.09 :     312.34 :     315.02 *
   
   ==> Sur une machine Linux (claut625, Intel Quad Xeon 2.33 GHz, 3 Go de RAM)
    * DYNA_LINE_HARM           :     253.00 :      12.80 :     265.80 :     405.36 *
    * DYNA_LINE_HARM           :     248.44 :       9.79 :     258.23 :     372.44 *
   
   ==> Sur Rocks (Clpaster, Bi Opteron 2.2 Ghz, 4 Go de RAM)
    * DYNA_LINE_HARM           :     405.35 :      18.17 :     423.52 :     424.28 *
    * DYNA_LINE_HARM           :     399.21 :      15.92 :     415.13 :     415.39 *
   
   
   Les temps sont donc sensiblement améliorés mais ils restent quand même supérieurs à ceux
   de la Bull. Deux cas de figure existent :
   
   ==> Sur la machine claut625 où la quantité de RAM est moindre que sur Rocks ou claut617,
   on remarque que les temps USER+SYS ne sont pas égaux à ELAPSED. C'est là le signe d'une
   utilisation du swap, ce qui est compréhensible dans la mesure où le test nécessite pas
   moins de 2Go de RAM et qu'un système Linux même fraîchement démarré (comme c'était le cas
   sur ces benchs) consomme déjà 900 Mo ...
   
   La question qui vient à l'esprit est pourquoi a-t-on besoin d'autant de RAM pour un test
   qui ne comporte que 80000 DDLs ?
   
   En étudiant un peu la répartition de la mémoire (avec JEVEUX dynamique), on se rend compte
   que c'est la MULT_FRONT qui représente l'essentiel des 2 Go. Est-ce normal ? Réponse plus
   loin ...
   
   ==> Sur ROCKS ou claut617, les temps écoulés sont de 50 à 100% supérieurs à celui de la
   Bull, par contre USER+SYS=ELAPSED. C'est cohérent avec la quantité de RAM installée
   (respectivement 4 et 3.5 Go)
   Quand à la différence de temps entre ROCKS et Calibre, on peut légitimement penser la
   machine clpaster qui a presque 3 ans est plus lente que les autres.
   
   b/ Pour revenir sur la consommation mémoire de la MULT_FRONT qui est ici la version
   complexe j'ai voulu utiliser MUMPS. Il y a alors un plantage en ASSERT(.FALSE.) (Fiche 11587).
   J'ai modifié quelques sources pour inverser le système linéaire par la voie canonique
   PRERES/RESOUD et je peux donc comparer avec le solveur MUMPS.
   
   J'ai commencé par des tests sur la Bull :
   
   MUMPS & JEVEUX dynamique (fortement conseillé avec MUMPS)
    * DYNA_LINE_HARM           :     186.79 :       1.41 :     188.20 :     188.28 *
    * DYNA_LINE_HARM           :     186.57 :       1.45 :     188.01 :     188.02 *
   ==> environ 2.1 Go (via Top, majoration incluant Python)
   
   MULT_FRONT & JEVEUX dynamique (pour comparer la même chose)
    * DYNA_LINE_HARM           :     209.77 :       5.10 :     214.88 :     215.18 *
    * DYNA_LINE_HARM           :     207.25 :       1.46 :     208.71 :     208.71 *
   ==> 1842 Mo (Jeveux)
   
   On constate d'une part que MUMPS est meilleur que MULT_FRONT mais que JEVEUX dynamique
   apporte un gain dans le solveur MULT_FRONT, pour s'en convaincre j'ai fait tourner :
   
   MUMPS & JEVEUX statique 
    * DYNA_LINE_HARM           :     186.96 :       1.47 :     188.42 :     188.43 *
    * DYNA_LINE_HARM           :     187.10 :       1.42 :     188.52 :     188.52 *
   ==> environ 2.2 Go (via Top, majoration incluant Python)
   
   Deuxième point important : la mémoire. La résolution de ce système de dimension 80000
   complexe nécessite bien un bon Go de mémoire à lui tout seul.
   
   c/ Application à Calibre et Rocks
   
   J'ai tout simplement essayé de faire tourner le test sans rien changer sauf JEVEUX
   dynamique et les BLAS optimisées : cela ne marche pas car les machines 32 bits sont
   limitées par le maximum de RAM allouable par un exécutable.
   
   Sans conviction j'ai essayé Jeveux Dynamique + MUMPS + Blas optimisées   ..... et ça a
   marché :
   
   ==> Sur une machine Linux (claut617, Bi Intel Xeon 3.4 GHz, 3,5 Go de RAM), on obtient ceci :
    * DYNA_LINE_HARM           :     193.41 :       3.31 :     196.72 :     220.84 *
    * DYNA_LINE_HARM           :     192.46 :       3.46 :     195.92 :     219.66 *
   11
   ==> Sur une machine Linux (claut625, Intel Quad Xeon 2.33 GHz, 3 Go de RAM), on obtient ceci :
    * DYNA_LINE_HARM           :     178.31 :       2.36 :     180.67 :     194.81 *
    * DYNA_LINE_HARM           :     178.16 :       2.34 :     180.50 :     194.82 *
   
   ==> Sur Rocks (Clpaster, Bi Opteron 2.2 Ghz, 4 Go de RAM)
   Problème ...
   
   
   
   Conclusion
   ==========
   
   Il ne semble pas y avoir de problèmes flagrants dans l'algorithmie de DYNA_LINE_HARM. La
   MULT_FRONT complexe semble consommer un peu plus de mémoire que MUMPS sur machine Calibre
   mais y-a-t-il vraiment un problème ?
   
   Modifier les cas-tests pour essayer de les faire passer comme il faut sur Calibre et Rocks
   (en utilisant JEVEUX dynamique, etc ...) n'est pas une bonne idée car les benchs ici ont
   été faits sans charge et puis la machine de référence est encore moins puissante et a
   encore moins de RAM (clp50a8).
   
   Seule préconisation : installer des BLAS optimisées, peut être émettre une fiche dédiée.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   miss09a
NB_JOURS_TRAV  : 2.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 011548 DU 2007-12-10 17:48:06
TYPE evolution concernant Code_Aster (VERSION 2.x)
TITRE
   Ecrasement de surface rugueuse
FONCTIONNALITE
   On modifie le message émis lorsque l'on fait du contact et que SYME='NON' (défaut) dans le
   mot clé SOLVEUR :
   
      !------------------------------------------------------------------------!
      ! <A> <CONTACT_1>                                                        !
      !                                                                        !
      !                                                                        !
      !  Contact méthodes discrètes.                                           !
      !   -> Les méthodes de contact discrètes supposent la symétrie de la     !
      !      matrice obtenue après assemblage.                                 !
      !      Si votre modélisation produit une matrice non-symétrique, on force!
      !      donc sa symétrie pour résoudre le contact.                        !
      !   -> Risque & Conseil :                                                !
      !      Ce changement peut conduire à des difficultés de convergence dans !
      !      le processus de Newton mais en aucun cas il ne produit des        !
      !      résultats faux.                                                   !
      !                                                                        !
      !      Si la matrice de rigidité de votre structure est symétrique, vous !
      !      pouvez ignorer ce qui précède.                                    !
      !      Enfin, il est possible de supprimer l'affichage de cette alarme en!
      !      renseignant SYME='OUI' sous le mot-clé facteur SOLVEUR.           !
      !                                                                        !
      !                                                                        !
      ! Ceci est une alarme. Si vous ne comprenez pas le sens de cette         !
      ! alarme, vous pouvez obtenir des résultats inattendus !                 !
      !------------------------------------------------------------------------!
   
   
   Par ailleurs on modifie la documentation du mot clé SOLVEUR pour remplacer la phrase "La
   symétrisation de la matrice A conduit donc à résoudre un autre problème que celui que l'on
   cherche à résoudre !". On pourrait par exemple renvoyer vers la documentation de référence
   de STAT_NON_LINE qui explique clairement que l'utilisation d'une matrice tangente non
   cohérente ou bien une erreur dans l'estimation des déplacements ne conduit jamais à des
   résultats faux. C'est le calcul correct des forces internes (et donc l'intégration du
   comportement) qui est garant de la justesse des résultats.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.50.01-F
VALIDATION
   nxc3xa9ant
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 011565 DU 2007-12-14 16:11:29
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TITRE
   En NEW9.2.1, le cas-test ssnv506d est NOOK sur Bull.
FONCTIONNALITE
   Problème
   ========
   
   Suite au changement de compilateur, le cas-test ssnv506d est NOOK sur Bull. Le test porte
   sur une valeur de non régression.
   
   Analyse
   =======
   
   1/ Sur ma machine : compilateur identique à ceux de la Bull (Intel 10.0.026), le test est
   OK, la valeur est la même qu'en STA9 sur Bull.
      Sur la Bull : avec un exécutable instrumenté pour la couverture de code, le test est
   aussi OK
   
   
   2/ En INFO=2, on compare les informations du contact avant et après le changement de
   compilateur. On voit alors qu'à partir du second pas de temps, des différences d'arrondis
   dans le contact conduisent à calculer des jeux différents, puis ces différences se
   répercutant, des appariemments noeuds-mailles changent aussi.
   
   3/ Avec le solveur MUMPS, ce cas-test est OK (il n'est pas nécessaire d'activer le
   raffinement de la solution).
      Avec le solveur MUMPS en parallèle sur 4 processeurs, il est NOOK avec exactement la
   même valeur que celle obtenue avec MULT_FRONT. Si on active le raffinement alors il
   devient OK.
   
   
   
   Conclusion et remarques
   =======================
   
   Je conclue que l'on peut ajuster la référence sur la nouvelle valeur. Cependant je fais
   une remarque :
   
   En consultant le document de validation de ce cas-test (V6.04.506-B), on s'aperçoit que
   les TEST_RESU décrits dans celui-ci qui utilisent une source externe ANALYTIQUE ne sont
   plus du tout les mêmes que ceux effectués dans le .comm qui sont des tests de non
   régression (pourtant le document n'est pas si vieux : 15/02/2006).
   
   En consultant le diff du fichier de commandes, je me suis aperçu qu'en effet les anciens
   TEST_RESU ont été supprimés en 7.3.14. À la décharge de la personne qui les a supprimés,
   ils ne servaient en effet à rien : les valeurs de référence commencent à l'instant 0.2
   alors que le calcul ne va qu'à l'instant 0.1. On peut cependant penser que les rédacteurs
   du document de validation avaient à l'époque fait tourner le calcul jusqu'au bout puis
   comparé les résultats sans les laisser dans le fichier de commandes car le test devait
   être trop long (d'où la présence de tests de non régresssion).
   J'ai repris ces TEST_RESU et en faisant tourner le calcul jusqu'au "bout", le test est
   NOOK avec des valeurs qui diffèrent très largement de ce qui est dans le document de
   validation ... Comme les références sont soi disant analytiques, c'est un peu embêtant.
   J'aimerai bien consulter le livre donnant la référence mais il est semble-t-il à SINETICS.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V6.04.506
VALIDATION
   ssnv506d
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 011597 DU 2008-01-04 09:11:40
TYPE express concernant Code_Aster (VERSION 2.x)
TITRE
   Variables non initialisxc3xa9es dans le contact discret
FONCTIONNALITE
   Des variables ne sont pas initialisées dans le contact discret. Rien de bien méchant mais
   cela conduit par exemple l'affichage d'un message d'alarme sur Calibre qui n'a pas lieu
   d'être (cf zzzz231a sur Calibre).
   
   Routines impactées :
   
   exnocp.f : mettre LVERIF et LQUADV à .FALSE.
   nbsuco.f : mettre LQUADV à .FALSE.
   
   
   Découvert grâce à Valgrind.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   valgrind
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR galenne      GALENNE Erwan          DATE 08/01/2008 - 13:56:35

--------------------------------------------------------------------------------
RESTITUTION FICHE 010895 DU 2007-05-24 08:19:19
TYPE evolution concernant Code_Aster (VERSION )
TMA : CS
TITRE
   POST_K1_K2_K3 : prise en compte de la temperature
FONCTIONNALITE
   # Objectif
   Dans POST_K1_K2_K3, si les propriétés matériau dépendent de la température, il est
   nécessaire de connaitre la température en fond de fissure pour faire le calcul des
   facteurs d'intensité des contraintes.
   Cette fonctionnalité avait été développée quand la température était une des charges
   mécaniques (AFFE_CHAR_MECA/TEMP_CALCULEE), on l'adapte dans cette fiche à la nouvelle
   définition de la température comme variable de commande.
   La solution retenue consiste à demander à l'utilisateur de donner explicitement le nom du
   champ de température en entrée de POST_K1_K2_K3.
   
   # Détails
   -> catalogue post_k1_k2_k3.capy : un nouveau mot clé EVOL_THER est ajouté (appelable
   uniquement si FISSURE est renseigné)
   -> macro post_k1_k2_k3_ops.py : prise en compte du nouveau mot clé
   
   Remarque : on en profite pour corriger le catalogue de la structure de donnée FOND_FISS
   qui n'avait pas été correctement défini dans une évolution précédente (remplacement des
   astergetvect par get dans la fiche 11439).
   
   # Validation
   Passage du cas test sslv134g (-> corrige en même temps la fiche 11569)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.82.05
VALIDATION
   sslv134g
--------------------------------------------------------------------------------
RESTITUTION FICHE 011569 DU 2007-12-14 16:31:30
TYPE anomalie concernant Code_Aster (VERSION 9.2)
TMA : CS
TITRE
   En NEW9.2.1, le cas-test sslv134g s'arrete en ARRET_ANORMAL sur Bull, Calibre et Rocks.
FONCTIONNALITE
   Cette fiche a été résolue dans le cadre de la réalisation de la fiche 10895.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sslv134g
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR proix        PROIX Jean-Michel      DATE 07/01/2008 - 11:11:13

--------------------------------------------------------------------------------
RESTITUTION FICHE 011479 DU 2007-11-20 11:35:33
TYPE aide utilisation concernant Code_Aster (VERSION 2.x)
TITRE
   Faire des calculs thermo m?nique avec des coques et des grilles
FONCTIONNALITE
   Bonjour
   
   Les solutions proposées ont permis au prestataire d'avancer correctement sans 
   renoncer au calcul coque.
   
   Je tiens à remercier ici Jean-Michel et tous ceux qui l'ont aidé à proposer 
   cette AOM rapidement et à débloquer ainsi la situation
   
   Cordialement
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   aucune
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 011493 DU 2007-11-22 15:48:29
TYPE aide utilisation concernant Code_Aster (VERSION 9.1)
TITRE
   STAT_NON_LINE: type de fonction inconnu
FONCTIONNALITE
   Problème rencontré : Arret de Code Aster dans STAT_NON_LINE avec le message suivant:
   
      !--------------------------------------------------------------------!
      ! <F> <UTILITAI6_36>                                                 !
      !  erreur de programmationtype de fonction inconnu  Ã??????C?????? !
      ! Cette erreur est fatale. Le code s'arrete.                         !
      !--------------------------------------------------------------------!
      
   #8  0x40000000000e3410 in u2mesg_??unw ()
   #9  0x40000000000f4ab0 in fonbpa_??unw ()
   #10 0x4000000000169160 in dismca_??unw ()
   #11 0x40000000000e9350 in dismoi_??unw ()
   #12 0x4000000000374fb0 in nmdome_??unw ()
   #13 0x4000000000fa96c0 in nmlect_??unw ()
   #14 0x400000000039e7c0 in op0070_??unw ()
   
   Solution : Plusieurs petites corrections sont à apporter au fichier de commandes pour
   qu'il tourne en version 9 (à cause principalement des nouvelles variables de commandes).
   Moyennant cela, et avec le paramètre -max_base=50000 dans astk, le calcul tourne.
   Je n'ai donc pas réussi à reproduire l'erreur. Si quelqu'un veut poursuivre... la
   recherche de ce message d'erreur...
   
    <I> <FIN> FERMETURE DE LA BASE "GLOBALE" EFFECTUEE.
    <I> <FIN> ARRET NORMAL DANS "FIN" PAR APPEL A "JEFINI".
   
    ************************************************************************
    * COMMAND          :       USER :     SYSTEM :   USER+SYS :    ELAPSED *
    ************************************************************************
    * POURSUITE        :       0.00 :       0.00 :       0.00 :       0.00 *
    * STAT_NON_LINE    :    4925.59 :     165.57 :    5091.16 :    5285.60 *
    * CALC_ELEM        :      24.39 :       0.04 :      24.42 :      24.43 *
    * IMPR_RESU        :      99.31 :      24.71 :     124.02 :     124.74 *
    * FIN              :       0.09 :       0.40 :       0.49 :       0.53 *
    ************************************************************************
    * TOTAL_JOB        :    5049.44 :     190.71 :    5240.15 :    5435.36 *
    ************************************************************************
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   xc3xa9tude jointe
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST MODIF comp005b                     courtois M.COURTOIS         289      1      1
 CASTEST MODIF miss09a                        desoza T.DESOZA           847      1      1
 CASTEST MODIF sdll138a                     courtois M.COURTOIS         660      1      1
 CASTEST MODIF sslv134g                      macocco K.MACOCCO         1143     10     10
 CASTEST MODIF ssnl109a                     courtois M.COURTOIS         645      1      1
 CASTEST MODIF ssnv506d                       desoza T.DESOZA           232      8      4
 CASTEST MODIF wtna105a                     courtois M.COURTOIS         761      1      1
 CASTEST MODIF wtnv126b                     courtois M.COURTOIS         823      1      1
 CASTEST MODIF wtnv126c                     courtois M.COURTOIS         827      1      1
 CASTEST MODIF wtnv132a                     courtois M.COURTOIS         615      1      1
 CASTEST MODIF zzzz108a                     courtois M.COURTOIS        1139      1      1
 CASTEST SUPPR ssnl108a.comm                courtois M.COURTOIS         152      0    152
CATALOPY MODIF commande/post_k1_k2_k3        macocco K.MACOCCO           80      3      2
 FORTRAN MODIF algorith/nsisot              courtois M.COURTOIS         573      2     21
 FORTRAN MODIF modelisa/exnocp                desoza T.DESOZA           165      3      1
 FORTRAN MODIF modelisa/nbsuco                desoza T.DESOZA           131      2      1
  PYTHON MODIF Execution/E_JDC              courtois M.COURTOIS         344     22      1
  PYTHON MODIF Macro/post_k1_k2_k3_ops       macocco K.MACOCCO         1094      7     12
  PYTHON MODIF Messages/contact               desoza T.DESOZA           154     12     10
  PYTHON MODIF SD/sd_fond_fiss               macocco K.MACOCCO           37      3      3
  PYTHON MODIF Utilitai/System              courtois M.COURTOIS         223      7      1
  PYTHON MODIF Utilitai/Table               courtois M.COURTOIS        1002     43     35


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :    0           0         0                +0
 MODIF :   21       11784       131     110       +21
 SUPPR :    1         152               152      -152
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :   22       11936       131     262      -131 
