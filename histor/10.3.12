

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR boiteau      BOITEAU Olivier        DATE 02/07/2011 - 04:16:49

--------------------------------------------------------------------------------
RESTITUTION FICHE 016325 DU 2011-01-28 17:25:11
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Inconsistance des comportements des solveurs linéaires directs
FONCTIONNALITE
   PROBLEME
   =========
   Sur un calcul de cube de petite taille bloqué sur la moitié de ses DDLs, soumis à
   un chargement thermique et avec un module de YOUNG négatif (rentré par une formule),
   STAT_NON_LINE (et MECA_STATIQUE) se comportent différemment suivant les solveurs
   linéaires directs:
     - MUMPS fonctionne qqes soit les options,
     - LDLT et MF plantent en indiquant différent types de pb liés à la singularité de
       la matrice (sauf MF+RENUM=MD !).
   
   ANALYSE
   ========
   Ce cas-test pose 3 pbs:
     1/ La matrice qu'il fournie est-elle, oui ou non inversible ?
     2/ Pourquoi le comportement des solveurs linéaires est-il différent ?
     3/ Lorsqu'on rentre des données matériaux avec des formules, quels sont les
        garde-fous possibles et le solveur linéaire peut-il être l'un d'entre eux.
   
   1/La matrice traitée n'est pas singulière (ni théoriquement, ni numériquement)
     on l'a testée avec Octave et Python. Par contre, elle est symetrique definie nega
     tive.
          -> Donc a priori hors périmètre LDLT/MF.
     Par contre le msg de ces derniers n'aide pas beaucoup (FACTOT_21..) car il pointe
     du doigt le fait que la matrice n'est pas factorisable (c'est vrai, du moins pas
     sans technique de pivotage) mais il livre peu de conseils pour rémédier au pb.
     Il désigne suivant le cas de figure, les conditions limites ou le contact !
   
     --> Je rajoute ds ces msgs des pistes pour remédier au pb, par exemple pour
      FACTOR_11 (je l'ai fait pour tous les msgs avec PIVOT=0 et MF/LDLT)
   
   11: _("""
   (Solveur linéaire LDLT ou MULT_FRONT) Matrice non factorisable !
     On sait en plus que:
      - pivot vraiment nul à la ligne : %(i1)d.
   
     -> Conseil & Risque :
       Verifiez votre mise en donnees (absence ou surabondance de conditions limites, 
       caracteristiques materiaux licites...).
       Si vous avez deja valide cette mise en donnees, vous pouvez essayer a la place le
       solveur lineaire MUMPS (mot-cle SOLVEUR/METHODE='MUMPS').    
   """),
   
      --> J'en ai profité pour uniformiser sur le fond et la forme les 18 msgs de ce
          type emis depuis TLDLG3:
        4 cas de figures x type de solveurs (MF/LDLT + MUMPS) x pivot presque nul/nul
        + cas particulier X_FEM
   
      --> Rajout des msgs FACTOR_81/82/83 pour préciser le diagnostic en cas de
         detection de singularité + MUMPS.
   
   
   2/ Le comportement des solveurs directs est different car MUMPS peut avaler tout 
     type de matrice (même singulière) et pas les 2 autres larrons. Les techniques de
     pivotage qu'il met en oeuvre lui procure cette souplesse. MUMPS pivote donc et
     ne trouve pas de pivot nul lors de sa factorisation numerique.
     
      Par contre, l'utilisateur Aster peut restreindre le perimètre de MUMPS en lui
      indiquant qu'il n'a pas besoin de pivoter car on sait que la matrice est SPD
      (c'est le cas de beaucoup de modélisations Aster si on ne met pas de Lagranges).
      On gagne ainsi en temps et en mémoire. C'est piloté par le mot-clé
       TYPE_RESOL='SYMDEF'.
      En faisant ce test sur cette matrice, on est surpris de voir que MUMPS, non seule
      ment ne se plaint pas de fait que la matrice est hors périmètre mais en plus il
      va jusqu'au bout. Cela vient du fait que:
          - il ne teste pas le caractère SPD des matrices fournies,
          - ds le cas definie négatif (comme ici), il n'a pas besoin de pivoter.
      
      -- >Au fil des échanges que j'ai eu avec l'équipe MUMPS, j'ai signalé cette 
   faille. Il ont été intéressés (les posts de cette fiche l'atteste) et vont sans
    doute corriger ou documenter ce point ds leur prochaine release.
      
      --> En attendant, 2 précautions valent mieux qu'une, j'ai blindé ds Aster le
       choix de l'utilisateur (TYPE_RESOL='SYMDEF'): la matrice doit être reelle,
       symétrique et avoir tous ces termes diagonaux >0, sinon FACTOR_80/84.
       Les déclanchements effectifs de ces UTMESS_F sont validés ds erreur03a/04a.
     Par exemple,
   
   84: _("""
   (solveur linéaire MUMPS) Probleme de parametrage du solveur !
   Attention, vous avez parametre le solveur lineaire MUMPS de maniere a resoudre un 
   systeme lineaire SPD (reel Symetrique Defini Positif): mot-cle 
            SOLVEUR/TYPE_RESOL='SYMDEF'.
   Or votre matrice comporte des termes negatifs ou nuls sur sa diagonale. Ceci est 
   contradictoire.
   
       -> Conseil & Risque :
      Si il s'agit d'un test vous voila averti, sinon utilisez le solveur lineaire MUMPS
      avec TYPE_RESOL='AUTO'.
   """),
   
   3/ Garde-fous or not garde-fous ? 
      Test en amont
      ------------
      La fiche 16331 traite le pb des fonctions formules et de leurs vérifications 
      dynamiques en cours de calcul.
      Test de type Sturm
      ------------------
      J'ai regardé si on pouvait, à peu de frais, rajouter très tard ds le calcul, c'est
      à dire après la factorisation numérique de la matrice, un test pour vérifier la
      conformité de la mise en données. Par exemple, en s'inspirant du test de Sturm
      utilisé en modal:
         nbre de termes diag négatifs de la facto = nbre de Lagrange
   
      Mais ce critère, s'il semble souvent vérifié ds les op. simple (MECA_STATIQUE) ne
      l'est plus toujours ailleurs: calcul modal, flambement, modélisation mixte...
       --> Bref, j'ai renoncé. Pour bien faire il faudrait calculer tous le spectre de
           la matrice pour éventuellement détecter un pb.
       --> Un utilisateur avancé peut toujours faire l'exercice en activant INFO=2 (les
          2 chiffres sont ds le texte qqe soit les solveurs). Je le signale ds la doc.
   
      Test basé sur MUMPS
      -------------------
      Je pensait que MUMPS restreint aux systèmes SPD pouvait être une moyen de tester
      ds certains cas: EF standard avec Lagrange bien numérotés...
      --> Il fonctionne même en dehors de ce périmètre. Ce n'est donc pas un critère
         absolu.
   
   VALIDATION
   ==========
       erreu03a/04a.
   
   SOURCES RESTITUEES
   ==================
   F77:tldlg3.f
   F90:amumpc.F  amumpd.F  amumpm.F  amumps.F  amumpz.F
   PY:factor.py
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U2.08.03
VALIDATION
    informatique, non-regression, fonctionnel
NB_JOURS_TRAV  : 4.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR flejou       FLEJOU Jean Luc        DATE 02/08/2011 - 04:59:32

--------------------------------------------------------------------------------
RESTITUTION FICHE 015648 DU 2010-09-30 16:00:15
TYPE evolution concernant Code_Aster (VERSION )
TMA : Necs
TITRE
    PMF : Gérer correctement les codes retour des ldc
FONCTIONNALITE
   Pris en compte du code retour des lois de comportement pour les poutres multifibres.
   On distingue deux sortes de codes retours :
   - FATAL : on arrête immédiatement les boucles sur les fibres ou groupes de fibres
   - ALARME : on note le code retour "enveloppe" sur les fibres et groupes de fibre et on
   renvoie une seule valeur par élément (donc on continue les boucles).
   
   Remarques sur les codes retours :
   1 = échec dans l'intégration de la loi de comportement (FATAL)
   3 = une des contraintes qui devrait être nulle dans les itérations de DEBORST ne l'est pas
   encore (ALARME), et on doit continuer les itérations de Newton même si le critères de
   convergence global est atteint.
   Le code retour "enveloppe" veut dire (idem codere.f pour les éléments classiques):
   - 0 si toutes les fibres sont ok et s'il n'y a pas de pb de contraintes planes
   - 1 des que l'une des fibres a eu un échec de comportement
   - 3 si au moins une fibre d'un des points de Gauss n'a pas convergé en contraintes planes
   (DEBORST).
   
   Modification des sources fortran :
   * pmfcom.f : "IF(CODRET.NE.0) RETURN " ajouté dans différentes boucles sur les fibres pour
   les lois de comportement 1D. Après l'appel au comportement 3D, si CODREF non nul on le
   memorise dans CODRET, puis terminer immédiatement (RETURN) si différent de 3 
   * pmfmcf.f : Si CODREP non nul on le memorise dans CODRET, puis terminer immédiatement
   (RETURN) si différent de 3.
   * te0535.f : Si CODREP différent de 0, copie dans CODRET, quel que soit le point de Gauss.
   Puis si CODREP différent de 3, GOTO 900 pour terminer immédiatement après copie dans
   PCODRET et destructions des vecteurs temporaires avec JEDETR
   * te0516.f : idem te0535
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssnl127b
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR delmas       DELMAS Josselin        DATE 02/08/2011 - 01:36:03

--------------------------------------------------------------------------------
RESTITUTION FICHE 016356 DU 2011-02-03 09:40:22
TYPE anomalie concernant Code_Aster (VERSION 10.3)
TITRE
    En NEW10.3.11, les cas-tests zzzz262a et zzzz262b s'arretent en erreur syntaxe.
FONCTIONNALITE
   Problème :
   ==========
   En NEW10.3.11, les cas-tests zzzz262a et zzzz262b s'arretent en erreur syntaxe.
   
   Correction :
   ============
   Le mot-clé NORME de CALC_ELEM a été supprimé en 10.3.10. Ce mot-clé ne servait
   exclusivement qu'aux options RADI* et ENDO* or il était utilisé ici pour une autre option
   et n'avait aucun effet.
   
   On supprime le mot-clé.
   
   Impacts :
   =========
   zzzz262a.comm
   zzzz262b.comm
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    passage des tests
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 02/08/2011 - 01:36:03

--------------------------------------------------------------------------------
RESTITUTION FICHE 016263 DU 2011-01-24 08:14:47
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.3.8, les cas-tests ssnv507g, ssnv507h et ssnv507i s'arretent par manque de temps CPU sur Calibre5 et Rocks.
FONCTIONNALITE
   Ces tests manquent de temps sur Rocks et Calibre5.
   En effet, leur .para est à 300 s, il faut jusqu'à 800 s pour la 
   modélisation i sur clpaster.
   
   On augmente les .para à 600, 800 et 900 s.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssnv507g, ssnv507h et ssnv507i
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desoza       DE SOZA Thomas         DATE 02/07/2011 - 02:27:10

--------------------------------------------------------------------------------
RESTITUTION FICHE 016259 DU 2011-01-21 15:47:58
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Couverture de code : contact
FONCTIONNALITE
   Anomalie
   ========
   
   Les scripts de Jacques montrent que la couverture des mot-clés du catalogue DEFI_CONTACT
   n'est pas complète :
   
   - STOP_INTERP='OUI' qui entraîne l'arrêt du calcul en cas de détection d'interpénétration
   en mode RESOLUTION='NON'. On le teste dans un try/except avec le test erreu08a.
   
   - VECT_MAIT='FIXE' et donc MAIT_FIXE=(...) n'est pas testé. On le teste dans le ZZZZ237A
   où la surface maître est plane et rigide. Les résultats analytiques ne bougent pas.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    erreu08a,zzzz237a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 016363 DU 2011-02-03 15:49:22
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.3.11, le cas-test ssnv505h est NOOK sur Calibre 5
FONCTIONNALITE
   Anomalie
   ========
   
   En NEW10.3.11, le cas-test ssnv505h est NOOK sur Calibre 5.
   Le test NOOK est le suivant:
   "
   --------------------------------------------------------------------------------
    ---- TABLE            NOM_PARA
         T_REA_LA         DY
         REFERENCE        LEGENDE          VALE_REF         VALE_CAL         ERREUR         
    TOLE            
   NOOK  NON_REGRESSION   XXXX             2442.544         2445.8534077082  0.14%          
    0.10%           
     
   "
   
   Analyse
   =======
   
   En 10.3.11, on a ajouté un calcul non-linéaire pour valider l'option de projection suivant
   la normale esclave d'un élément de poutre. Pour cela on a aussi orienté la tangente de la
   poutre 'POU2'.
   Le test qui est NOOK sur Calibre 5 concerne un calcul pré-existant qui n'a pas été touché.
   Ce test utilise la poutre 'POU2' comme esclave, la réorientation de cette dernière ne
   devrait donc rien changer (si ce n'est l'ordre de parcours des noeuds) lors de l'écriture
   des conditions de contact (et donc aussi la numérotation du complément de Schur).
   
   En comparant le calcul avec et sans réorientation de 'POU2' en INFO=2, on se rend compte
   que à l'instant 0.41 et à l'itération 1, 'MULT_FRONT' qui est le solveur linéaire utilisé
   ici (avec renuméroteur 'MDA') ne donne pas le même résultat dans les 2 calculs !
   Pire il semblerait qu'il modifie la matrice tangente.
   
   Le passage au solveur 'LDLT' résout le problème. J'émets une autre fiche pour traiter ce
   comportement anormal de 'MULT_FRONT'.
   
   Remarque : la fiche issue10312 avait déjà montré que MULT_FRONT a un comportement bizarre
   avec ce test.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssnv505h
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR devesa       DEVESA Georges         DATE 02/07/2011 - 03:05:32

--------------------------------------------------------------------------------
RESTITUTION FICHE 016199 DU 2011-01-13 19:23:53
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    evolutions necessaires pour les calculs dynamiques explicites generalises
FONCTIONNALITE
   On introduit une évolution nécessaire aux calculs dynamiques 
   explicites généralisés afin de pouvoir faire évoluer la base de 
   projection. 
   Pour rappel, on y traite avec l'option PROJ_MODAL et le mot-clé 
   MASS_GENE de la commande DYNA_NON_LINE un problème sur un modèle 
   global comportant un domaine linéaire condensé modalement ainsi 
   qu'un domaine non linéaire plus réduit mais non condensé 
   modalement. La résolution et l'assemblage porte strictement sur 
   ce modèle non linéaire réduit d'où le gain de performances. Les 
   termes assemblés relatifs au domaine linéaire étant stockés une 
   fois pour toutes.
   Cette méthode nécessite la projection sur une base modale 
   représentative des mouvements du modèle global. En général, 
   cette base de projection est constante. Une amélioration pour 
   prendre en compte des déformations liées à la non-linéarité 
   serait d'utiliser une base modale évolutive au cours du calcul 
   par plages temporelles. Il faut alors pouvoir assurer 
   l'enchaînement entre des calculs successifs sur modèle réduit 
   avec bases de projection différentes. Pour cela, il faut à la 
   fin de chaque étape de calcul recalculer les champs cinématiques 
   généralisés sur la base réactualisée qu'on introduira comme 
   données de l'étape de calcul suivante. Et pour bâtir une base 
   réactualisée, il faut aussi restituer sur le modèle complet par 
   l'opérateur REST_COND_TRAN les champs SIEF_ELGA et VARI_ELGA 
   d'un EVOL_NOLI. 
   Enfin, lors de cette restitution par REST_COND_TRAN on complète 
   avec la dernière étape de calcul l'évolution calculée au cours 
   des étapes précédentes sur le modèle global.
   L'impact sur les opérateurs existants est alors :
   - dans DYNA_NON_LINE : possibilité de prendre en compte des 
   champs cinématiques généralisés initiaux via les mots-clés 
   DEPL_INIT_GENE, VITE_INIT_GENE, ACCE_INIT_GENE de PROJ_MODAL.
   - dans REST_COND_TRAN avec option liée à la présence du mot-clé 
   BASE_MODALE, possibilité d'avoir un résultat EVOL_NOLI si 
   demandé par TYPE_RESU en complétant et expansant les champs 
   SIEF_ELGA et VARI_ELGA du modèle réduit au modèle global. 
   Egalement la possibilité d'avoir le concept résultat réentrant 
   afin de compléter l'évolution globale avec les résultats 
   expansés de la dernière étape de calcul.
   La validation du développement est obtenue en enrichissant 
   le cas test SDNV107C (poutre plastique condensée dynamiquement) 
   avec un calcul d'une nouvelle évolution sur modèle réduit 
   utilisant une reprise de champs cinématiques généralisés 
   initiaux, et en utilisant un enrichissement par concept 
   réentrant de l'évolution globale non linéaire restituée. En 
   outre, sur cette évolution globale non linéaire, via la 
   commande CALCUL pour calculer la matrice de rigidité tangente, 
   on calcule ensuite une base modale réactualisée en cours de 
   plastification dont on compare la première fréquence propre à 
   celle obtenue suite au même état de déformation non linéaire par 
   un calcul direct sur le modèle complet : on retrouve que la 
   première FP initialement à 166 Hz en linéaire, passe à 117 Hz en 
   cours de plastification.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V5.03.107 U4.53.01 U4.63.33 R5.05.05 U2.06.13
VALIDATION
    cas test SDNV107C
NB_JOURS_TRAV  : 6.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 016208 DU 2011-01-14 15:37:38
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    amelioration des operateurs LIRE_IMPE_MISS et LIRE_FORC_MISS
FONCTIONNALITE
   Dans le traitement des cas tests MISS3D avec chargement sismique 
   (MISS01 et MISS05 notamment), la résorption de l'appel à 
   MACRO_MISS_3D est assurée par l'appel à CALC_MISS enchaîné à une 
   boucle de calculs harmoniques par DYNA_LINE_HARM.
   Dans cette boucle, on lit à chaque fréquence de calcul 
   nécessaire une impédance de sol et une force sismique issue d'un 
   champ incident unitaire respectivement par les opérateurs 
   LIRE_IMPE_MISS et LIRE_FORC_MISS.
   Or, les fréquences de la boucle de calcul peuvent être celles 
   nécessaires à la transformée de Fourier des signaux transitoires 
   imposés. Et ces fréquences seront alors en nombre beaucoup plus 
   important que les fréquences de la gamme de calcul par CALC_MISS.
   On améliore donc les opérateurs LIRE_IMPE_MISS et LIRE_FORC_MISS 
   afin de pouvoir interpoler les impédances et forces sismiques 
   aux fréquences de restitution FFT à partir des valeurs calculées 
   par CALC_MISS pour des fréquences beaucoup moins nombreuses. 
   Jusqu'à présent, ces opérateurs se contentent quand la fréquence 
   d'extraction ne correspond pas exactement à une valeur calculée 
   d'impédance ou de force sismique, d'extraire la valeur calculée 
   la plus proche sans interpolation.
   La validation porte sur les cas tests MISS01A et MISS05A où on 
   compare des résultats obtenus en utilisant pour CALC_MISS une 
   gamme de fréquences grossière aux résultat de référence obtenus 
   avec MACRO_MISS_3D avec une gamme de fréquences nécessaire pour 
   une restitution FFT.
   On note que l'amélioration des opérateurs pour pouvoir 
   interpoler n'a pas d'impact autre que sur le source Fortran des 
   routines OP0164, OP0179, IRMIFR, ACEARM, sans effet sur leur 
   syntaxe.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V1.10.120 V1.10.124
VALIDATION
    cas tests MISS01 et MISS05
NB_JOURS_TRAV  : 4.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR granet       GRANET Sylvie          DATE 02/08/2011 - 05:35:43

--------------------------------------------------------------------------------
RESTITUTION FICHE 016323 DU 2011-01-28 16:36:42
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Mxc3xa9nage cas tests THM wtnp102
FONCTIONNALITE
   Les cas tests wtnv102 n'apportent rien de plus que les wtnp102 et ne sont pas documentés.
   Ce sont des cas test de non régression de type THH. wtnv102 est une version 3D du wtnp102,
   mais il a plus sa place en wtnp102e (même solution que le 2D mais sur un maillage 3D).
   
   On crée un wtnp102e (modélisation 3D_THHD qui reprend le wtnv102b)
   On crée un wtnp102f (3D_THHS) car 3D_THHS n'était jusqu'à présent pas testée !
   On met à jour la doc (succinte)
   On supprime wtnv102a et b (les deux sous cas tests étaient les mêmes : la b se contentant
   de prendre un maillage linéaire et de de le transformer en quad).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V7.32.102
VALIDATION
    test wtnp102e et f
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 016276 DU 2011-01-24 16:11:36
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Rxc3xa9sorber des modxc3xa9lisations THM inutiles
FONCTIONNALITE
   On résorbe les modélisations THM suivantes qui ne sont ni documentées ni validées et qui
   ne sont pas pertinentes (modélisation non lumpé ni sélective en hydro non saturé): 
   3d_thh  
   3d_thv 
   axis_thh
   axis_thhm
   d_plan_thh
   d_plan_thhm
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : U4.41.01 U2.04.05
VALIDATION
    passage cas tests THM
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 016324 DU 2011-01-28 16:51:51
TYPE evolution concernant Code_Aster (VERSION 9.1)
TITRE
    Rajout de cas test en 3D_THMD et 3D_THMS
FONCTIONNALITE
   Les modélisations 3D_THMS (intégration sélective) et 3D_THMD (intégration lumpée) existent
   et sont documentées mais ne sont pas testées, il faut donc enrichir la base de cas test.
   Pour cela on rajoute les tests wtnv113i (3D_THMD) et wtnv113j (3D_THMS).
   Ces cas test représentent un écoulement gravitaire THM sur un seul élément avec solution
   analytique pour l'intégration aux points de Gauss. Ces tests i et j ne reproduiront donc
   pas la solution analytique dans la mesure où l'intégration est différente. Ce seront donc
   des tests de non régression.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V7.31.113
VALIDATION
    passage tests wtnv113i et wtnv113j
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 016326 DU 2011-01-31 09:02:23
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Ménage defi_materiau en THM
FONCTIONNALITE
   Après examen de DEFI_MATERIAU, un certain nombre de mots clés concernant la THM sont soit
   inutiles (jamais appelés, résidus de vieux développements désormais caduques), soit non
   testés.
   On  rajoute un appel aux mots clés suivants (mots clés déjà documentés, fonctionnels mais
   jamais testés) :
   defi_materiau     
   thm_diffu            d_fa_t dans wtna102a
   thm_diffu            d_fv_t  dans wtnp102e
   thm_diffu            d_lb_phi  dans wtnp102e
   thm_diffu            lamb_phi  dans wtnp102e
   
   On supprime du catalogue defi_materiau les mots clés suivant (pas d'impact documentaire,
   la doc de defi_materiau étant plus à jour que le catalogue de la commande, il ne s'agit
   pas ici d'une résorption mais d'un ménage):
   
   thm_diffu            chal_vapo
   thm_diffu            d_sigma_t
   thm_diffu            perm_g_intr
   thm_diffu            sigma_t
   thm_init             pres_atmo
   thm_liqu             coef_henry
   thm_liqu             d_lb_phi
   thm_liqu             d_lb_t
   thm_liqu             lamb_ct
   thm_liqu             lamb_phi
   thm_liqu             lamb_t
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    passage cas test wtna102a et wtnp120e
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 016295 DU 2011-01-26 14:37:03
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    carte responsable CHAVANT dans les sources Aster
FONCTIONNALITE
   On modifie la responsabilité (Chavant-> Granet) des routines ou catalogues suivants :
   algorith/assthm.f 
   algorith/cabthm.f 
   algorith/calcco.f 
   algorith/calcfh.f 
   algorith/calcft.f 
   algorith/calcme.f 
   algorith/calcva.f 
   algorith/comthm.f 
   algorith/equthm.f 
   algorith/fnothm.f 
   algorith/hmgazp.f 
   algorith/hmlgat.f 
   algorith/hmliga.f 
   algorith/hmlisa.f 
   algorith/hmliva.f 
   algorith/hmlvag.f 
   algorith/kitdec.f 
   algorith/nmthmc.f 
   algorith/thmlec.f 
   algorith/thmrcp.f 
   elements/caethm.f 
   elements/te0466.f 
   elements/te0472.f 
   elements/te0600.f 
   
   typelem/gener_me3h43.cata:2  
   typelem/gener_medh31.cata:2  
   typelem/gener_me3h13.cata:2  
   typelem/gener_meah21.cata:2  
   typelem/gener_me3h12.cata:2  
   typelem/gener_meah51.cata:2  
   typelem/gener_me3h42.cata:2  
   typelem/gener_me3h33.cata:2  
   typelem/gener_me3h22.cata:2  
   typelem/gener_medh21.cata:2  
   typelem/gener_medh32.cata:2  
   typelem/gener_me3h52.cata:2  
   typelem/gener_medh51.cata:2  
   typelem/gener_meah41.cata:2  
   typelem/gener_meah11.cata:2  
   typelem/gener_medh11.cata:2  
   typelem/gener_meah32.cata:2  
   typelem/gener_me3h32.cata:2  
   typelem/gener_meah31.cata:2  
   typelem/gener_me3h53.cata:2  
   typelem/gener_me3h23.cata:2  
   typelem/gener_medh41.cata:2  
   
   Comportement/kit_ddi.py 
   Comportement/hoek_brown_tot.py
   Comportement/hoek_brown_eff.py
   Comportement/cjs.py
   Comportement/hoek_brown.py
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    vxc3xa9rification cas test THM
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 016342 DU 2011-02-02 08:56:57
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Prise en compte de l'emmagasinement même avec mécanique (THM)
FONCTIONNALITE
   Lors des modélisations THM avec mécanique (*HM*), le coefficient d'emmagasinement doit
   être ignoré (il n'a de sens qu'en hydraulique pure).
   Un mauvais blindage fait que celui ci peut malgré tout être pris en compte depuis la 10.2;
    et du coup aboutir à un résultat faux (voir fiche 15668). L'impact est généralement
   faible ce qui fait qu'on a pu ne pas s'en apercevoir.
   On rajoute donc un blindage de manière à ce que ce coefficient ne soit pas pris en compte.
   On précise également l'appel à l'emmagasinement dans U4.43.01 (cf 15668).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 10.2
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.43.01
VALIDATION
    Passage cas test wtnp127d
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 016371 DU 2011-02-07 09:46:02
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Changement de noms des modélisations joints en THM
FONCTIONNALITE
   Suite à la fiche 14831 et afin d'éviter toute confusion avec les éléments joints
   mécanique, on propose de changer le nom des modélisations THM de la façon suivante :
   2D_JOINT_HMS    devient PLAN_JHMS
   AXIS_JOINT_HMS  devient AXIS_JHMS
   Cela impacte donc les modélisations, les cas test wtnp125*, wtnp126*, wtnp128* wtna111a.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V7.32.125 V7.32.126 V7.32.128 V7.33.111 U4.41.01
VALIDATION
    passage cas tests THM
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR kazymyre     KAZYMYRENKO Kyrylo     DATE 02/08/2011 - 05:35:45

--------------------------------------------------------------------------------
RESTITUTION FICHE 016044 DU 2010-12-09 10:43:45
TYPE anomalie concernant Code_Aster (VERSION 10.4)
TITRE
    En NEW10.3.1, les cas-tests wtnp128a, b, c et d s'arretent sur Bull et Aster4.
FONCTIONNALITE
   Titre: correction d'anomalies détectées dans le cas-tests wtnp128.
   
   Lors de la restitution de la fiche 14558, on a fait les modifications de la 
   taille de matrices EPS, DSIDEP et SIGP pour les lois CZM en mettant la plus 
   grande taille acceptée dans le lc0000.f (6 et 6x6 respectivement). Ceci était 
   fait pour éviter la redimentionnement de ces appels au niveau de passage te -
   > lc0000.f -> lc00xx.f
   
   La taille de EPS, DSIDEP et SIGP au retour de lcejex.f et lcejli.f a été donc 
   modifiée. Par oublie de notre part les routine XFEM et THM, qui font appel a 
   cette loi de comportement n'ont pas été modifiées.
   
   Dans cette fiche on corrige la partie THM en modifiant la taille de DSIDEP
   (6,6) de coeime.f (les modification de SIGP et EPS n'étant pas nécessaires).
   
   cette fiche est restituee avec la fiche 15247
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    wtnp128a/b/c/d
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR greffet      GREFFET Nicolas        DATE 02/07/2011 - 06:10:04

--------------------------------------------------------------------------------
RESTITUTION FICHE 016083 DU 2010-12-16 12:52:26
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.3.2, le cas-test fdlv110a s'arrete anormalement sur Aster4.
FONCTIONNALITE
   En creusant un peu plus j'ai pu trouver une solution.
   Ce cas-test utilise en fait deux domaines fluides séparés par une paroi.
   Lors du calcul de masse ajoutée, on cherche donc à résoudre un problème au 
   laplacien (analogie thermique) sur ces deux domaines à la fois.
   Or on ne fixe la température en un point que sur un des deux domaines. 
   L'autre domaine se retrouve sans aucun point où la température serait 
   imposée : le champ de température solution est donc défini à une constante 
   près, d'où le message de matrice à inverser singulière (ou presque).
   On avait d'ailleurs mis, dans CALC_MATR_AJOU :
         SOLVEUR=_F( STOP_SINGULIER = 'NON'),
   Donc je modifie les conditions aux limites : j'impose la température en 
   deux noeuds : un pour chaque domaine fluide.
   
   Le maillage fluide vient d'Ideas (UL 21) : je modifie donc le fichier 
   fdlv110a.21.
   Je retire aussi de fdlv110a.comm le STOP_SINGULIER = 'NON' qui ne sert 
   plus car le système est bien posé.
   
   Pas d'impact doc car on ne rentre pas dans ce niveau de détail.
   
   Report en version 9 : très simple car le fichier fdlv110a.21 est identique.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    fdlv110a
NB_JOURS_TRAV  : 0.3
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR meunier      MEUNIER Sébastien     DATE 02/07/2011 - 04:42:48

--------------------------------------------------------------------------------
RESTITUTION FICHE 016369 DU 2011-02-04 15:36:07
TYPE express concernant Code_Aster (VERSION 10.3)
TITRE
    Mxc3xa9nage routines elraga + carcha (Arlequin + chantier nouveaux noms options calcul)
FONCTIONNALITE
   1er point :
   ===========
   A la suite de la résorption de la méthode Arlequin (fiche 15653), j'ai oublié de supprimer
   les familles de points de Gauss qui ne sont pas utilisées dans les catalogues d'éléments.
   
   Je supprime donc les familles de points de Gauss suivantes de la routine elraga.f, qui ne
   sont appelées dans aucun catalogue d'éléments :
   
   arlq8
   arlq9
   fpg64 (hexa8, 20 ou 27)
   
   Ces familles étaient utilisées uniquement par Arlequin.
   
   De plus, il est à noter que les familles suivantes ne sont pas utilisées non plus. Je les
   laisse cependant car elles sont peut-être utilisées par certains développeurs ?
   
   fpg6b (pe6, p15 ou p18)
   fpg5nos (py5 oup13)
   fpg13 (tr3,6 ou 7)
   fpg16 (tr3,6 ou 7)
   fpg2nos (se2, 3 ou 4)
   
   2ème point :
   ============
   
   Dans la routine carcha.f, les blocs suivants sont en double. J'en supprime donc un
   exemplaire pour chacun :
   
          ELSE IF (NOCH.EQ.'SIEF_ELNO') THEN
            NOMGD  = 'SIEF_R'
            TYPCHA = 'ELNO'
            OPTION = 'SIEF_ELNO'
            PARAM  = 'PSIEFNOR'
          ELSE IF (NOCH.EQ.'EPSI_ELGA') THEN
             NOMGD  = 'EPSI_R'
             TYPCHA = 'ELGA'
             OPTION = 'EPSI_ELGA'
             PARAM  = 'PDEFORR'
         ELSE IF (NOCH.EQ.'SIEF_NOEU') THEN
            NOMGD  = 'SIEF_R'
            TYPCHA = 'NOEU'
         ELSE IF (NOCH.EQ.'VARI_ELNO') THEN
            NOMGD  = 'VARI_R'
            TYPCHA = 'ELNO'
            OPTION = 'VARI_ELNO'
            PARAM  = 'PVARINR'
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    aucune
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 016285 DU 2011-01-26 08:06:59
TYPE anomalie concernant Code_Aster (VERSION 10.3)
TITRE
    Option EPMH_xxx n'existe pas ?
FONCTIONNALITE
   Problème :
   ==========
   On trouve une trace dans epsvmc l. 156 de l'option epmh_***. Pourtant, elle n'est dans
   aucun catalogue d'éléments.
   
   Solution :
   ==========
   On enlève cette trace.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    aucune
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 016299 DU 2011-01-26 17:52:52
TYPE anomalie concernant Code_Aster (VERSION 10.3)
TITRE
    Anomalie PROJ_CHAMP('MATR_PROJECTION')
FONCTIONNALITE
   Problème :
   ==========
   
   J'ai voulu utiliser la fonctionnalité MATR_PROJECTION réalisée par Jacques que j'avais
   demandée dans la fiche 14669. Cette fonctionnalité m'est très utile pour le chaînage HM.
   Dans le chaînage HM, je projette un très grand nombre de champs (qui varient) entre 2
   maillages qui restent identiques. Ces champs vont être détruits au fur et à mesure qu'ils
   ne me sont plus utiles.
   
   Dans le test zzzz261a, si on effectue l'enchaînement de commandes suivant :
   
   MATPROJ=PROJ_CHAMP(METHODE='COLLOCATION',  MAILLAGE_1=MA1, MAILLAGE_2=MA2, PROJECTION='NON')
   TEMP2B=PROJ_CHAMP(RESULTAT=TEMP1, MATR_PROJECTION=MATPROJ, NOM_CHAM='TEMP')
   TEMP3B=PROJ_CHAMP(RESULTAT=TEMP1, MATR_PROJECTION=MATPROJ, NOM_CHAM='TEMP')
   
   on est arrêté dans le calcul de TEMP3B par le message :
   
      !------------------------------------------------------------------------------!
      ! <F> <JEVEUX_26>                                                              !
      !                                                                              !
      ! Objet JEVEUX inexistant dans les bases ouvertes : >CORRESP         .PJXX_K1< !
      !      l'objet n'a pas été créé ou il a été détruit                            !
      !                                                                              !
      !                                                                              !
      ! Cette erreur est fatale. Le code s'arrete.                                   !
      !------------------------------------------------------------------------------!
   
   Solution :
   =========
   
   Le problème est que à la fin du calcul de TEMP2B, la matrice de projection MATPROJ est
   détruite.
   
   Le problème se situe dans op0166.f. La ligne coupable est la ligne 369 :
   
   CALL DETRSD('CORRESP_2_MAILLA',LCORRE(1))
   
   Dans le cas '2', où on utilise une matrice de projection donnée en argument, on détruit la
   matrice de projection CORRESP. Lors du second PROJ_CHAMP, on ne la trouve donc plus, ce
   qui explique le plantage.
   
   Je mets donc cette ligne dans un bloc conditionnel :
   
   IF (TYPCAL.NE.'2') THEN
     CALL DETRSD('CORRESP_2_MAILLA',LCORRE(1))
   ENDIF
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    zzzz261a
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 016320 DU 2011-01-28 13:35:06
TYPE anomalie concernant Code_Aster (VERSION 10.3)
TITRE
    Calcul de l'option VARC_ELGA faux
FONCTIONNALITE
   Problème :
   =========
   
   Le calcul de l'option varc_elga dans calc_elem est faux pour toutes les variables de
   commande, sauf pour la température, l'hydratation et le séchage. Cela se voit dans te0530
   où on n'appelle pas la routine rcvarc avec les bonnes variables de commande.
   
   Solution :
   ==========
   
   La correction est simple. Il suffit de remplacer par les bonnes variables de commande.
   J'en profite pour remplacer les rcvarc par une boucle sur les noms de variables de
   commande, fournis en paramètres.
   
   Cela évite de recopier n fois le même bloc quand un jour on voudra rajouter ses
   variables de commande (comme au hasard pour le chaînage HM sur lequel je travaille
   actuellement).
   
   Validation :
   ============
   
   Je valide la correction en rajoutant des tests de non-régression sur la valeur de la
   variable de commande irradiation dans le test ssnl128b.
   
   Impact :
   ========
   
   te0530.f
   ssnl128b
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 10.2.19
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssnl128b
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR nistor       NISTOR Ionel           DATE 02/08/2011 - 08:12:23

--------------------------------------------------------------------------------
RESTITUTION FICHE 016214 DU 2011-01-17 06:36:38
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.3.6, le cas-test sdls121a s'arrete en erreur fatale sur la machine Calibre5.
FONCTIONNALITE
   Problème:
   -----------------------------------
    En NEW10.3.6, le cas-test sdls121a s'arretait en erreur fatale sur la machine Calibre5.
   
      !------------------------------------------------------------------------------------!
      ! <A> <RECAL0_83>                                                                    !
      !                                                                                    !
      ! Erreur! Le calcul esclave 'calc_3' ne s'est pas arrêté correctement!               !
      ! L'output du job est : /tmp/tmp_macr_recal_9FhFHh/flash/sdls121a-calc_3.o0003-10535 !
      !                                                                                    !
      !                                                                                    !
      ! Ceci est une alarme. Si vous ne comprenez pas le sens de cette                     !
      ! alarme, vous pouvez obtenir des résultats inattendus !                             !
      !------------------------------------------------------------------------------------!
      
   Diagnostic:
   -----------------------------------
   Le cas-test passe maintenant sans problèmes sur toutes les machines. La solution donnée par la fiche 16162
   l'a sans doute corrigé.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sdls121a
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR proix        PROIX Jean-Michel      DATE 02/08/2011 - 08:00:25

--------------------------------------------------------------------------------
RESTITUTION FICHE 016304 DU 2011-01-27 09:07:33
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.3.9, le cas-test ssna303b s'arrete en erreur fatale sur Rocks.
FONCTIONNALITE
   En NEW10.3.9, le cas-test ssna303b s'arretait en erreur fatale sur Rocks. (erreur
   numérique) au deuxième pas de temps. 
   
   Cela provenait d'un variable non initialisée dans la routine poslog, suite à un renommage
   incomplet des variables locales. Après correction, tout est OK
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssna303b
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 016035 DU 2010-12-08 13:23:24
TYPE anomalie concernant Documentation (VERSION *)
TITRE
    COMP002: V6.07.102: Equations non lisibles
FONCTIONNALITE
   proix  	Date: 2010-12-13.15:52:14
   
   Il s'agissait de transformer quelques équations qui étaient encore au format Word en
   Openoffice. C'est fait
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : v6.07.102
VALIDATION
    la doc
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 016348 DU 2011-02-02 11:49:48
TYPE express concernant Code_Aster (VERSION 9.1)
TITRE
    Amelioration de la lisibilite des tests COMP001, COMP002
FONCTIONNALITE
   n 10.3.10, pour faciliter l'introduction de tests thermo-visco-plastiques, on a jouté une
   nouvelle macro : TEST_COMPOR. Le fichier de commandes des tests comp008* s'en est trouvé
   très simplifié.
   
   Le but de la présente fiche est d'étendre TEST_COMPOR aux tests mécaniques, qui font
   actuellement appel à des INCLUDE contenant beaucoup de python. Avec la macro TEST_COMPOR,
   comp001a ressemblera à :
   
   DEBUT(...)
   
   ACIER[0]=DEFI_MATERIAU( ELAS=_F(ALPHA=1.18E-05,E=2.E11,NU=0.3),
                           ECRO_LINE=_F(SY=4.37E8,D_SIGM_EPSI=2.0247469E9), );
   ACIER[1]=DEFI_MATERIAU(ELAS=_F(ALPHA=1.18E-05,E=2.E5,NU=0.3),
                           ECRO_LINE=_F(SY=437.0,D_SIGM_EPSI=2024.7469), );
   
   compor='VMIS_ISOT_LINE'
   
   tabresu=TEST_COMPOR(OPTION='MECA',
                 COMP_INCR=_F(RELATION=compor,),
                 NEWTON=_F(REAC_ITER=1),
                 LIST_MATER=ACIER,
                 LIST_NPAS=4*[1] + [1, 5, 25],              
                 VARI_TEST=('V1','VMIS','TRACE'),
                 #LIST_TOLE=4*[1.E-10] + [1.E-1] + 2*[1.E-2] + [1.E-8]  
                 YOUNG=YOUNG,POISSON=POISSON,
                 )
   
   FIN()
   
   
   Validation : les tests COMP001*, COMP002* ( sauf I et J, qui seront traités plus tard)
   
   Impact doc : la doc U de test_compor : U4.92.06
    Ceci permettra d'étendre plus facilement ces tests à de nouveaux comportements.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.92.06
VALIDATION
    comp001, comp002
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 016286 DU 2011-01-26 09:45:13
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    plantage lors d'un calcul cristallin
FONCTIONNALITE
   L'étude jointe plante avec une erreur numérique (floating point exception) dans une
   routine de calcul de la matrice jacobienne pour les comportement cristallins (loi DD_CFC).
   
   Cette erreur numérique est due à une divergence de l'algorithme à l'instant 0.53 (on veut
   aller jusqu'à 1.), après 137 pas de temps.
   
   La calcul a du mal à converger (à l'instant 0.53, il y a déjà eu 28 subdivisions du pas de
   temps pour cause d'échec d'intégration de la loi de comportement (100 itérations maxi
   atteintes).
   
   Correction : elle consiste à tenter d'améliorer la convergence :
   
   - soit en utilisant la recherche linéaire locale, introduite par Samuel : NEWTON_RELI
   - soit en remplaçant la matrice jacobienne (supposée exacte, mais qui peut conduire à des
   divergences, comme dans les algos de Newton habituels) par la matrice obtenue par
   perturbation.
   On l'utilise en choisissant le nouveau mot- clé ALGO_INTE='NEWTON_PERT' 
   
   Au passage j'augmente le nombre d'itérations internes par défaut : ITER_INTE_MAXI=20 par
   défaut
   
   Validation : NEWTON_PERT est testé dans ssnv171b.
   
   Sur l'étude jointe, la recherche linéaire est plus efficace, mais sur un autre calcul
   monocristallin, c'est la matrice par perturbation qui fonctionne le mieux.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.51.11
VALIDATION
    etude jointe
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR tardieu      TARDIEU Nicolas        DATE 02/08/2011 - 09:57:29

--------------------------------------------------------------------------------
RESTITUTION FICHE 015465 DU 2010-08-27 11:49:21
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    SV04 Amxc3xa9liorer la gestion du recalcul du prxc3xa9conditionneur simple prxc3xa9cision
FONCTIONNALITE
   Problématique
   ~~~~~~~~~~~~~
   A l'heure actuelle, le seul bouton de réglage du préconditionneur simple précision LDLT_SP
   est la fréquence de re-factorisation du préconditionneur sous le mot-clé REAC_PRECOND. A
   l'usage, ce paramètre est délicat à manœuvrer : 
   - s'il est trop petit, on re-factorise trop souvent et on perd en performance
   - s'il est trop grand, on prend le risque d'avoir une convergence très lente ou de ne pas
   converger du tout
   
   Solution
   ~~~~~~~~
   On propose une nouvelle signification pour le mot-clé REAC_PRECOND : il s'agit du nombre
   d'itérations du solveur itératif au-delà duquel on déclenche une re-factorisation du
   préconditionneur.
   L'intérêt est donc d'avoir une approche adaptative qui essaie de suivre l'écart qui se
   crée entre la vraie matrice tangente et sa préconditionnée.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : U4.50.01
VALIDATION
    astout des tests LDLT_SP
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 015963 DU 2010-11-24 14:51:31
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TMA : DeltaCad
TITRE
    Soupxc3xa7on d'anomalies dans les poutres avec thermique
FONCTIONNALITE
   Problème
   ~~~~~~~~
   Sur le forum d'utilisation, un utilisateur soulève un soupçon d'anomalies dans les poutres
   avec thermique. Il se base sur une comparaison de solutions analytiques avec Nastran pour
   un calcul de tuyaux. Sachant qu'Aster ne dispose pas des mêmes éléments que Nastran, il
   utilise une modélisation "équivalente". 
   
   Il joint ses fichiers d'études + un document descriptif.
   
   http://www.code-aster.org/forum2/viewtopic.php?pid=24736
   
   http://www.code-aster.org/forum2/viewtopic.php?pid=24720
   
   Analyse
   ~~~~~~~
   Ce n'est pas une anomalie mais un problème de mise en donnée utilisateur. Cela peut 
   arriver quelque soit le type de modélisation.
   
   La prise en compte de la température dans un calcul Code_Aster est différente entre  
   MECA_STATIQUE et STAT_NON_LINE.
   
    - MECA_STATIQUE : prend en compte la totalité de température
    - STAT_NON_LINE : prend en compte l'accroissement de température entre pas de temps 
   en tenant compte de la température à l'instant 0 (température ambiante)
   
   => MECA_STATIQUE (pipe1, et pipe2): syntaxe utilisateur
      C1Temp = CREA_CHAMP( OPERATION='AFFE', 
                           TYPE_CHAM='NOEU_TEMP_R', 
                           MAILLAGE=line1,
                           AFFE=_F( TOUT = 'OUI',
                                    NOM_CMP = 'TEMP',
                                    VALE = 20.0+Dtemp))
      PipeMAT=AFFE_MATERIAU(MAILLAGE=line1,
                           AFFE=_F(TOUT='OUI',
                                    MATER=Steel,),
                           AFFE_VARC=_F(TOUT='OUI',
                                      NOM_VARC='TEMP',
                                      CHAMP_GD=C1Temp,
                                      VALE_REF=20));
   
   => STAT_NON_LINE (pipe3 et pipe4)
   L'utilisateur fait la même chose en linéaire et en non-linéaire!! Code_Aster 
   considère alors que ce champ est le même pour tous les instants y compris pour 
   l'instant 0 (initiale) donc pas d'accroissement de température entre deux pas de 
   temps. 
   
   En utilisant les commandes suivantes on prend bien en compte la température.
      
      C0Temp=CREA_CHAMP(OPERATION='AFFE', 
                     TYPE_CHAM='NOEU_TEMP_R', 
                     MAILLAGE=line1,
                     AFFE=_F(TOUT = 'OUI',
                             NOM_CMP = 'TEMP',
                             VALE=20.));
      C1Temp=CREA_CHAMP(OPERATION='AFFE', 
                     TYPE_CHAM='NOEU_TEMP_R', 
                     MAILLAGE=line1,
                     AFFE=_F(TOUT = 'OUI',
                             NOM_CMP = 'TEMP',
                             VALE=417.));
   				    
      RESU_T=CREA_RESU(TYPE_RESU='EVOL_THER',
                    OPERATION='AFFE',
                    NOM_CHAM='TEMP',
                    AFFE=(
   		       _F(CHAM_GD=C0Temp,INST=0.,),
   		       _F(CHAM_GD=C1Temp,INST=1.,),
   		       )); 
   		       
      PipeMAT=AFFE_MATERIAU(MAILLAGE=line1,
                         AFFE=_F(TOUT='OUI',
                                 MATER=Steel,),
                         AFFE_VARC=_F(TOUT='OUI',
                                      NOM_VARC='TEMP',
                                      EVOL=RESU_T,
                                      VALE_REF=20) );
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    Passage des tests joints
--------------------------------------------------------------------------------
RESTITUTION FICHE 016354 DU 2011-02-02 13:47:10
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    paramxc3xa8tre matxc3xa9riau ALPHA_L
FONCTIONNALITE
   Problème
   ~~~~~~~~
   L'utilisateur définit bien pour son matériau elastique isotrope transverse des
   coefficients de dilatation thermique. Or, une fois dans le calcul, on lui affirme qu'il ne
   les a pas déclarés.
   
   Solution
   ~~~~~~~~
   Il s'agit d'une erreur de copier/coller dans nmorth : on a recopié le même bout de code
   pour ELAS_ISTR que pour ELAS_ORTH, or il y a un petit changement à faire : 
   133c133
   <           CALL VERIFT(FAMI,KPG,KSP,'T',IMATE,'ELAS_ISTR',2,
   ---
   >           CALL VERIFT(FAMI,KPG,KSP,'T',IMATE,'ELAS_ORTH',2,
   
   Validation
   ~~~~~~~~~~
   Cette fonctionnalité n'était pas testée. Je propose donc une nouvelle modélisation du test
   COMP008, la M qui valide ELAS_ISTR.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V6.07.108
VALIDATION
    Nouveau cas test comp008m
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 016378 DU 2011-02-08 07:32:13
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Bug dans jjprem
FONCTIONNALITE
   En 10.1.10, la routine JJPREM a été modifiée de manière à :
   - étendre la catalogue de nombres premiers nécessaires à la construction de la table de
   hashage de JEVEUX
   - améliorer l'algorithme de dichotomie qui rendait une réponse sous-optimale
   
   Mais en faisant ces évolutions, j'ai introduit un bug dans l'algorithme qui pouvait
   conduire à obtenir des adresses négatives.
   
   Voici la correction (merci Nicolas S.!) :
   
   142c142
   <            I = MAX(I - J,1)
   ---
   >            I = I - J
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    Passage de tests posant problème
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST AJOUT comp008m                      tardieu N.TARDIEU          131    131      0
 CASTEST AJOUT erreu08a                       desoza T.DESOZA           137    137      0
 CASTEST AJOUT wtnp102e                       granet S.GRANET           389    389      0
 CASTEST AJOUT wtnp102f                       granet S.GRANET           386    386      0
 CASTEST AJOUT wtnv113i                       granet S.GRANET           255    255      0
 CASTEST AJOUT wtnv113j                       granet S.GRANET           255    255      0
 CASTEST MODIF comp001a                        proix J-M.PROIX           73     11    195
 CASTEST MODIF comp001b                        proix J-M.PROIX          113     27    297
 CASTEST MODIF comp001c                        proix J-M.PROIX           75     14    142
 CASTEST MODIF comp001d                        proix J-M.PROIX           82     14    189
 CASTEST MODIF comp001e                        proix J-M.PROIX          219     14    191
 CASTEST MODIF comp001f                        proix J-M.PROIX           90     15    141
 CASTEST MODIF comp001g                        proix J-M.PROIX          101     15    139
 CASTEST MODIF comp001h                        proix J-M.PROIX           81     13    263
 CASTEST MODIF comp001i                        proix J-M.PROIX          131     27    243
 CASTEST MODIF comp002a                        proix J-M.PROIX           75     13    263
 CASTEST MODIF comp002b                        proix J-M.PROIX           96     14    143
 CASTEST MODIF comp002c                        proix J-M.PROIX           99     13    144
 CASTEST MODIF comp002d                        proix J-M.PROIX           97     14    145
 CASTEST MODIF comp002e                        proix J-M.PROIX          103     15    141
 CASTEST MODIF comp002f                        proix J-M.PROIX          105     14    116
 CASTEST MODIF comp002g                        proix J-M.PROIX          134     13    114
 CASTEST MODIF comp002h                        proix J-M.PROIX          118     13    189
 CASTEST MODIF erreu03a                      boiteau O.BOITEAU          235     24      5
 CASTEST MODIF erreu04a                      boiteau O.BOITEAU          227     24      4
 CASTEST MODIF fdlv110a                      greffet N.GREFFET          503      5      3
 CASTEST MODIF miss01a                        devesa G.DEVESA           896    484     75
 CASTEST MODIF miss05a                        devesa G.DEVESA           813    433     64
 CASTEST MODIF sdnv107c                       devesa G.DEVESA           927    282      7
 CASTEST MODIF ssna303b                        proix J-M.PROIX          273      1      1
 CASTEST MODIF ssnl128b                      meunier S.MEUNIER          744     72      1
 CASTEST MODIF ssnp15b                       tardieu N.TARDIEU          547    426    627
 CASTEST MODIF ssnv171b                        proix J-M.PROIX          242     61      6
 CASTEST MODIF ssnv505h                       desoza T.DESOZA           472      3      2
 CASTEST MODIF wtna102a                       granet S.GRANET           342      2      1
 CASTEST MODIF wtna111a                       granet S.GRANET           366      4      4
 CASTEST MODIF wtnp125a                       granet S.GRANET           428      2      2
 CASTEST MODIF wtnp125b                       granet S.GRANET           362      2      2
 CASTEST MODIF wtnp126a                       granet S.GRANET           417      3      3
 CASTEST MODIF wtnp126b                       granet S.GRANET           415      3      3
 CASTEST MODIF wtnp127d                       granet S.GRANET           322      3     15
 CASTEST MODIF wtnp128a                       granet S.GRANET           474      3      3
 CASTEST MODIF wtnp128b                       granet S.GRANET           436      3      3
 CASTEST MODIF wtnp128c                       granet S.GRANET           360      3      3
 CASTEST MODIF wtnp128d                       granet S.GRANET           374      3      3
 CASTEST MODIF zzzz237a                       desoza T.DESOZA           400      4      2
 CASTEST MODIF zzzz262a                       delmas J.DELMAS           626      1      2
 CASTEST MODIF zzzz262b                       delmas J.DELMAS           638      1      2
 CASTEST SUPPR wtnv102a.comm                  granet S.GRANET           341      0    341
 CASTEST SUPPR wtnv102b.comm                  granet S.GRANET           357      0    357
CATALOGU MODIF compelem/phenomene_modelisation__     granet S.GRANET          1709      4     35
CATALOGU MODIF typelem/gener_me3g33           granet S.GRANET           171      1     20
CATALOGU MODIF typelem/gener_me3h12           granet S.GRANET            74      3      3
CATALOGU MODIF typelem/gener_me3h13           granet S.GRANET           249      2      2
CATALOGU MODIF typelem/gener_me3h22           granet S.GRANET            73      3      3
CATALOGU MODIF typelem/gener_me3h23           granet S.GRANET           243      2      2
CATALOGU MODIF typelem/gener_me3h32           granet S.GRANET            65      3      3
CATALOGU MODIF typelem/gener_me3h33           granet S.GRANET           177      2     21
CATALOGU MODIF typelem/gener_me3h42           granet S.GRANET            73      3      3
CATALOGU MODIF typelem/gener_me3h43           granet S.GRANET           252      2      2
CATALOGU MODIF typelem/gener_me3h52           granet S.GRANET            72      3      3
CATALOGU MODIF typelem/gener_me3h53           granet S.GRANET           246      2      2
CATALOGU MODIF typelem/gener_meah11           granet S.GRANET            65      3      3
CATALOGU MODIF typelem/gener_meah21           granet S.GRANET            64      3      3
CATALOGU MODIF typelem/gener_meah31           granet S.GRANET            59      3      3
CATALOGU MODIF typelem/gener_meah32           granet S.GRANET           160      2     14
CATALOGU MODIF typelem/gener_meah41           granet S.GRANET            65      3      3
CATALOGU MODIF typelem/gener_meah42           granet S.GRANET           218      1     13
CATALOGU MODIF typelem/gener_meah51           granet S.GRANET            65      3      3
CATALOGU MODIF typelem/gener_medh11           granet S.GRANET            65      3      3
CATALOGU MODIF typelem/gener_medh21           granet S.GRANET            64      3      3
CATALOGU MODIF typelem/gener_medh31           granet S.GRANET            59      3      3
CATALOGU MODIF typelem/gener_medh32           granet S.GRANET           160      2     14
CATALOGU MODIF typelem/gener_medh41           granet S.GRANET            65      3      3
CATALOGU MODIF typelem/gener_medh42           granet S.GRANET           217      1     13
CATALOGU MODIF typelem/gener_medh51           granet S.GRANET            65      3      3
CATALOPY MODIF commande/affe_modele           granet S.GRANET           273      4     10
CATALOPY MODIF commande/calc_forc_ajou       tardieu N.TARDIEU          107      3      3
CATALOPY MODIF commande/calc_matr_ajou       tardieu N.TARDIEU           99      3      3
CATALOPY MODIF commande/defi_materiau         granet S.GRANET          3139      2     52
CATALOPY MODIF commande/dyna_line_tran       tardieu N.TARDIEU          195      3      3
CATALOPY MODIF commande/dyna_non_line         devesa G.DEVESA           226      4      1
CATALOPY MODIF commande/factoriser           tardieu N.TARDIEU           75      2      2
CATALOPY MODIF commande/macro_matr_ajou      tardieu N.TARDIEU          142      4      4
CATALOPY MODIF commande/meca_statique        tardieu N.TARDIEU          132      3      3
CATALOPY MODIF commande/mode_statique        tardieu N.TARDIEU          153      3      3
CATALOPY MODIF commande/rest_cond_tran        devesa G.DEVESA            64     12      5
CATALOPY MODIF commande/test_compor            proix J-M.PROIX           82     25      3
CATALOPY MODIF commande/ther_lineaire        tardieu N.TARDIEU          137      3      3
CATALOPY MODIF commande/ther_non_line        tardieu N.TARDIEU          157      3      3
CATALOPY MODIF commande/ther_non_line_mo     tardieu N.TARDIEU          104      3      3
CATALOPY MODIF commun/c_comp_incr              proix J-M.PROIX          156      3      3
CATALOPY MODIF commun/c_relation              granet S.GRANET           154      3      2
CATALOPY MODIF commun/c_solveur              tardieu N.TARDIEU          105      3      3
 FORTRAN MODIF algeline/gcpc                 tardieu N.TARDIEU          274      9      7
 FORTRAN MODIF algeline/pcmump               tardieu N.TARDIEU           96      4      7
 FORTRAN MODIF algeline/tldlg3               boiteau O.BOITEAU          493      6      5
 FORTRAN MODIF algorith/assthm                granet S.GRANET           439      3      3
 FORTRAN MODIF algorith/bamo78                devesa G.DEVESA           401    176     11
 FORTRAN MODIF algorith/cabthm                granet S.GRANET           323      3      3
 FORTRAN MODIF algorith/calcco                granet S.GRANET           155      3      3
 FORTRAN MODIF algorith/calcfh                granet S.GRANET          1641      2      2
 FORTRAN MODIF algorith/calcft                granet S.GRANET           148      3      3
 FORTRAN MODIF algorith/calcme                granet S.GRANET           549      3      3
 FORTRAN MODIF algorith/calcva                granet S.GRANET           114      3      3
 FORTRAN MODIF algorith/coeime                granet S.GRANET           251      3      3
 FORTRAN MODIF algorith/comthm                granet S.GRANET           289      3      3
 FORTRAN MODIF algorith/equthm                granet S.GRANET           703      3      3
 FORTRAN MODIF algorith/fnothm                granet S.GRANET           144      3      3
 FORTRAN MODIF algorith/hmgazp                granet S.GRANET           280      4      4
 FORTRAN MODIF algorith/hmladg                granet S.GRANET           369      3      3
 FORTRAN MODIF algorith/hmlgat                granet S.GRANET           289      4      4
 FORTRAN MODIF algorith/hmliga                granet S.GRANET           352      4      4
 FORTRAN MODIF algorith/hmlisa                granet S.GRANET           295      4      4
 FORTRAN MODIF algorith/hmliva                granet S.GRANET           387      4      4
 FORTRAN MODIF algorith/hmlvag                granet S.GRANET           377      4      4
 FORTRAN MODIF algorith/hmlvga                granet S.GRANET           399      3      3
 FORTRAN MODIF algorith/kitdec                granet S.GRANET            72      3      3
 FORTRAN MODIF algorith/lc0000               meunier S.MEUNIER          689      7     26
 FORTRAN MODIF algorith/lc0032                 proix J-M.PROIX           56      3      3
 FORTRAN MODIF algorith/lcplnl                 proix J-M.PROIX          278     16     11
 FORTRAN MODIF algorith/ndloam                devesa G.DEVESA           182     35      3
 FORTRAN MODIF algorith/nmorth               tardieu N.TARDIEU          221      2      2
 FORTRAN MODIF algorith/nmthmc                granet S.GRANET           479      5      5
 FORTRAN MODIF algorith/nmvccc               meunier S.MEUNIER          143      4     22
 FORTRAN MODIF algorith/nmvcpr               meunier S.MEUNIER          203      3     19
 FORTRAN MODIF algorith/op0078                devesa G.DEVESA           109     10      3
 FORTRAN MODIF algorith/op0164                devesa G.DEVESA           322     56      7
 FORTRAN MODIF algorith/op0166               meunier S.MEUNIER          377      5      3
 FORTRAN MODIF algorith/op0179                devesa G.DEVESA           235     43      5
 FORTRAN MODIF algorith/poslog                 proix J-M.PROIX          309      5      5
 FORTRAN MODIF algorith/thmlec                granet S.GRANET           224      3      3
 FORTRAN MODIF algorith/thmrcp                granet S.GRANET          2219      3      3
 FORTRAN MODIF algorith/utlcal                 proix J-M.PROIX          107      6      2
 FORTRAN MODIF debug/lcjacp                    proix J-M.PROIX          184     11      7
 FORTRAN MODIF elements/caethm                granet S.GRANET           121      3      3
 FORTRAN MODIF elements/elraca               meunier S.MEUNIER         1008      3      5
 FORTRAN MODIF elements/elraga               meunier S.MEUNIER         1386      2     48
 FORTRAN MODIF elements/epsvmc               meunier S.MEUNIER          183      9      9
 FORTRAN MODIF elements/eqcara                granet S.GRANET           280      2      2
 FORTRAN MODIF elements/pmfcom              dallolio L.DALLOLIO         332     24      7
 FORTRAN MODIF elements/pmfmcf              dallolio L.DALLOLIO          87      9      3
 FORTRAN MODIF elements/te0466                granet S.GRANET           634      3      3
 FORTRAN MODIF elements/te0472                granet S.GRANET           444      3      3
 FORTRAN MODIF elements/te0516              dallolio L.DALLOLIO         619     11      3
 FORTRAN MODIF elements/te0529               meunier S.MEUNIER          185      4      4
 FORTRAN MODIF elements/te0530               meunier S.MEUNIER           82     19     57
 FORTRAN MODIF elements/te0535              dallolio L.DALLOLIO         367     23      9
 FORTRAN MODIF elements/te0600                granet S.GRANET           440      2      2
 FORTRAN MODIF jeveux/jjprem                 tardieu N.TARDIEU          154      3      3
 FORTRAN MODIF modelisa/acearm                devesa G.DEVESA           228      3      3
 FORTRAN MODIF modelisa/irmifr                devesa G.DEVESA            62     16      6
 FORTRAN MODIF prepost/carcha                meunier S.MEUNIER          188      1     19
FORTRAN90 MODIF mumps/amumpc                  boiteau O.BOITEAU          409      6      2
FORTRAN90 MODIF mumps/amumpd                  boiteau O.BOITEAU          409      5      3
FORTRAN90 MODIF mumps/amumpm                  boiteau O.BOITEAU          719     24      5
FORTRAN90 MODIF mumps/amumps                  boiteau O.BOITEAU          406      5      2
FORTRAN90 MODIF mumps/amumpz                  boiteau O.BOITEAU          409      6      2
FORTRAN90 MODIF petsc/apetsr                  tardieu N.TARDIEU          379      8      3
  PYTHON MODIF Comportement/cjs               granet S.GRANET            38      3      3
  PYTHON MODIF Comportement/hoek_brown        granet S.GRANET            40      3      3
  PYTHON MODIF Comportement/hoek_brown_eff     granet S.GRANET            41      3      3
  PYTHON MODIF Comportement/hoek_brown_tot     granet S.GRANET            41      3      3
  PYTHON MODIF Comportement/kit_ddi           granet S.GRANET            38      3      3
  PYTHON MODIF Comportement/monocristal        proix J-M.PROIX           41      3      3
  PYTHON MODIF Intranet/macro_bascule_schema_cata     devesa G.DEVESA           340      5      2
  PYTHON MODIF Macro/test_compor_ops           proix J-M.PROIX          757    583     29
  PYTHON MODIF Messages/factor               boiteau O.BOITEAU          508    152     53
  PYTHON MODIF Miss/miss_fichier_interf       devesa G.DEVESA           231     13      5


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :    6        1553      1553             +1553
 MODIF :  161       50709      3705    4727     -1022
 SUPPR :    2         698               698      -698
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :  169       52960      5258    5425      -167 
