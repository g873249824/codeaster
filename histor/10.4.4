

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR laverne      LAVERNE Jérôme       DATE 05/24/2011 - 02:06:14

--------------------------------------------------------------------------------
RESTITUTION FICHE 016660 DU 2011-03-25 16:33:12
TYPE anomalie concernant Code_Aster (VERSION 11.1)
TITRE
    En NEW10.3.20, le cas-test ssnv199f s'arrete en erreur F sur Rocks et Cal5.
FONCTIONNALITE
   Pour ce type de loi de comportement 'CZM_OUV_MIX', uniquement destinée au mode I, on
   introduit une rigidité artificielle en glissement afin de permettre qu'un élément
   totalement rompu en mode d'ouverture garde une composante tangentielle non nulle.
   
   La valeur adoptée arbitrairement pour cette dernière dans ssnv199f est de 10. On observe
   que lorsqu'on augmente cette rigidité tangentielle à 1000 le pb de pivot presque nul
   disparait sous clpaster.
   On propose donc de faire tourner ce test avec RIGI_GLIS=1000. On suppose que cela permet
   d'améliorer le conditionnement de la matrice, mais on ne connaît pas la raison exacte.
   
   Il faudra donc poursuivre la réflexion sur le mauvais conditionnement de la matrice pour
   ce type de modélisation EF (xxx_INTERFACE) et les problèmes que cela engendre avec Mumps.
   Des pistes ont déjà été envisagées avec O. Boiteau mais sans réel succès (fiche 16305).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssnv199f sous clpaster et aster4 en dbg et nodbg
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR durand       DURAND Christophe      DATE 05/24/2011 - 02:06:14

--------------------------------------------------------------------------------
RESTITUTION FICHE 016946 DU 2011-05-17 15:07:13
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    MACR_LIGN_COUPE / GROUP_MA transforme abusivement le nom du groupe en majuscules
FONCTIONNALITE
   Dans MACR_LIGN_COUPE, les noms des groupes (noeuds et mailles) sont systématiquement
   passés en majuscule (méthode upper). Je ne vois pas bien pourquoi, alors que LIRE_MAILLAGE
   et DEFI_GROUPE respectent la casse.
   
   Donc, suppression de toutes les méthodes upper sur les strings (en pratique group_no et
   group_ma) dans macr_lign_coupe_ops.py.
   
   Fiche à réaliser en versions 10 et 11.
   
   A noter, sur le cas fourni ici, on aura toujours un arrêt fatal car la ligne demandée est
   une courbe fermée. Ce que DEFI_GROUP/NOEUD_ORDO, appelé en sous-main par MACR_LIGN_COUPE,
   ne sait pas traiter. Cela fait l'objet de la demande d'évolution issue16921.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    xc3xa9tude fournie
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR zentner      ZENTNER Irmela         DATE 05/24/2011 - 02:06:14

--------------------------------------------------------------------------------
RESTITUTION FICHE 016886 DU 2011-05-04 15:15:59
TYPE anomalie concernant Code_Aster (VERSION 11.1)
TITRE
    moments spectraux avec POST_DYNA_ALEA
FONCTIONNALITE
   Corrections dans POST_DYNA_ALEA:
   
   >> Pour déterminer les moments spectraux il faut multiplier par 2 le spectre si uniquement
   la partie de la DSP pour w positive est donnée (c'est déjà fait pour l'écart-type mais pas
   pour les moments). 
   Test simple: la racine du moment d'ordre 0 (sqrt(LAMBDA_00)) doit être
   égale à l'écart-type avec POST_DYNA_ALEA. Autre test simple: l'écart-type d'un signal
   généré à partir de la DSP (GENE_FONC_ALEA) doit être égal à sqrt(lambda00).
   
   Je corrige des coquilles et des erreurs dans les test zzzz180a
   - Les valeurs des ecart-type des fonctions 1 et 2 étaient échangées dans certains test.
   - J'ajoute un test de base : ecart-type signal=sqrt(lambda00)
   - Je mets en non régression les tests où le resu vient de Aster.
   - Je peux ainsi diminuer certaines tolérances.
   
   Autres cas test concernés (calcul des moments en non regression uniquement): sdld23a ,
   sdll104a,
   sdll110a,sdld101a
   
   
   >>Je modifie la DSP de Kanai-Tajimi dans DEFI_INTE_SPEC.  Cela concerne le cas test
   sdll104a. 
   J'ajoute un test simple: l'écart-type d'un signal généré à partir de la DSP
   (GENE_FONC_ALEA) doit être égal à sqrt(lambda00).
   
   Dans sdld101a, la DSP Kanai-Tajimi est calculée mais pas utilisée, ni testée:
   j'enlève cet appel à DEFI_INTE_SPEC.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.84.04, V2.01.023, V2.02.104,V2.01.101
VALIDATION
    sdld101a, sdld23a, sdll110a,zzzz180a,sdll104a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR geniaut      GENIAUT Samuel         DATE 05/24/2011 - 02:06:15

--------------------------------------------------------------------------------
RESTITUTION FICHE 016895 DU 2011-05-06 07:36:03
TYPE anomalie concernant Code_Aster (VERSION 11.1)
TITRE
    En NEW11.0.4, le cas-test hsnv132a est NOOK sur Rocks.
FONCTIONNALITE
   Problème :
   ----------
   
   En NEW11.0.4, le cas-test hsnv132a est NOOK sur Rocks.
   Ce cas-test a été modifié la semaine précédente dans le cadre de la fiche 16849 par S.
   Géniaut.
   Le cas-test NOOK est le suivant:
   TABLE            NOM_PARA
         TABDEP           DX
         REFERENCE        LEGENDE          VALE_REF                 VALE_CAL                
   ERREUR           TOLE            
   NOOK  NON_REGRESSION   XXXX             -8.740426289951E-04      -8.7404262896455E-04    
   3.5E-09%         1.0E-09%        
   
   
   
   Solution :
   ----------
   
   On fait désormais les tests de non-régression sur le déplacement avec une tolérance
   relative de 1e-8%.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : v7.22.132
VALIDATION
    hsnv132a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desoza       DE SOZA Thomas         DATE 05/24/2011 - 02:06:15

--------------------------------------------------------------------------------
RESTITUTION FICHE 016969 DU 2011-05-20 08:56:21
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    [FORUM] Chargement FORCE_COQUE en repère local : résultats faux
FONCTIONNALITE
   Anomalie
   ========
   
   Réf : http://www.code-aster.org/forum2/viewtopic.php?pid=28239
   
   Un membre du forum qui cherchait à utiliser le chargement FORCE_COQUE des plaques/coques
   en repère local a remarqué un comportement erratique lorsque le maillage comporte des
   triangles ou des éléments "distordus".
   
   Analyse
   =======
   
   Après étude du cas transmis, on se rend compte de plusieurs choses :
   
   - la doc de AFFE_CARA_ELEM page 14 précise que le repère local est défini par Xloc Yloc
   Zloc où Xloc est "la projection du vecteur défini par ANGL_REP/VECTEUR sur le plan
   tangent" et Zloc la normale orientée au plan tangent. On obtient Yloc en complétant la base.
   ==> le calcul semble pourtant montrer que le Xloc effectivement choisi est perpendiculaire
   au Xloc "théorique"
   
   - sur un calcul d'une plaque simplement appuyée sur 2 bords maillée en triangles, la
   solution obtenue lorsque l'on charge en repère local (FORCE_COQUE/F1,F2,F3,MF1,MF2) ne
   colle pas à la solution obtenue en repère global équivalent (même en tenant compte de la
   remarque ci-dessus). Avec le même calcul en quadrangles cela semble marcher.
   
   Correction
   ==========
   
   Il s'avère que lors du calcul du second membre pour FORCE_COQUE en repère local, le
   chargement fourni par l'utilisateur est passé du repère local donc vers le repère
   intrinsèque à l'élément avec la mauvaise matrice de rotation (on prenait la transposée
   pour une raison inexpliquée) :
   
   - cela explique pourquoi le chargement n'est pas dans la bonne direction
   
   - cela explique aussi pourquoi le calcul en triangles donnait des résultats complètement
   faux. En effet en soi, ce n'est pas l'utilisation de la mauvaise matrice de rotation qui
   pose problème c'est le fait que derrière on repasse du repère intrinsèque de l'élément au
   repère global, et on se retrouve alors avec des chargements "alternés" c'est à dire qui ne
   sont pas identiques sur chaque maille de la plaque ! En quadrangle ça marchait car les
   carrés étaient droit et avaient tous la même transformation vers l'élément de référence
   mais avec un maillage de carrés non "droits", le même problème se serait posé.
   
   Le nommage des matrices de passages étant obscurs, je corrige le code en homogénéisant les
   routines. À faire en V10.
   
   Impact :
   dxefr2.f  dxefro.f  dxqfor.f  dxrepe.f  dxsiro.f  dxtfor.f  te0031.f  te0032.f  te0033.f 
   te0040.f  te0409.f  te0580.f
   
   Validation
   ==========
   
   Un astout plaque ne donne qu'un seul NOOK : ssls200a
   C'est normal, c'est le seul test qui valide le chargement FORCE_COQUE en repère local avec
   autre chose que F3 (direction normale à la plaque pour laquelle il n'y avait pas de problème).
   Il s'agit d'un test de non-régression on change donc la référence.
   
   Pour assurer la validation en attendant plus de tests en repère local, on modifie un des 2
   cas-tests qui fait du FORCE_COQUE dans le plan d'une plaque DKT ou DST. Il s'agit de
   SSLS111C. On transforme tous les FORCE_COQUE FX/FY/FZ/MX/MY/MZ en F1/F2/F3/MF1/MF2 : les
   résultats doivent rester identique. Avant correction ce n'est pas le cas, désormais ca l'est.
   
   Résultats faux
   ==============
   
   Depuis toujours dans le cas suivant :
   
   - modélisation plaque ('DKT', 'DST', )
   - chargement FORCE_COQUE
   - utilisation de F1, F2, MF1 ou MF2
   
   À noter : pas de résultats faux lorsque l'on utilisait F3, pas de résultats faux en COQUE_3D.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 9.0.0
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 9.0.0
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V3.03.111
VALIDATION
    astout plaque + ssls200a + ssls111c
NB_JOURS_TRAV  : 3.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR sellenet     SELLENET Nicolas       DATE 05/24/2011 - 02:06:15

--------------------------------------------------------------------------------
RESTITUTION FICHE 016912 DU 2011-05-11 15:06:06
TYPE anomalie concernant Code_Aster (VERSION 11.1)
TITRE
    Lecture de champs aux points de Gauss
FONCTIONNALITE
   Problème :
   ----------
   """
   Impression MED du résultat : DEPL + SIEF_ELGA
      instant = 0
      numéro de pas de temps = 1
      numéro d'ordre = 1
   Relecture des champs :
   - champs de déplacement : OK
   - champs aux points de Gauss : OK si on pilote par les numéros d'ordre et de pas de temps,
   plantage si on pilote par l'instant.
   """
   
   
   Analyse :
   ---------
   C'est un coquille dans LRCAME. Lorsqu'on demandait le nombre d'éléments d'un champ pour un
   type de géométrie et un type d'entité donné, on ne testait pas le bon code retour.
   
   En effet la routine MFNEMA copiait son code retour dans CODE_RE2 et c'est ensuiet CODE_RET
   qui était testé. De ce fait, on diagnostiquait mal l'existence d'un champ dans un fichier MED.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    unitaire
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR assire       ASSIRE Aimery          DATE 05/24/2011 - 02:06:15

--------------------------------------------------------------------------------
RESTITUTION FICHE 016720 DU 2011-04-04 08:28:07
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Stanley : Prise en compte des rxc3xa9sultats temporels
FONCTIONNALITE
   Dans le cas de résultats à plusieurs instants, Stanley+Salome ne traitait que le premier
   instant.
   On crée un objet de type Presentations lorsque le résultats a plusieurs instants.
   On nomme cet objet à l'aide du maillage et du champ.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    Stanley
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 016718 DU 2011-04-04 07:37:45
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Stanley : Problxc3xa8me avec courbes sur plusieurs instants
FONCTIONNALITE
   Dans certains cas, lors de l'affichage de courbes, on pouvait rencontrer un plantage
   Python dans Stanley.
   
   Par exemple, le cas-test ssnp503a contient les composantes LAGS_C et LAGS_F1 dans le champ
   DEPL. Lorsque l'on selectionne au moins une de ces deux composantes (ou TOUT_CMP), alors
   on plante car POST_RELEVE_T ne sait pas extraite les valeurs de ces composantes.
   
   On blinde la génération des courbes dans Stanley pour ne jamais planter et n'afficher que
   les courbes qu'on a pu extraire.
   
   D'autre part, on en profite pour modifier les labels des courbes et de l'axe des abscisses.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    Stanley
NB_JOURS_TRAV  : 1.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 016717 DU 2011-04-04 07:24:13
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Stanley ;Champ ELEM sur dxc3xa9formxc3xa9e non pris en compte
FONCTIONNALITE
   Dans Stanley, lorsqu'on a un champ ELEM et qu'on coche 'Sur déformée', Stanley n'envoyait
   (dans Salome) que le champ ELEM vers Salome. On corrige.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    Stanley
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST MODIF hsnv132a                      macocco K.MACOCCO          226      3      3
 CASTEST MODIF sdld101a                      macocco K.MACOCCO          482     74     88
 CASTEST MODIF sdld23a                       macocco K.MACOCCO          503     28    188
 CASTEST MODIF sdll104a                      macocco K.MACOCCO          531     81      3
 CASTEST MODIF sdll110a                      macocco K.MACOCCO          538      6      3
 CASTEST MODIF ssls200a                      macocco K.MACOCCO          401     15     16
 CASTEST MODIF ssnv199f                      macocco K.MACOCCO          375      2      2
 CASTEST MODIF zzzz180a                      macocco K.MACOCCO          874    102     54
 FORTRAN MODIF elements/dxefr2               macocco K.MACOCCO           67     12      6
 FORTRAN MODIF elements/dxefro               macocco K.MACOCCO           72     12      6
 FORTRAN MODIF elements/dxqfor               macocco K.MACOCCO           98     15     12
 FORTRAN MODIF elements/dxrepe               macocco K.MACOCCO           87      7     18
 FORTRAN MODIF elements/dxsiro               macocco K.MACOCCO           64     12      6
 FORTRAN MODIF elements/dxtfor               macocco K.MACOCCO           81     12     12
 FORTRAN MODIF elements/te0031               macocco K.MACOCCO          409      8      8
 FORTRAN MODIF elements/te0032               macocco K.MACOCCO          270      4      4
 FORTRAN MODIF elements/te0033               macocco K.MACOCCO          330      7      7
 FORTRAN MODIF elements/te0040               macocco K.MACOCCO          205      7      8
 FORTRAN MODIF elements/te0409               macocco K.MACOCCO          363      5      5
 FORTRAN MODIF elements/te0580               macocco K.MACOCCO          105      4      4
 FORTRAN MODIF prepost/lrcame                macocco K.MACOCCO          626      2      2
  PYTHON MODIF Macro/defi_inte_spec_ops      macocco K.MACOCCO          154      4      3
  PYTHON MODIF Macro/macr_lign_coupe_ops     macocco K.MACOCCO          982      6      6
  PYTHON MODIF Macro/post_dyna_alea_ops      macocco K.MACOCCO          445     23      9
  PYTHON MODIF Messages/stanley              macocco K.MACOCCO          214      2      5
  PYTHON MODIF Stanley/as_courbes            macocco K.MACOCCO          301      2      2
  PYTHON MODIF Stanley/gmsh                  macocco K.MACOCCO          379      2      2
  PYTHON MODIF Stanley/graphiqueTk           macocco K.MACOCCO          581      2      2
  PYTHON MODIF Stanley/ihm_parametres        macocco K.MACOCCO          712      1      1
  PYTHON MODIF Stanley/salomeRunScript       macocco K.MACOCCO          207      1      1
  PYTHON MODIF Stanley/salomeVisu            macocco K.MACOCCO          418      1      2
  PYTHON MODIF Stanley/salomeVisuPylo        macocco K.MACOCCO          508      1      1
  PYTHON MODIF Stanley/stanley_engine        macocco K.MACOCCO         3368     30     19
  PYTHON MODIF Stanley/xmgrace               macocco K.MACOCCO          267      2      2
  PYTHON MODIF Templates/salomeGetStudies    macocco K.MACOCCO           49      1      1
  PYTHON MODIF Templates/salomeScript        macocco K.MACOCCO          277     84      3


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :    0           0         0                +0
 MODIF :   36       15569       580     514       +66
 SUPPR :    0           0                 0        +0
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :   36       15569       580     514       +66 
