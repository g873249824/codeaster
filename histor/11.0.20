

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 09/05/2011 - 04:03:54

--------------------------------------------------------------------------------
RESTITUTION FICHE 017453 DU 2011-09-01 06:59:25
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    NEW11.0.19 - tests wtnaXXX et wtnpXXX en erreur dans CALC_ELEM
FONCTIONNALITE
   Lors de la restitution de issue16749/issue16750, le catalogue 
   de CALC_ELEM n'a pas été restitué à cause d'un conflit.
   
   On restitue donc calc_elem.capy utilisant la fonction 
   'au_moins_un' dans les conditions de bloc qui traite 
   indifféremment les mots-clés contenant une seule valeur (max=1) 
   ou plusieurs (max>1 ou '**').
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    14 tests wtnaXXXX
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 017455 DU 2011-09-01 07:04:45
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    NEW11.0.19 - zzzz264a en errreur dans POST_ENDO_FISS
FONCTIONNALITE
   Suite à la restitution de issue16749 & issue16750, le test 
   zzzz264a échoue dans POST_ENDO_FISS.
   En effet, d'après la documentation et le source de la macro, 
   plusieurs mots-clés n'attendent qu'une valeur et non max='**'.
   
   Il s'agit des mots-clés INST, NUME_ORDRE sous le bloc RESULTAT, 
   et de PAS, GROUP_MA sous le mot-clé facteur RECHERCHE.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    zzzz264a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 015104 DU 2010-05-21 09:40:46
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Augmentation du temps du cas-test zzzz264a
FONCTIONNALITE
   Problème
   ========
   
   Lors de la réalisation de issue15076 (passage à numpy dans 
   POST_ENDO_FISS), le .para a été augmenté de 400 à 1000 s.
   
   
   Correction
   ==========
   
   -      Gauss = NP.zeros((len(Dist),), float)
   -      for m in range(len(Dist)) :
   -        Gauss[m] = NP.e**(-(2*Dist[m]/lreg)**2)
   +      Gauss = NP.exp( -(2/lreg)**2 * (Dist * Dist) )
   
   Sur ma machine, le temps passé dans POST_ENDO_FISS passe de 
   648s à 41s.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    zzzz264a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 016583 DU 2011-03-09 13:48:59
TYPE anomalie concernant astk (VERSION 1.2)
TITRE
    xc3x89mission de fiches depuis ASTK
FONCTIONNALITE
   Lors de l'émission de fiche depuis astk, la liste de diffusion 
   n'est pas remplie.
   
   Si ce dernier ne rajoute pas de message manuellement, il n'est 
   plus tenu au courant et ne peut pas répondre aux sollicitations 
   éventuelles.
   
   Maintenant, l'utilisateur est automatiquement ajouté dans la 
   liste de diffusion lors de l'émission de la fiche.
   
   Validation : émission de la fiche 17458.
   
   
   Détails (révision 2155) : schema.py (déclaration de la table 
   issue_nosy), rex.py (ajout d'un enregistrement issue_nosy).
   
   Au passage, on corrige le format de la date d'émission 
   (révision 2154).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    fiche 17458
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 017232 DU 2011-07-01 12:06:54
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW11.00.13, les cas-tests sdls121a, b et zzzz159b s'arretent en erreur fatale sur Rocks.
FONCTIONNALITE
   Ces tests plantaient sur Rocks (clpaster) en batch car les ressources 
   n'étaient pas suffisantes pour soumettre les calculs esclaves en batch.
   
   Lors de la mise à jour d'asrun, le paramètre définissant le fichier de 
   ressources (batch et interactif) a été mis en commentaire.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    tests MACR_RECAL
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 017273 DU 2011-07-08 15:26:14
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Evolution de la commande include_materiau
FONCTIONNALITE
   Cette fiche avait pour objectif de séparer le catalogue de 
   données matériaux "générique" (et historique) par opposition 
   aux données matériaux introduites récemment dédiées aux calculs 
   d'assemblages.
   
   En fait, les catalogues des assemblages sont uniquement 
   appelables par CALC_MAC3COEUR, leurs noms n'étant pas connus de 
   l'utilisateur. La séparation ne serait donc que pour le 
   développeur : pas d'intérêt.
   
   En résumé :
   - L'utilisateur récupère les données via INCLUDE_MATERIAU en 
   donnant un nom de matériau tel que décrit dans la doc M.
   - Pour les assemblages, c'est CALC_MAC3COEUR qui se débrouille 
   avec le nom du matériau et qui devra donner dans sa doc 
   l'origine des valeurs.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ras
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR sellenet     SELLENET Nicolas       DATE 09/05/2011 - 04:03:56

--------------------------------------------------------------------------------
RESTITUTION FICHE 017207 DU 2011-06-27 11:45:59
TYPE evolution concernant Code_Aster (VERSION )
TMA : DeltaCad
TITRE
    option DEGE_ELGA non calculxc3xa9e
FONCTIONNALITE
   1 - Objectif
   ============
   Calculer les déformations généralisées aux points de gauss : option DEGE_ELGA. 
   Les éléments concernés par cette option sont les éléments de structure
   POUTRE,TUYAU,PLAQUE,COQUE.
   Cette grandeur contient les composantes suivantes :
   
    - COQUE/PAQUE  =>  EXX,  EYY,  EXY,  KXX,  KYY, KXY, GAX, GAY
    - POUTRE       =>  EPXX, GAXY, GAXZ, GAT,  KY,  KZ,  GAX
    - TUYAU        =>  EPXX, GAXY, GAXZ, GAT,  KY,  KZ
   
   2 - Interventions
   =================
   2.1 Option : catalogue/source 
   -----------------------------
     - création d'un nouveau catalogue d'option : dege_elga.cata
     - catalogues de commandes: calc_champ, calc_elem, c_nom_cham_into 
     - routines mecalc, rscrsd 
     
   2.2 - Éléments de poutres
   -------------------------
   => éléments/cata
        Éléments              cata        
         MECA_POU_D_T       gener_mepdt1
         MECA_POU_D_E       gener_mepde1
         MECA_POU_D_TG      gener_mepdg1
         MECA_POU_D_EM      gener_mepmf1
         MECA_POU_D_TGM     gener_mepmf2
   => Modifications
        - Fortran : te0158 
        - cata    : ajout de l'option dans le catalogue des éléments
   => Validation
      - cas-test ssnl106b : calcul de l'option DEGE_ELGA et ajout de TEST_RESU 
   
   2.3 - Éléments tuyaux TUYAU_3M, TUYAU_6M
   ----------------------------------------
   => éléments/cata
        Éléments          cata        
         MET3SEG3      met3seg3
         MET3SEG4      met3seg4
         MET6SEG3      gener_metu61
   => Modifications
        - Fortran : tusief
        - cata    : ajout de l'option dans le catalogue des éléments
   => Validation
      cas-test ssnl106e : calcul de l'option DEGE_ELGA et ajout de TEST_RESU
   
   2.4 - Éléments de plaque DKT,DST,Q4G,DKTG
   -----------------------------------------
   ==> éléments/cata
       Éléments          cata  
         MEDKTR3     gener_medkt2
         MEDKQU4         '''
         MEDSTR3         ''' 
         MEDSQU4         ''' 
         MEQ4QU4         ''' 
         MEDKTG3     gener_medkg1 
         MEDKQG4         '''  
   => Modifications
        - fortran  : te0033 et création d'une nouvelle routine dxdege pour calculer DEGE_ELGA
        - cata    : ajout de l'option dans le catalogue des éléments
   => Validation
      ssls200a : calcul de l'option DEGE_ELGA et ajout de TEST_RESU
   
   2.5 - Élément de coque 1D
   -------------------------
   => éléments/cata
         Éléments          cata  
          MECXSE3      gener_mecqd1
          METCSE3      gener_mecqd1
          METDSE3      gener_mecqd1
   => Modifications
        - Fortran : te0228 
        - cata    : ajout de l'option dans le catalogue des éléments
   => Validation
       ssls100i : calcul de l'option DEGE_ELGA et ajout de TEST_RESU
   
   3 - Validation
   ==============
     Cas-tests décrit ci-dessus
     Passage de la liste complète
   
   4 - Documentation
   =================
     - Ajout de l'option dans la doc U4 de CALC_ELEM
     - Ajout des TEST_RESU dans la doc V des cas-tests
   
   =>Remarques:
    Les travaux de doc V seront effectues en même temps que ceux de la fiche 16785. 
    Sauf pour le cas-test ssnl106 documentation éditée actuellement par Lina DJEKHIANE
    La doc U4 est envoyée par email.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssls100i + liste complxc3xa8te
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR flejou       FLEJOU Jean Luc        DATE 09/05/2011 - 04:03:56

--------------------------------------------------------------------------------
RESTITUTION FICHE 015644 DU 2010-09-30 15:41:12
TYPE evolution concernant Code_Aster (VERSION )
TMA : Necs
TITRE
    PMF : ménage dans les fibres
FONCTIONNALITE
   Le but de cette fiche est de déplacer les efforts, déformations et modes incompatibles qui
   étaient jusqu'à maintenant stockés  à la fin des champs de contraintes et de variables
   internes rallongés spécialement pour cela grâce à la création de fausses fibres.
   Pour faire ce travail, on a créé un champ de structure STRX_ELGA pour contenir tous ces
   éléments, ce champ a été intégré dans la variable chapeaux VALINC, d'où le nombre de
   routines impactées. De plus, comme pour les variables internes on a créé un champ -+ qui
   conserve la valeur du champ à la dernière itération de Newton.
   
   Voici le détail des développements :
   CATALOGUES DE COMMANDE :
   c_nom_cham_into.capy :  ajout de "STRX_ELGA",
   c_nom_grandeur.capy  :  ajout de "STRX_R",
   crea_resu.capy : ajout de STRX_ELGA
   stat_non_line.capy : ajout de STRX dans ETAT_INIT
   dyna_non_line.capy : ajout de STRX dans ETAT_INIT
   calc_matr_elem.capy : ajout de STRX_ELGA
   
   CATALOGUES DE COMMANDE
   grandeur_simple.cata :
   <<  STRX_R  Type:R Champs spécial pour les éléments de structure
          N : effort normal
          VY : effort tranchant suivant CY efforts internes des poutres
          VZ : effort tranchant suivant CZ efforts internes des poutres
          MT : moment de torsion suivant CX
          MFY : moment de flexion suivant GY
          MFZ : moment de flexion suivant GZ
          BX : bi-moment (poutre avec gauchissement)
          EPXX
          GAXY
          GAXZ
          GAT
          KY
          KZ
          GAX
          DXINT
   >>
       STRX_R = R     N        VY       VZ       MT       MFY      MFZ
                BX       EPXX     GAXY     GAXZ     GAT      KY
                KZ        GAX     DXINT
   
   gener_mepmf1 :
   ESTRAUX  = STRX_R   ELGA__ RIGI    (N        VY       VZ       MT       MFY      MFZ
                                       BX       EPXX     GAXY     GAXZ      GAT      KY
                                       KZ        GAX     DXINT)
     ESTRAUX  PSTRXMR  en IN de FORC_NODA, FULL_MECA, RAPH_MECA et RIGI_MECA_TANG
     ESTRAUX  PSTRXPR  en OUT de FULL_MECA, RAPH_MECA,
     ESTRAUX  PSTRX_R  en OUT de TOU_INI_ELGA
     ESTRAUX  PSTRXRR  en IN de SIEF_ELNO et OUT de SIEF_ELGA
   
   gener_mepmf2 :
   ESTRAUX  = STRX_R   ELGA__ RIGI    (N        VY       VZ       MT      MFY      MFZ
                                       BX       EPXX     GAXY     GAXZ    GAT      KY
                                       KZ        GAX     DXINT)
     ESTRAUX  PSTRXMR  en IN de FORC_NODA, FULL_MECA,RAPH_MECA,RIGI_MECA_TANG
     ESTRAUX  PSTRXPR  en OUT de FULL_MECA, RAPH_MECA,RIGI_MECA_TANG
     ESTRAUX  PSTRX_R  en OUT de TOU_INI_ELGA
     ESTRAUX  PSTRXRR  en IN de SIEF_ELNO et RIGI_MECA_GE
     ESTRAUX  PSTRXMP  en IN de FULL_MECA et RAPH_MECA
   
   ajout de ces champs en IN et OUT dans les .cata correspondants
   PARTICULARITE POUR SIEF_ELNO, IL FAUT AJOUTER 'RESU!STRX_ELGA!N' APRES PSTRXTR, POUR QUE
   LCHIN SOIT TROUVE AUTOMATIQUEMENT PAR CCLCPI.F
   
   FORTRAN
   op0070.f : ZVALIN=20
   nmchai.f : NVALIN=20 et STRMOI STRPLU dans le DATA LVALIN
   autres routine avec ZVALIN :nmflma.f, nmcere.f,nmsens.f,nmrepl.f,nmrelp.f,op0026.f
   nmchap.f : ajout de STRMOI et STRPLU (nom, CALL NMCHA0 et CALL NMNSLE)
   rscrsd.f : ajout de STRX_ELGA dans les champs mécanique
   merimo.f : routine pour option FULL_MECA,RAPH_MECA,RIGI_MECA_TANG
              NBOUT=9 NBIN=56
              ajout de STRPLU
              CALL NMCHEX(VALINC,'VALINC','STRPLU',STRPLU)
              LPAOUT(9) = 'PSTRXTP'
              LCHOUT(9) = STRPLU(1:19)
   merimp.f : (appelée par merimo)
              CALL NMCHEX(VALINC,'VALINC','STRPLU',STRPLU)
              CALL NMCHEX(VALINC,'VALINC','STRMOI',STRMOI)
              LPAIN(55) = 'PSTRXMR'
              LCHIN(55) = STRMOI
              DATA VARMOJ
              LPAIN(56) = 'PSTRXMP'
              LCHIN(56) = STRMOJ
   
   nmcalv.f : ajout de STRMOI et STR
              CALL NMCHEX(VALINC,'VALINC','STRMOI',STRMOI)
              dans IF (OPTION.EQ.'SIGMOI') THEN on ajout STR    = STRMOI ,
              pour (OPTION.EQ.'SIGEXT')  STR    = ' '
              ajout de STR en argument de vefnme
   
   vefnme.f : routine pour l'option FORC_NODA
              ajout de STR en argument
              NBIN=33
              LPAIN(33) = 'PSTRXTM'
              LCHIN(33) = STR
              impact sur op0008.f op0106.f op0183.f op132b.f  ajout d'un argument (on a mis ' ')
   
   nmfpas.f : copie de STRPLU dans STRMOI
              CALL NMCHEX(VALINC,'VALINC','STRPLU',STRPLU)
              CALL NMCHEX(VALINC,'VALINC','STRMOI',STRMOI)
              CALL COPISD('CHAMP_GD','V',STRPLU,STRMOI)
   
   nmetcr.f : NBMAX=17
              ajout de STRX_ELGA et tout ce qui va avec
              DISMOI(LPMF)
              IF LPMF  CHAACT(17)=.TRUE.
   nmetcc.f   ajout de
              ELSEIF (NOMCHA.EQ.'STRX_ELGA') THEN
                 NOMCHX = 'CHAP#VALINC#STRMOI'
   nmetc0.f : prise en compte de STRX0 (initialisation dans TOU_INI_ELGA)
   
   On n'a pas trouvé d'autre solution que d'utiliser les routines de sensibilité
   nmnsle.f : ELSEIF (TYPCHP.EQ.'STRPLU') THEN
                  TYPEST = 24
              ELSEIF (TYPCHP.EQ.'STRMOI') THEN
                  TYPEST = 25
   segico.f     : NBPSCX=25
                  ZK24(IAUX+24) = BASENO  //'VAR_C8_P'//SAUX03//'     '
                  ZK24(IAUX+25) = BASENO  //'VAR_C8_M'//SAUX03//'     '
   nmcalm.f : CALL NMCHEX(VALINC,'VALINC','STRPLU',STRPLU)
               ajout de STRPLU en argument de merige
   merige.f  : ajout de STRX en argument d'entrée
               LCHOUT(12),LPAOUT(12)
               si XFEM
                 LPAIN(12) = 'PSTRXTR'
                 LCHIN(12) = STRX
               sinon
                 LPAIN(10) = 'PSTRXTR'
                 LCHIN(10) = STRX
               voir si on peut avoir POU_D_TGM avec XFEM
   dismmo.f : prise en compte de EXI_PMF
   dismlg.f : prise en compte de EXI_PMF
   
   Pour CALC_MATR_ELEM
   op0009.f  : CALL GETVID(' ','STRX_ELGA',0,1,1,STRX,N7)
               IF(N7.NE.0)THEN
                  CALL CHPVER('F',STRX,'ELGA','STRX_R',IER)
               ENDIF
               ajout de EFF en argument de merige
   Pour l'option SIEF_ELGA (appelé par op0046.f meca_statique)
   op0046.f  : ajout de CALL RSEXCH(RESULT,'STRX_ELGA',IORDR,CHAME2,IRET)
               et on met CHAME2 en argument de mecalc apres CHAMEL à la place de K24BLA
               CALL RSNOCH(RESULT,'STRX_ELGA',IORDR,' ')
               ajout de IF LPMF avant CALL RSEXCH et CALL RSNOCH
   mecalc.f  : on utilise CHELEX pour LCHOUT(2) si OPTIO2==SIEF_ELGA et LPMF==OUI
   
   Pour CALC_NO
   op0106.f : IF EXI_PMF
              CALL RSEXCH(RESUCO,'STRX_ELGA',IORDR,STRX,IRET)
              et ajout de STRX en argument de vefnme
   
   Routine POST_CHAMP
   w155ma.f : suppression d'un commentaire
   
   Pour CREA_RESU
   crperm.f : ajout de STRX_ELGA et agrandissement de quelques vecteurs de 3 à 4
   
   Pour CALC_CHAMP :
   ccchel.f : LIPAOU(1) devient LIPAOU(2)
              et on ajoute provisoirement MODELE en argument de cclpco
   cclpco.f : Les changements apportés sont temporaires, le temps que cette routine soit
   finalisée.
              ajout de MODELE en argument d'entrée pour appeler DISMOI(EXI_PMF)
              et prise en compte de STRX_ELGA dans LIPAOU
   ccfnrn.f : ajout de  DISMOI(EXIPMF)
           IF (LPMF) THEN
             CALL RSEXCH(RESUIN,'STRX_ELGA',IORDR,STR,IRET)
             IF (IRET.NE.0) THEN
               CALL CODENT(IORDR,'G',KIORD)
               VALK(1)=KIORD
               VALK(2)=OPTION
               CALL U2MESK('A','PREPOST5_9',2,VALK)
               GOTO 280
             ENDIF
           ENDIF
           STR en argument de vefnme
   prepost5.py : ajout du message d'erreur correspondant (PREPOST5_9)
   
   CALCUL ELEMENTAIRE :
   
   te0496.f et te0478.f : suppression de +6 et +7 au nombre de fibres.
   te0143.f, te0516.f, te0.517.f,te0535.f et te0537.f : changements nécessaires pour le
   stockage des efforts et des déformations dans le nouveau champ de structure.
   pmfmcf.f : suppression de +6
   
   CAS TESTS :
   ssnl123a : ajout de CREA_CHAMP STRX_ELGA et de STRX_ELGA en argument de CALC_MATR_ELEM
   zzzz131b : ajout de STRX_ELGA dans CREA_RESU
   ssnl106g : Découpage d'un STAT_NON_LINE en 3 appels à STAT_NON_LINE pour tester "reuse +
   ETAT_INIT ", une fois avec une SD RESULTAT et une fois avec les champs DEPL, SIGM, VARI et
   STRX
   
   Rq1 : nous n'avons pas mis d'alarme pour avertir d'un éventuel oublie de STRX dans
   ETAT_INIT s'il y a des PMF dans le modèle. 
   
   DOCUMENTATION :
   On a indiqué dans le résumé de la doc V6.02.106 de la série de cas tests ssnl106, que la
   modélisation g est utilisée pour tester le champ STRX_ELGA avec reuse et ETAT_INIT de
   STAT_NON_LINE  
   
   Rq2 : les opérateurs CALCUL, CALC_VECT_ELEM, CALC_FORC_NONL et CALC_SENSI n'étant associés 
   aux PMF dans aucuns cas tests, rien n'a été fait de particulier pour qu'ils prennent en
   compte le nouveau champ de structure.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : v6.02.106,U4.51.03,
VALIDATION
    passage des cas tests structure
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR geniaut      GENIAUT Samuel         DATE 09/06/2011 - 05:30:59

--------------------------------------------------------------------------------
RESTITUTION FICHE 017288 DU 2011-07-13 12:44:35
TYPE anomalie concernant Code_Aster (VERSION 11.1)
TITRE
    RUPT : K faux si fissure non plane
FONCTIONNALITE
   Problème :
   ----------
   
   On obtient des résultats faux sur K2 dans le cas suivant :
   
   - définition de la fissure par DEFI_FOND_FISS avec LEVRE_SUP et LEVRE_INF.
   - calcul de G et des K par CALC_G, option CALC_K_G.
   
   Le problème vient du fait que DEFI_FOND_FISS calcule "une normale" aux lèvres, stockée
   dans l'objet .NORMALE de la sd_fond_fiss. Alors que la doc dit que cet objet n'est défini
   que pour une fissure plane. Il faudrait une normale par maille des levres ! la normale
   calculée n'est pas la normale à la maille touchant le fond de fissure.
   
   Ensuite, dans CALC_G, on se sert de cette normale pour le calcul de la base locale en fond
   de fissure, puis des champs auxiliaire (le mot-clé DIRECTION de CALC_G n'a aucun effet sur
   ce point).
   
   Ce bug ne se produit qu'en 2D, car en 3D, le calcul des K nécessite de passer par les
   level sets (DEFI_FISS_XFEM), et la base locale est alors correctement calculée.
   
   
   Solution :
   ----------
   
   Grace à la restitution de la fiche 14537, une base locale en fond de fissure est créée par
   DEFI_FOND_FISS dans l'objet .BASEFOND.
   On peut alors utiliser cet objet dans CALC_G pour récupérer la bonne normale au fond.
   
   On ne corrige qu'en version NEW car la fiche 14537 a été restituée en NEW uniquement 
   En STA, on propose de dire dans la doc de CALC_G qu'il faut pour les fissure non planes
   définir la normale via DEFI_FOND_FISS/NORMALE.
   
   Validation : 
   sslv155a : l'erreur sur K2 passe de 120% à 1,3%
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 3.0.0
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.82.03, V3.04.155
VALIDATION
    sslv155a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 017344 DU 2011-07-28 08:46:30
TYPE anomalie concernant Code_Aster (VERSION 11.1)
TITRE
    En NEW11.0.16, le cas-test sslv155a s'arrete en erreur fatale sur Aster4, Rocks et Calibre 5.
FONCTIONNALITE
   Problème :
   ----------
   
   Suite à la restitution du cas test sslv155a et de la fiche 14537 sur une amélioration de
   DEFI_FOND_FISS, ce cas-test s'est planté sur toutes les plate-formes dans DEFI_FOND_FISS :
   
   <F> <RUPTURE0_34>                             !
      !                                               !
      ! Les l�vres de la fissure sont trop d�coll�es. 
   
   Le critère actuel définissant des lèvres collées est :
   produit scalaire entre les 2 vecteurs de direction de propagation (un par lèvre) est
   inférieur à 1e-4.
   
   ce critère n'est pas vérifié pour le cas sslv155a (on a écarté un peu les lèvres pour des
   raisons de maillage avec Salomé).
   
   
   Solution :
   ----------
   
   On revoit le critère caractérisant les lèvres collées/décollées.
   Les lèvres sont collées si l'angle entre les 2 vecteur normaux est inférieur à 5°.
   
   (dans le cas symétrique, cela revient à vérifier que l'angle entre le vecteur normal à la
   lèvre et le vecteur normal au plan de symétrie est inférieur à 2,5°)
   
   On en profite pour revoir un peu la programmation de fonnor.f et de fonno6.f
   Dans le cas symétrique, on impose :
   - soit de définir les lèvres (LEVRE_SUP)
   - soit de définir le vecteur de propagation au point origine du fond (DTAN_ORI)
   de manière à pouvoir déterminer le sens du vecteur propagation.
   
   impact :
   rupture0.py
   defi_fond_fiss.capy
   fonno1.f  fonno2.f  fonno4.f  fonno5.f  fonno6.f  fonnor.f
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.82.01
VALIDATION
    ssslv155a
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR abbas        ABBAS Mickael          DATE 09/06/2011 - 05:30:59

--------------------------------------------------------------------------------
RESTITUTION FICHE 017394 DU 2011-08-17 08:20:39
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Dxc3xa9gradation des temps de certains cas-tests en 11.0.15 et 11.0.16 dans STAT_NON_LINE
FONCTIONNALITE
   idem issue17454
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ras
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR geniaut      GENIAUT Samuel         DATE 09/06/2011 - 05:30:59

--------------------------------------------------------------------------------
RESTITUTION FICHE 017454 DU 2011-09-01 07:00:18
TYPE anomalie concernant Code_Aster (VERSION 11.1)
TITRE
    [FORUM] DEFI_LIST_INST : bug gestion AUTO et INST_FIN
FONCTIONNALITE
   Problème :
   ----------
   
   http://www.code-aster.org/forum2/viewtopic.php?id=15538 :
   
   En 11.0.16, si la gestion automatique du pas de temps est utilisée, le mot-clé INST_FIN n'est 
   pas respecté, le calcul continue au-dela.
   
   Tout se passe bien en gestion manuelle 
   Tout se passe bien également en gestion auto en 11.0.10
   
   
   Solution proposée :
   -------------------
   
   Dans nmcrli, on crée la liste des instants de calculs -- ou jalons -- (TPSIPO) par copie
   de la 
   liste provisoire PROVLI. Or cette liste contient tous les instants et ne tient pas compte de 
   INST_INIT ni de INST_FIN. Il faut se servir de la liste provisoire retaillée, créée par 
   nmcrls : SDDISC(1:19)//'.DITR'
   
   Je remplace la ligne de nmcrli.f :
         CALL JEDUP1(PROVLI,'V',TPSIPO) 
   par
         CALL JEDUPO( SDDISC(1:19)//'.DITR','V',TPSIPO)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    test DEFI_LIST_INST
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 017358 DU 2011-08-01 13:20:39
TYPE anomalie concernant Code_Aster (VERSION 11.1)
TITRE
    RUPT : bug dans POST_RUPTURE, OPERATION='CUMUL_CYCLES'
FONCTIONNALITE
   Lors de la restitution de la fiche 16685 (POST_RUPTURE, OPERATION='CUMUL_CYCLES' en
   11.0.16), un bug
   a été introduit.
   Le cumul ne se faisait que sur le paramètre DELTA_A (valeur par défaut de NOM_PARA), même
   si l'utilisateur avait choisi un autre paramètre.
   
   On corrige.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 11.0.16
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    zzzz287a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR greffet      GREFFET Nicolas        DATE 09/05/2011 - 07:05:25

--------------------------------------------------------------------------------
RESTITUTION FICHE 017263 DU 2011-07-07 09:03:50
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW11.00.14, le cas-test sdnl130a s'arrete en erreur fatale sur Rocks.
FONCTIONNALITE
   On ne leur affecte une valeur que dans certains cas (tests IF).
   Ces variables intermédiaires sont apparues récemment : version 11.0.14.
   
   
   Solution :
   On initialise ces deux variables. Suite aux conseils de François Voldoire et afin de 
   garder la bonne dimension physique, on va mettre :
         Y1 = Y01/10.D0      
         Y2 = Y02/10.D0
   On a donc des valeurs petites devant Y01 et Y02.
   
   
   Validation : on passe tous les tests (54) utilisant les PMF.
   
   
   Impact :
   Sources : nmcb1d.f
   Cas-tests : ssns106j.comm
   En effet, ce cas-test a quatre valeurs de non regression qui bougent (de moins de 2%). On 
   retrouve d'ailleurs les valeurs d'avant la version 11.0.14.
   A noter que ssns106i plante (non convergence a 2 s) même sans surcharge (même instant) sur 
   aster4 mais si il tournait il y a de fortes chances que des valeurs de non regression 
   bougent aussi comme ssns106j. En tout cas cela ne règle pas la fiche 16773, dommage !
   
   Pas de report en STA10.
   Pas d'impact doc (on est en cohérence avec la doc R).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 11.0.14
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    cas-tests PMF
NB_JOURS_TRAV  : 3.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR pellet       PELLET Jacques         DATE 09/05/2011 - 05:00:07

--------------------------------------------------------------------------------
RESTITUTION FICHE 017444 DU 2011-08-30 13:30:07
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    NEW11.0.19 - 2 tests seront "NOOK" : ssls101e et ssnl127e
FONCTIONNALITE
   Problème :
   ----------
   Suite à la restitution de la fiche 17405, les 2 tests ssls101e et ssnl127e sont "NOOK" en
   11.0.19
                                                                                            
                         
   L'objet de cette fiche est de comprendre pourquoi et de corriger ces tests.
                                                                                            
                         
                                                                                            
                         
   Analyse :
   --------
   Le problème disparait si dans les routines DXSIRO et VDSIRO on ne force pas SIZZ=0.
                                                                                            
                         
   En revanche, il faudrait comprendre pourquoi SIZZ != 0 est nécessaire pour avoir un "bon"
   comportement dans STAT_NON_LINE (par exemple moins d'itérations de Newton pour le test
   ssnl127e).
                                                                                            
                         
   Correction :
   ------------
   On ne "force" plus à zéro la composante SIZZ lorsqu'on change de repère dans le plan tangent.
   La composante SIZZ est donc conservée telle quelle.
                                                                                            
                         
                                                                                            
                         
   Remarques :
   -----------
   1) La correction n'est totalement satisfaisante : on aimerait bien comprendre pourquoi la
   non-nullité de la composante SIZZ (qui est négligée dans les théories de plaque/coque)
   permet parfois une meilleure convergence de STAT_NON_LINE (par exemple dans le test ssnl127e).
      Mais ce n'est pas moi qui vais l'expliquer !
                                                                                            
                         
   2) Je profite de cette fiche pour fusionner quelques routines "doublons" introduites
   récemment :
     * Pour "tourner"les contraintes :
        * vdsiro et vdsir2  -> vdsiro
        * dxsiro et dxsir2  -> dxsiro
     * Pour les routines de calcul des matrices de rotation :
        * vdrepe et vdrep2
        * dxrepe et dxrep2
       Je ne fais rien car les routines xxxx2 ont 2 arguments supplémentaires (alpha et beta)
   que je n'ai pas envie d'imposer aux 2 autres routines.
     * Pour "tourner" les efforts, je supprime les 2 routines ajoutées :
        * vdefr2
        * dxefr2
       car je pense que l'ajout de l'argument NBSP est une erreur : il n'y a pas de
   sous-points pour les efforts.
    
    
   Liste des fichiers impactés par la correction de la fiche:  17444
     dxsiro.f  te0442.f  te0443.f  vdsiro.f
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    tests cassxc3xa9s
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 017447 DU 2011-08-30 16:50:14
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Plantage sale CREA_CHAMP('ASSE')
FONCTIONNALITE
   Problème :
   ----------
   L'étude fournie se plante salement dans la commande CREA_CHAMP / ASSE (écrasement mémoire
   dans jedetr.f).
                                                                                            
                                                                             
   Analyse :
   ---------
   Il s'agit d'une erreur d'utilisation :
   On cherche à "assembler" un champ (vrmpro) associé au maillage (MAILLIN) en donnant en
   argument le motclé MODELE=MODELE mais MODELE est associé au maillage MAIL.
                                                                                            
                                                                             
   Correction :
   ------------
   On "blinde" la routine chapss.f pour qu'elle vérifie l'identité des 2 maillages.
                                                                                            
                                                                             
   le message d'erreur est maintenant :
                                                                                            
                                                                             
   !----------------------------------------------------------------!
   !.<F>.<CALCULEL2_17>.............................................!
   !.Erreur.utilisateur.dans.la.commande.CREA_CHAMP.:...............!
   !..Incohérence.entre.le.champ.vrmpro.associé.au.maillage.MAILLIN.!
   !..et.le.maillage.MAIL...........................................!
   !----------------------------------------------------------------!
    
    
   Liste des fichiers impactés par la correction de la fiche:  17447
     chpass.f
     calculel2.py
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    test joint
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 017130 DU 2011-06-15 08:23:23
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    renommage test PERF012
FONCTIONNALITE
   Problème :
   ----------
   Le test PERF012 sert à mesurer les performances des calculs élémentaires (et à vérifier
   qu'elles ne se dégradent pas).
   
   Accessoirement, c'est une test qui nous sert à nous comparer (en termes de perfs à
   Europlexus). 
   
   Ce test utilise la commande DYNA_NON_LINE en explicite mais ce n'est pas le test de
   performance de DYNA_NON_LINE en explicite.
   
   La comparaison avec Europlexus n'est pas à notre avantage. Comme la page Web des
   performances se veut une "vitrine", ce test ne doit pas y figurer.
   
   Réponse :
   ---------
   Le test continuera à s'appeler perf012 car ce nom est une bonne indication de ce pour quoi
   il a été introduit dans le code. En particulier, il ne faut pas modifier son maillage ni
   son .comm.
   
   En revanche, on décide de ne pas le documenter sur la page Web des performances.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    rien de particulier
NB_JOURS_TRAV  : 0.05
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR sellenet     SELLENET Nicolas       DATE 09/06/2011 - 09:11:33

--------------------------------------------------------------------------------
RESTITUTION FICHE 017445 DU 2011-08-30 13:44:19
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Erreur signe modxc3xa8le DIS_VISC R5.03.17, U4.43.01, V6.08.101
FONCTIONNALITE
   Problème :
   ----------
   """
   Suite à une étude du CIPN (pose d'amortisseurs sismiques), une erreur de signe a été
   révélée dans la valeur du coef de la loi DIS_VISC (restituée par NECS il y qq temps) et
   indécelable par le cas-test SSND101 (V6.08.101), qui ne teste que les valeurs maxi sur un
   cycle sinus.
   """
   
   
   Résultats faux :
   ----------------
   Les éléments discrets visqueux non linéaires DIS_VISC [R3.05.17], disponibles depuis la
   version 9.0.3 (Fiche 9368) ont été développés avec une convention de signe trompeuse :
   avec un coefficient positif on obtenait une force propulsive et non pas de rappel comme
   cela est naturellement attendu pour un amortisseur. Aussi les déplacements des structures
   comportant de tels éléments discrets étaient excessifs avant la correction apportée, qui
   consiste à modifier le signe de l'effort induit.
   
   
   Solution :
   ----------
   Il est nécessaire de modifier le signe de la force d'amortissement calculée dans la
   routine DINON2.
   
   De plus, on modifie le test ssnd101a pour y ajouter 2 DYNA_NON_LINE. Dans ces deux
   calculs, on tire sur un SEG2 dont un des noeuds est fixe. Dans un cas, on affecte un
   amortissement type A_T_D_L et dans l'autre on utilise DIS_VISC avec les mêmes paramètres
   d'amortissement.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 9.0.3
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 9.0.3
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : R5.03.17, U4.43.01, V6.08.101
VALIDATION
    ssnd101a
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR proix        PROIX Jean-Michel      DATE 09/05/2011 - 04:23:51

--------------------------------------------------------------------------------
RESTITUTION FICHE 017307 DU 2011-07-19 17:20:00
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Comportements non linxc3xa9aires et SHB
FONCTIONNALITE
   Demande :
   _________
   
   Sur le forum une question revient souvent s'agissant des coques SHB : dans quelle
   catégorie rentre-t-elle pour les comportements non linéaires ? Est-ce COQUE ou 3D au sens
   de la "nomenclature des modélisations" (§3 de la doc U4.51.11 "Comportements non
   linéaires") ? Dit simplement, peut-on utiliser les cinématiques en grandes déformations
   (GDEF_LOG, SIMO_MIEHE) avec ? (aucun test ne le valide).
   
   Réponse :
   _________
   
   Effectivement ce n'est pas clair. En fait ce sont des éléments de coque au sens de
   U4.51.11 : leur TE pour les options non linéaires est particulier (notamment parce qu'il
   faut calculer des termes de stabilisation), donc tous les développements génériques des TE
   3D et 2D, comme les modèles de grandes déformations, la matrice tangente par perturbation,
   etc.. ne fonctionnent pas pour les SHB. Il faudrait réfléchir à un autre découpage de la
   routine TE, si on voulait mutualiser avec les éléments 3D...
   
   En attendant, pour que les utilisateurs connaissent les limitation en termes de types de
   déformations, je l'ajoute dans U5.51.11, ainsi que dans le fortran : les seules
   déformation permises sont 'PETIT' et 'GROT_GDEP'.
   
   A ce propos, il faudrait aussi mettre à jour les docs R, et revoir le fortran, notamment
   le paramètre LAG (qui justement permet de calculer les déformations de Green-Lagrande), et
   la matrice tangente, dont l'expression est donnée dans la doc R, mais pas programmée dans
   le fortran : la matrice programmée est linéaire (par rapport au comportement) : on
   n'utilise pas l'opérateur tangent issu de NMCOMP.
   Mais tout ce travail dépasse le cadre de cette fiche.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.51.11
VALIDATION
    tests SHB
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 017321 DU 2011-07-25 13:44:08
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    [FORUM] Interface UMAT : segmentation fault
FONCTIONNALITE
   Anomalie
   ========
   
   Réf : http://www.code-aster.org/forum2/viewtopic.php?id=13161
   
   Dans ce post du forum, un utilisateur rencontre une segmentation fault en utilisant sa
   UMAT. En fait le bug se produit dans l'interface (avant même l'appel à sa routine) : comme
   dans une UMAT on ne distingue pas prédiction/correction et instant "-" et "+", l'interface
   UMAT-Aster doit donner un tableau contenant en entrée les variables internes à l'instant -
   et en sortie les variables internes à l'instant + (quand elles on un sens, c'est à dire en
   FULL_MECA, ou RAPH_MECA). De même pour les contraintes.
   
   Or quand on calcule RIGI_MECA_TANG : les variables internes n'existent pas et donc le
   tableau STATEV dans lc0050 pointe vers une zone non initialisée de la mémoire.
   
   On choisit pour corriger d'effectuer 2 appels à UMATWP : un pour RIGI_MECA_TANG et un
   autre pour *_MECA. En RIGI_MECA_TANG on passe le tableau VIM  (toujours défini) à la place
   de STATEV : la UMAT modifiera donc les variables internes "-" mais ce n'est pas grave,
   elles ne sortent pas de la routine TE.
   
   Au passage on en profite pour augmenter le nombre de paramètres possibles : on passe de 50
   à 200, comme cela avait été demandé par un utilisateur. Quant au nombre de variables
   internes, il est dynamique puisque choisi par l'utilisateur par le mot-clé NB_VARI.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    tests umat
NB_JOURS_TRAV  : 0.4
--------------------------------------------------------------------------------
RESTITUTION FICHE 017341 DU 2011-07-28 08:13:23
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW11.0.16, le cas-test comp010f s'arrete en erreur fatale sur Aster4, Rocks et Calibre 5.
FONCTIONNALITE
   En NEW11.0.16, le cas-test comp010f s'arrête en erreur fatale sur Aster4, Rocks et Calibre 5.
   Il s'agit d'un PB sur le nombre de variables internes initiales pour VISC_IRRA_LOG.
   
   En effet dans la fiche 17275, le nombre de variables internes est passé de 1 à 2 pour les
   comportements GRAN_IRRA_LOG, VISC_IRRA_LOG et DIS_GRICRA.
   
   Le test COMP010F n'avais pas été mis à jour. On définit maintenant 2 variables internes et
   tout est OK.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    comp010f
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 017368 DU 2011-08-02 15:29:17
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    cohxc3xa9rence comp010 et doc V associxc3xa9e
FONCTIONNALITE
   Probleme constaté :
   La documentation v6.07.110, pour la modélisation G, donne des valeurs de paramètres
   matériau pour les bornes T0=20C à Tmax=500C. Or, dans le test, on voit que les plages sont
   définies tantôt sur [T0, Tmax], tantôt sur
   [0,1000]. Dans la doc, on ne voit jamais cette plage [0,1000]. 
   
   On rend cohérent le test  comp010G avec la doc (tout est défini entre T0=20 C et Tmax=500
   C). Au passage, on corrige un petit problème dans le fichier de commandes concernant la
   récupération de la solution d'un pas de temps pour servir d'état initial au suivant (on
   repartait toujours de 0).
   
   De plus, pour les modélisations H et I, il y avait des erreurs dans la documentation : les
   données ne correspondaient pas à celle des fichiers de commandes. La doc est donc mise à jour.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : v6.07.110
VALIDATION
    comp010
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR tardieu      TARDIEU Nicolas        DATE 09/05/2011 - 04:23:52

--------------------------------------------------------------------------------
RESTITUTION FICHE 017141 DU 2011-06-16 07:27:59
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW11.0.11, le cas-test ssnl119a s'arrete en erreur fatale sur Calibre 5.
FONCTIONNALITE
   Problème :
   ----------
   En NEW11.0.11, le cas-test ssnl119a s'arrete en erreur fatale sur Calibre 5.
   
   
   Solution :
   ----------
   Dans le cadre de la réalisation de la fiche 16566
   (http://clpwdev.der.edf.fr:8080/REX/issue16566) ont été introduites 2 variables
   non-initialisées dans nmcb1d.f, Y1 et Y2.
   Ceci induit un comportement erratique du test ssnl119a.
   On corrige le problème en initialisant : 
   Y1 =Y01/10.D0  et Y2 = Y02/10.D0
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    Passage des tests
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR proix        PROIX Jean-Michel      DATE 09/05/2011 - 04:23:52

--------------------------------------------------------------------------------
RESTITUTION FICHE 017401 DU 2011-08-19 07:08:26
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW11.0.17, les cas-tests perfe03a et ssnv194a s'arretent anormalement sur Rocks.
FONCTIONNALITE
   En NEW11.0.17, les cas-tests perfe03a et ssnv194a s'arretent anormalement sur Rocks. Le
   plantage est dû à une non convergence de la loi monocristal dans ces deux tests, et ceci
   seulement en nodebug sur clpaster. En debug, cela converge exactement de la même façon que
   sur les autres machines.
   
   Avec la NEW11.0.19, ces deux tests sont OK.
   
   Je classe donc sans suite
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    eux memes
NB_JOURS_TRAV  : 0.4
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST MODIF comp008n                      tardieu N.TARDIEU          310      2      2
 CASTEST MODIF comp010a                      tardieu N.TARDIEU          242      2      2
 CASTEST MODIF comp010b                      tardieu N.TARDIEU          103      2      3
 CASTEST MODIF comp010f                      tardieu N.TARDIEU          222      5      4
 CASTEST MODIF comp010g                      tardieu N.TARDIEU          293     77     35
 CASTEST MODIF hplv103a                      geniaut S.GENIAUT          470      5     20
 CASTEST MODIF sdls114a                      geniaut S.GENIAUT          345      1      1
 CASTEST MODIF ssls100i                     courtois M.COURTOIS         194     19      3
 CASTEST MODIF sslv110b                      geniaut S.GENIAUT          291      3      2
 CASTEST MODIF sslv110c                      geniaut S.GENIAUT          362      2      1
 CASTEST MODIF sslv134a                      geniaut S.GENIAUT          374      8      9
 CASTEST MODIF sslv134e                      geniaut S.GENIAUT          297     20     29
 CASTEST MODIF sslv134f                      geniaut S.GENIAUT          326      3      2
 CASTEST MODIF sslv134g                      geniaut S.GENIAUT          656      1      1
 CASTEST MODIF sslv155a                      geniaut S.GENIAUT          170      4     14
 CASTEST MODIF ssnd101a                     sellenet N.SELLENET         524    165      5
 CASTEST MODIF ssnd101b                     sellenet N.SELLENET         309      4      4
 CASTEST MODIF ssnl106g                     courtois M.COURTOIS         327     74      1
 CASTEST MODIF ssnl123a                     courtois M.COURTOIS         384     11      2
 CASTEST MODIF ssns101a                      tardieu N.TARDIEU          351      1      1
 CASTEST MODIF ssns106j                      greffet N.GREFFET         1417      5      5
 CASTEST MODIF umat001a                      tardieu N.TARDIEU          216      2      2
 CASTEST MODIF zzzz131b                     courtois M.COURTOIS         609      2      2
 CASTEST MODIF zzzz264a                     courtois M.COURTOIS         126      2      2
CATALOGU AJOUT options/dege_elga            courtois M.COURTOIS          55     55      0
CATALOGU MODIF compelem/grandeur_simple__   courtois M.COURTOIS        2146     23      1
CATALOGU MODIF options/forc_noda            courtois M.COURTOIS          94      2      1
CATALOGU MODIF options/full_meca            courtois M.COURTOIS          84      4      1
CATALOGU MODIF options/raph_meca            courtois M.COURTOIS          84      4      1
CATALOGU MODIF options/rigi_meca_ge         courtois M.COURTOIS          44      2      1
CATALOGU MODIF options/rigi_meca_tang       courtois M.COURTOIS          85      3      2
CATALOGU MODIF options/sief_elno            courtois M.COURTOIS          61      3      1
CATALOGU MODIF options/tou_ini_elga         courtois M.COURTOIS          40      2      1
CATALOGU MODIF typelem/gener_mecqd1         courtois M.COURTOIS         195      4      1
CATALOGU MODIF typelem/gener_medkg1         courtois M.COURTOIS         265      6      1
CATALOGU MODIF typelem/gener_medkt2         courtois M.COURTOIS         406      4      1
CATALOGU MODIF typelem/gener_mepde1         courtois M.COURTOIS         313      5      1
CATALOGU MODIF typelem/gener_mepdg1         courtois M.COURTOIS         279      6      1
CATALOGU MODIF typelem/gener_mepdt1         courtois M.COURTOIS         291      5      1
CATALOGU MODIF typelem/gener_mepmf1         courtois M.COURTOIS         274     18     10
CATALOGU MODIF typelem/gener_mepmf2         courtois M.COURTOIS         277     19      7
CATALOGU MODIF typelem/gener_metu61         courtois M.COURTOIS         263      6      1
CATALOGU MODIF typelem/met3seg3             courtois M.COURTOIS         260      6      1
CATALOGU MODIF typelem/met3seg4             courtois M.COURTOIS         256      6      1
CATALOPY MODIF commande/calc_champ          courtois M.COURTOIS         254      3      3
CATALOPY MODIF commande/calc_elem           courtois M.COURTOIS         467     23     57
CATALOPY MODIF commande/calc_matr_elem      courtois M.COURTOIS         157      2      1
CATALOPY MODIF commande/crea_resu           courtois M.COURTOIS         217      3      2
CATALOPY MODIF commande/defi_fond_fiss       geniaut S.GENIAUT          106      7      9
CATALOPY MODIF commande/defi_materiau        tardieu N.TARDIEU         3450    301      1
CATALOPY MODIF commande/dyna_non_line       courtois M.COURTOIS         243      2      1
CATALOPY MODIF commande/post_endo_fiss      courtois M.COURTOIS          78      5      5
CATALOPY MODIF commande/stat_non_line       courtois M.COURTOIS         163      3      1
CATALOPY MODIF commun/c_nom_cham_into       courtois M.COURTOIS         207      3      1
CATALOPY MODIF commun/c_nom_grandeur        courtois M.COURTOIS         153      2      1
 FORTRAN AJOUT elements/dxdege              courtois M.COURTOIS         130    130      0
 FORTRAN MODIF algorith/lc0050               tardieu N.TARDIEU          304     28      4
 FORTRAN MODIF algorith/memokg               geniaut S.GENIAUT          248     14     12
 FORTRAN MODIF algorith/merimo              courtois M.COURTOIS         296      6      3
 FORTRAN MODIF algorith/merimp              courtois M.COURTOIS         351     24      5
 FORTRAN MODIF algorith/nmcalm              courtois M.COURTOIS         219      5      4
 FORTRAN MODIF algorith/nmcalv              courtois M.COURTOIS         328      7      4
 FORTRAN MODIF algorith/nmcere              courtois M.COURTOIS         237      2      2
 FORTRAN MODIF algorith/nmchai              courtois M.COURTOIS         144      4      4
 FORTRAN MODIF algorith/nmchap              courtois M.COURTOIS         355      9      4
 FORTRAN MODIF algorith/nmcrli               geniaut S.GENIAUT          213      4      4
 FORTRAN MODIF algorith/nmetc0              courtois M.COURTOIS         163     12      6
 FORTRAN MODIF algorith/nmetcc              courtois M.COURTOIS         150      3      2
 FORTRAN MODIF algorith/nmetcr              courtois M.COURTOIS         284     21     12
 FORTRAN MODIF algorith/nmflma              courtois M.COURTOIS         357      2      2
 FORTRAN MODIF algorith/nmfpas              courtois M.COURTOIS         130      5      2
 FORTRAN MODIF algorith/nmnsle              courtois M.COURTOIS         124      6      2
 FORTRAN MODIF algorith/nmrelp              courtois M.COURTOIS         382      2      2
 FORTRAN MODIF algorith/nmrepl              courtois M.COURTOIS         367      2      2
 FORTRAN MODIF algorith/nmsens              courtois M.COURTOIS         272      2      2
 FORTRAN MODIF algorith/op0070              courtois M.COURTOIS         362      2      2
 FORTRAN MODIF algorith/vefnme              courtois M.COURTOIS         303     15     10
 FORTRAN MODIF calculel/ccfnrn              courtois M.COURTOIS         499     20     10
 FORTRAN MODIF calculel/crperm              courtois M.COURTOIS         247     13      4
 FORTRAN MODIF calculel/mecact               geniaut S.GENIAUT          160      1      1
 FORTRAN MODIF calculel/mecalc              courtois M.COURTOIS         526      3      1
 FORTRAN MODIF calculel/meficg               geniaut S.GENIAUT          487     15     11
 FORTRAN MODIF calculel/merige              courtois M.COURTOIS         158     11      7
 FORTRAN MODIF calculel/op0008              courtois M.COURTOIS         238      3      3
 FORTRAN MODIF calculel/op0009              courtois M.COURTOIS         215      8      4
 FORTRAN MODIF calculel/op0026              courtois M.COURTOIS         410      2      2
 FORTRAN MODIF calculel/w155ma              courtois M.COURTOIS         181      2      3
 FORTRAN MODIF elements/dinon2              sellenet N.SELLENET         120      4      4
 FORTRAN MODIF elements/dxsiro                pellet J.PELLET            69      2      2
 FORTRAN MODIF elements/fonno1               geniaut S.GENIAUT          115      7      6
 FORTRAN MODIF elements/fonno2               geniaut S.GENIAUT          133      8      3
 FORTRAN MODIF elements/fonno4               geniaut S.GENIAUT          142      6      3
 FORTRAN MODIF elements/fonno5               geniaut S.GENIAUT          166     20     16
 FORTRAN MODIF elements/fonno6               geniaut S.GENIAUT          289    199    128
 FORTRAN MODIF elements/fonnor               geniaut S.GENIAUT          263     93     71
 FORTRAN MODIF elements/nmcb1d               greffet N.GREFFET          142      4      1
 FORTRAN MODIF elements/pmfmcf              courtois M.COURTOIS          86      2      2
 FORTRAN MODIF elements/te0033              courtois M.COURTOIS         354     20      3
 FORTRAN MODIF elements/te0143              courtois M.COURTOIS         247      7     10
 FORTRAN MODIF elements/te0158              courtois M.COURTOIS         255     29      2
 FORTRAN MODIF elements/te0228              courtois M.COURTOIS         122     19      3
 FORTRAN MODIF elements/te0299               geniaut S.GENIAUT          351      7      6
 FORTRAN MODIF elements/te0442                pellet J.PELLET           172      7     19
 FORTRAN MODIF elements/te0443                pellet J.PELLET           208      9     23
 FORTRAN MODIF elements/te0477               tardieu N.TARDIEU          497     14     14
 FORTRAN MODIF elements/te0478              courtois M.COURTOIS         203      3      3
 FORTRAN MODIF elements/te0496              courtois M.COURTOIS         159      3      7
 FORTRAN MODIF elements/te0516              courtois M.COURTOIS         618     48     48
 FORTRAN MODIF elements/te0517              courtois M.COURTOIS         355     25     23
 FORTRAN MODIF elements/te0535              courtois M.COURTOIS         333     22     22
 FORTRAN MODIF elements/te0537              courtois M.COURTOIS         167      9     60
 FORTRAN MODIF elements/vdsiro                pellet J.PELLET           138      3      4
 FORTRAN MODIF prepost/op0106               courtois M.COURTOIS         813     16     10
 FORTRAN MODIF prepost/op0183               courtois M.COURTOIS         358      4      3
 FORTRAN MODIF prepost/op132b               courtois M.COURTOIS         837      2      2
 FORTRAN MODIF utilitai/chpass                pellet J.PELLET           312     10      3
 FORTRAN MODIF utilitai/dismlg              courtois M.COURTOIS         400     11      2
 FORTRAN MODIF utilitai/dismmo              courtois M.COURTOIS         250      4      2
 FORTRAN MODIF utilitai/rscrsd              courtois M.COURTOIS         434      6      5
 FORTRAN MODIF utilitai/segico              courtois M.COURTOIS         319      8      2
 FORTRAN SUPPR elements/dxsir2                pellet J.PELLET            67      0     67
 FORTRAN SUPPR elements/vdefr2                pellet J.PELLET            99      0     99
 FORTRAN SUPPR elements/vdsir2                pellet J.PELLET            89      0     89
  PYTHON MODIF Macro/post_endo_fiss_ops     courtois M.COURTOIS         859      5     14
  PYTHON MODIF Macro/post_rupture_ops        geniaut S.GENIAUT          637      2      2
  PYTHON MODIF Messages/calculel2             pellet J.PELLET           455      7      1
  PYTHON MODIF Messages/compor1              tardieu N.TARDIEU          376     24     18
  PYTHON MODIF Messages/prepost5            courtois M.COURTOIS         225      9      4
  PYTHON MODIF Messages/rupture0             geniaut S.GENIAUT          569     35     10
  PYTHON MODIF Messages/rupture1             geniaut S.GENIAUT          393      1      8


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :    2         185       185              +185
 MODIF :  125       41781      1869     974      +895
 SUPPR :    3         255               255      -255
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :  130       42221      2054    1229      +825 
