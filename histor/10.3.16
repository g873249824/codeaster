

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR abbas        ABBAS Mickael          DATE 02/28/2011 - 05:46:31

--------------------------------------------------------------------------------
RESTITUTION FICHE 016467 DU 2011-02-23 10:26:25
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Problème dans les listes d'instants
FONCTIONNALITE
   Problème
   ========
   
   La liste d'instants d'archivage est mal prise en compte (on oublie systématiquement le
   dernier instant).
   
   Solution
   ========
   
   Il y a un bug dans NMCRIT, à l'appel de la routine utilisateur UTACLI:
   NBINTV = NBINST - 1
   CALL UTACLI(INST  ,ZR(JLIST),NBINTV,TOLE  ,NBINDI)
   C'est faux.
   Il faut faire:
   CALL UTACLI(INST  ,ZR(JLIST),NBINST,TOLE  ,NBINDI)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    liste restreinte
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 016151 DU 2011-01-05 10:12:34
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Affichage des itxc3xa9rations de gxc3xa9omxc3xa9trie/frottement pour contact continu
FONCTIONNALITE
   Problème
   ========
   
   Les itérations de frottement en contact continu ne devraient pas être affichées si le
   frottement n'est pas activé.
   De plus lorsque ce dernier est activé (exemple SSNA102F), le nombre d'itérations semble
   non initialisé :
     Statistiques de résolution du contact continu dans ce pas de temps.
       * Nombre d'itérations de contact                       : 8 
       * Nombre d'itérations de frottement                    : 6917529027658370224 
       * Nombre d'itérations de réactualisations géométriques : 576460752290519449 
    
   
   Pour les itérations de géométrie, il y a le même problème (exemple SSNV129D).
   
   Solution
   ========
   
   On a oublié de remplir les vecteurs d'entiers avant l'appel à U2MESG dans nmimpl.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    visuelle
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 016150 DU 2011-01-05 10:05:37
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Affichage des iterations de DEBORST dans le tableau de convergence
FONCTIONNALITE
   Problème
   ========
   
   On constate un problème dans l'affichage des informations sur DEBORST dans le tableau de
   convergence.
   
   Exemple : forma03d
   --------------------------------------------------------------------------------------
   |   ITERATIONS   |     RESIDU     |     RESIDU     |     DEBORST    |     OPTION     
   |     NEWTON     |     RELATIF    |     ABSOLU     |                |   ASSEMBLAGE   
   |                | RESI_GLOB_RELA | RESI_GLOB_MAXI |                |                
   --------------------------------------------------------------------------------------
   |     0        X | 1.12603E-02  X | 1.12597E+01    |    Unknown erro|TANGENTE        
   |     1          | 5.68468E-16    | 5.68434E-13    |    Unknown erro|TANGENTE        
   --------------------------------------------------------------------------------------
   
   Solution
   ========
   
   Chaine incorrectement initialisée dans nmconv
   CALL IMPSDR(SDIMPR,'ITER_DEBO',K16BLA,R8B,IBID)
   et non
   CALL IMPSDR(SDIMPR,'ITER_DEBO',' ',R8B,IBID)
   
   Remarque: cette erreur suffit à rendre le fichier .mess binaire. C'était très casse-pieds
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    visuelle
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------
RESTITUTION FICHE 016474 DU 2011-02-24 10:27:09
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    ARCHIVAGE - Instants négatifs
FONCTIONNALITE
   Problème
   ========
   
   Lorsque les instants sont négatifs (!), la sélection par ARCHIVAGE ne fonctionne plus.
   
   Solution
   ========
   
   Il y a un bug dans nmcrpo. En effet, pour trouver la tolérance de recherche de l'instant
   en mode REALTIF (mot-clef PRECISION), on multiplie cette précision par l'instant courant.
   Si l'instant est négatif, la tolérance est négative. On a aucune chance de sélectionner un
   instant.
   On change TOLR = INST*TOLE en TOLR = ABS(INST)*TOLE
   
   Validation
   ==========
   
   On modifie ssnv128a pour utiliser une liste d'instants négatifs avec le mot_clef
   ARCHIVAGE/LIST.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssnv128a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 016501 DU 2011-02-28 07:53:21
TYPE express concernant Code_Aster (VERSION 9.1)
TITRE
    PILOTAGE et RECH_LINEAIRE
FONCTIONNALITE
   Problème
   ========
   
   Lorsque l'utilisateur sélectionne la méthode "PILOTAGE" en RECH_LINEAIRE et qu'il oublie
   le mot-clef PILOTAGE, il est arrêté par un CALL ASSERT(.FALSE.)
   
   
   Réponse
   =======
   
   Il faut vérifier (dans le FORTRAN car impossible dans le catalogue): exfonc.f, mecanonline5_35
   
   La recherche linéaire de type PILOTAGE nécessite de faire du pilotage (présence du
   mot-clef facteur PILOTAGE).
   
   Si RECH_LINEAIRE='PILOTAGE', il faut du PILOTAGE
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    liste restreinte
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR assire       ASSIRE Aimery          DATE 03/01/2011 - 06:04:14

--------------------------------------------------------------------------------
RESTITUTION FICHE 016472 DU 2011-02-24 09:39:32
TYPE evolution concernant Code_Aster (VERSION 9.1)
TITRE
    Evolutions dans EXEC_LOGICIEL
FONCTIONNALITE
   On fait deux évolutions dans EXEC_LOGICIEL.
   
   1. Possibilité de lancer des scripts sur une machine distante.
   
   Par exemple :
   EXEC_LOGICIEL(LOGICIEL='pwd',
                 MACHINE_DISTANTE=_F(SSH_ADRESSE  = 'cli75ca',
                                     SSH_PORT     = 22,),);
                                     SSH_LOGIN    = 'assire',),);
   
   Lance la commande 'pwd' sur ma machine :)
   
   Catalogue :
   MACHINE_DISTANTE = FACT(statut='f',
   SSH_ADRESSE  = SIMP(statut='o'
   SSH_LOGIN    = SIMP(statut='f'
   SSH_PORT     = SIMP(statut='f'
   ),
   
   
   
   2. Possibilité de lancer un script Salome.
   
   Là, c'est un peu plus compliqué. On ajoute un mot-clé facteur SALOME qui prend en argument :
   - [o] un chemin vers un script python à la syntaxe Salome
   - [f] SALOME_HOST (defaut=local) et SALOME_PORT (defaut=2810) pour définir la machine sur
   laquelle tourne Salome et le port de Salome. 
   - [f] SALOME_RUNAPPLI : le chemin vers le script de lancement en mode console de script
   Salome (qui se trouve dans l'arborescence de Salome) 
   
   Ensuite, il y a une mécanique qui est mise en place afin de gérer des fichiers de données
   nécessaires au script Salome (et qui seront copiés sur la machine si elle est distante) :
   - [f] FICHIERS_ENTREE : une liste de chemin de fichiers
   
   La même chose pour les fichiers qui sont crées par le script Salome, dans le cas où l'on
   veut les récuperer sur la machine d'exécution d'Aster (par exemple on lance un script de
   génération d'un maillage et on veut récuperer le .MED) :
   - [f] FICHIERS_SORTIE : une liste de chemin de fichiers
   
   Pour traiter ces fichiers d'entrée et de sortie dans le cas d'une machine distante, il y a
   des remplacement qui sont fait dans le script Salome (puisque les chemins sur la machine
   distante ne seront plus les memes que sur la machine locales).
   
   Il y a une convention qui sera décrite dans la documentation. Le script Salome doit
   contenir des mot-clés codifiés :
   
   INPUTFILE1  = ...
   INPUTFILE2  = ...
   OUTPUTFILE1 = ...
   OUTPUTFILE2 = ..
   
   Le script ira remplacer la chaine à droit du signe = de chaque parametre par le vrai nom
   de fichier défini dans la liste FICHIERS_ENTREE.
   
   
   - [f] NOM_PARA : une liste de champs texte qui seront modifiés dans le script
   - [f] VALE : une liste de valeur pour les champs texte définis par NOM_PARA
   
   
   
   
   Example 1 : lancer un script dans un Salome "local", sans fichier de donnée ni de résultat
   EXEC_LOGICIEL(
   SALOME=_F(CHEMIN_SCRIPT = './fort.18',
   SALOME_RUNAPPLI = "/chemin-salome/runAppli ",),);
   
   
   Exemple 2 : lancer un script dans un Salome "distant", avec des fichiers de données et des
   fichiers de résultats à rappatrier :
   
   EXEC_LOGICIEL(
   SALOME=_F(CHEMIN_SCRIPT   = './fort.18',
             #UNITE_SCRIPT    = 18,  # utilisera fort.18
             SALOME_HOST     = 'cli75ca.der.edf.fr',
             SALOME_PORT     = 2811,
             FICHIERS_ENTREE = [ './fort.91', './fort.92' ],
             FICHIERS_SORTIE = [ './fort.98', './fort.99' ],
             SALOME_RUNAPPLI = '/chemin-salome/runAppli ',),);
   
   A noter que le mot-clé MACHINE_DISTANTE peut être utiliser coinjointement pour préciser le
   port SSH et le login distant s'il est différent. Cependant, si le mot-clé SSH_ADRESSE est
   différent du mot-clé SALOME_HOST (ce qui ne serait pas normal..), une alarme est émise et
   c'est SALOME_HOST qui est pris en compte.
   
   
   Le test zzzz141a montre un fonctionnement basique de ces deux fonctionnalités (sachant que
   le lancement via Salome n'a pas encore été testé..).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U7.00.01
VALIDATION
    zzzz141a
NB_JOURS_TRAV  : 10.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 016423 DU 2011-02-15 16:08:47
TYPE evolution concernant Code_Aster (VERSION 9.1)
TITRE
    Résorption Pylotage
FONCTIONNALITE
   On résorbe Pylotage et on le remplace par une nouvelle fonctionnalité de la commande
   EXEC_LOGICIEL / mot-clé SALOME (voir la fiche 16472).
   
   
   
   
   Pour Stanley, la stratégie a été completement revue.
   
   Plusieurs fichiers sont impactés :
   
   - Scripts Python/Aster dans bibpyt/Stanley :
   Il s'agit des fichiers Aster de la macro-commande Stanley.
   
   . stanley_engine.py : le fichier coeur de Stanley, legerement modifié.
   . salomeVisuPylo.py : c'est la recopie de l'ancien salomeVisu.py, qui fait appel à
   l'ancien Pylotage (on le laisse pendant la phase de mise au point)
   . salomeVisu.py : le fichier d'appel au nouveau mécanisme de Pylotage (appel à la commande
   EXEC_LOGICIEL / SALOME)
   
   
   - Scripts Python/Salome dans bibpyt/Stanley :
   Il s'agit de templates de scripts Python à la syntaxe Salome.
   
   . salomeGetStudies.py : template permettant de récupérer la liste des études Salome
   ouvertes (pour propose le choix dans Stanley)
   . Stanley/salomeScript.py : template qui permet d'ouvrir dans Salome un résultat. Le
   script gère tous les cas (DEPL, NOEUD, ELNO, GAUSS et COURBE).
   
   Ces fichiers eux sont chargeables directement dans Salome (à condition de modifier les
   quelques paramètres en entete des fichiers comme l'option et le chemin vers le fichier MED). 
   Note : Normalement, ils utilisent une syntaxe simple de Salome et devraient être
   relativement peu sensible à la version de Salome.
   
   
   - Script Python indépendant d'Aster et de Salome dans bibpyt/Stanley :
   
   . salomeRunScript.py : le fichier qui permet de générer le script Salome à partir du template.
   
   Ce fichier est chargeable directement dans Salome et fait office de test unitaire : il
   vient simuler les 6 cas d'usage (récupération des études, visualisation d'un DEPL, GAUSS,
   ELNO, NOEU et d'une COURBE), les fichiers de données étant les fichiers zzzz141.91 à 95.
   
   
   Ajout de pas mal de fichiers de données au cas-test zzzz141a :
   zzzz141a.91 (DEPL.rmed)
   zzzz141a.92 (ELGA.rmed)
   zzzz141a.93 (NOEU.rmed)
   zzzz141a.94 (ELNO.rmed)
   zzzz141a.95 (Table.txt)
   
   zzzz141a.18 (fichiers script simulant le mot-clé SALOME dans zzzz141a)
   zzzz141a.19 
   
   Attention, ce développement n'est pas encore fonctionnel car il nécessite la version de
   Salome compatible. Des corrections sont donc à prévoir dans les 15 jours.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    zzzz141a + manuelle pour Stanley
NB_JOURS_TRAV  : 15.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 016253 DU 2011-01-21 10:28:53
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    STAT_NON_LINE plante sur aster4 à la premiere iteration
FONCTIONNALITE
   Problème :
   ----------
   L'étude en trace jointe passe en STA10, sur BULL et Calibre, mais plante à la première
   itération sur Aster4.
   
   
   Résolution :
   ------------
   On peut voir ligne 69 de l'output :
   
   TERM_MEMLIMIT: job killed after reaching LSF memory usage limit.
   
   Ce qui signifie que le job a été tué par le séquenceur de travaux LSF : ça passait sur
   Bull car on ajoutait systématiquement un peu de mémoire aux jobs ce qui n'est pas encore
   fait sur Aster4.
   On répercute sur Aster-4 la configuration LSF faite sur BULL.
   
   Note : il n'y a pas de restitution de source dans Aster.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    Etude jointe
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

16404
15324
13688
15416


-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR bottoni      BOTTONI Marina         DATE 02/28/2011 - 03:14:54

--------------------------------------------------------------------------------
RESTITUTION FICHE 016327 DU 2011-01-31 14:45:17
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Changement de version Ecrevisse
FONCTIONNALITE
   Pour pouvoir utiliser Écrevisse v3.2, il faut ajouter une ligne dans la mise en données
   d'écrevisse coté Aster (fichier "data.dat")
   
   J'ai fait des tests avec l'exécutable Ecrevisse non couplé avec Aster, toutes les versions
   disponibles :
   3.1.1, 3.1.2 et la nouvelle 3.2. Effectivement, sans la modification du fichier "data.dat"
   la version 3.2 ne marche pas.
   Par contre, avec la ligne supplémentaire, toutes les versions marchent correctement.
   
   Couplage Code-Aster : j'ai donc modifié l'écriture du fichier "data.dat" dans la macro
   "macr_ecre_calc_ops.py" (pour rappel : MACR_ECREVISSE appelle la macro CALC_ECREVISSE qui
   elle appelle la macro MACR_ECRE_CALC). 
   
   Je restitue les cas-tests zzzz218a,b,c, déjà présents, en modifient la version d'écrevisse
   : 3.1.2 --> 3.2.  
   
   Dans le fichier .comm, la version peut être renseignée via le mot-clé VERSION ou le
   mot-clé LOGICIEL de MACR_ECREVISSE (et pareil dans CALC_ECREVISSE et MACR_ECRE_CALC).
   Avec LOGICIEL, on renseigne le chemin de l'exécutable en dur. C'est ce que j'ai fait pour
   l'instant pour les cas-tests : Aimery s'occupera de modifier le script écrevisse dans
   /aster/outils qui renvoie à la version.
   
   J'ai modifié aussi les trois catalogues pour ajouter l'option de version 3.2
   (macr_ecre_calc.capy, calc_ecrevisse.capy et macr_ecrevisse.capy) sous le mot-clé VERSION.
   On trouvera la ligne :
   VERSION = SIMP(statut='f',typ='TXM',into = ("3.1.1","3.1.2","3.2")),
   à la place de :
   VERSION = SIMP(statut='f',typ='TXM',defaut="3.1.2",into = ("3.1.1","3.1.2") ),
   
   J'ai dû enlever la version par défaut parce que cela faisait conflit avec la règle :
   UN_PARMI('LOGICIEL','VERSION')
   Dès qu'on utilisait LOGICIEL (sans VERSION) on avait l'erreur : 
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         ! Règle(s) non respectée(s) : - Il ne faut qu un mot cle parmi : ('LOGICIEL', !
         ! 'VERSION')                                                                  !
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U7.03.41
VALIDATION
    cas-test existants
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR boyere       BOYERE Emmanuel        DATE 03/01/2011 - 03:11:54

--------------------------------------------------------------------------------
RESTITUTION FICHE 016498 DU 2011-02-25 16:10:02
TYPE express concernant Code_Aster (VERSION 9.1)
TITRE
    petite coquille sans consequence dans la routine lonseg
FONCTIONNALITE
   Mon vieux compilateur a repéré une petite coquille dans la routine LONSEG, introduite la
   semaine dernière.
   
   
   Dans une étape de cette routine, on veut vérifier que la norme des composantes
   perpendiculaire au plan local formé par 3 noeuds est bien quasi-nulle.
   
   Pour cela on avait écrit :
   CALL NORMEV(TMP,NORM)
   CALL ASSERT(TMP.LE.R8MIEM())
   où TMP, de dimension 3, est le vecteur rassemblant les composantes perpendiculaires
   locales des 3 noeuds et où NORMEV donne la norme du vecteur créé par ces composantes.
   
   Il me semble qu'il va de soi qu'on voulait écrire :
   CALL NORMEV(TMP,NORM)
   CALL ASSERT(NORM.LE.R8MIEM())
   
   Je corrige en passant.
   A priori il n'y pas de conséquence possible, si ce n'est de faire râler un vieux
   compilateur bougon.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sans
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR corus        CORUS Mathieu          DATE 03/01/2011 - 03:33:42

--------------------------------------------------------------------------------
RESTITUTION FICHE 016463 DU 2011-02-22 16:28:32
TYPE express concernant Code_Aster (VERSION 10.3)
TITRE
    probleme avec DEFI_MODELE_GENE / group_ma_mait_2
FONCTIONNALITE
   Probleme :
   ----------
   
   En testant une nouvelle methode pour la modification structurale, Charles a trouve un bug
   dans DEFI_MODELE GENE. En effet, quand on est dans une approche par modes d'interfaces,
   avec l'option 'reduit', si le groupe de maille maitre appartient a la deuxieme sous
   structure, ce qui induit des plantages sales. En consequence, le risque de resultat faux
   existe mais est tres limite. Si on inverse les deux matrices de liaison, comme c'etait le
   cas, on se retrouve a lire des valeurs non initialisees, et on assemble des matrices de
   macro elements avec des valeurs "fantomes". La possibilite que ca donne un resultat est
   faible, mais existe. Les differents tests ont tous introduit un NAN dans un vecteur, d'ou
   plantage sale dans MODE_ITER_SIMULT.
   
   Solution:
   ---------
   
   Il s'agit d'un copier coller malheureux et hatif dans la routine callis.f. Il y a deux
   appels a liared a inverser si la sous structure maitresse est la sous structure 2 pour que
   tout rentre dans l'ordre.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 10.2
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    Aucune
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 016464 DU 2011-02-22 16:35:04
TYPE express concernant Code_Aster (VERSION 10.3)
TITRE
    probleme avec NUME_DDL_GENE / methode='ELIMINE'
FONCTIONNALITE
   Probleme :
   ----------
   
   En testant les modifications induites par la fiche 16463, je me suis apercu qu'il restait
   une coquille dans la routine asgeel.f (et non nugeel.f comme indique initialement). La
   liste de correspondance entre les noms de sous structures et de macro elements n'etait pas
   remplie correctement, et il y avait un risque d'ecrasement des noms de cette liste,
   induisant des plantages sales, voir des resultats faux. Le probleme est tres similaire a
   celui traite par la fiche 16427 (confusion entre les deux listes de macros elements
   generes dans defi_modele_gene)
   
   Solution :
   ----------
   
   J'ai supprime la ligne en trop dans asgeel.f. Probablement encore un copier coller un peu
   hatif.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 10.2
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    Aucune
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 014651 DU 2010-02-17 13:51:18
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    format PLEXUS dans IMPR_MACR_ELEM
FONCTIONNALITE
   Problème :
   ----------
   
   Cette fiche a comme objectif d'éclaircir et de valider l'utilité actuelle de l'option
   FORMAT='PLEXUS' de la commande IMPR_MACR_ELEM. Je la dépose dans le REX suite à une
   discussion avec Serguei qui s'est vu investi (sans le savoir pendant plus de 8 ans) de la
   responsabilité du cas-test sdls110, le seul qui teste cette option. 
   
   En regardant en peu la doc de la commande IMPR_MACR_ELEM on s'aperçoit que en mettant
   FORMAT='PLEXUS' on fait "Impression de la base modale de type ‘DIAG_MASS’ au format IDEAS
   versions 5". Or, la même option peut être renseignée FORMAT='IDEAS' qui fait: "Permet de
   spécifier le format d’impression. Le format ‘IDEAS’ est pris par défaut. Actuellement
   seule l’impression s’effectue suivant les spécifications de la version 5."
   
   J'ai testé les deux valeurs de l'option FORMAT et il s'avère qu'on ne obtient pas la même
   chose contrairement à ce qu'on pouvait penser après la lecture de la doc (j'ai cru à un
   doublon). On imprime un peu plus de choses avec PLEXUS par rapport à IDEAS
   
   La question qui se pose maintenant c'est: faut il maintenir FORMAT='PLEXUS' (même Serguei
   n'était pas au courant que ça existe) ou faut-il fusionner avec  FORMAT='IDEAS' (pour
   imprimer toutes les données de la sd_macr_elem_dyna quelque soit la nature de la base
   modale contenue)
   
   En tout cas il faudra produire une doc pour sdls110, une page de garde suffira à mon avis.
   
   Analyse :
   ---------
   
   Après discussion avec Serguei, on peut résorber l'option "PLEXUS". Ça n'était utilise que
   dans le cadre d'une thèse, et les développements n'ont pas été poursuivis. L'utilisation
   de macros éléments dans EUROPLEXUS n'est pas judicieuse, et ça n'est plus faisable. Il n'y
   a donc pas d'intérêt à garder ce mot clé. Il semble que personne n'utilise cette
   fonctionnalité. Pour ce qui est de la fusion des deux mots clés (IDEAS et PLEUXUS), ça ne
   me semble pas présenter de grand intérêt.
   
   On s'est posé la question de IMPR_MACR_ELEM au format CADYRO. Après instruction, il
   ressort que cette option ne peut plus avoir d'avenir car :
   - les fonctionnalités CADYRO sont (presque) transférées dans Code_Aster.
   - on ne fera plus d'étude "rotor" avec Cadyro, mais avec Code_Aster. 
   Donc la seule passerelle dont on a toujours besoins concerne la mise en données (le
   traducteur pour assurer le transfert des modèles patrimoniales des machines tournantes
   existantes dans Cadyro vers Aster) et non pas les résultats. Cette fonctionnalité n'est
   testée que dans le test "ZZZZ108 - Test de l'interface Aster-MISS3D". Il se trouve qu'il
   faisait aussi, en catimini en fin de fichier de commandes, et sans aucun TEST_*** associé,
   la vérification de IMPR_MACR_ELEM au format CADYRO. La doc V1.01.108 ne mentionne CADYRO à
   aucun moment d'ailleurs. 
   
   Solution :
   ----------
   
   Je propose la résorption des formats CADYRO et PLEXUS. Je propose en même temps de
   supprimer le cas test sdls110, qui ne sert qu'a tester l'impression au format PLEXUS.
   L'impression au format IDEAS est testée par ailleurs (sdls102), ainsi que celle au format
   MISS_3D (y en plein...)
   
   Ça fait :
   - résorber les routines suivante :
       iredpl.f
       iredca.f
       squseg.f
       squlis.f
       sdls110a.*
   
   - modifier :
       op0160.f
       impr_macr_elem.capy
       zzzz108a.comm
   
   Ça évite d'avoir à faire une doc sur un cas test qui ne servira plus à rien, puisque la
   construction de macro éléments dynamique est largement testée et documentée par ailleurs
   (plus de 20 cas tests).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    zzzz108a
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 016427 DU 2011-02-16 11:53:53
TYPE anomalie concernant Code_Aster (VERSION 10.3)
TITRE
    probleme avec REST_SOUS_STRUC / mot cle "SOUS_STRUC", et "SQUELETTE" si le squelette est partiel.
FONCTIONNALITE
   Probleme :
   ----------
   
   Je me suis rendu compte hier d'une petite boulette dans regeec et regegl, quand ne ne
   restitue que sur une sous structure, ou un squelette ne contenant pas tous les macros
   elements. Une petite confusion entre deux noms de listes, vite reparee.
   
   Solution :
   ----------
   
   Pour les besoins de la methode "ELIMINE", on construit une liste des macros elements qui
   reprend l'ordre de definition des liaison. Par ailleurs, DEFI_MODELE_GENE construit
   egalement une liste des macros elements, dans l'ordre de déclaration de ces macros
   elements. Ces deux listes ne coincident pas necessairement, et il y avait une inversion
   entre ces deux listes dans le code. On cherchait des objets associe a un certain macro
   element dans un autre, qu'on ne trouvaient donc pas. On obtenait une erreu JEVEUX, mais
   pas de risque de resultat faux.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    Aucune
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 03/01/2011 - 06:16:51

--------------------------------------------------------------------------------
RESTITUTION FICHE 013928 DU 2009-09-24 07:47:44
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Refonte de l'interface entre Miss3D et Code_Aster
FONCTIONNALITE
   Dans la première étape de la refonte du chaînage Code_Aster-Miss3D 
   (disponible en 10.2), CALC_MISS remplace MACRO_MISS_3D pour 
   l'appel à Miss3D pour le calcul des impédances et forces 
   sismiques.
   
   Dans cette deuxième étape, on ajoute à CALC_MISS les 
   fonctionnalités de post-traitement qui étaient auparavant faites 
   soit dans Miss3D lui-même, soit dans les programmes interface 
   ptaster/gtaster. Cela permet de couvrir la quasi-totalité des 
   études d'ISS, et au moins celles pour lesquelles l'AQ est 
   indispensable.
   Les fonctionnalités manquantes sont les points de contrôle et les 
   ondes inclinées. Pour celles-ci, le recours à MACRO_MISS_3D (hors 
   AQ en version 11) sera possible en attendant leur intégration dans 
   CALC_MISS.
   
   Cette nouvelle version de CALC_MISS (macro-commande) réalise 
   différentes tâches  et produit différents types de concepts selon 
   ces arguments (cf. RTA du 10/02/2011).
   
   * Cas 1 - calcul Miss3D seul : TYPE_RESU = 'FICHIER'
       - seuls les fichiers sont produits (impédances et forces 
   sismiques),
       - pas de concept en sortie de CALC_MISS,
       - utilisé à titre d'exemple dans miss01a.
   
   CALC_MISS(
   . . TYPE_RESU = 'FICHIER',
   . . TABLE_SOL = tabsol,
   . . BASE_MODALE = BASMO,
   . . MATR_RIGI = MATRIGI,
   . . MATR_MASS = MATMASS,
   . . AMOR_REDUIT = l_amor,
   . . GROUP_MA_INTERF = 'SRADIER',
   
   . . PARAMETRE=_F(
   . . . . FREQ_MIN = dfc,
   . . . . FREQ_MAX = fmaxc,
   . . . . FREQ_PAS = dfc,
   . . . . TYPE = 'BINAIRE',
   . . . . Z0 = -11.60,
   . . . . SURF = 'OUI',
   . . . . ALGO = 'DEPL',
   . . . . OFFSET_MAX = 110,
   . . . . OFFSET_NB = 400,
   . . . . SPEC_MAX = 0.12,
   . . . . SPEC_NB = 16384,
   . . ),
   )
   
   * Cas 2 - post-traitement seul : TYPE_RESU != 'FICHIER' + 
   UNITE_RESU_IMPE/UNITE_RESU_FORC fournis.
       - les fichiers associés aux impédances (UNITE_RESU_IMPE) et 
   forces sismiques (UNITE_RESU_FORC) doivent exister,
       - le concept en sortie est soit une TABLE, un TRAN_GENE ou un 
   HARM_GENE.
       - utilisé à titre d'exemple dans miss01a.
   
   resgen = CALC_MISS(
   . . TYPE_RESU = 'TRAN_GENE',
   . . TABLE_SOL = tabsol,
   . . BASE_MODALE = BASMO,
   . . MATR_RIGI = MATRIGI,
   . . MATR_MASS = MATMASS,
   . . AMOR_REDUIT = l_amor,
   . . GROUP_MA_INTERF = 'SRADIER',
   
   . . PARAMETRE=_F(
   . . . . FREQ_MIN=0.,
   . . . . FREQ_MAX=fmax,
   . . . . FREQ_PAS=df,
   . . . . TYPE='BINAIRE',
   . . . . Z0= -11.60,
   . . . . SURF='OUI',
   . . . . ALGO = 'DEPL',
   . . . . OFFSET_MAX=110,
   . . . . OFFSET_NB=400,
   . . . . SPEC_MAX=0.12,
   . . . . SPEC_NB=16384,
   . . ),
   . . UNITE_RESU_IMPE=38,
   . . UNITE_RESU_FORC=28,
   
   . . MODELE. . . .  = MODELE,
   . . ACCE_X. . . .  = ACCE_X,
   . . ACCE_Y. . . .  = ACCE_Y,
   . . ACCE_Z. . . .  = ACCE_Z,
   )
   
   
   * Cas 3 - calcul Miss3D et post-traitement dans Code_Aster : 
   TYPE_RESU != 'FICHIER'
       - les unités logiques sont générées automatiquement (il est 
   possible de fixer le répertoire de travail de Miss3D pour debug si 
   besoin),
       - manque un jeu de mots-clés pour post-traiter sur une plage 
   de fréquence différente de celle du calcul Miss3D,
       - devrait devenir le mode d'utilisation privilégié 
   (simplification, évite la redondance sur certains mots-clés).
   
   
   Il y a deux types de post-traitement :
   
   - post-traitement de type 1 (TYPE_RESU='HARM_GENE'/'TRAN_GENE') : 
   on produit l'harm_gene (sortie de DYNA_LINE_HARM) ou un tran_gene 
   (sortie du REST_SPEC_TEMP). Avec au choix, des accélérogrammes en 
   entrée (par exemple dans miss01a) ou des vect_asse (dans miss09a).
   
   - post-traitement de type 2 (TYPE_RESU='TABLE') : on produit une 
   table contenant les fonctions résultat en ACCE, VITE et DEPL. On 
   récupère ces fonctions par EXTR_TABLE.
   
   
   
   Compléments
   -----------
   
   - on peut calculer le macr_elem_dyna en amont de CALC_MISS et lui 
   fournir (mot-clé MACR_ELEM_DYNA) sinon il est calculer à partir de 
   BASE_MODALE, MATR_RIGI, MATR_MASS.
   
   - on remplace partout où c'est possible MACRO_MISS_3D (qui restera 
   testé sur les tests "hors AQ") par CALC_MISS. A priori, restent 
   avec MACRO_MISS_3D : fdlv112, fdlv113, zzzz108 et zzzz200.
   
   - on érifie les valeurs de AMOR_REDUIT (utilisé dans 
   DYNA_LINE_HARM) : len <= nb_modes_dyn. On complète jusqu'à 
   nb_modes_dyn avec la dernière valeur, puis un 0. pour les modes 
   statiques.
   
   - on blinde MACRO_MISS_3D (interdire MISS_IMPE seul) pour inciter 
   à passer à CALC_MISS.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : u7.03.12
VALIDATION
    tous les tests miss
NB_JOURS_TRAV  : 10.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 016403 DU 2011-02-11 11:45:53
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    EXTR_TABLE : pouvoir extraire des fonctions stockxc3xa9es dans une table
FONCTIONNALITE
   Dans le cadre du post-traitement des calculs Miss, on produit une 
   table qui contient des noms de fonctions.
   
   L'extraction d'une composante, d'un champ, d'un cas de calcul en 
   un point donné conduit à 3 fonctions (dans les 3 directions).
   
   Si on utilise une table_fonction, on aura donc trois lignes à 
   chaque fois et il faut ajouter un paramètre 'NOM_CMP'.
   
   Dans une table_container, les champs TYPE_OBJET, NOM_OBJET, NOM_SD 
   ne sont pas très adaptés : TYPE_OBJET serait toujours FONCTION, 
   NOM_OBJET n'est pas suffisant...
   
   Le post-traitement de miss03a, par exemple, conduit à :
    3 (chargements) * 3 (directions) 
    * [ ( 1 accéléro + 1 fft )
        + 3 champs * 3 paramètres * 2 group_no ]
    = 180 fonctions
   
   On propose donc de stocker ces fonctions dans une table 
   "ordinaire" avec 3 colonnes FONC_X, FONC_Y, FONC_Z.
   On a donc 60 lignes au lieu de 180.
   Et le n-uplets (numero_calcul, group_no, nom_champ, nom_para) est 
   la clé primaire pour accéder aux fonctions.
   
   
   Pour cela, il est nécessaire d'étendre EXTR_TABLE aux objets de 
   type FONCTION pour récupérer les concepts.
   L'extraction est faite par COPISD, il y a donc quasiment rien à 
   faire.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : u4.71.05
VALIDATION
    missXXX
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR greffet      GREFFET Nicolas        DATE 03/01/2011 - 06:16:51

--------------------------------------------------------------------------------
RESTITUTION FICHE 016454 DU 2011-02-21 15:18:51
TYPE express concernant Code_Aster (VERSION 9.1)
TITRE
    CALC_MISS : bascule des tests miss, suite...
FONCTIONNALITE
   Le but de cette fiche est de faire basculer le plus possible de tests miss vers 
   CALC_MISS, en lieu et place de MACRO_MISS_3D.
   
   C'est donc la suite de la fiche 16444.
   
   Plus précisément, on va utiliser CALC_MISS dans tous les tests miss qui se servent de 
   l'option : MODULE='MISS_IMPE', qui est actuellement le seul mode de fonctionnement de 
   CALC_MISS. Cette fiche se place dont en amont des évolutions de CALC_MISS pour les post-
   traitements (traitées par Mathieu).
   Il s'agit donc de faire deux choses :
   - remplacer MACRO_MISS_3D par CALC_MISS pour les calculs d'impédances et de forces 
   sismiques,
   - utiliser DEFI_SOL_MISS pour définir les caractéristiques de sols dans le .comm au lieu 
   d'un fichier externe.
   
   Je modifie aussi la valeur par défaut de de l'unité logique pour UNITE_RESU_FORC qui 
   valait 0... ce qui fait planter la macro. Je mets une valeur correcte non utilisée et 
   cohérente ave l'unité logique de l'impédance : 30.
   On modifie donc une ligne dans calc_miss.capy :
     UNITE_RESU_FORC  = SIMP(statut='f',typ='I',defaut=33),
   
   
   Impact fichiers :
   miss06a.comm
   miss06b.comm
   miss06c.comm
   miss07a.comm
   miss08a.comm
   miss09a.comm
   Fichiers supprimés car devenus inutiles (fichiers de sol et d'options pour 
   MACRO_MISS_3D) :
   miss06a.21
   miss06a.22
   miss06b.21
   miss06b.22
   miss06c.21
   miss06c.22
   miss07a.22
   miss08a.22
   miss09a.22
   
   calc_miss.capy
   
   
   Perspectives :
   basculer les cas-tests miss02a, miss03a, miss04a et miss07b qui utilisent l'option 
   TOUT='OUI' qui 
   n'existe pas directement dans CALC_MISS, mais que les évolutions de Mathieu vont 
   permettre de reproduire.
   Ne resteront donc plus avec MACRO_MISS_3D que les tests suivants :
   fdlv112a, fdlv113a, zzzz108a et zzzz108b qui font tous appels à des options qui ne seront 
   pas disponibles à très court terme dans CALC_MISS (comme l'ISFS, les points de contrôle, 
   les ondes inclinées et les sources ponctuelles).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V1.10.125, V1.10.126, V1.10.127, V1.10.128
VALIDATION
    miss06a, miss06b, miss06c, miss07a, miss08a, miss09a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR delmas       DELMAS Josselin        DATE 02/28/2011 - 05:24:28

--------------------------------------------------------------------------------
RESTITUTION FICHE 016483 DU 2011-02-25 08:55:38
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.3.14, le cas-test forma05b s'arrete en erreur fatale sur Aster4 et Calibre 5.
FONCTIONNALITE
   Problème :
   ==========
   En NEW10.3.14, le cas-test forma05b s'arrete en erreur fatale sur Aster4 et Calibre 5.
   
   Correction :
   ============
   Le problème est liée au chantier ARCHIVAGE et vient de MACR_ADAP_MAIL qui a maintenant
   besoin qu'on lui donne le NUME_ORDRE pour le champ qui pilote l'adaptation.
   
   On indique donc NUME_ORDRE dans MACR_ADAP_MAIL. Il faut faire de même dans POST_ELEM qui
   calcul une grandeur pour un test de non-régression.
   
   Impact :
   ========
   forma05b.comm
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    passage du test
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR durand       DURAND Christophe      DATE 03/01/2011 - 09:18:23

--------------------------------------------------------------------------------
RESTITUTION FICHE 016200 DU 2011-01-14 08:16:39
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    MACR_LIGN_COUPE mot-clxc3xa9 VECT_Y
FONCTIONNALITE
   Dans le catalogue de MACR_lIGN_COUPE, le mot clé VECT_Y doit être facultatif et non
   obligatoire, comme il l'est dans le POST_RELEVE_T sous-jacent à la macro. Pas d'impact sur
   la doc qui est correcte.
   
   Report à faire en version 9.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    xc3xa9tude jointe + cas tests
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR geniaut      GENIAUT Samuel         DATE 03/01/2011 - 09:28:23

--------------------------------------------------------------------------------
RESTITUTION FICHE 016388 DU 2011-02-09 16:31:35
TYPE anomalie concernant Documentation (VERSION *)
TITRE
    SSLP101: V3.02.101 - Modelisation E manquante
FONCTIONNALITE
   Document V3.02.101 publié ce jour avec l'ajout demandé. La présente fiche peut être fermée
   (via asrest/EDA).
   
   Merci Samuel.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V3.02.101
VALIDATION
    aucun
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 016487 DU 2011-02-25 09:26:30
TYPE express concernant Code_Aster (VERSION 10.4)
TITRE
    X-FEM : petits menages
FONCTIONNALITE
   1) le routine xenrch.f est trop longue (500 lignes).
   on fait la création des tables du fond dans une nouvelle routine : xtabff.f
   
   2) suppression du défaut dans DEFI_GROUP / TYPE_GROUP (obligatoire) si OPTION='FISS_XFEM'
   
   3) dans ssnv192a, on récupère le nombre de fonds de fissure pour faire la boucle sur les
   fonds (CALC_G)
   -> PAR_LOT='NON'
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.22.01, V6.04.192
VALIDATION
    tests x-fem et ssnv192a
NB_JOURS_TRAV  : 0.4
--------------------------------------------------------------------------------
RESTITUTION FICHE 016409 DU 2011-02-14 12:32:25
TYPE anomalie concernant Code_Aster (VERSION 10.4)
TITRE
    CALC_G - Probleme avec ARCH_ETAT_INIT
FONCTIONNALITE
   Problème :
   ----------
   
   Il semblerait que CALC_G ne prennent pas bien en compte les résultats qui ont un numéro
   d'ordre nul (qui correspond à l'état initial).
   En effet, dans OP0100, on récupère la longueur du résultat EVOL_NOLI. S'il y a les numéros
   d'ordre 0,1,2,3, la variable LONVEC va valoir 4.
   Ensuite, il fait une boucle de 1 à LONVEC. Donc, boum, le NUME_ORDRE 4 n'existe pas.
   Il ne doit pas y avoir bcp de calculs de G avec SNL (qui génère des numéros d'ordre nuls).
   
   
   Solution :
   ----------
   
   Je propose de clore cette fiche, sauf contre-ordre, car je ne vois pas d'anomalie dans le
   comportement de CALC_G, tous les numéros d'ordre sont bien calculés, sans débordement
   mémoire apparent.
   
   par ex si on fait un SNL avec 1 pas de temps, on archive :
   nume_ordre 0 : inst 0s
   nume_ordre 1 : inst 1s
   
   tout se passe bien dans op0100 :
   lonvec = 2  
    DO 33 I = 1,LONVEC  (boucle Ide 1 à 2)
      IORD = ZI(IVEC-1+I) -> renvoit 0 puis 1
      TIME  = ZR(JINST) -> renvoit 0s, puis 1s
   
   On fait donc le calcul de G pour les instants 0s et 1s, comme en 
   témoigne par ex la table de ssnv185a :
   
   NUME_ORDRE   INST         NUM_PT         G            
        0     0.00000E+00         1    0.00000E+00 
        0     0.00000E+00         2   -0.00000E+00 
        0     0.00000E+00         3    0.00000E+00 
        0     0.00000E+00         4    0.00000E+00 
        0     0.00000E+00         5    0.00000E+00 
        0     0.00000E+00         6    0.00000E+00 
        1     1.00000E+00         1    5.50603E+02 
        1     1.00000E+00         2    5.50603E+02 
        1     1.00000E+00         3    5.50603E+02 
        1     1.00000E+00         4    5.50603E+02 
        1     1.00000E+00         5    5.50603E+02 
        1     1.00000E+00         6    5.50603E+02 
   
   le calcul de G à l'instant 0s ne sert à pas à grand chose ici.
   
   
   
   De plus, tous les tests qui font du SNL avec CALC_G sont :
   
   - dans la grande majorité : des tests X-FEM élastiques linéaires, qui seront basculés sous
   MECA_STATIQUE une fois la fiche 13329 réalisée, donc plus de pb de filtre sur les n° d'ordres
   
   - quelques tests élastiques non-linéaires, légitimement résolus avec SNL. Ils ne seront
   pas modifiés. CALC_G calculera donc par défaut le G à tous les instant archivés, donc
   aussi à l'instant initial.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    aucun
NB_JOURS_TRAV  : 0.3
--------------------------------------------------------------------------------
RESTITUTION FICHE 016434 DU 2011-02-17 09:00:13
TYPE anomalie concernant Code_Aster (VERSION 10.4)
TITRE
    En NEW10.3.13, le cas-test ssnp138b est NOOK sur Aster4, Rocks et Calibre5.
FONCTIONNALITE
   Problème :
   ----------
   
   En NEW10.3.13, le cas-test ssnp138b est NOOK sur toutes les plates-formes.
   Le cas-test est un test X-FEM avec chargements volumiques.
   Le test en question porte sur la valeur du taux de restitution d'énergie (commande CALC_G, 
   option CALC_G).
   
   
   
   Solution :
   ----------
   
   La fiche 16288 (RUPT : CALC_G et G negatif) a corrigé un bug portant sur la non prise en 
   compte des chargements volumiques par l'option CALC_G de CALC_G pour les fissures X-FEM.
   Lors de la restitution de cette fiche, on a cru que le seul test qui valide les charges 
   volumiques pour X-FEM est le ssnv185p, qui ne teste actuellement que l'option CALC_K_G. 
   On a alors rajouté un test sur l'option CALC_G.
   
   Mais le test ssnp138b teste justement le calcul de G pour les charges volumiques avec 
   l'option CALC_G !
   Mais ce test est bien évidemment "faux".
   Dans le ssnp138b, le G obtenu par CALC_G, option CALC_K_G vaut 1.19751E-04 pour la fissure 
   inclinée à 0° et 5.64356E-05 pour la fissure à 45°.
   Or on prenait comme valeur de réf 1.1488233E-04 (ang=0°) et 5.186283E-05 (ang=45°) pour 
   tester le G de CALC_G, option CALC_G !
   Désormais, on retrouve bien pareil entre option CALC_G et option CALC_K_G.
   
   impact : ssnp138b.comm
   modif de la valeur de réf pour les tests sur CALC_G, option CALC_G.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V6.03.138
VALIDATION
    ssnp138b
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 016432 DU 2011-02-16 16:34:48
TYPE anomalie concernant Documentation (VERSION *)
TITRE
    SSLV110: V3.04.110 - modelisation E manquante
FONCTIONNALITE
   L'introduction de la doc V dit :
   "Ce test contient 6 modélisations différentes ; la modélisation E, de validation
   informatique, n’est pas documentée."
   
   Or sslv110e n'a, à sa lecture, rien de très spécifiquement informatique. Il a été
   introduit en version 3.3.24 (1995 !) avec le texte d'histor suivant :
   "Ajout de la modelisation SSLV110E : Calcul de G 3D avec pression sur les levres de la
   fissure."
   
   
   On reporte tous les tests dans la doc.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V3.04.110
VALIDATION
    aucun
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 016468 DU 2011-02-24 07:41:15
TYPE express concernant Code_Aster (VERSION 10.4)
TITRE
    ssnv166 : changement de ref pour certains tests
FONCTIONNALITE
   Suite à la restitution de la fiche 14541, certains test des cas-test ssnv166a et b ont été
   modifiés par erreur.
   
   On corrige
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V6.04.166
VALIDATION
    ssnv166a et b
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 016455 DU 2011-02-21 17:07:30
TYPE anomalie concernant Documentation (VERSION *)
TITRE
    X-FEM: doc U4.82.08 DEFI_FISS_XFEM incomplxc3xa8te
FONCTIONNALITE
   Problème :
   ----------
   
   Les modifications de la doc U2.82.08  suite à la restitution de la fiche 13199 ont été
   perdues (?).
   
   
   Solution :
   ----------
   
   On re-met à jour cette doc (nouveaux mot-clés CHAM_NO_LSN...)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : U2.82.08
VALIDATION
    attente de relecture
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 016288 DU 2011-01-26 10:12:31
TYPE anomalie concernant Code_Aster (VERSION 10.4)
TITRE
    RUPT : CALC_G et G negatif
FONCTIONNALITE
   Problème :
   ----------
   
   sur l'étude la fiche 16230, on trouve un G totalement faux (négatif...)
   
   commande CALC_G, option CALC_G, fissure X-FEM
   en prenant l'option CALC_K_G, le G devient OK...
   
   
   Solution :
   ----------
   
   Après analyse, le problème vient de la non prise en compte des chargements volumiques par
   l'option CALC_G de CALC_G
   (te0288). Lors de la restitution sur les charges volumiques pour X-FEM (en 9.3.16), le
   calcul de G a été traité que pour l'option CALC_K_G.
   La correction consiste à calculer dans le te0288 les forces nodales correspondant aux
   charges volumiques (nouvelle routine xcgvfo, dorénavant aussi appelée par le te0297), puis
   par l'ajout du terme volumique popur G (xgelem).
   
   On ajoute aussi aux catalogues des éléments X-FEM 3D les paramètres relatifs aux charges
   volumiques (ces paramètres existaient déjà pour les éléments 2D) pour l'option CALC_G et
   CALC_G_F.
   
   De plus, la correction de ce bug a permis de mettre en évidence un autre bug, dans
   l'affichage des quantités élémentaires en INFO=2 pour l'option CALC_K_G en 3D pour lissage
   LEGENDRE-LEGENDRE.
   Normalement, ces quantités élémentaires ne servent à pas grand chose.
   
   impact : 
   te0288.f te0297.f xcgfvo.f  xgelem.f (et gkmet1.f pour le bug d'affichage)
   gener_me_xh.cata   gener_me_xhh.cata  gener_me_xhtc.cata  gener_me_xtc.cata
   gener_me_xhc.cata  gener_me_xht.cata  gener_me_xt.cata
   
   
   Validation :
   le seul test qui valide les charges volumiques pour X-FEM est le ssnv185p, qui ne teste
   actuellement que l'option CALC_K_G. 
   On rajoute un test sur l'option CALC_G.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 9.3.16
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 9.3.16
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V6.04.185
VALIDATION
    etude + ssnv185p
DEJA RESTITUE DANS : 10.3.13
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR greffet      GREFFET Nicolas        DATE 02/28/2011 - 06:12:10

--------------------------------------------------------------------------------
RESTITUTION FICHE 015326 DU 2010-07-12 15:09:19
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Evolution du cas-test SDNL113 TUYAUTERIE EN FORME DE LYRE (ELSA)
FONCTIONNALITE
   Objectif
   Rendre ce cas-test plus pertinent : apparition de la plasticité et signal 
   d'entrée (accéléro) réaliste.
   
   
   Contexte
   Le cas-test sdnl113a est inspiré du cas-test elsa01. Il s'agit donc d'une 
   tuyauterie sous séisme en non-linéaire matériau. Or, on ne fait que trois 
   pas de temps (le signal de l'accéléro ne comporte que trois instants : on a 
   tronqué le vrai accéléro) et il n'y a pas de plastification. bref on ne 
   teste pas grand chose ici.
   
   
   Evolution proposée
   On reprend le signal de l'accéléro complet dans le fichier sdnl113a.22 (en 
   fait c'est le même accéléro que pour elsa01). On va mener le transitoire 
   plus loin pour voir apparaître de la palsticité, tout en essayant de 
   minimiser le temps CPU.
   Pour cela, on va baisser la limite élastique (facteur 2) ce qui permet de 
   plastifier très tôt dans le temps. Toutes les autres caractéristiques 
   restent elles inchangées et réaliste.
   On arrive donc à plastifier pour t = 0,16 s. On arrête le calcul à t = 0,17 
   s et on optimise la taille du pas de temps pour arriver à un temps CPU total 
   de 110 s sur Calibre 5 et 59 s sur aster4.
   
   Au niveau des valeurs testées, on conserve les tests existants (en régime 
   élsatique à t = 0,01 s) et on rajoute deux tests de non-régression 
   (FORC_NODA et plasticité cumulée) à t = 0,17 s, donc avec présence de 
   plasticité.
   
   Si on veut avoir le calcul complet réaliste il suffit de redéfinir la liste 
   d'instants de calcul et de remettre la valeur physique de SY (facteur 2).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V5.02.113
VALIDATION
    sdnl113a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR michel       MICHEL-PONNELLE Sylvie   DATE 02/28/2011 - 06:18:55

--------------------------------------------------------------------------------
RESTITUTION FICHE 015622 DU 2010-09-28 10:57:40
TYPE evolution concernant Code_Aster (VERSION 7.0)
TMA : Necs
TITRE
    couverture de code : routine projkn.f (DEFI_CABLE_BP)
FONCTIONNALITE
   La projection d'un nœud de câbles sur le maillage béton est d'abord tentée sur les mailles
   de béton. Si la géométrie du béton n'est pas plane (par exemple un cylindre), la
   projection sur les mailles peut échouer et la projection est alors tentée sur les bords
   des mailles de béton. En cas d'une double courbure (par exemple une coupole), la
   projection sur les bords des mailles peut également échouer et la projection est alors
   effectuée sur le nœud de béton le plus proche par la routine PROJKN.
   
   Le cas-test de validation de DEFI_CABLE_BP (zzzz111a), du fait de sa géométrie (voile
   semi-cylindrique), n'utilise pas la routine PROJKN.
   
   Les modifications suivantes sont apportées:
   
   1) Le cas-test zzzz111b est ajouté pour couvrir la routine PROJKN.
   
   Le modèle utilisé est composé de quatre mailles QUAD4 de béton en forme de « coupole » et
   de deux mailles SEG2 pour le câble. Le point milieu du câble est situé dans la zone où les
   projections sur les mailles et les bords des mailles de béton échouent pour que la routine
   PROJKN soit appelée.
   
   Dans l'état actuel des choses, on ne peut pas tester la couverture de la routine PROJKN
   dans le cadre d'un cas-test. On ne teste donc que l'indice de projection, pas que
   laprojection a été effectuée par routine PROJKN.
   
   Le fichier de commande est basé sur celui du cas test zzzz111a et adapté aux maillage et
   tests décrits ci-dessus.
   
   2) Des commentaires ont été ajoutés dans projca.f pour expliquer dans quel cas on appelle
   dans la routine projkn.
   
   3) La doc v1.01.111, "ZZZZ111 - Validation de l’opérateur DEFI_CABLE_BP" a été mise à jour.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : v1.01.111
VALIDATION
    nouvelle modxc3xa9lisation
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR voldoire     VOLDOIRE François     DATE 02/28/2011 - 06:18:56

--------------------------------------------------------------------------------
RESTITUTION FICHE 011983 DU 2008-04-14 15:40:54
TYPE evolution concernant Code_Aster (VERSION 9.2)
TMA : Necs
TITRE
    test ssnl119a et loi LABORD_1D : modification du transitoire
FONCTIONNALITE
   Cas test SSNL119 - Réponse statique d’une poutre en béton armé (section rectangulaire) à
   comportement non linéaire.
   
   Il n'y avait pas convergence en 200 itérations au pas de temps 2.84 pour un résidu relatif
   de 1.E-5.
   Avec un résidu 3.E-5, le test passe bien t=2.84 mais pour t=3.00 la convergence n'est pas
   monotone.
   Le résidu descend, puis remonte, puis redescend pour atteindre la convergence en 128
   itérations.
   
   Entre t=2.84 et t=3.00, on atteint la ruine de la poutre. Le béton comprimé se dégrade
   tellement que l'on observe une
   décharge élastique des aciers (haut et bas), et même le béton tendu a tendance à se
   comprimer. 
   Il y a un snap back difficile à capter numériquement.
   Quel que soit le découpage en temps entre ces deux instants, on observe la "remontée puis
   redescente" du résidu.
   
   Si on choisi le résidu à 1.E-5 et le nombre maximum d'itérations à 250, le calcul passe.
   Les valeurs (contraintes, déformations, réactions, etc) dépendent très peu du résidu
   choisi, sauf pour le dernier instant (3.00).
   
   Correction adoptée :
   - on remet le résidu à 1.E-5 ; 
   - on garde le transitoire jusqu'à t=3.00 (pour montrer qu'il y a ruine à cet instant)
   - on met le nombre d'itérations maxi à 250 ;
   - les valeurs testées et les tolérances sont ajustées au plus près des résultats de la
   référence Feap ;
   - on met à jour la documentation V6.02.119 (référence extérieure = Feap à la place de
   Eficos, retracer des courbes, valeurs testées et tolérances).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V6.02.119
VALIDATION
    ssnl119a
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR lefebvre     LEFEBVRE Jean-Pierre   DATE 03/01/2011 - 12:47:37

--------------------------------------------------------------------------------
RESTITUTION FICHE 016477 DU 2011-02-24 10:44:18
TYPE express concernant Code_Aster (VERSION 10.3)
TITRE
    Rétablir la fonctionnalité d'impression des catalogues d'éléments
FONCTIONNALITE
   But de la fiche : rétablir la fonctionnalité AIDE(TYPE_ELEM=_F()) pour la couverture de code.
   
   On ne rétablit pas la commande AIDE, mais on complète la commande MAJ_CATA en ajoutant les
   mots-clés :
   
                 UNITE       =SIMP(statut='f',typ='I',defaut=8),       
                 TYPE_ELEM   =FACT(statut='f',),
   De plus on restitue la routine fortran aidty2 utilisée jusqu'alors en surcharge et on
   supprime aidtyp.
   
   On enrichit le test zzzz281a pour appeler MAJ_CATA( TYPE_ELEM =_F() ), mais aussi pour
   réaliser l'étape de construction du fichier cata_ele.pickled en modifiant
   bibpyt/Lecture_Cata_Ele/make_capy_offi.py.
   
   Les catalogues de messages SUPERVIS et CATAELEM sont rétablis, car utilisés dans les
   routines GCECCO et AIDTYP. Les scripts lancés devront tenir compte de ces modifications en
   version NEW10.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : U4.15.01
VALIDATION
    zzzz281a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 016479 DU 2011-02-24 13:56:57
TYPE express concernant Code_Aster (VERSION 9.1)
TITRE
    Bévue lors de la suppression de JXABOR
FONCTIONNALITE
   Le remplacement de l'appel à JXABOR par un CALL ASSERT dans JEFINI provoque des appels
   récursifs en cas d'erreur <F>. Il faut faire un appel direct à la fonction ABORT.
   On remplace le CALL ASSERT par CALL ABORT dans JEFINI.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    par NS sur MED 3.0
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 016488 DU 2011-02-25 09:44:55
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.3.15, les cas-tests ascou21a, gcpc001a, ssnv156a, ssnv185n et zzzz110b s'arrete en erreur fatale sur Calibre 5.
FONCTIONNALITE
   Les tests ascou21a, gcpc001a, ssnv156a, ssnv185n et zzzz110b s'arrêtent en erreur par
   manque de mémoire JEVEUX.
   Tous ces tests travaillent en mémoire statique (zone mémoire gérée dynamiquement par Jeveux).
   Depuis le passage des arguments en Mo pour la mémoire JEVEUX (10.3.15), la compatibilité
   avec les arguments d'appels en Mw était mal assurée dans le cas statique, en effet la valeur
   par défaut de la mémoire statique est toujours de 1 Mo (pour la gestion interne de JEVEUX)
   et on testait la présence ou non de l'argument -memjeveux_stat sur une valeur nulle,
   correction effectuée : on teste maintenant sur la valeur 1.
   De plus,l'argument récupéré derrière memjeveux_stat était traité en Mw alors qu'il est fourni
   en Mo. Les opérations de conversion sont réordonnées pour éviter de dépasser la valeur
   maximale de
   l'entier sur les plates-formes 32 bits.On corrige la routine IB0MAI en conséquence.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ascou21a, gcpc001a, ssnv156a, ssnv185n,  zzzz110b
NB_JOURS_TRAV  : 0.4
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR michel       MICHEL-PONNELLE Sylvie   DATE 03/01/2011 - 05:17:32

--------------------------------------------------------------------------------
RESTITUTION FICHE 011497 DU 2007-11-23 10:53:30
TYPE evolution concernant Code_Aster (VERSION )
TMA : Necs
TITRE
    Excentrement des GRILLE et déformation thermique -suite AOM 11479
FONCTIONNALITE
   Le but de cette fiche était de valider la prise en compte de la thermique par les grilles
   d'armatures. 
   Pour cela un nouveau cas-test est restitué de type béton armé avec chargement thermique et
   réponse mécanique.
   
   Deux types de modélisation sont testées:
   
   - Plaque en béton (DKT) et armature en acier (GRILLE_EXCENTREE)
   - Béton en volumique et armature en acier (GRILLE_MEMBRANE)
   
   On chauffe l'acier ce qui entraîne une déformation de la plaque. 
   La référence est le calcul analytique
   
   Nom du cas test : HSNS102A,B
   
   Doc V7.23.102
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V7.23.102
VALIDATION
    solution analytique
--------------------------------------------------------------------------------
RESTITUTION FICHE 016108 DU 2010-12-22 13:51:19
TYPE anomalie concernant Documentation (VERSION *)
TITRE
    V3.04.130: Valeurs des déplacements radiaux de la solution de référence incorrectes
FONCTIONNALITE
   J'ai repris la documentation du test et notamment :
   - modifier l'introduction qui parlait de modélisations F et G qui n'existent pas
   - corriger les valeurs de référence et les unités 
   - mise aux nouvelles normes  des tableaux de résultats
   - compléter avec les données sur la formulation UP avec éléments linéaires
   - créer la modélisation E qui valide les PENTA15
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V3.04.130
VALIDATION
    sans objet
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR meunier      MEUNIER Sébastien     DATE 03/01/2011 - 05:17:35

--------------------------------------------------------------------------------
RESTITUTION FICHE 016321 DU 2011-01-28 14:27:59
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Documentation de CALC_ELEM(EPVC_ELGA,EPVC_ELNO)
FONCTIONNALITE
   Problème :
   =========
   
   On ne trouve pas dans la documentation de calc_elem d'explication sur la signification des
   options EPVC_ELGA et EPVC_ELNO.
   
   Solution :
   ==========
   
   Un paragraphe est rajouté dans la documentation de calc_elem sur la signification des
   options EPVC_ELGA et EPVC_ELNO par Sylvie.
   
   Réponse de Sylvie Michel :
   ==========================
   
   Cette option a été développée pour les besoins en dépouillement en génie civil : elle ne
   calcule donc que les déformations liées à la thermique, à l'hydratation et au séchage (on
   n'utilise jamais la variable de commande d'irradiation en génie civil). Elles sont
   accessibles avec les noms de composantes suivantes : EPTHER_L, EPTHER_T, EPTHER_N, EPSECH
   et EPHYDR. 
   
   Je n'ai pas viser l'exhaustivité, j'ai simplement prévu en plus de mes besoins que les
   déformations thermiques pouvaient être orthotropes.
   
   En revanche, rien n'empêche d'ajouter de nouvelles composantes pour calculer les
   déformations liées à la corrosion ou à l'irradiation. En revanche, il faut aller chercher
   dans les lois de comportement concernées comment sont calculées ces déformations pour être
   cohérent.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 8.3.19
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.81.01
VALIDATION
    aucune
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR michel       MICHEL-PONNELLE Sylvie   DATE 03/01/2011 - 05:17:36

--------------------------------------------------------------------------------
RESTITUTION FICHE 015346 DU 2010-07-16 09:02:08
TYPE evolution concernant Code_Aster (VERSION )
TMA : Necs
TITRE
    QUA03 ajout d'une nouvelle modélisation pour valider 2 routines de l'opérateur DEFI_CABLE_BP
FONCTIONNALITE
   Le but de la fiche était de tester l'opérateur DEFI_CABLE_BP avec les tétraètres et les
   pyramides.
   Pour cela 2 deux variantes du cas test sslv115a ont été introduites 
       sslv115b passe par IMMEPY (pyramide)
       sslv115c passe par IMMETT (tétraèdre)
   
   Dans les cas b et c, il y a plusieurs éléments volumiques.
   Les contraintes et déformation du béton varient légèrement d'un élément à un autre (effet 3D).
   La valeur moyenne vérifie bien la solution analytique.
   Ces deux routines sont donc maintenant testées.
   
   Remarque : 
   Dans sslv115a, il y avait un second test non commenté dans la documentation.
   C'était un test thermomécanique qui testait la prise en compte de la température en cas de
   précontrainte.
   Le cas test n'est pas assez pertinente car les tolérance sont trop grandes (0.1%) par
   rapport aux grandeurs testées et les références n'étaient pas tout à fait exactes. Cette
   partie du test a été supprimée de sslv115a.comm, elle devra fera l'objet d'un autre cas test.
   
   On garde la partie test des contraintes due à la précontrainte.
   La doc est mise à jour (solution analytique et valeurs testées)
   
   
   Dans les cas b et c, il y a plusieurs éléments volumiques.
   Les contraintes et déformation du béton varient légèrement d'un élément à un autre (effet 3D).
   La valeur moyenne vérifie bien la solution analytique.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V3.04.115
VALIDATION
    analytique
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR pellet       PELLET Jacques         DATE 03/01/2011 - 10:09:32

--------------------------------------------------------------------------------
RESTITUTION FICHE 016107 DU 2010-12-21 15:42:01
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Problèmes si DEPL_R a plus de 120 CMPS
FONCTIONNALITE
   Problème :
   ----------
   Quand on ajoute des CMPS dans la grandeur DEPL_R (au dela de 120) :
    - le test zzzz162a devient NOOK
    - les tests sdlv128a,b devient NOOK
                                                                                            
                                                                        
   Analyse :
   ---------
   1) Pour le test zzzz162a :
   Il s'agit d'un bug de la routine idensd.f qui détermine si 2 PROF_CHNO sont identiques.
   Pour vérifier cette identité, on compare les objets .DEEQ, .LILI et .NUEQ, ce qui permet
   de vérifier que les cmps sont bien rangées dans le meme ordre et qu'elles sont les memes
   pour tous les noeuds.
                                                                                            
                                                                        
   Ici, les champs de VARI_NOEU ont 2 CMPS par noeud de numéro 1 et 2 (V1, V2)  et les champs
   de DEPL ont également 2 CMPS par noeud de numéro 1 et 2 (DX, DY). Les objets .DEEQ sont
   donc identiques et les PROF_CHNO sont considérés comme identiques. On les économise en
   n'en gardant qu'un.
                                                                                            
                                                                        
   Jusqu'à présent, le nombre d'entiers codés pour DEPL_R (120 CMPS) et VAR2_R (100 CMPS) est
   le meme : 4. Tout se passe bien !
   Mais si l'on ajoute des CMPS à DEPL_R, on passe à 5 entiers codés pour DEPL_R.
                                                                                            
                                                                        
   Du coup, l'objet .PRNO du PROF_CHNO n'est plus identique et on se plante plus loin, car
   les cmps du champ sont mal interprétées.
                                                                                            
                                                                        
   2) Pour les tests sdlv128a,b :
   Il s'agit d'une erreur des fichiers de commande qui n'est pas "trappée" par le code et qui
   est sans importance jusqu'ici :
   La commande coupable est :
      MODESEXP=PROJ_CHAMP( RESULTAT=MODEAIR, NOM_CHAM='EPSI_NOEU',
                           NUME_DDL=NUMEXP, ...);
   C'est une erreur de vouloir imposer la numérotation des champs EPSI_NOEU avec la
   numérotation NUMEXP qui concerne les ddls de DEPL_R.
   Mais cette erreur ne se voit pas actuellement car les ddls utilisés dans ce test sont
   toujours les ddls 1,2 et 3 (DX/DY/DZ ou EPXX/EPYY/EPZZ) et le nombre d'entiers codés pour
   DEPL_R er EPSI_R est le meme (4).
                                                                                            
                                                                        
   Si le nombre d'entiers codés diffère entre DEPL_R et EPSI_R (ce qui arrive si DEPL_R passe
   à 5), les champs de MODESEXP (EPSI_R) sont mal interpretés et les résultats du tests sont
   NOOK.
                                                                                            
                                                                        
   Corrections :
   -------------
     * Je corrige la routine idensd.f pour qu'elle vérifie également que l'objet .PRNO est
   identique.
     * Je corrige les tests sdlv128a,b (suppression du mot clé NUME_DDL=NUMEXP)
     * Je "blinde" la programmation de PROJ_CHAMP / NUME_DDL pour vérifier la cohérence entre
   la numérotation que l'on veut imposer et les champs auquels ont veut l'imposer. Pour le
   test sdlv128b (sans sa correction) l'erreur produite est :
                                                                                            
                                                                        
   !--------------------------------------------------------------------------!
   !.<F>.<CALCULEL4_6>........................................................!
   !..........................................................................!
   !.Erreur.utilisateur.(ou.programmeur).:....................................!
   !..On.veut.imposer.la.numérotation.des.ddls.du.cham_no.MODESEXP.013.000001.!
   !..avec.le.nume_ddl.NUMEXP.........NUME....................................!
   !..Mais.ces.2.structures.de.données.sont.incompatibles.....................!
   !..Par.exemple.:...........................................................!
   !.....-.ce.n'est.pas.le.meme.maillage.sous-jacent..........................!
   !.....-.ce.n'est.pas.la.meme.grandeur.sous-jacente.........................!
   !--------------------------------------------------------------------------!
                                                                                            
                                                                        
                                                                                            
                                                                        
   Validation :
   ------------
   Les 3 tests sont OK si j'ajoute 8 CMPS bidons dans DEPL_R
                                                                                            
                                                                        
   NEW9 :
   ------
   Bien que ces 2 erreurs apparaissent lorsque les nombres d'entiers codés de DEPL_R, VAR2_R
   et EPSI_R diffèrent, ce qui n'est pas vrai en version 9 (il faut 4 entiers codés pour ces
   3 grandeurs), je propose de reporter les corrections en NEW9.
                                                                                            
                                                                        
    
    
   Liste des fichiers impactés par la correction de la fiche:  16107
     cnscno.f  idensd.f
     calculel4.py
     sdlv128a.comm  sdlv128b.comm
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    3 tests incriminés
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 016396 DU 2011-02-10 10:05:48
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Créer une vérification du nombre d'entiers codés
FONCTIONNALITE
   Problème :
   ----------
   Comment faire en sorte que le code ne se plante pas si on se contente d'ajouter des
   composantes dans une grandeur existante (par exemple DEPL_R) ?
   
   Réponse :
   ---------
   Je ne crois pas qu'il soit possible de faire une vérification automatique du nombre
   d'entiers codés des grandeurs :
   
   Le nombre de CMPS dans une grandeur peut varier au cours des années et peut franchir à
   l'occasion  les "multiples de 30", ce qui entraine un changement du nombre d'entiers codés
   nécessaires pour cette grandeur.
   
   Il est donc important que les routines Fortran ne "gravent" pas dans le marbre le nombre
   d'entiers codés des grandeurs (ni d'ailleurs la "position" des CMPS d'une grandeur : par
   exemple, toujours supposer que DEPL_R(1)='DX').
   
   Je ne vois pas comment vérifier automatiquement la généricité du fortran.
   
   Les problèmes apparus lorsque J. Beaurain (ou P. Massin) ont essayé de dépasser 120 CMPS
   dans DEPL_R, ont été résolus dans le cadre de la fiche 16107. Les deux problèmes
   rencontrés n'étaient pas liés (comme je l'avais d'abord cru) à une programmation trop en
   "dur". Il s'agissait de deux bugs que l'on n'avait pas encore observés par malchancce (ou
   par chance si l'on veut !) car les grandeurs EPSI_R, VAR2_R et DEPL_R avaient toutes les 3
   le même nombre d'entiers codés (4), ce qui masquait les bugs.
   
   Cette fiche est donc "sans suite" car corrigée par 16107
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    essai perso
NB_JOURS_TRAV  : 0.05
--------------------------------------------------------------------------------
RESTITUTION FICHE 016433 DU 2011-02-17 07:39:13
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.3.13, les cas-tests sdld104a sdld104b sdls112a et sdlv122a s'arretent en erreur fatale sur Aster4, Calibre4 et Rocks.
FONCTIONNALITE
   Problème :
   ----------
   En NEW10.3.13, les cas-tests sdld104a sdld104b sdls112a et 
   sdlv122a s'arretent en erreur fatale sur Aster4, Calibre4 et 
   Rocks.
                                                                                            
                               
   Analyse :
   ---------
   En 10.3.13, on a retiré les CMPS D1, D1X, D1Y et D1Z des grandeurs 
   DEPL_R, DEPL_C et DEPL_F.
   Je croyais que ces composantes n'étaient plus utilisées car elles 
   ne sont pas utilisées dans les catalogues d'éléments.
   En réalité, ces composantes sont utilisées quand on lit des 
   déplacements au format IDEAS_DS58.
   Il faut donc les rétablir.
                                                                                            
                               
   Correction :
   ------------
   On remet les composantes supprimées par erreur. C'est possible 
   depuis la correction de la fiche 16107.
                                                                                            
                               
   Validation :
   ------------
   Les 4 tests incriminés sont réparés.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    tests cassés
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 016448 DU 2011-02-18 09:37:21
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Evolution de EVOL_IMPO dans AFFE_CHAR_CINE
FONCTIONNALITE
   Problème :
   ----------
   Le mot clé EVOL_IMPO de la commande AFFE_CHAR_CINE ne permet pas de choisir les
   composantes à imposer :
   On impose systématiquement OUTES les composantes trouvées dans la sd_evol_xxx.
                                                                                            
                           
   Evolution proposée :
   --------------------
   On ajoute le mot clé (facultatif) NOM_CMP=('DX','DZ',...) pour permettre de "filtrer" les
   CMPS à imposer.
                                                                                            
                           
   Validation :
   ------------
   Je modifie le test zzzz230a (zoom structural) pour que les déplacements imposés sur le
   bord (DX et DY) soient appliqués à travers 2 charges différentes :
     CHAR22A=AFFE_CHAR_CINE(MODELE=MO2, EVOL_IMPO=UIMP,NOM_CMP='DX')
     CHAR22B=AFFE_CHAR_CINE(MODELE=MO2, EVOL_IMPO=UIMP,NOM_CMP='DY')
   La solution reste la meme.
   
   Impact documentaire :
   --------------------
   U4.44.03 : affe_char_cine
    
    
   Liste des fichiers impactés par la correction de la fiche:  16448
     charci.f  chcsur.f
     affe_char_cine.capy
     zzzz230a.comm
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.44.03
VALIDATION
    zzzz230a
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 016450 DU 2011-02-18 11:37:54
TYPE evolution concernant Code_Aster (VERSION 9.1)
TITRE
    Problème de performance CPU pour LIRE_RESU et PROJ_CHAMP
FONCTIONNALITE
   Problème :
   ----------
   R. Fernandes a remarqué que les commandes LIRE_RESU et PROJ_CHAMP consommaient plus au
   moins de tmps CPU selon que l'on typait le resultat comme evol_ther ou evol_noli.
                                                                                            
                                                                   
   Pourtant, il s'agit bien des memes champs de température que l'on cherche à lire et à
   projeter.
                                                                                            
                                                                   
   Analyse :
   ---------
   En repassant l'étude jointe avec "gprof", je me suis aperçu que la routine exisdg.f était
   énormément appelée et consommait beaucoup de temps.
                                                                                            
                                                                   
   Ici, les routines qui appelent beaucoup exisdg sont :
     * pteequ
     * cmpcha
     * cnocns
                                                                                            
                                                                   
   Dans ces 3 routines, il y a une double boucle :
   do ino=1,nbno
     do icmp=1,ncmpmx
        if (exisdg(icmp,dg))
          ...
                                                                                            
                                                                   
   ncmpmx est le nombre MAXIMUM de composantes de la grandeur du cham_no.
    Quand la grandeur est TEMP_R, ncmpmx=4
    Quand la grandeur est DEPL_R, ncmpmx=120
                                                                                            
                                                                   
   C'est ce qui explique (en partie) que les 2 commandes LIRE_RESU et PROJ_CHAMP sont plus
   couteuses pour les evol_noli que pour les evol_ther.
                                                                                            
                                                                   
   Corrections :
   -------------
   C1) L'idée est de limiter la boucle "do icmp=1,ncmpmx" aux seules composantes réellement
   présentes dans le champ.
   Pour cela, on complète l'utilitaire cmpcha.f qui détermine la liste des CMPS d'un champ :
   un nouvel objet est créé qui donne la liste des numeros des CMPS présentes dans le champ.
                                                                                            
                                                                   
   C2) Dans la routine cmpcha.f, on ne sait pas encore la liste des CMPS présentes (puisqu'on
   cherche à la déterminer!). Pour économiser les appels à exisdg, on calcule (en parcourrant
   tous les noeuds), un descripteur_grandeur (vecteur d'entiers codés) qui est "l'enveloppe"
   de tous les descripteur_grandeur des points du champ.
                                                                                            
                                                                   
   Validation :
   ------------
   Pour l'étude fournie par Roméo, sur aster4 :
                                                                                            
                                                                   
   ...................!......avant.......!........après....!
   ___________________!__________________!_________________!
   LIRE_RESU../.TEMP..!......16.72.......!........13.41....!
   LIRE_RESU../.DEPL..!.....300.92.......!.......151.01....!
   PROJ_CHAMP./.TEMP..!.....155.01.......!.......137.88....!
   PROJ_CHAMP./.DEPL..!.....424.74.......!.......141.84....!
   ___________________!__________________!_________________!
                                                                                            
                                                                   
   Commentaires :
     * On voit que pour PROJ_CHAMP, le cout est maintenant à peu près le meme pour TEMP et DEPL.
     * En revanche, pour LIRE_RESU, le gain (300 -> 150) du à pteequ est appréciable, mais il
   reste un problème.
       Après avoir regardé rapidement la routine lrcnme.f, je pense qu'il faudrait
   l'améliorer en ne créant pas le cham_no_s sur TOUTES les CMPS de DEPL_R : il faudrait
   limiter ce nombre de CMPS :
         * prendre les composantes trouvées sur le fichier s'il existe une routine MED qui
   donne cette info,
         * ou bien, se limiter aux CMPS que l'utilisateur demande avec le mot clé NOM_CMP
       Je ne résoudrai pas ce problème dans le cadre de cette fiche => j'en émets une
   nouvelle (16499)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    étude jointe
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 016473 DU 2011-02-24 10:20:52
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    recherche de modes de corps rigides avec charges "cinématiques"
FONCTIONNALITE
   Problème :
   ----------
   Actuellement, on ne peut pas utiliser la routine tldlg2 (qui détermine les modes de corps
   rigides d'une matrice) si cette matrice comporte des blocages "cinématiques" (AFFE_CHAR_CINE).
   On veut lever cette restriction afin d'étendre les possibilités d'utilisation de CAAY,
   FETI, ...
                                                                                            
                                                     
   Correction :
   ------------
   Dans la routine tldlg2.f, on utilise la routine mtmchc.f sur la matrice de travail avant
   de lui ajouter des relations cinématiques supplémentaires pour bloquer les modes de corps
   rigides.
                                                                                            
                                                     
   Validation :
   ------------
   1) Essais perso pour vérifier sur des cas simples 2D que les modes rigides sont bien calculés.
   2) J'ai vérifié que la routine fonctionne correctement si on mélange AFFE_CHAR_MECA et
   AFFE_CHAR_CINE.
   3) J'ai vérifié que cela fonctionne avec CAAY
   4) J'ai voulu voir si cela permettait d'utiliser les charges cinématiques avec FETI :
      Pour cela, j'ai modifié feti003c.comm pour que CH2 et CH3 soient des char_cine.
      On est actuellement arreté par un message clair dans ascavc.f (ALGORITH_16).
      Si on "force" le passage, le calcul va au bout mais les resultats sont tout faux !!
      Il reste donc des choses à faire pour permettre l'usage des charges cinématiques avec FETI.
                                                                                            
                                                     
                                                                                            
                                                     
   Détails :
   ---------
   Je modifie les arguments de tldlg2 :
     * ajout d'un argument FETI=' '/'FETI' pour signifer à cette routine qu'il faut en faire
   un peu plus si 'FETI'.
       Cet argument est également utilisé pour CAAY.
     * suppression de l'argument BASE (inutilisé)
     * modification de l'argument INPN : je remplace l'adresse JEVEUX par le nom de objet JEVEUX.
     * suppression du "call jedetc" (performances)
    
    
   Liste des fichiers impactés par la correction de la fiche:  16473
     asschc.f  fetfac.f  op0045.f  tldlg2.f
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    essais perso
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR proix        PROIX Jean-Michel      DATE 02/28/2011 - 06:50:23

--------------------------------------------------------------------------------
RESTITUTION FICHE 016465 DU 2011-02-22 17:03:32
TYPE express concernant Code_Aster (VERSION 9.1)
TITRE
    probleme dans SIMU_POINT_MAT si une seule varaible interne initiale
FONCTIONNALITE
   Francis a remarqué que si on donne une seule variable interne initiale dans
   SIMU_POINT_MAT, cela plante comme ceci :
        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         ! Erreur dans la macro SIMU_POINT_MAT                                             !
         ! Traceback (most recent call last):                                              !
         !    File "./Python/Build/B_MACRO_ETAPE.py", line 106, in _Build                  !
         !     ier= apply(self.definition.proc,(self,),d)                                  !
         !    File "./Python/Macro/simu_point_mat_ops.py", line 501, in simu_point_mat_ops !
         !     nbvari=len(VARINI['VALE'])                                                  !
         !  TypeError: len() of unsized object                                             !
   
   En effet à la ligne 501 de simu_point_mat_ops.py, on trouve : nbvari=len(VARINI['VALE'])
   
   Or si on donne une seule variable interne, VARINI[VALE] ne contient plus une liste (ni un
   tuple) mais un reel. Comment s'en sortir ? Grâce à la fonction  "is_enum" :
   
             if (not is_enum(VARINI['VALE'])) :
                      VARINI['VALE'] = [VARINI['VALE'],]
             nbvari=len(VARINI['VALE'])
   Et là cela marche !
   
   J'en profite aussi pour calculer EPSG au lieu de EPSI dans le cas de grandes déformations.
   
   Validation :
   - tous les tests utilisant SIMU_POINT_MAT et TEST_COMPOR
   - ajout de VARI_INIT=_F(VALE=0.) dans comp007a
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    comp007a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR sellenet     SELLENET Nicolas       DATE 02/28/2011 - 05:02:17

--------------------------------------------------------------------------------
RESTITUTION FICHE 016377 DU 2011-02-07 17:51:00
TYPE anomalie concernant Documentation (VERSION *)
TITRE
    ERREU* -> Cas-tests sans clxc3xa9 documentaire
FONCTIONNALITE
   Problème :
   ----------
   """
   Les cas-tests suivant ont été rentrés dans le code sans clé documentaire:
   10.0.21: erreu03a + erreu04a (M.Courtois)
   10.0.25: erreu05a (M.Courtois)
   10.1.7 : erreu06a (N.Sellenet)
   """
   
   
   Solution :
   ----------
   On rédige une doc succinte qui décrit les messages d'erreurs validés par chacun des tests.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V1.01.277 V1.01.278 V1.01.279 V1.01.280
VALIDATION
    aucune
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 016500 DU 2011-02-28 07:02:03
TYPE express concernant Code_Aster (VERSION 9.1)
TITRE
    Matrice distribuee et charges cinxc3xa9matiques
FONCTIONNALITE
   Problème :
   ----------
   A la dernière stabilisation, on avait décidé d'interdire les charges cinématiques et la
   distribution de la matrice car perf011b était NOOK.
   
   
   Analyse :
   ---------
   En réalité perf011b n'est pas NOOK à cause de matrice distriubée.
   
   Pour l'instant, je n'ai toujours pas compris pourquoi perf011b devient NOOK de manière
   aléatoire.
   
   
   Solution :
   ----------
   On autorise les charges cinématiques et la distribution de la matrice.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    perf011b
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 016485 DU 2011-02-25 09:16:11
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.3.14, le cas-test ssnv147a s'arrete en erreur fatale sur Aster4 et Calibre 5.
FONCTIONNALITE
   Problème :
   ----------
   """
   En NEW10.3.14, le cas-test ssnv147a s'arrete en erreur fatale sur Aster4 et Calibre 5.
   """
   
   
   Analyse :
   ---------
   Le plantage est dû à un appel à RSUTOR (utilitaire qui à partir d'un nom d'un champ dans
   une sd résultat renvoit son nom symbolique et son numéro d'ordre) réalisé par UTEREF dans
   IMPR_RESU.
   
   En réalité, j'avais omis le cas où le champ ne fait pas partie d'une sd résultat. De ce
   fait lorsqu'on fait un IMPR_RESU sur un champ seul hors d'un sd résultat, on plante dans
   RSUTOR.
   
   
   Solution :
   ----------
   Distinguer le cas champ seul du cas sd résultat dans UTEREF.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssnv147a
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR sfayolle     FAYOLLE Sebastien      DATE 03/01/2011 - 11:00:49

--------------------------------------------------------------------------------
RESTITUTION FICHE 016462 DU 2011-02-22 15:39:42
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    GLRC_DM : nouvelles structures, nouveaux cas test et suppression d'un bug
FONCTIONNALITE
   Au travers de cette fiche, on traite plusieurs aspects.
   
   Dans un premier temps, on corrige un bug dans lcgldm.f pour le 
   calcul des contraintes de
   membranes. En effet, on utilise une valeur de la trace des 
   déformations qui ne prend pas
   en compte la valeur de Eps_zz actualisée. On a donc un risque de 
   résultats faux (l'erreur est très faible). Les
   valeurs de non-regressions des cas tests sont modifiés en 
   conséquence.
   
   On introduit une nouvelle structure dans lcgldm.f afin de se 
   rapprocher des futurs
   développements de Christelle.
   
   lcgldm
   |
   |-cstgld (calcul de constante de GLRC_DM)
   |
   |-gldloc
   |
   |-cntmat (calcul des contraintes et de la matrice tangente)
   
   Christelle a modifié tanmgl.f qui sert à passer la matrice 
   tangente du repère propre des
   déformations au repère local de l'élément. Les modifications 
   permettent d'être plus
   efficace et d'éviter des calculs inutiles.
   
   On modifie le calcul de la matrice tangente pour éviter de 
   calculer des termes inutiles et
   on passe par l'utilisation de MATINV aux lieu de la méthode 
   manuelle actuelle.
   
   Pour finir, on introduit le cas test en distorsion de Christelle.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 8.3.21
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V6.05.106
VALIDATION
    cas test GLRC
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR geniaut      GENIAUT Samuel         DATE 03/01/2011 - 09:50:20

--------------------------------------------------------------------------------
RESTITUTION FICHE 013723 DU 2009-08-17 07:34:41
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    X-FEM : Option K_G_MODA
FONCTIONNALITE
   Contexte : 
   
   Cette fiche d’évolution fait suite à la fiche 13048 de NISTOR Ionel (calcul des fréquences
   propres avec X-FEM) et également équivalente à la fiche 8917 d’Erwan Galenne (K_G_MODA
   pour FEM). Il s’agit de définir les facteurs d'intensité des contraintes (K) modaux comme
   étant les K associes aux modes propres de vibration d'une structure.
   
   Une manière simple de résoudre un problème en dynamique consiste a passer par une
   décomposition modale. On souhaite pouvoir de la même manière résoudre un problème de
   mécanique de la rupture en dynamique. Cela passe par la définition de facteurs d'intensité
   des contraintes modaux, calculables par la méthode thêta a partir du déplacement de la
   forme bilinéaire g du taux de restitution de l'énergie et des fonctions singulières
   statiques. En dynamique harmonique un terme supplémentaire apparaît cependant dans
   l'expression de g (dépendant de la fréquence propre).
   
   Cadre : Anode 2011, lot 3.3
   Travaux réalisés :
   Les travaux réalisées par Erwan mais pas restitués il y 2 ans sont récupérés 
   dans ce développement.
   	Modification de :
   -	fortran : cakgmo, meficg.f, op0100,  te0037,  xcgfvo
   -	cata : gener_mecpl2_xh,   gener_medpl2_xh, gener_me_xh,   k_g_moda, 
   gener_mecpl2_xht,  gener_medpl2_xht,  gener_me_xht, gener_mecpl2_xt, 
   gener_medpl2_xt,   gener_me_xt,
   -	castest : sdls114c (C_PLAN),sdls114d (3D)
   
   
   Impact documents :
   	R7.02.12 - eXtended Finite Element Method (ajout d’un terme) 
   	U2.05.02 - Notice d'utilisation de la méthode X-FEM
   	U4.82.03 – Opérateur CALC_G 
   	V2.03.114 - doc V du cas-test sdls114 (C_PLAN et 3D)
   Remarque :
   L'utilisation des fonctions singulières statique dans la forme bilinéaire de G
   introduit une approximation dans la méthode mais on peut montrer que l'erreur est
   limitée tant qu'on reste au voisinage du fond de fissure et a des fréquences
   modérées. K1 étant une fonction linéaire du champ de déplacement, les facteurs
   d'intensité modaux peuvent être recombines comme les déplacements pour 
   reconstruire la solution d'un problème dynamique.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V2.03.114, U4.82.03, R7.02.12, U2.05.02
VALIDATION
    sdls114c, sdls114d
NB_JOURS_TRAV  : 7.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR tran         TRAN Van-xuan          DATE 03/01/2011 - 09:50:20

--------------------------------------------------------------------------------
RESTITUTION FICHE 016353 DU 2011-02-02 13:41:29
TYPE aide utilisation concernant Code_Aster (VERSION 9.1)
TITRE
    CALC_FATIGUE: critère de FATEMI-SOCIE
FONCTIONNALITE
   Context:
   
   Cette fiche s'agit d'une aide à l'utilisation.
   
   Question: 
   Peut-on avoir directement la valeur du critère de FATEMI-SOCIE de 
   l'opérateur CALC_FATIGUE, appelé epsilon_eq(n) (U4.83.02), ou bien est-on 
   obligé de la déduire de la valeur de l'endommagement ENDO1 et de la courbe de 
   MANSON- COFFIN.
   
   Réponse:
   Pour la version actuelle du Code_Aster, toutes les grandeurs sont sorties pour 
   les critères Dang_Van_AC et Matake_AC. Pour les autres seuls l'endommagement 
   et les coordonnées du vecteur correspondant à l'endommagement max sont sortis, 
   cf doc R7.04.04,  § 8.4. 
   
   Donc, la sortie d’Epsi_eq(n) du critère de FATEMI-SOCIE n’est pas actuellement 
   disponible.
   
   Pour la deuxième partie de la question, si on déduit d’Epsi_eq(n) de la valeur 
   de l'endommagement ENDO1 et de la courbe de MANSON-COFFIN, il est remarqué que 
   la courbe de MANSON-COFFIN est en traction-compression tandis que d’Epsi_eq(n) 
   du critère de FATEMI-SOCIE est en cisaillement. Il est donc nécessaire de 
   convertir la courbe de MANSON-COFFIN en traction-compression en une courbe de 
   MANSON-COFFIN en cisaillement.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    aucun
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 016412 DU 2011-02-14 15:42:36
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    menage D_CUMULE suite fiche 16136
FONCTIONNALITE
   enlever D_CUMULE dans grandeur_simple__
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    aucun
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST AJOUT hsns102a                       michel S.MICHEL           267    267      0
 CASTEST AJOUT hsns102b                       michel S.MICHEL           269    269      0
 CASTEST AJOUT sdls114c                         tran V-X.TRAN           177    177      0
 CASTEST AJOUT sdls114d                         tran V-X.TRAN           169    169      0
 CASTEST AJOUT sslv115b                       michel S.MICHEL           211    211      0
 CASTEST AJOUT sslv115c                       michel S.MICHEL           208    208      0
 CASTEST AJOUT ssnl137a                     bargelli R.BARGELLINI       126    126      0
 CASTEST AJOUT ssnp140e                     bargelli R.BARGELLINI       185    185      0
 CASTEST AJOUT zzzz111b                        labbe M.LABBE            152    152      0
 CASTEST MODIF comp007a                        proix J-M.PROIX          174      2      1
 CASTEST MODIF forma05b                       delmas J.DELMAS           363      3      1
 CASTEST MODIF miss01a                      courtois M.COURTOIS         330     50    616
 CASTEST MODIF miss03a                      courtois M.COURTOIS         315     74    793
 CASTEST MODIF miss06a                      courtois M.COURTOIS         654     23     22
 CASTEST MODIF miss06b                      courtois M.COURTOIS         820     35     22
 CASTEST MODIF miss06c                      courtois M.COURTOIS         818     37     22
 CASTEST MODIF miss07a                      courtois M.COURTOIS         368     43     35
 CASTEST MODIF miss08a                      courtois M.COURTOIS         379     45     38
 CASTEST MODIF miss09a                      courtois M.COURTOIS         871     44     23
 CASTEST MODIF perf011b                     sellenet N.SELLENET         590      2      2
 CASTEST MODIF sdls110a                        corus M.CORUS            236      3      2
 CASTEST MODIF sdls118a                     courtois M.COURTOIS         482      7     18
 CASTEST MODIF sdlv128a                       pellet J.PELLET           436      2      2
 CASTEST MODIF sdlv128b                       pellet J.PELLET           282      2      2
 CASTEST MODIF sdnl113a                      greffet N.GREFFET          328     74     26
 CASTEST MODIF sdns106e                     sfayolle S.FAYOLLE          333      1      1
 CASTEST MODIF ssla103e                     bargelli R.BARGELLINI       233     49      3
 CASTEST MODIF sslv115a                       michel S.MICHEL           223     31    203
 CASTEST MODIF ssnl119a                        labbe M.LABBE            314    110     20
 CASTEST MODIF ssnp131a                     bargelli R.BARGELLINI       179     12    174
 CASTEST MODIF ssnp131b                     bargelli R.BARGELLINI       274     19    205
 CASTEST MODIF ssnp138b                      geniaut S.GENIAUT          384     27     17
 CASTEST MODIF ssnp140a                     bargelli R.BARGELLINI       176      2      2
 CASTEST MODIF ssnp140b                     bargelli R.BARGELLINI       178      2      2
 CASTEST MODIF ssnp140c                     bargelli R.BARGELLINI       180      2      2
 CASTEST MODIF ssnp140d                     bargelli R.BARGELLINI       201      2      2
 CASTEST MODIF ssns106a                     sfayolle S.FAYOLLE         1219      5      6
 CASTEST MODIF ssns106b                     sfayolle S.FAYOLLE         1644      3      5
 CASTEST MODIF ssns106c                     sfayolle S.FAYOLLE         1880     44     44
 CASTEST MODIF ssns106d                     sfayolle S.FAYOLLE          597    160      8
 CASTEST MODIF ssns106e                     sfayolle S.FAYOLLE          557      2      3
 CASTEST MODIF ssns106f                     sfayolle S.FAYOLLE          632     18     24
 CASTEST MODIF ssns106g                     sfayolle S.FAYOLLE          451      6      6
 CASTEST MODIF ssns106h                     sfayolle S.FAYOLLE          910     12     12
 CASTEST MODIF ssns106i                     sfayolle S.FAYOLLE          981      1      1
 CASTEST MODIF ssns106j                     sfayolle S.FAYOLLE         1415     24     24
 CASTEST MODIF ssnv128a                        abbas M.ABBAS            497     21      4
 CASTEST MODIF ssnv147a                     sellenet N.SELLENET         228      1      1
 CASTEST MODIF ssnv164a                     bargelli R.BARGELLINI      1088    538     16
 CASTEST MODIF ssnv166a                      geniaut S.GENIAUT          305      9      9
 CASTEST MODIF ssnv166b                      geniaut S.GENIAUT          322      9      9
 CASTEST MODIF ssnv192a                      geniaut S.GENIAUT          421     59    104
 CASTEST MODIF ssnv218a                     bargelli R.BARGELLINI       385     87    598
 CASTEST MODIF zzzz108a                        corus M.CORUS           1152      3     45
 CASTEST MODIF zzzz141a                       assire A.ASSIRE            87     25      3
 CASTEST MODIF zzzz200b                     courtois M.COURTOIS        1145     13     41
 CASTEST MODIF zzzz218a                      bottoni M.BOTTONI          358      5      3
 CASTEST MODIF zzzz218b                      bottoni M.BOTTONI          377      4      4
 CASTEST MODIF zzzz218c                      bottoni M.BOTTONI          387      4      2
 CASTEST MODIF zzzz230a                       pellet J.PELLET           175     34     17
 CASTEST SUPPR hsna103a.comm                bargelli R.BARGELLINI       557      0    557
 CASTEST SUPPR sdls110a.comm                   corus M.CORUS            236      0    236
 CASTEST SUPPR sdls110a                        corus M.CORUS            236      0    236
CATALOGU MODIF options/k_g_moda                 tran V-X.TRAN            55     12      2
CATALOGU MODIF typelem/gener_mebar1         bargelli R.BARGELLINI       243      6      1
CATALOGU MODIF typelem/gener_mecpl2_xh          tran V-X.TRAN           327     27     14
CATALOGU MODIF typelem/gener_mecpl2_xht         tran V-X.TRAN           307     26     14
CATALOGU MODIF typelem/gener_mecpl2_xt          tran V-X.TRAN           302     25     14
CATALOGU MODIF typelem/gener_medpl2_xh          tran V-X.TRAN           322     23     11
CATALOGU MODIF typelem/gener_medpl2_xht         tran V-X.TRAN           302     25     14
CATALOGU MODIF typelem/gener_medpl2_xt          tran V-X.TRAN           300     24     13
CATALOGU MODIF typelem/gener_me_xh              tran V-X.TRAN           343     23     13
CATALOGU MODIF typelem/gener_me_xht             tran V-X.TRAN           341     25     15
CATALOGU MODIF typelem/gener_me_xt              tran V-X.TRAN           341     25     15
CATALOPY MODIF commande/affe_char_cine        pellet J.PELLET           170     12      4
CATALOPY MODIF commande/calc_ecrevisse       bottoni M.BOTTONI          173      3      4
CATALOPY MODIF commande/calc_miss           courtois M.COURTOIS         166    136     37
CATALOPY MODIF commande/calc_precont        bargelli R.BARGELLINI        80      9      3
CATALOPY MODIF commande/defi_group           geniaut S.GENIAUT          239      2      2
CATALOPY MODIF commande/defi_list_inst      bargelli R.BARGELLINI       245     24     11
CATALOPY MODIF commande/exec_logiciel         assire A.ASSIRE            88     41      3
CATALOPY MODIF commande/impr_macr_elem         corus M.CORUS             63     16     16
CATALOPY MODIF commande/macr_ecre_calc       bottoni M.BOTTONI          182      3      3
CATALOPY MODIF commande/macr_ecrevisse       bottoni M.BOTTONI          287      4      4
CATALOPY MODIF commande/macr_lign_coupe       durand C.DURAND           123      2      2
CATALOPY MODIF commande/maj_cata            lefebvre J-P.LEFEBVRE        30      8      4
CATALOPY MODIF commun/c_relation            bargelli R.BARGELLINI       152      1      4
 FORTRAN AJOUT algorith/eibex               bargelli R.BARGELLINI       398    398      0
 FORTRAN AJOUT algorith/fragex              bargelli R.BARGELLINI       305    305      0
 FORTRAN AJOUT algorith/lcimpl              bargelli R.BARGELLINI       106    106      0
 FORTRAN AJOUT algorith/nmisex              bargelli R.BARGELLINI       462    462      0
 FORTRAN AJOUT algorith/xtabff               geniaut S.GENIAUT          143    143      0
 FORTRAN AJOUT elements/cntmat              sfayolle S.FAYOLLE          314    314      0
 FORTRAN AJOUT elements/cstgld              sfayolle S.FAYOLLE          108    108      0
 FORTRAN MODIF algeline/op0045                pellet J.PELLET          1225      3      3
 FORTRAN MODIF algeline/op0144                pellet J.PELLET           398     13      3
 FORTRAN MODIF algeline/tldlg2                pellet J.PELLET           470    270    288
 FORTRAN MODIF algorith/asgeel                 corus M.CORUS            279     14     16
 FORTRAN MODIF algorith/cakgmo                  tran V-X.TRAN           325     54      6
 FORTRAN MODIF algorith/callis                 corus M.CORUS            448     12     22
 FORTRAN MODIF algorith/exfonc                 abbas M.ABBAS            275      8      2
 FORTRAN MODIF algorith/extdch              bargelli R.BARGELLINI       187     24      5
 FORTRAN MODIF algorith/fetfac                pellet J.PELLET           155      7     10
 FORTRAN MODIF algorith/lc0001              bargelli R.BARGELLINI       159     10      2
 FORTRAN MODIF algorith/lc0005              bargelli R.BARGELLINI        87      8      4
 FORTRAN MODIF algorith/lc0006              bargelli R.BARGELLINI       128     10      2
 FORTRAN MODIF algorith/lceib1              bargelli R.BARGELLINI       179      7      2
 FORTRAN MODIF algorith/nmadat              bargelli R.BARGELLINI       229     27      4
 FORTRAN MODIF algorith/nmcadt              bargelli R.BARGELLINI       176     53      5
 FORTRAN MODIF algorith/nmconv                 abbas M.ABBAS            544      4      4
 FORTRAN MODIF algorith/nmcrit                 abbas M.ABBAS            116      5     11
 FORTRAN MODIF algorith/nmcrpo                 abbas M.ABBAS            111      2      2
 FORTRAN MODIF algorith/nmdocr              bargelli R.BARGELLINI       274     33      3
 FORTRAN MODIF algorith/nmiclb              bargelli R.BARGELLINI       175     31      8
 FORTRAN MODIF algorith/nmimpl                 abbas M.ABBAS            346      8      2
 FORTRAN MODIF algorith/nmimps                 abbas M.ABBAS            136      2      2
 FORTRAN MODIF algorith/op0028              bargelli R.BARGELLINI       570     48      8
 FORTRAN MODIF algorith/regeec                 corus M.CORUS            290     11      3
 FORTRAN MODIF algorith/regegl                 corus M.CORUS            387     14     19
 FORTRAN MODIF algorith/utdidt              bargelli R.BARGELLINI       379      5      2
 FORTRAN MODIF algorith/xenrch               geniaut S.GENIAUT          433      5     72
 FORTRAN MODIF assembla/asmchc              sellenet N.SELLENET         304      2      3
 FORTRAN MODIF assembla/asschc                pellet J.PELLET           128     12      2
 FORTRAN MODIF assembla/pteequ                pellet J.PELLET           125     31     31
 FORTRAN MODIF calculel/afchno                pellet J.PELLET           118     14      7
 FORTRAN MODIF calculel/aidty2              lefebvre J-P.LEFEBVRE        80      2      3
 FORTRAN MODIF calculel/carces                pellet J.PELLET           237     13     12
 FORTRAN MODIF calculel/celces                pellet J.PELLET           364     20     15
 FORTRAN MODIF calculel/cnocns                pellet J.PELLET           193     15     11
 FORTRAN MODIF calculel/cnscno                pellet J.PELLET           381     52     15
 FORTRAN MODIF calculel/meficg                  tran V-X.TRAN           480     33      8
 FORTRAN MODIF calculel/op0100                  tran V-X.TRAN          1114     48      9
 FORTRAN MODIF calculel/op0173              courtois M.COURTOIS         124      9      3
 FORTRAN MODIF elements/ceps33              sfayolle S.FAYOLLE           69      6      7
 FORTRAN MODIF elements/gldloc              sfayolle S.FAYOLLE          153      1      1
 FORTRAN MODIF elements/lcgldm              sfayolle S.FAYOLLE          211     25    280
 FORTRAN MODIF elements/lonseg                boyere E.BOYERE           164      2      2
 FORTRAN MODIF elements/tanmgl              sfayolle S.FAYOLLE          104     39     78
 FORTRAN MODIF elements/te0037                  tran V-X.TRAN           356     36     19
 FORTRAN MODIF elements/te0100              bargelli R.BARGELLINI       334      7      1
 FORTRAN MODIF elements/te0139              bargelli R.BARGELLINI       309      7      1
 FORTRAN MODIF elements/te0248              bargelli R.BARGELLINI       453     13      4
 FORTRAN MODIF elements/xcgfvo                  tran V-X.TRAN           172      3      2
 FORTRAN MODIF jeveux/jefini                lefebvre J-P.LEFEBVRE       168      3      3
 FORTRAN MODIF modelisa/charci                pellet J.PELLET           310     25     13
 FORTRAN MODIF modelisa/chcsur                pellet J.PELLET           150     37     46
 FORTRAN MODIF modelisa/projca                 labbe M.LABBE            268     14      6
 FORTRAN MODIF supervis/ib0mai              lefebvre J-P.LEFEBVRE       115      4      4
 FORTRAN MODIF utilitai/cmpcha                pellet J.PELLET           225    142    114
 FORTRAN MODIF utilitai/idensd                pellet J.PELLET            90     11      7
 FORTRAN MODIF utilitai/op0020              lefebvre J-P.LEFEBVRE        49     19      4
 FORTRAN MODIF utilitai/op0040                pellet J.PELLET            97     10      9
 FORTRAN MODIF utilitai/op0160                 corus M.CORUS             74     15     15
 FORTRAN MODIF utilitai/uteref              sellenet N.SELLENET         326      9      3
 FORTRAN SUPPR algorith/dyobar                 abbas M.ABBAS             79      0     79
 FORTRAN SUPPR algorith/nmdifi                 abbas M.ABBAS            106      0    106
 FORTRAN SUPPR algorith/ntrepr                 abbas M.ABBAS             39      0     39
 FORTRAN SUPPR algorith/ntstoc                 abbas M.ABBAS             68      0     68
 FORTRAN SUPPR algorith/squlis                 corus M.CORUS             59      0     59
 FORTRAN SUPPR algorith/squseg                 corus M.CORUS            122      0    122
 FORTRAN SUPPR calculel/aidtyp              lefebvre M.ADMINISTRATEUR    158      0    158
 FORTRAN SUPPR calculel/cisoli              bargelli R.BARGELLINI       115      0    115
 FORTRAN SUPPR calculel/inite2              lefebvre M.ADMINISTRATEUR     80      0     80
 FORTRAN SUPPR calculel/lc0077              bargelli R.BARGELLINI       350      0    350
 FORTRAN SUPPR calculel/lc0088              bargelli R.BARGELLINI       301      0    301
 FORTRAN SUPPR calculel/lc0090              bargelli R.BARGELLINI       464      0    464
 FORTRAN SUPPR utilitai/iredca                 corus M.CORUS            533      0    533
 FORTRAN SUPPR utilitai/iredpl                 corus M.CORUS            375      0    375
  PYTHON AJOUT Macro/post_miss_ops          courtois M.COURTOIS          52     52      0
  PYTHON AJOUT Miss/miss_post               courtois M.COURTOIS         556    556      0
  PYTHON AJOUT Stanley/salomeRunScript        assire A.ASSIRE           201    201      0
  PYTHON AJOUT Stanley/salomeVisuPylo         assire A.ASSIRE           508    508      0
  PYTHON AJOUT Templates/salomeGetStudies     assire A.ASSIRE            49     49      0
  PYTHON AJOUT Templates/salomeScript         assire A.ASSIRE           147    147      0
  PYTHON MODIF Cata_Utils/t_fonction        courtois M.COURTOIS         778     32      2
  PYTHON MODIF Comportement/elas            bargelli R.BARGELLINI        38      2      2
  PYTHON MODIF Comportement/endo_fragile    bargelli R.BARGELLINI        39      4      4
  PYTHON MODIF Comportement/endo_isot_beton   bargelli R.BARGELLINI        40      4      4
  PYTHON MODIF Comportement/vmis_isot_line   bargelli R.BARGELLINI        39      2      2
  PYTHON MODIF Lecture_Cata_Ele/make_capy_offi   lefebvre J-P.LEFEBVRE       132     76     62
  PYTHON MODIF Macro/calc_miss_ops          courtois M.COURTOIS          56     10      5
  PYTHON MODIF Macro/calc_precont_ops       bargelli R.BARGELLINI       476     37     12
  PYTHON MODIF Macro/exec_logiciel_ops        assire A.ASSIRE           429    239      5
  PYTHON MODIF Macro/macr_ecre_calc_ops      bottoni M.BOTTONI          579      5      3
  PYTHON MODIF Macro/simu_point_mat_ops        proix J-M.PROIX          689     18      6
  PYTHON MODIF Messages/algeline3             pellet J.PELLET           442      5      5
  PYTHON MODIF Messages/algorith10             corus M.CORUS            283      1      9
  PYTHON MODIF Messages/assembla            sellenet N.SELLENET         294      2      7
  PYTHON MODIF Messages/calculel4             pellet J.PELLET           374     11      3
  PYTHON MODIF Messages/cataelem            lefebvre J-P.LEFEBVRE        75     44      1
  PYTHON MODIF Messages/discretisation      bargelli R.BARGELLINI       136     10      1
  PYTHON MODIF Messages/elements5           bargelli R.BARGELLINI       231     13      3
  PYTHON MODIF Messages/execlogiciel0         assire A.ASSIRE           188    100      2
  PYTHON MODIF Messages/mecanonline5           abbas M.ABBAS            225      6      2
  PYTHON MODIF Messages/mecanonline6           abbas M.ABBAS            177      6      3
  PYTHON MODIF Messages/supervis2           courtois M.COURTOIS          45     11      1
  PYTHON MODIF Messages/supervis            lefebvre J-P.LEFEBVRE       447     25      1
  PYTHON MODIF Messages/utilitai6              corus M.CORUS            286      2     17
  PYTHON MODIF Messages/utilitai7           lefebvre J-P.LEFEBVRE        85      2      7
  PYTHON MODIF Miss/miss_calcul             courtois M.COURTOIS         314     77     47
  PYTHON MODIF Miss/miss_fichier_interf     courtois M.COURTOIS         231      1      1
  PYTHON MODIF Miss/miss_fichier_option     courtois M.COURTOIS          60      2      2
  PYTHON MODIF Miss/miss_fichier_sol        courtois M.COURTOIS         124      1      1
  PYTHON MODIF Miss/miss_resu_aster         courtois M.COURTOIS         180      1      1
  PYTHON MODIF Miss/miss_utils              courtois M.COURTOIS         281    104     15
  PYTHON MODIF Stanley/salomeVisu             assire A.ASSIRE           508      2      2
  PYTHON MODIF Stanley/stanley_engine         assire A.ASSIRE          3247     16     16
  PYTHON MODIF Utilitai/Table               courtois M.COURTOIS        1070     23      2
  PYTHON SUPPR Comportement/implex_frag     bargelli R.BARGELLINI         0      0      0
  PYTHON SUPPR Comportement/implex_isot_beto   bargelli R.BARGELLINI         0      0      0
  PYTHON SUPPR Comportement/implex_isot_line   bargelli R.BARGELLINI         0      0      0


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :   22        5113      5113             +5113
 MODIF :  169       61439      4553    4972      -419
 SUPPR :   20        3878              3878     -3878
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :  211       70430      9666    8850      +816 
