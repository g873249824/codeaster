

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR boiteau      BOITEAU Olivier        DATE 09/27/2010 - 02:59:08

--------------------------------------------------------------------------------
RESTITUTION FICHE 015544 DU 2010-09-15 12:44:09
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
    Instabilite numerique du solveur modal QZ avec les nouveaux elements de poutre
FONCTIONNALITE
   Probleme
   ========
     Lors du traitement de la fiche 11850 (Extension du calcul de la matrice
    de gyroscopie à tous les types de poutre), F.Lebouvier a rencontre des pbs
   numeriques lors de l'utilisation de la solveur modal QZ (MODE_ITER_SIMULT +
   METHODE='QZ').
   
   Analyse
   =======
      Les pbs rencontres concernent le cas-test SDLL123a (Bull en seq).
      J'ai passe 4 jours a tenter de corriger le pb sans succes. En gros, on a 2
   pathologies (suivant les types de poutre):
     - apparition aleatoire de 1 ou 2 valeurs propres abberantes (en 10**12) avec la 
   variante TYPE_QZ='QZ_SIMPLE'. On les detecte facilement (leur norme d'erreur est
   tres mauvaise) et on peut les filtrer du resultat retenus. Neanmoins, ce comportement
   numerique est inquietant et n'est pas comfortable pour l'utilisateur.
     - resultat completement faux (valeurs propres nulles et normes d'erreurs enormes)
    avec la variante 'QZ_EQUI'.
   
   RQ. Remarquons qu'en utilisant la methode de SORENSEN (methode par defaut de MODE
   _ITER_SIMULT) avec plusieurs shifts, on arrive a capturer tout le spectre convena
   blement. Donc l'utilisateur a une solution. Cependant c'est QZ qui est censee etre la
   methode insubmersible de reference !
   
   Tout ceci est facheux car la methode QZ est preconise pour resoudre avec robustesse
   des petits pbs modaux difficiles (comme ici un QEP non symetrique reel).
   En retravaillant sur le sources, j'ai trouve qqes ameliorations possibles (calcul de
   norme, transmission des donnes a LAPACK), mais elles ne resolvent pas le pb.
   
   En fait, de l'aveux meme du forum officiel de LAPACK, leurs routines dediees aux
   resolutions QZ (DGGEV, ZGGEV...) utilisees ds Aster (routine VPQZLA) sont fragiles 
   et  'can fail on suprisingly easy matrix pencils'. 
   Effectivement, en perturbant un peu les donnees (compilation en
   nodebug, seuillage des termes tres petits...) on trouve des valeurs tres differentes
   avec Aster: le cas test SDLL123a passe avec QZ_SIMPLE et QZ_EQUI plante 
   moins.
   On retrouve cette sensibilite extreme aux erreurs d'arrondis en utilisant:
      - Python/scipy 2.4.4 installe sur calibre 5 par defaut,
      - En surchargeant Aster avec les LAPACK3.2.2 telecharges du site officiel (et
     leurs dependances BLAS) en lieu et place des MKL BULL (normalement tirees de LAPACK
     3.1).
   
   Bref, je n'ai pas de solution satisfaisante. LAPACK avoue lui-même son impuissance et
   conseille a ces utilisateurs de recourir:
      - a un vieux package (GUPTRI) de 1987, plus maintenu et touffu ! J'ai essaye et
       tres vite arrete. Trop complique et trop obsolete.
      - a MATLAB qui utilise une variante plus robuste de QZ (avec "shifts
    exceptionnels" DGEHQZ). A terme elle sera incorpore ds LAPACK. Effectivement, j'ai
    essaye (merci JP) et a l'air de bien marcher sur notre pb.
   
   RQ. 
   Resoudre un QEP avec robustesse est toujours un pb mathematique ouvert et depuis une
   10aine d'annees plusieurs algos sont testes (Q-Arnoldi, QZ avec shift, algo de Benner
   cf. CR-I23/2008/044). Il faudrait leur consacrer du temps.
   
   Restitution
   ===========
    VPQZLA.f
   
   J'ai fait passe la liste des cas-tests utilisant QZ avec cette surcharge (Bull + 
   NEW10 + nodebug). Tout a l'air OK:
   fdlv106a  OK_ALARME
   fdlv112b  OK_ALARME
   forma11a  OK_ALARME
   forma11b  OK_ALARME
   sdld21c   OK_ALARME
   sdld23a   OK_ALARME
   sdld27a   OK_ALARME
   sdld27e   OK_ALARME
   sdld313c  OK_ALARME
   sdld34a   OK_ALARME
   sdll123a  OK_ALARME
   sdll123b  OK_ALARME
   sdll123c  OK_ALARME
   sdll124a  OK_ALARME
   sdll125a  OK_ALARME
   sdll125b  OK_ALARME
   sdll126d  OK_ALARME
   sdll127a  OK_ALARME
   sdll127b  OK_ALARME
   sdll127c  OK_ALARME
   sdll128a  OK_ALARME
   sdll140a  OK_ALARME
   sdll141c  OK_ALARME
   sdlx201a  OK_ALARME
   sensd09b  OK_ALARME
   --------  ---------
         25     25
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    informatique, non-rxc3xa9gression
NB_JOURS_TRAV  : 4.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 013951 DU 2009-09-28 15:36:23
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Valeur 'DECOUPE' du mot-clé STOP_SINGULIER
FONCTIONNALITE
   Probleme
   ========
     La doc U SOLVEUR n'etait pas complete sur l'utilisation du mot-cle 
   STOP_SINGULIER='DECOUPE'. En particulier, elle ne precise pas que ce parametre est
   commun a plusieurs solveurs lineaires (MF, LDLT et MUMPS ). D'autre part, le
   mecanisme de detection de singularite etant different suivant MF/LDLT et MUMPS, on
   devrait tester l'activation de ce mot-cle en changeant de solveur lineaire.
   
   Solution
   ========
     * La doc a ete mise a jour cette ete par la refonte de la doc U4 SOLVEUR en une
   doc U4 (rappel des mot-cles, 1er niveau de lecture) et une doc U2 (Notice 
   d'utilisation detaillee, 2nd niveau de lecture).
     * J'ai teste le changement de solveur ds les 2 seuls cas-tests utilisant cette
   fonctionnalite: FORMA03C et SSNL136B (Sur Bull en NEW10 nodebug). Dans les 2 cas, les 
   multiples detections de singularites se produisent au même moment ds le processus de
   chargement (qqe soit le solveur lineaire). 
   Au final, le nbre d'iterations de Newton est legerement different, mais le maximum
   de RESI_GLOB_RELA est tres proche (a 10-3% pres) et sur le meme DDL. D'autre part
   les valeurs testees via TEST_RESU ou TEST_FONCTION sont bonnes.
     * Je restitue le cas-test SSNL136B ds lequel j'ai doublonne le STAT_NON_LINE+STOP_
   SINGULIER='DECOUPE'. Le premier est avec MF (explicitement), l'autre avec MUMPS.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : U2.08.03,U4.50.01
VALIDATION
    informatique,non-régression
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR boyere       BOYERE Emmanuel        DATE 09/27/2010 - 05:01:13

--------------------------------------------------------------------------------
RESTITUTION FICHE 015593 DU 2010-09-24 04:42:49
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
    cas test simple montrant l'effet de la correction statique pour un calcul sismique sur base modale
FONCTIONNALITE
   En complément à la fiche 15536 je propose un cas test simple qui montre l'intérêt de la
   correction statique a posteriori pour le calcul d'une réponse transitoire à un séisme avec
   DYNA_TRAN_MODAL.
   
   Le test SDLD04, issu du VPCS, traite le même sujet, mais il n'est pas très pertinent
   (double correction statique, a priori et a posteriori, et pas de troncature modale ;
   chargement peu réaliste).
   Je pars de la même base, que je simplifie.
   
   Le SDLD105 a en outre une ambition pédagogique.
   
   Je joins une illustration tirée de la doc où l'on voit sur un noeud particulier l'effet
   important de la
   contribution quasi-statique d'un mode. La troncature modale aboutit à des résultats
   inexacts. La correction statique les corrige amplement.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : v2.01.105
VALIDATION
    SDLD105a
NB_JOURS_TRAV  : 3.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 015536 DU 2010-09-14 09:13:20
TYPE aide utilisation concernant Code_Aster (VERSION 7.0)
TITRE
    prise en compte des modes nxc3xa9gligxc3xa9 - calcul dynamique
FONCTIONNALITE
   Un utilisateur du CIH voulait faire un calcul sismique sur base modale. Il posait trois
   questions pertinentes :
   1 - jusqu'à quelle fréquence monter pour la base dynamique ?
   2 - que se passe-t-il si la masse effective cumulée de la base choisie n'atteint pas 100%
   de la masse effective totale ?
   3 - quel est l'intérêt de la correction statique et comment la mettre en oeuvre ?
   
   
   Voici mes conseils :
   
   1 - une règle générale en calcul modal est de prendre les modes jusqu'à deux fois la
   fréquence maximale de l'excitation.
   2 - le concept de masse modale effective ne s'applique rigoureusement que dans le cas des
   chargements par les appuis (L'exemple type est le séisme.). Dans ce cas, obtenir près de
   100% de la masse effective dans une direction garantit que l'excitation dans cette
   direction sera bien prise en compte. Plus le cumul est proche de 1, meilleure est la
   projection. Si ce n'est pas le cas, on peut s'attendre à des effets de troncature modale.
   3 - C'est là que la correction statique peut être intéressante. Comme on a respecté la
   règle qui dicte de prendre les modes jusqu'à au moins deux fois la fréquence maximale
   d'excitation, on est sûr de ne pas occulter d'effet d'amplification dynamique dû aux
   modes. En revanche il est possible que la réponse quasi-statique de certains modes "haute
   fréquence" omis dans la base modale ne soit pas négligeable. La correction statique a
   posteriori permet alors de prendre en compte leur contribution.
   
   
   Voici un résumé de sa mise en oeuvre sur l'étude proposée :
   
   I - calcul du chargement statique :
   
   CORSTA=MACRO_ELAS_MULT(MODELE=modele,
                          CHAM_MATER=chmat,
                          CHAR_MECA_GLOBAL=clim,
                          CAS_CHARGE=(
                                     _F(NOM_CAS='CORRX', CHAR_MECA=PESX,),
                                     _F(NOM_CAS='CORRY', CHAR_MECA=PESY,),
                                     _F(NOM_CAS='CORRZ', CHAR_MECA=PESZ,),
                        ));
   L'ordre de déclaration des cas de charge est important. Il doit être cohérent avec la
   déclaration des excitations dans DYNA_TRAN_MODAL.
   
   
   II -calcul des dérivés premières et secondes des accélérogrammes :
   
   d_acc1=CALC_FONCTION(DERIVE=_F(FONCTION=acc_1,),);
   d2_acc1=CALC_FONCTION(DERIVE=_F(FONCTION=d_acc1,),);
   ... pour chaque accéléro
   
   Elles seront nécessaires pour les corrections des vitesses et accélérations calculées par
   DYNA_TRAN_MODAL.
   
   
   III - calcul de la réponse transitoire
   
   dyna=DYNA_TRAN_MODAL(MASS_GENE=mass_g,
                        RIGI_GENE=rigi_g,
                        AMOR_REDUIT=(0.05,0.05,),
                        MODE_CORR=CORSTA,
                        INCREMENT=_F(INST_INIT=0.0,INST_FIN=10.23,PAS=0.0005,),
                        EXCIT=(
                               _F(VECT_GENE=chsx_g,FONC_MULT=acc_1,
                                  CORR_STAT='OUI', D_FONC_DT=d_acc1, D_FONC_DT2=d2_acc1,,),
                               _F(VECT_GENE=chsy_g, FONC_MULT=acc_2,
                                 CORR_STAT='OUI', D_FONC_DT=d_acc2h, D_FONC_DT2=d2_acc2,),
                               _F(VECT_GENE=chsz_g,FONC_MULT=acc_3,
                                  CORR_STAT='OUI', D_FONC_DT=d_acc3, D_FONC_DT2=d2_acc3,,),
                                 ),);
   
   C'est un DYNA_TRAN_MODAL "normal" avec le mot-clef MODE_CORR=CORSTA et, pour chaque
   excitation, la précision des dérivées premières et secondes des fonctions multiplicatives
   en temps (les accéléros).
   Comme indiqué au point I, l'ordre de déclaration des excitations doit être le même que
   l'ordre de déclaration des cas de charges de MACRO_ELAST_MULT.
   
   IV - restitution par base physique
   
   Elle passe classiquement par REST_GENE_PHYS ou RECU_FONCTION mais il ne faut pas oublier
   le mot clef CORR_STAT='OUI' sous peine de ne pas voir la correction apparaître.
   
   Par exemple pour un RECU_FONCTION :
   DXN19=RECU_FONCTION(RESU_GENE=dyna,NOM_CHAM='DEPL',NOM_CMP='DX',NOEUD='N19',CORR_STAT='OUI',)
   
   Dans le cas de l'étude présentée, les premiers dépouillements ne semblent pas montrer
   d'influence notable de la correction statique. 
   On peut créer des cas où son importance est plus sensible (cd fiche 15593).
   
   La méthode de correction statique est présentée par ses mots clefs bien sûr dans la doc de
   DYNA_TRAN_MODAL [U4.53.21] au paragraphe 3.5.1. Sa mise en oeuvre en séisme est décrite
   dans les docs "Réponse sismique par analyse transitoire" [R4.05.01], page 12, et dans la
   doc "Analyse sismique : application aux tuyauterie" [U2.06.09], page 33.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sans objet
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR geniaut      GENIAUT Samuel         DATE 09/27/2010 - 03:44:13

--------------------------------------------------------------------------------
RESTITUTION FICHE 015555 DU 2010-09-16 08:46:35
TYPE express concernant Code_Aster (VERSION 10.2)
TITRE
    X-FEM : cas-test de propagation 3d avec raffinement adaptatif
FONCTIONNALITE
   Contexte :
   ----------
   
   Un seul cas test teste la propagation 3D en mode mixte : sslv315.
   Dans ce test, le maillage est fixe et relativement grossier (5 éléments le long du fond de 
   fissure). De plus, on impose une propagation identique à tous les points du fond. Ainsi, le 
   fond de fissure reste une droite perpendiculaire aux bords de la structure.
   Ceci est restrictif.
   
   
   Réponse :
   ---------
   
   On propose un nouveau test de propagation 3D en mode mixte, où le front est libre de se 
   propager, avec un raffinement adaptatif qui suit le fond de fissure.
   
   La méthodologie mise en place est celle du travail de stage de Laura Chappé.
   Ce nouveau cas test pourra donc être facilement ré-utilisé pour servir de base à d'autres 
   études.
   
   sslv317a : TITRE PROPAGATION MIXTE D'UNE FISSURE 3D AVEC X-FEM ET RAFFINEMENT ADAPTATIF
   modélisation a : METHODE MAILLAGE DE PROPA_FISS
   On simule 2 pas de propagation.
   Le calcul des K est fait par CALC_G, lissage de Legendre de degré 3.
   Le test (ne non-régression) porte sur la valeur max et min de KI le long du fond de fissure, 
   au dernier pas. Cette modélisation tourne en 100s sur Bull. Un travail a été réalisé afin que 
   celui passe en PAR_LOT='OUI'.
   
   à l'avenir, ce test sera enrichi avec des modélisations b et c (pour SIMPLEX et UPWIND) lors 
   d'un prochain stage
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : v3.02.317, U2.05.02
VALIDATION
    sslv317a
NB_JOURS_TRAV  : 1.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 015572 DU 2010-09-21 06:58:19
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    X-FEM : dxc3xa9finition de fissure en 3D de type 'rectangle'
FONCTIONNALITE
   Besoin :
   --------
   
   On souhaite pouvoir définir des fissures en 3d de forme rectangulaire (avec angles arrondis).
   
   
   Solution :
   ----------
   
   Nouveau type rajouté au catalogue de fissures dans DEFI_FISS_XFEM : FORM_FISS =
   'RECTANGULAIRE'.
   Niveau vocabulaire, ce sont les mêmes mot-clés que pour une fissure elliptique :
              DEMI_GRAND_AXE 
              DEMI_PETIT_AXE 
              CENTRE         
              VECT_X         
              VECT_Y         
              COTE_FISS      
   auxquels on ajoute 
              RAYON_ANGLE   
   servant à donner la valeur du rayon des angles arrondis.
   Par défaut, RAYON_ANGLE = 0, et la fissure est donc un vrai rectangle.
   
   J'en profite pour revoir un peu la prog du calcul des level sets lorsqu'on donne une forme
   pré-définie.
   -> création d'une nouvelle routine xcatls.f pour alléger xinils.f
   Pour la fissure RECTANGLE :
   Le calcul de la LSN est identique à celui d'une ellipse
   Le calcul de la LST se fait de manière analytique en considérant 3 zones (création d'une
   routine de calcul de la distance à un rectangle à angles arrondis : disrec.f)
   
   Validation :
   Ajout d'un nouveau cas test : sslv318a : fissure X-FEM rectangulaire dans un cube
   Après création des LS, on teste en 2 points la valeur de LST.
   (aucun calcul mécanique n'est fait)
   Le test prend 8s sur Bull
   
   
   Doc :
   D6.00.01 (wiki)
   U4.82.08 
   V3.02.318
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : D6.00.01, U4.82.08, V3.02.318
VALIDATION
    sslv318a
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR idoux        IDOUX Ludovic          DATE 09/28/2010 - 10:26:51

--------------------------------------------------------------------------------
RESTITUTION FICHE 015348 DU 2010-07-16 12:51:28
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
    differrence Calibre/Bull dans la detection d'un chargement presque nul
FONCTIONNALITE
   1) Problème
   Une différence de comportement est observée entre calibre et bull sur un cas-test simple
   (non présent dans la base). 
   Sur Bull : le calcul va jusqu'au bout. 
   Sur Calibre : on n'arrive pas à passer un chargement nul, on cherche à raffiner le pas
   de temps et on s'arrête en erreur lorsqu'on a raffiné au niveau maximum.
   
   2) Analyse du problème
   L'affichage lié au changement de critère de convergence lors de la détection d'un
   chargement nul est à revoir. En fait, grâce à Thomas qui m'a pasé une de ses surcharges
   géniales, j'ai pu vérifier que le chargement nul est détecté correctement sur les deux
   plateformes. 
   Le souci, c'est simplement qu'avec le nombre d'itérations de Newton autorisées (10), on
   n'arrive pas à descendre plus bas que le résidu global maxi du pas de temps précédent sur
   calibre, tandis que sur bull on y arrive.
   
   En regardant plus en détail, on voit que ce résidu global du pas de temps prcédent est 10
   fois plus petit sur calibre que sur bull. En conséquence, le critère de convergence au
   moment du chargement nul est plus resseré sur calibre que sur bull (10 fois plus petit),
   ce qui explique pourquoi sur bull on passe, et pas sur calibre. 
   
   Une solution immédiate au problème est donc simplement d'augmenter le nombre d'itérations
   de Newton !
   Pour résumer, ce cas-test a mis en avant des différences dans le calcul de la matrice
   tangente, ce qui engendre des chemins de convergence différents, donc des résidus
   différents, donc un critère de convergence différent lors du chargement nul.
   
   3) Amélioration de la convergence
   Tous mes essais pour rapprocher calibre et bull n'ont pas été inutiles. En effet, ma
   dernière proposition (modifier les vecteurs propres calculés lorsque la matrice à
   diagonaliser est quasiment déjà diagonale) conduit à une nette amélioration de la
   convergence, et à rapprocher les résidus calculés par les deux plateformes. 
   
   --------------------------------------------------------------------------------------
   |   ITERATIONS   |      BULL      |    CALIBRE     |      BULL      |    CALIBRE     |
   |     NEWTON     |      AVANT     |     AVANT      |      APRES     |     APRES      |
   |                |                |                |                |                |
   --------------------------------------------------------------------------------------
   |   1 à 5        |    idem        |     idem       |       idem     |      idem      |
   |     6        X | 9.41297E-03  X | 9.41307E-03  X | 9.41297E-03  X | 9.41297E-03  X |
   |     7        X | 6.23368E-04  X | 6.23724E-04  X | 6.23338E-04  X | 6.23338E-04  X | 
   |     8        X | 4.13622E-05  X | 4.25020E-05  X | 4.12457E-05  X | 4.12455E-05  X | 
   |     9        X | 3.10774E-06  X | 1.24228E-05  X | 2.73153E-06  X | 2.73083E-06  X | 
   |    10        X | 3.75710E-06  X | 4.14985E-05  X | 1.88216E-07    | 1.85878E-07    | 
   --------------------------------------------------------------------------------------
   
   En pratique, je vérifie si les valeurs propres obtenues sont les mêmes que les termes
   diagonaux de la matrice à diagonaliser (à une tolérance 1e-12 près, cette tolérance étant
   une tolérance utilisée ailleurs dans les sources de EOB). Lorsque c'est le cas, on est
   dans le cas où la matrice en entrée est déjà diagonale, et j'impose alors que les vecteurs
   propres soient (1 0 0) (0 1 0) et (0 0 1). Cette modification couvre les cas où les termes
   hors diagonaux sont très petits et perturbent le calcul des vecteurs propres. 
   
   4) Restitution
   je restitue les développements qui ont permis de rapprocher sensiblement les résultats
   entre les deux plateformes. Cela impacte :
   
   dfmdf.f
   dfpdf.f
   ssnv217b
   
   Je propose de modifier le chargement du cas-tests ssnv217b. Ce cas-test a pour rôle
   principalement de faire de la couverture de code de certaines sources EOB (fiche 15347).
   Je pourrais utiliser le même chargement que dans cette fiche, afin d'illustrer l'intérêt
   du développement.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V6.04.217
VALIDATION
    tous les cas-tests ENDO_ORTH_BETON
NB_JOURS_TRAV  : 10.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR guiton       GUITON Martin          DATE 09/28/2010 - 10:43:46

--------------------------------------------------------------------------------
RESTITUTION FICHE 014112 DU 2009-10-27 16:39:59
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    X-FEM : grandes rotations sur lélements XT et XHT
FONCTIONNALITE
   GRANDES ROTATIONS X-FEM :
   Ces développements permettent d'utiliser X-FEM dans le cadre des rotations 
   finies (mot clé DEFORMATION = 'GR_ROT'). Les développements concernent 
   tous les éléments 2D et 3D X-FEM. En effet, le développement pour les 
   éléments avec des enrichissements de fond de fissure est réalisé dans 
   cette fiche après avoir été réalisé pour les éléments heaviside dans une 
   fiche précédente (Fiche 13989).Afin de prendre en compte les pointes de 
   fissures les termes dans la doc de référence x-fem sont ajoutés dans les 
   routines xnmgr2 et xnmgr3.
   
   On profite de cette restitution pour corriger les termes élémentaires 
   associés dans les routines :
   algorith/xrige2.f  
   algorith/xrige3.f
   
   Les cas tests suivants sont également modifiés (tests de non régression) 
   suite à cette correction:
   
   sdls 120b ; sdlv 130b 
   Cette fiche est restituée en même temps que la fiche 15392.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V2.04.130;V2.03.120;R7.02.12
VALIDATION
    sdls 120b ; sdlv 130b; ssnv 507*
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR massin       MASSIN Patrick         DATE 09/28/2010 - 10:43:48

--------------------------------------------------------------------------------
RESTITUTION FICHE 015392 DU 2010-07-27 11:56:55
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    X-FEM : Mailles avec plusieurs fissures
FONCTIONNALITE
   Ces travaux ont été réalisés par Maximilien Siavelis dans le 
   cadre de sa thèse sur les grands glissements XFEM à l'IFP 
   Energies Nouvelles (responsable Martin Guiton). Cette fiche est 
   restituée en même temps que la fiche 14112.
   
   Le but de cette évolution est de pouvoir prendre en compte 
   l'enrichissement Heaviside de plusieurs fissures différentes 
   dans le même élément XFEM. L'approche est pour l'instant limitée 
   à 2 fissures en D_PLAN pour un maillage linéaire sans prise en 
   compte du contact. De plus, si un élément peut "voir" 2 
   fissures, il ne peut pas être découpé par les 2 en même temps. 
   Les fonctionnalités sont donc très limitées, mais il s'agit de 
   la première étape d'un chantier qui prévoit à terme que cela 
   fonctionne en 3D, avec plus de 4 fissures "vues" par l'élément 
   XFEM (fiche 15558) ainsi que l'extension au contact (fiche 
   15559).
   
   La fiche est en 3 parties. La première décrit les changements 
   apportés à l'opérateur MODI_MODEL_XFEM, afin de pouvoir lors de 
   la concaténation, stocker sur un élément les informations de 
   plusieurs fissures. La deuxième partie décrit les modifications 
   dans les TE. La dernière partie décrit les modifications 
   apportées aux opérateurs POST_MAIL_XFEM et POST_CHAMP_XFEM, afin 
   que l'utilisateur visualise le résultat sur des mailles multi-
   Heavisides.
   
   1 / CONCATENATION DES CHAMPS NODAUX DANS MODI_MODELE_XFEM
   
   dans l'op0113, on récupère les CHAMP_NO des sd_fiss_xfem qui 
   sont :
   
   FISS(i)//'.STNO'
   FISS(i)//'.LTNO'
   FISS(i)//'.LNNO'
   
   on concatène ces champs dans des sd de type CHAMP_ELEM ELNO :
   
   MODELE//'.STNO'
   MODELE//'.LTNO'
   MODELE//'.LNNO'
   
   Ces champs ne sont donc plus des CHAMP_NO mais des CHAMP_ELEM de 
   type ELNO.
   
   On appelle les te0510 et te0514 directement pour le ligrel du 
   modèle et non pour le ligrel de chaque fissure, ainsi on 
   récupère directement en sortie les champs MODELE//'.TOPOFAC.xx' 
   et MODELE//'.TOPOSE.xxx'.
   
   Avant on récupérait des FISS(i)//'.TOPOFAC.xx' et FISS
   (i)//'.TOPOFSE.xxx' qu'il fallait concaténé dans xconel pour 
   obtenir MODELE//'.TOPOFAC.xx' et MODELE//'.TOPOFSE.xxx' . On n'a 
   plus besoin de faire cela.
   
   Pour les champs MODELE//['.BASLOC','.STNO','.LTNO','.LNNO'], le 
   nombre de points ne change pas : par contre le nombre de sous 
   points varie d'un élément à un autre (on les compte dans 
   xtyele). Il est égal au nombre de fissures "vues" par l'élément. 
   Les champs concaténés ne sont donc pas surdimensionnés, car le 
   nombre de sous points vaut zéro pour les élément non-xfem, 1 
   pour les éléments xfem traditionnels et >1 pour les élément qui 
   voient plus de 2 fissures. Un élément qui voit plusieurs 
   fissures peut donc à présent stoker les informations pour 
   chacune des fissures.
   
   L'ensemble des FISS(i)//'LISNOH' devient MODELE//'LISNOH', 
   L'appel à xdelh dans caxfem se fait donc une seule fois en 
   utilisant MODELE//'LISNOH.
   
   Dans le cas ou au moins une maille est vue par au moins 2 
   fissures, on crée la structure de données MODELE//'.FISSNO', qui 
   est un CHAMP_ELEM entier de type ELNO, le nombre de points de ce 
   champs est invariant par maille et vaut 1. Le nombre de sous 
   points en revanche vaut zéro si la maille ne voit pas au moins 2 
   fissures. Dans le cas contraire il est égal au nombre de 
   fonctions Heaviside de l'élément (il vaudra 1 si l'élément ne 
   contient que les ddl D et H1, il vaudra 2 si il contient D, H1 
   et H2). Cette structure de données doit être interrogée pour 
   savoir à quel numéro local de fissure ifiss, se rapporte le ddl 
   globale H_ifh. Cette SD est créée dans la nouvelle routine 
   xfisno, appelée par xcodec.
   
   Il était parfois plus pratique hors TE de manipuler des champs 
   noeuds plutôt que des champs élémentaires de type elno pour  
   MODELE//['.STNO','.LTNO','.LNNO'], notamment pour l'imposition 
   de conditions limites sur des noeuds xfem. On crée donc la 
   structure de donnés MODELE//'.NOXFEM', qui est un CHAMP_NO 
   entier. Le nombre de points est de 2. On active les valeurs (ZL
   (JCNSL2-1+(INO-1)*2+1) = .TRUE.) uniquement si le noeud a un 
   statut > 0 ('.STNO') pour au moins une fissure. On remplit les 
   valeurs en donnant pour ce noeud le numéro global d'une maille X-
   FEM qui le contient, ainsi que son numéro local dans cette 
   maille. Cette SD est créée dans xconno, en même temps que la 
   concaténation de '.STNO'. Elle est ensuite utilisée lors de 
   l'imposition de conditions limites (dans afddli ou cafaci qui 
   appelent xddlim ou dans charci). On teste ZL(JCNSL2-1+(INO-1)
   *2+1) pour savoir si le noeud est x-fem. Si c'est un noeud x-
   fem, on récupère les valeurs de MODELE//
   ['.STNO','.LTNO','.LNNO'] du noeud global INO via l'élément ZI
   (JCNSV2-1+(INO-1)*2+1) qui contient ce noeud localement en ZI
   (JCNSV2-1+(INO-1)*2+2).
   
   Pour les grands glissements on ne peut plus récupérer 
   directement le champ .stno. Il faut le passer par la carte en 
   champ ELEM via xmcart, dans les catalogues grands glissements 
   (gener_me_xhc_xh.cata, gener_medpl2_xhc_xh.cata, 
   gener_mecpl2_xhc_xh.cata). STANO est donc maintenant de type 
   ELEM au lieu de ELNO. On modifie aussi xappar et xmrlst qui 
   manipulaient le champ '.LTNO'.
   
   
   2 / UTILISATION DES CHAMPS DANS LES TE
   
   Dans tous les te xfem, xteini ne fournit plus l'info ddlh 
   (nombre de ddl Heaviside par noeuds, qui vaut ndim si l'élément 
   possède des Heaviside) mais nfh le nombre de fonctions Heaviside 
   (comme nfe est le nombre de fonctions crack-tip). Si nfh = 2 en 
   2d par exemple, on sait qu'on a alors les ddls H1X, H1Y, H2X, 
   H2Y dans l'élément. xteini fournit aussi n_fiss, le nombre de 
   fissures "vues" par la maille. n_fiss est pour l'instant en dur, 
   mais il sera récupéré par tecach (nombre de sous points) lors de 
   la généralisation.
   
   Lorsqu'on manipule les ddls Heaviside (lors de l'assemblage par 
   exemple) on remplace :
   
   DO 120 N=1,NNOP
     DO 122 I=1,DDLH
       ...*HE
   par :
   
   DO 120 N=1,NNOP
     DO 122 Ig=1,nfh
       DO 123 I=1,ndim
         ...*HE(fisno(n,ig))
   
   Lors de la création des éléments XFEM, c'est le noeud qui 
   possède le plus de ddls H qui définit le type d'éléments. 
   Ensuite la convention aster reste la même i.e. les autres noeuds 
   sont enrichis de la même manière et on élimine les ddls en trop.
   
   Pour l'élimination des ddl Heaviside en trop, il faut récupérer 
   le statut du ddl heaviside ifh pour le noeud ino. On remplace 
   donc dans xteddl :
   
   STANO(ino)
   par :
   
   STANO((INO-1)*nfiss+fisno(ino,ifh))
   
   afin de savoir quel est le statut du noeud ino pour le ddl 
   global H_ifh.
   
   Remarque : les ddl Heaviside éliminés sont toujours les 
   derniers, on ne peut pas éliminer H2 alors que H3 est actif.
   
   3 / POST-TRAITEMENT
    
   Pour le post-traitement, il faut adapter la stratégie, car 
   certains éléments possèdent plusieurs fonctions Heaviside. 
   La version actuelle était structurée selon: 
   
   CALL XPOMAX(..)
      CALL XPOAJN(..)  (création des noeuds)
   Pour un noeud ou un pt d'intersection sur lsn=0, on crée 2 
   noeuds associés à un signe de H
      CALL XPOAJM(..)  (création des mailles)
   On va chercher le noeud correspondant à la valeur de H dans le 
   sous-élément.
   
   Cette stratégie pose problème pour les mailles qui possèdent 
   plusieurs fonctions Heaviside, si H=(+1,-1), on ne sait pas si 
   il faut alors utiliser le noeud plus ou le noeud moins.
   
   La modification apportée est :
   
   CALL XPOMAX(..)
      CALL XPOAJM(..)  (création des mailles)
         IF le noeud n'est pas déjà crée avec les MEMES valeurs des 
   n_fiss fonctions vues par l'élément
           CALL XPOAJN(..)
         ELSE 
           on rajoute ce noeud dans la connectivité de la maille
   
   Cette stratégie permet de créer moins de noeuds en double.
   On en profite aussi pour rendre le code plus propre, les LAGS
   sont maintenant calculés uniquement du côté esclave.
   
   4/ IMPACT FORTRAN
   
   modi_modele_xfem :
   
   te0514.f  xconno.f  xdecov.f  xmoajo.f  xstan2.f  xtyele.f
   op0113.f  xmele2.f  xmolig.f  xmoini.f  xmoimp.f  xoripe.f  
   xtopoc.f
   te0510.f  xcodec.f  xdecou.f  xmmres.f  xreacg.f  xtopoi.f
   
   nouvelle routines : xtyhea.f  xfisno.f
   
   résorbé : xconnel
   
   condition limite :
   
   charci.f  afddli.f  cafaci.f  xddlim.f  caxfem.f
   
   grands glissements :
   
   xappar.f  xmacon.f  xmcart.f  xmrema.f  xmrlst.f
   
   te :
   
   merimo.f  te0036.f  te0440.f  te0536.f  xbsig2.f  xjacf2.f  
   xnmel.f   xnmpl.f   xsifle.f
   merimp.f  te0037.f  te0441.f  te0538.f  xbsig3.f  xjacff.f  
   xnmgr2.f  xpesro.f  xteddl.f
   nmelcm.f  te0046.f  te0519.f  te0539.f  xbsig.f   xmase2.f  
   xnmgr3.f  xplmat.f  xteini.f
   nmelcv.f  te0288.f  te0532.f  te0542.f  xbsigr.f  xmase3.f  
   xnmgr.f   xrige2.f
   reere3.f  te0289.f  te0533.f  te0548.f  xfovol.f  xnmel2.f  
   xnmpl2.f  xrige3.f
   reeref.f  te0297.f  te0534.f  vefnme.f  xgelem.f  xnmel3.f  
   xnmpl3.f  xsifel.f
   
   post-traitement
   
   xpoajd.f  xpoajm.f  xpoajn.f  xpocmp.f  xpoco2.f  xpoffo.f  
   xpolsn.f  xpomax.f
   
   5/ IMPACT DES CATALOGUES :
   
   ajout de la sd modele//.'fissno' dans les TE
   
   forc_noda.cata
   full_meca.cata
   raph_meca.cata
   refe_forc_noda.cata
   rigi_meca.cata
   rigi_meca_tang.cata
   
   modifs des catalogues élémentaires
   
   gener_medpl1_xht.cata, gener_medpl1_xh.cata, 
   gener_medpl1_xt.cata, gener_me_xh_2.cata,
   gener_me_xht_2.cata , gener_me_xt_2.cata :
   
   on ajoute les options FULL_MECA en 99 pour les éléments de 
   bords, pour concaténer les nouveaux champs élémentaires
   
   gener_me_xhc_xh.cata, gener_medpl2_xhc_xh.cata, 
   gener_mecpl2_xhc_xh.cata :
   
   catalogues grands glissements, STANO passe maintenant par la 
   carte, on remplace donc champ ELNO par champ ELEM
   
   d_depl_r_h2x.cata, d_depl_r_h2y.cata, d_depl_r_h2z.cata, 
   gener_medpl2_xhh.cata : nouveaux catalogues qui contiennent les 
   éléments H1,H2
    
   phenomene_modelisation__.cata :
                 MAILLE__ TRIA3     ELEMENT__ MEDPTR3_XH1
                 MAILLE__ QUAD4     ELEMENT__ MEDPQU4_XH1
                 MAILLE__ TRIA3     ELEMENT__ MEDPTR3_XH2
                 MAILLE__ QUAD4     ELEMENT__ MEDPQU4_XH2
   
   grandeur_simple__.cata : ajout H2X, H2Y, H2Z
   
   modif du catalogue affe_char_meca.capy pour ajouter des CL sur 
   H2X, H2Y, H2Z
   modif de sd_xfem.py pour prendre en compte le passage champ_no à 
   champ_elno
   ainsi que l'ajout de MODELE//'.FISSNO' et MODELE//'.NOXFEM'
   modif de xfem.py : modification de l'ancien message "les 
   fissures sont trop proche"
   
   6/ CAS TESTS
   
   on modifie les cas tests suivants pour des raisons de post-
   traitement :
   ssnp144j,k, ssnp503l, ssnv209b : le nom des noeuds testés ont 
   changés
   ssnv185b,d,n,p, ssnv182d,i : le nombre de noeuds sur les tests 
   somm a diminué
   
   ssnv510a : nouveau cas test, compression uniaxiale d'un bloc 
   multi-fissuré
   
   7/ Impact documentaire :
   
   v2.03.120 v2.04.130 v6.03.503 v6.04.185 v6.04.510
   d4.10.02 d9.05.06 r7.02.12
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V2.03.120;V2.04.130;V6.03.503;V6.04.185;V6.04.510;D4.10.02;D9.05.06;R7.02.12
VALIDATION
    V6.04.510
NB_JOURS_TRAV  : 80.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR caron        CARON Axelle           DATE 09/28/2010 - 10:43:49

--------------------------------------------------------------------------------
RESTITUTION FICHE 015448 DU 2010-08-23 12:46:56
TYPE anomalie concernant Code_Aster (VERSION 10.2)
TITRE
    X-FEM : Tests de validation X-FEM quadratique 2D
FONCTIONNALITE
   Afin de valider les éléments quadratiques 2D et la visualisation correspondante, je
   propose d'ajouter dans la base deux nouveaux cas tests décrits ci-après :
   
   ssnv508 :
   --------
   Titre  : bloc avec interface en traction et pression latérale sans contact frottement avec
   X-FEM quadratiques
   Résumé : Ce test a pour but de valider la déformée sur les 
   lèvres d'une fissure droite, en se limitant au cas où la fissure traverse complètement la
   structure (interface). Ce test met en jeu un bloc parallélépipédique en traction soumis à
   une pression latérale linéaire sur sa partie supérieure. L'interface est représentée par
   une level set droite et horizontale coupant des éléments ou en coïncidant avec leurs
   bords. Il fait intervenir les éléments X-FEM P2 qui disposent de DDL de déplacement en
   chaque noeud.
   Maillage : un test sans mailles coupées (ssnv508a), un test avec des mailles coupées
   (ssnv508b)
   
   
   ssnv509 :
   --------
   Titre  : chaînette en contact frottant avec X-FEM quadratiques
   Résumé : Ce test a pour but de valider la prise en compte du contact sur les lèvres d'une
   fissure courbe, en se limitant au cas où la fissure traverse complètement la structure
   (interface). On se place dans le cadre de la méthode continue adaptée à X-FEM avec
   résolution par le Lagrangien augmenté. Ce test met en jeu un bloc parallélépipédique en
   compression. L'interface est représentée par une level set circulaire coupant des éléments
   avec des angles variables. Il fait intervenir les éléments X-FEM P2P1 qui disposent de DDL
   de déplacement en chaque noeud et de DDL de contact/frottement sur les noeuds sommets.
   Maillage : un test en QUAD8 (ssnv509a) et un test en TRIA6 (ssnv509b)
   
   
   Pour ces deux tests, on attend d'avoir un nom avant de pouvoir faire la restitution
   validée lors du l'EDA du 23/08/10.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V6.04.508,V6.04.509
VALIDATION
    ssnv508 ssnv509
NB_JOURS_TRAV  : 10.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR proix        PROIX Jean-Michel      DATE 09/27/2010 - 02:15:38

--------------------------------------------------------------------------------
RESTITUTION FICHE 015446 DU 2010-08-23 12:01:42
TYPE evolution concernant Documentation (VERSION )
TITRE
    Etendre U2.10.01 (Aster-Zmat) xc3xa0 Aster-UMAT
FONCTIONNALITE
   Suite à la fiche, l'interface Aster-UMAT est décrite dans U2.10.01 (actuellement dévolue à
   Aster-Zmat).
   On fait référence à U2.10.01 dans D5.04.01
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U2.10.01, D5.04.01
VALIDATION
    aucune
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 015468 DU 2010-08-27 14:52:09
TYPE evolution concernant Code_Aster (VERSION 7.0)
TITRE
    ELAS_HYPER non programmé
FONCTIONNALITE
   Demande inscrite dans le cadre de l'AT
   =====================================
   
   Lors d'un calcul thermomécanique avec sur un groupma le comportement ELAS_HYPER,
   Code_Aster s’arrête dans STAT_NON_LINE avec le message :
   
   « la nature du matériau  ELAS_HYPER  n'est pas traitée, seules sont considérées les
   natures : ELAS, ELAS_ISTR, ELAS_ORTH. »
   
   En regardant plus précisément la trace d’exécution, on constate que le message est émis
   dans la routine dmat3d (calcul de la matrice de Hooke). On effectue dans cette routine un
   RCCOMA ('ELAS') pour récupérer le comportement complet : on 
   remarque que les seuls cas traités dans dmat3d sont les comportements ELAS, ELAS_ORTH,
   ELAS_ISTR
   
   Correction :
   ============
   
   En partant de l'hypothèse que l'on ne traite pas actuellement les effets de température
   dans ELAS_HYPER, (ce qui ne se fera que sur demande motivée des utilisateurs), la solution
   consiste à :
   
   - modifier la routine sigtmc.f pour éviter le type d'erreur décrit dans la fiche : si les
   déformations thermiques sont nulles, on ne va pas chercher à calculer la matrice
   d'élasticité et on ne calcule pas les contraintes correspondantes.
   - traduire les paramètres matériaux d'hyper-élasticité en paramètres d'élasticité linéaire
   standard pour pouvoir ensuite appeler les traitements qui les nécessitent (mdans le cas de
   PREDICTION='ELASTIQUE' par exemple)
   
   Validation :
   ============
   
   Dans SSNV187C, on ajoute un champ de température. Avant la modification, cela s'arrête
   comme évoqué plus haut. Maintenant cela ne plante plus et les résultats sont OK.
   On ajoute également PREDICTION='ELASTIQUE' sur un des STAT_NON_LINE. Les résultats sont
   tous OK sauf un test de non régression qui diffère de 6.E-5). Je modifie la valeur de non
   régression.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : u4.51.11
VALIDATION
    ssnv187c
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR pellet       PELLET Jacques         DATE 09/27/2010 - 02:26:21

--------------------------------------------------------------------------------
RESTITUTION FICHE 015497 DU 2010-09-06 11:43:32
TYPE evolution concernant Documentation (VERSION )
TMA : DeltaCad
TITRE
    doc D5 manquantes
FONCTIONNALITE
   La liste des documentations D5.02.XX a été enrichie par 4 nouvelles documentations:
   D5.02.01 : Introduire une nouvelle grandeur (ou une nouvelle composante),
   D5.02.02 : Introduire un nouveau type de maille ou un nouvel élément de référence,
   D5.02.03 : Introduire une nouvelle option de calcul élémentaire,
   D5.02.04 : Introduire une nouvelle modélisation dans AFFE_MODELE.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : D5.02.01  D5.02.02 D5.02.03 D5.02.04
VALIDATION
    rien de particulier
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST AJOUT sdld105a                       boyere E.BOYERE           276    276      0
 CASTEST AJOUT sslv317a                      geniaut S.GENIAUT          482    482      0
 CASTEST AJOUT sslv318a                      geniaut S.GENIAUT          106    106      0
 CASTEST AJOUT ssnv508a                       massin P.MASSIN           303    303      0
 CASTEST AJOUT ssnv508b                       massin P.MASSIN           289    289      0
 CASTEST AJOUT ssnv509a                       massin P.MASSIN           295    295      0
 CASTEST AJOUT ssnv509b                       massin P.MASSIN           293    293      0
 CASTEST AJOUT ssnv510a                       massin P.MASSIN           247    247      0
 CASTEST MODIF sdls120b                       massin P.MASSIN           337     12     12
 CASTEST MODIF sdlv130b                       massin P.MASSIN           349     12     12
 CASTEST MODIF ssnl136b                      boiteau O.BOITEAU          369    141      2
 CASTEST MODIF ssnp144j                       massin P.MASSIN           487     17      9
 CASTEST MODIF ssnp144k                       massin P.MASSIN           477     17     13
 CASTEST MODIF ssnp503l                       massin P.MASSIN           275      3      4
 CASTEST MODIF ssnv182d                       massin P.MASSIN           227      3      3
 CASTEST MODIF ssnv182i                       massin P.MASSIN           229      3      3
 CASTEST MODIF ssnv182k                       massin P.MASSIN           227     19     19
 CASTEST MODIF ssnv182l                       massin P.MASSIN           231     28      8
 CASTEST MODIF ssnv185b                       massin P.MASSIN           397      5      5
 CASTEST MODIF ssnv185d                       massin P.MASSIN           300      7      7
 CASTEST MODIF ssnv185n                       massin P.MASSIN           385      7      7
 CASTEST MODIF ssnv185p                       massin P.MASSIN           365      7      7
 CASTEST MODIF ssnv187a                        proix J-M.PROIX          254      1      1
 CASTEST MODIF ssnv187b                        proix J-M.PROIX          270      1      1
 CASTEST MODIF ssnv187c                        proix J-M.PROIX          292     25      3
 CASTEST MODIF ssnv189a                        proix J-M.PROIX          136      1      1
 CASTEST MODIF ssnv189b                        proix J-M.PROIX          136      1      1
 CASTEST MODIF ssnv189c                        proix J-M.PROIX          146      1      1
 CASTEST MODIF ssnv209b                       massin P.MASSIN           619     59      9
 CASTEST MODIF ssnv217b                        idoux L.IDOUX            224     10      9
CATALOGU AJOUT typelem/d_depl_r_h2x           massin P.MASSIN            63     63      0
CATALOGU AJOUT typelem/d_depl_r_h2y           massin P.MASSIN            63     63      0
CATALOGU AJOUT typelem/d_depl_r_h2z           massin P.MASSIN            63     63      0
CATALOGU AJOUT typelem/gener_medpl2_xhh       massin P.MASSIN           299    299      0
CATALOGU MODIF compelem/grandeur_simple__     massin P.MASSIN          2065     10     10
CATALOGU MODIF compelem/phenomene_modelisation__     massin P.MASSIN          1613      8      1
CATALOGU MODIF options/forc_noda              massin P.MASSIN            96      2      1
CATALOGU MODIF options/full_meca              massin P.MASSIN            80      2      1
CATALOGU MODIF options/raph_meca              massin P.MASSIN            82      2      1
CATALOGU MODIF options/refe_forc_noda         massin P.MASSIN            66      2      2
CATALOGU MODIF options/rigi_meca              massin P.MASSIN            61      3      2
CATALOGU MODIF options/rigi_meca_tang         massin P.MASSIN            84      2      1
CATALOGU MODIF typelem/gener_mecpl2_xhc_xh     massin P.MASSIN           187      2      2
CATALOGU MODIF typelem/gener_medpl1_xh        massin P.MASSIN            84      3      2
CATALOGU MODIF typelem/gener_medpl1_xht       massin P.MASSIN            84      3      1
CATALOGU MODIF typelem/gener_medpl1_xt        massin P.MASSIN            83      3      3
CATALOGU MODIF typelem/gener_medpl2_xhc_xh     massin P.MASSIN           188      2      2
CATALOGU MODIF typelem/gener_me_xh_2          massin P.MASSIN            94      3      2
CATALOGU MODIF typelem/gener_me_xhc_xh        massin P.MASSIN           176      2      2
CATALOGU MODIF typelem/gener_me_xht_2         massin P.MASSIN            95      3      2
CATALOGU MODIF typelem/gener_me_xt_2          massin P.MASSIN            95      3      2
CATALOPY MODIF commande/affe_char_meca        massin P.MASSIN           748      5      2
CATALOPY MODIF commande/defi_fiss_xfem       geniaut S.GENIAUT          160     17      8
 FORTRAN AJOUT algorith/disrec               geniaut S.GENIAUT          100    100      0
 FORTRAN AJOUT algorith/xcatls               geniaut S.GENIAUT          425    425      0
 FORTRAN AJOUT modelisa/xfisno                massin P.MASSIN           156    156      0
 FORTRAN AJOUT modelisa/xtyhea                massin P.MASSIN            92     92      0
 FORTRAN MODIF algeline/vpqzla               boiteau O.BOITEAU         1153     74     22
 FORTRAN MODIF algorith/merimo                massin P.MASSIN           295      2      2
 FORTRAN MODIF algorith/merimp                massin P.MASSIN           332      6      2
 FORTRAN MODIF algorith/nmelcm                massin P.MASSIN           317      2      1
 FORTRAN MODIF algorith/nmelcv                massin P.MASSIN           303      2      1
 FORTRAN MODIF algorith/op0041               geniaut S.GENIAUT          341     13      4
 FORTRAN MODIF algorith/op0113                massin P.MASSIN           224      6     67
 FORTRAN MODIF algorith/vefnme                massin P.MASSIN           298      7      4
 FORTRAN MODIF algorith/xappar                massin P.MASSIN           369     12      4
 FORTRAN MODIF algorith/xcodec                massin P.MASSIN           112     29     24
 FORTRAN MODIF algorith/xconno                massin P.MASSIN           215     90     73
 FORTRAN MODIF algorith/xdecou                massin P.MASSIN           230     51     13
 FORTRAN MODIF algorith/xdecov                massin P.MASSIN           479     53     30
 FORTRAN MODIF algorith/xinils               geniaut S.GENIAUT          224     12    372
 FORTRAN MODIF algorith/xjacf2                massin P.MASSIN           229      6      4
 FORTRAN MODIF algorith/xjacff                massin P.MASSIN           220      6      4
 FORTRAN MODIF algorith/xmase2                massin P.MASSIN           224      9      7
 FORTRAN MODIF algorith/xmase3                massin P.MASSIN           227      7      5
 FORTRAN MODIF algorith/xmcart                massin P.MASSIN           361    108     54
 FORTRAN MODIF algorith/xmele2                massin P.MASSIN           304     25      1
 FORTRAN MODIF algorith/xmilac                massin P.MASSIN           211      5      7
 FORTRAN MODIF algorith/xmmred                massin P.MASSIN           100      2      4
 FORTRAN MODIF algorith/xmmres                massin P.MASSIN           462     20      8
 FORTRAN MODIF algorith/xmrema                massin P.MASSIN           373      6      3
 FORTRAN MODIF algorith/xmrlst                massin P.MASSIN           122     12      8
 FORTRAN MODIF algorith/xnmel2                massin P.MASSIN           429     21     17
 FORTRAN MODIF algorith/xnmel3                massin P.MASSIN           434     26     21
 FORTRAN MODIF algorith/xnmel                 massin P.MASSIN           249     46     23
 FORTRAN MODIF algorith/xnmgr2                massin P.MASSIN           407     86     62
 FORTRAN MODIF algorith/xnmgr3                massin P.MASSIN           443     96     66
 FORTRAN MODIF algorith/xnmgr                 massin P.MASSIN           208     38     16
 FORTRAN MODIF algorith/xnmpl2                massin P.MASSIN           381     23     17
 FORTRAN MODIF algorith/xnmpl3                massin P.MASSIN           389     30     23
 FORTRAN MODIF algorith/xnmpl                 massin P.MASSIN           226     40     16
 FORTRAN MODIF algorith/xoripe                massin P.MASSIN           419     39     25
 FORTRAN MODIF algorith/xplmat                massin P.MASSIN            72      6      6
 FORTRAN MODIF algorith/xreacg                massin P.MASSIN            90      1     90
 FORTRAN MODIF algorith/xrige2                massin P.MASSIN           220     45    103
 FORTRAN MODIF algorith/xrige3                massin P.MASSIN           221     48    103
 FORTRAN MODIF algorith/xstan2                massin P.MASSIN           234     30     49
 FORTRAN MODIF algorith/xtopoc                massin P.MASSIN           151     17     18
 FORTRAN MODIF algorith/xtopoi                massin P.MASSIN           142     14     15
 FORTRAN MODIF elements/btdbmc                 proix J-M.PROIX          228      2      2
 FORTRAN MODIF elements/dmat3d                 proix J-M.PROIX          289     36      2
 FORTRAN MODIF elements/dmatcp                 proix J-M.PROIX          203     21      2
 FORTRAN MODIF elements/dmatdp                 proix J-M.PROIX          273     33      2
 FORTRAN MODIF elements/reere3                massin P.MASSIN           228     17     14
 FORTRAN MODIF elements/reeref                massin P.MASSIN           251     17     15
 FORTRAN MODIF elements/sigtmc                 proix J-M.PROIX          136     12      3
 FORTRAN MODIF elements/te0036                massin P.MASSIN           520     18     12
 FORTRAN MODIF elements/te0037                massin P.MASSIN           337      8      7
 FORTRAN MODIF elements/te0046                massin P.MASSIN           199      6      6
 FORTRAN MODIF elements/te0288                massin P.MASSIN           245     10     13
 FORTRAN MODIF elements/te0289                massin P.MASSIN           201      3      3
 FORTRAN MODIF elements/te0297                massin P.MASSIN           332     10     12
 FORTRAN MODIF elements/te0440                massin P.MASSIN           187      9      6
 FORTRAN MODIF elements/te0441                massin P.MASSIN           208      9      7
 FORTRAN MODIF elements/te0510                massin P.MASSIN           214     18      6
 FORTRAN MODIF elements/te0514                massin P.MASSIN           421     99     39
 FORTRAN MODIF elements/te0519                massin P.MASSIN           147      9      7
 FORTRAN MODIF elements/te0532                massin P.MASSIN           328      7      7
 FORTRAN MODIF elements/te0533                massin P.MASSIN          1085     50     50
 FORTRAN MODIF elements/te0534                massin P.MASSIN           913     37     35
 FORTRAN MODIF elements/te0536                massin P.MASSIN           128      8      9
 FORTRAN MODIF elements/te0538                massin P.MASSIN           125      9      8
 FORTRAN MODIF elements/te0539                massin P.MASSIN           329     24     21
 FORTRAN MODIF elements/te0542                massin P.MASSIN           121     11     11
 FORTRAN MODIF elements/te0548                massin P.MASSIN           338      7      7
 FORTRAN MODIF elements/xbsig2                massin P.MASSIN           218     21     17
 FORTRAN MODIF elements/xbsig3                massin P.MASSIN           218     23     17
 FORTRAN MODIF elements/xbsig                 massin P.MASSIN           191     36     14
 FORTRAN MODIF elements/xbsigr                massin P.MASSIN           198     38     15
 FORTRAN MODIF elements/xfovol                massin P.MASSIN           251      4      2
 FORTRAN MODIF elements/xgelem                massin P.MASSIN           458     47     19
 FORTRAN MODIF elements/xpesro                massin P.MASSIN           213      5      3
 FORTRAN MODIF elements/xsifel                massin P.MASSIN           576     48     17
 FORTRAN MODIF elements/xsifle                massin P.MASSIN           396      5      5
 FORTRAN MODIF elements/xteddl                massin P.MASSIN           275     38     20
 FORTRAN MODIF elements/xteini                massin P.MASSIN           134     22     17
 FORTRAN MODIF modelisa/afddli                massin P.MASSIN           186     23      5
 FORTRAN MODIF modelisa/cafaci                massin P.MASSIN           471     23     12
 FORTRAN MODIF modelisa/caxfem                massin P.MASSIN           177     11     25
 FORTRAN MODIF modelisa/charci                massin P.MASSIN           297      8     13
 FORTRAN MODIF modelisa/xddlim                massin P.MASSIN           342    119     68
 FORTRAN MODIF modelisa/xloria               geniaut S.GENIAUT           75      3      2
 FORTRAN MODIF modelisa/xmacon                massin P.MASSIN           238     10     17
 FORTRAN MODIF modelisa/xmoajo                massin P.MASSIN           117     19      5
 FORTRAN MODIF modelisa/xmoimp                massin P.MASSIN           159     13      9
 FORTRAN MODIF modelisa/xmoini                massin P.MASSIN           107      8      3
 FORTRAN MODIF modelisa/xmolig                massin P.MASSIN           439     83     42
 FORTRAN MODIF modelisa/xtyele                massin P.MASSIN           338     79     18
 FORTRAN MODIF prepost/xpoajd                 massin P.MASSIN           291    147    214
 FORTRAN MODIF prepost/xpoajm                 massin P.MASSIN           225    120     45
 FORTRAN MODIF prepost/xpoajn                 massin P.MASSIN           158     72     50
 FORTRAN MODIF prepost/xpocmp                 massin P.MASSIN           138     10     17
 FORTRAN MODIF prepost/xpoffo                 massin P.MASSIN           135      6      4
 FORTRAN MODIF prepost/xpolsn                 massin P.MASSIN           148     52     39
 FORTRAN MODIF prepost/xpomax                 massin P.MASSIN           533    138    173
 FORTRAN MODIF utilitai/dfmdf                  idoux L.IDOUX            318     78     12
 FORTRAN MODIF utilitai/dfpdf                  idoux L.IDOUX            318     79     19
 FORTRAN SUPPR algorith/xconel                massin P.MASSIN           241      0    241
  PYTHON MODIF Messages/xfem                  massin P.MASSIN           417     51      1
  PYTHON MODIF SD/sd_xfem                     massin P.MASSIN           135     10      7


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :   16        3552      3552             +3552
 MODIF :  143       42189      3567    2830      +737
 SUPPR :    1         241               241      -241
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :  160       45982      7119    3071     +4048 
