

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR boiteau      BOITEAU Olivier        DATE 10/26/2010 - 03:26:21

--------------------------------------------------------------------------------
RESTITUTION FICHE 015778 DU 2010-10-20 15:47:28
TYPE express concernant Code_Aster (VERSION 9.1)
TITRE
    calcul modal + MATR_GENE+ SOLVEUR MUMPS
FONCTIONNALITE
   PROBLEME
   ========
     Actuellement, l'utilisateur ne peut pas faire un calcul modal s'appuyant sur des matrices
     MATR_GENE (pas forcement issues d'un calcul avec maillage, mais par ex. d'une campagne de
     mesures) en utilisant un autre solveur lineaire que 'LDLT'.
     Si il choisit 'MULT_FRONT' ou 'MUMPS', on lui impose par derriere 'LDLT' (en l'avertissant
     du changement via ALGELINE5_72). Or ce solveur peut etre tres lent sur de gros problemes.
   
   SOLUTION
   ========
     On impose a la place le solveur lineaire 'MUMPS' qui est beaucoup plus rapide et econome
     en memoire. On laisse le message ALGELINE5_72,en le modifiant en consequence
   
   72: _("""
       Les matrices utilisées ne s'appuient pas sur des données issues d'un maillage.
       Dans ce cas on doit utiliser, soit le solveur linéaire LDLT, soit celui MUMPS.
       On a donc changé le paramétrage pour vous et selectionné le solveur linéaire
       MUMPS (avec son paramétrage usuel par défaut).
       Conseil:
       ========
       La prochaine fois, dans une telle situation (NUME_DDL_GENE...), paramétrer
       explicitement SOLVEUR/METHODE='MUMPS'.
   """),
   
      RQ1. Le solveur 'MULT_FRONT' reste prohibe ds ce cas.
      RQ2. On en profite pour corriger un pb d'affichage ds ce cas avec le monitoring
           MUMPS (si INFO=2). On ne peut lire le nbre de mailles (on laisse -9999 valeur
          par defaut).
   
   OPERATEURS IMPACTES
   ===================
     IMPR_STURM (au cas ou ,car bizarrement il n'accepte pas encore de MATR_GENE)
     MODE_ITER_SIMULT/INV
   
   VALIDATION
   ==========
     On enrichi le petit cas-test SDLD102C (masse-ressort + calcul par sous-structuration) 
     qui utilise (en autre) des MATR_GENE + MODE_ITER_SIMULT:
     - on impose le solveur lineaire MULT_FRONT (en explicitant ds le cas-test pourquoi on
      fait cela) pour forcer le mecanisme de changement,
     - on duplique une partie des calculs en les basant sur MODE_ITER_INV + MULT_FRONT pour
     susciter le meme mecanisme ds cet operateur.
   
     On valide donc 2 fois tous le processus de sous-structuration mis en place en changeant
     de solveur modal. Et en plus, on valide cette extension de perimetre des solveurs
     lineaires vis-a-vis des solveurs modaux.
   
   SOURCES IMPACTEES
   =================
   crsvl2.f  crsvmu.f  op0032.f  op0044.f  op0045.f
   algeline5.py
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : U4.50.01,U2.08.03
VALIDATION
    informatique,non-regressuin,fonctionnel
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 015782 DU 2010-10-21 07:38:30
TYPE express concernant Code_Aster (VERSION 9.1)
TITRE
    Extension du pxc3xa9rimxc3xa8tre d'utilisation d'IMPR_STURM aux MATR_GENE
FONCTIONNALITE
   PROBLEME
   =========
   En faisant des tests autour des opérateurs modaux, linéaires et du parallélisme, je me suis
   aperçut que l'operateur IMPR_STURM (op. modal de diagnostic permettant de calibrer son
   spectre de calcul avec un GEP sym reel) ne permet pas l'usage de matrices generalisees.
   C'est fonctionnellement contradictoire avec le fait que ces matrices soient acceptees
   par les op. modaux classiques: MODE_ITER_INV et MODE_ITER_SIMULT.
   
   SOLUTION
   =========
   On corrige ce trou de perimetre d'utilisation en rendant possible l'usage IMPR_STURM +
   MATR_GENE.
   
   RQ1. QUESTION SUBSIDIAIRE AUX DYNAMICIENS
   =========================================
   Pourquoi la macro MACRO_MODE_MECA (qui encapsule MODE_ITER_SIMULT) ne permet pas, elle-
   aussi, l'usage des MATR_GENE ? C'est moins grave en terme de faille ds le perimetre d'utilis
   ation qu'IMPR_STRURM (une macro est destinee a un besoin precis et n'a pas mission d'univer
   salite), mais quand meme, y'a t'il une raison fonctionnelle ?
   
   RQ2. A contrario, vue ses objectifs, on comprend pourquoi l'autre macro modal, CALC_MODAL,
   ne permet pas les MATR_GENE. 
   
   OPERATEUR IMPACTE
   ==================
    IMPR_STURM
   
   VALIDATION
   ===========
    1 appel IMPR_STURM + MATR_GENE ds le cas-test SDLD102C
   
   SOURCES RESTITUEES
   ==================
    op0032.f, impr_sturm.capy
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : U4.50.01
VALIDATION
    informatique, non-regression,fonctionnel
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 015637 DU 2010-09-30 09:05:50
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.2.17, le cas-test feti003c est NOOK sur Bull MPI.
FONCTIONNALITE
   PROBLEME
   =========
          NOOK heratiques sur feti003c en NEW10_mpi (Bull)
   ANALYSE
   ========
   En lançant le cas-test une dizaine de fois, j'ai pu reproduire le NOOK 2 fois. Pour 
   ce faire, il suffit de baisser legerement la memoire, de 764Mo a 740Mo par exemple. 
   Mais, la je n'y arrive plus !
   En utilisant les affichages du monitoring FETI, j'ai cru voir que le pb venait du
   partitionneur SCOTCH.
   On sait depuis longtemps qu'il peut être instable (j'ai la fiche 13095 sur ce 
   sujet) et particulierement en parallele (pb de graine distincte suivant les proc 
   pour les algos evolutionnaires).
   J'ai deja contacte F.Pellegrini plusieurs fois sur le sujet. Il m'a propose 
   recemment d'upgrader notreversion, de la v4.0 a la 5.1.6.
   Il est sans doute plus sage de faire cet upgrade apres la stabilisation (j'emet la 
   fiche associee).
   
   Conformement aux voeux de l'EDA, en // uniquement, on debranche provisoirement le 
   choix de SCOTCH ds DEFI_PART_FETI en attendant la montee de version. On laisse le 
   choix ds les capy (DEFI_PART_FETI et DEFIT_PART_PA_OPS), mais ce n'est plus le
    choix par defaut, et ds le fortran (FETSKP), si 
   l'utilisateur a choisit SCOTCH on lui impose KMETIS avec un msg d'eclaircissement
   (UTILITAI_53):
   53 : _("""
    Vous avez choisi le partitionneur SCOTCH pour un calcul parallèle. Celui-ci est
     momentanement débranché de cette fonctionnalité. On préconise à la place la
     méthode KMETIS. On a fait le changement de méthode pour vous lors de ce calcul
    de partitionnement.
    Une autre possibilité consiste à faire votre calcul en 2 étapes:
      - un calcul séquentiel qui génère votre partitionnement créé via SCOTCH,
      - le reste de votre calcul (FETI, MUMPS avec distribution par SOUS_DOMAINES...)
        en parallèle.
    Sinon, si vous avez un besoin spécifique lié à l'usage de Scotch, contactez 
    l'équipe de développement.
   """),
   
   COMMANDES IMPACTEES
   ===================
     DEFI_PART_FETI
     DEFI_PART_PA_OPS
   
   SOURCES RESTITUEES
   ==================
       defi_part_feti.capy, defi_part_pa_ops.capy
       fetskp.f
       utilitai.py
   
   VALIDATION
   ==========
     FETI003C, FETI003D et FETI007A
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    informatique, non-regression
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 015554 DU 2010-09-16 08:32:40
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.2.15, le cas-test feti005b s'arrete en erreur_<F> sur Bull.
FONCTIONNALITE
   PROBLEME
   ========
     Cas-test feti005b casse en 10.2.15 sur Bull: ASSEMBLA_36 --> NOEUD INEXISTANT (ds
   NUEFFE/RENUNO)
   ANALYSE
   ========
     Si on change le solveur lineaire de FETI a MULT_FRONT, LDLT ou MUMPS, il plante sur le
   meme pb. C'est
     donc du a un pb ds la construction des structures de donnees de la modelisation, en
   amont du solveur 
     (grosse restit en 10.2.15 sur le sujet).
     Le pb a ete corrige depuis, le cas-test fonctionne et est OK en 10.2.21.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    informatique, non-regression
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 015354 DU 2010-07-19 05:36:39
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Plantage MUMPS
FONCTIONNALITE
   PROBLEME
   ========
      Planton avec MUMPS en parallele distribue en erreur DMUMPS_254
   ANALYSE
   =======
     Cas de THM de bonne taille (N=0.7M ) en reel symetrique regulier. On a un planton
   heratique se produisant
     au bout de plusieurs dizaines d'heures sur C2 avec 16 proc. Il s'agit d'un pb
   d'allocation de BUFFER au 
     fin fond de MUMPS (erreur DMUMPS_254).
     L'equipe MUMPS a ete contactee et ne voit pas comment une telle erreur peut se produire
   ds notre cas.
     On arrive pas a reproduire le planton. Peut-etre est-ce du a un d'installation de MUMPS
   (et des dependan
     ces) ou de MPI sur Clamart 2 ?
     Le pb n'etant pas re-apparut ds les runs de Romeo, on clot la fiche.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    informatique, non-regression
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 015792 DU 2010-10-22 09:27:27
TYPE express concernant Code_Aster (VERSION 9.1)
TITRE
    Mauvais formattage de l'affichage MESURE_TEMPS item 4
FONCTIONNALITE
   PROBLEME
   ========
   Fiche tres cosmetique pour corriger l'affichage des perf en temps gerees par le mot-cle 
   MESURE_TEMPS de la cmde DEBUT. L'item 4 s'affichait en majuscule et en minuscule.
   J'homogeneise en miniscule.
   Au lieu de :
   #2.2.1 Assemblage matrices                 CPU (USER+SYST/SYST/ELAPS): 0.00   0.00  0.00
   #2.2.2 Assemblage seconds membres          CPU (USER+SYST/SYST/ELAPS): 0.00   0.00  0.00
   #4 DECHARGEMENT DE LA MEMOIRE SUR DIsque   CPU (USER+SYST/SYST/ELAPS): 0.03   0.02  0.03
   
   On a maintenant:
   
   #4 Dechargement de la memoire sur disque   CPU (USER+SYST/SYST/ELAPS): 0.03   0.02  0.03
   
   SOURCE RESTITUEE
   ================
     uttcpl.f
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    informatique
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 10/25/2010 - 04:46:34

--------------------------------------------------------------------------------
RESTITUTION FICHE 015772 DU 2010-10-20 08:35:44
TYPE express concernant Code_Aster (VERSION 9.1)
TITRE
    Problxc3xa8me de compilation avec gfortran 4.1.2
FONCTIONNALITE
   La routine mffami.F ne compile pas avec la vieille version de 
   gfortran présente sur les Calibre5.
   
   LEN ne parvient pas à trouver la longueur dans le tableau de 
   chaînes de caractères :
   
          CHARACTER*(*) ATTDES(*),GRO(*)
   -      CALL ASSERT(LEN(ATTDES).EQ.200)
   -      CALL ASSERT(LEN(GRO).EQ.80)
   +      CALL ASSERT(LEN(ATTDES(1)).EQ.200)
   +      CALL ASSERT(LEN(GRO(1)).EQ.80)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    10.2.21 sur Calibre5
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 015777 DU 2010-10-20 14:32:10
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    NEW10.2.20 Tests umat/zmat en ERREUR_<F>
FONCTIONNALITE
   Problème
   ========
   
   Les tests UMAT/ZMAT sont cassés en 10.2.20.
   
   
   Correction
   ==========
   
   En découpant la routine qui gérait la liste des symboles chargés 
   dynamiquement (pour libérer la bibliothèque correctement), j'ai 
   fait un appel au dictionnaire avant l'initialisation de celui-
   ci.
   
   Impact : dll_interface.c, dll_umat.c, dll_zmat.c, dll_yacs.c
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    umat/zmat
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 015822 DU 2010-10-25 07:04:00
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    MED en entier court : marche arrixc3xa8re
FONCTIONNALITE
   Suite à l'évolution en 10.2.21 permettant d'utiliser MED avec 
   des entiers courts pour faciliter la gestion des différentes 
   installations de MED, on a constaté plusieurs anomalies.
   
   On décide de faire (partiellement) marche arrière :
   
   - on garde la possibilité d'utiliser MED avec des entiers 
   courts (4 octets) : pour cela, définir le flag de 
   précompilation _USE_MED_SHORT_INT et, bien entendu, construire 
   l'exécutable avec la bibliothèque MED compilée sans forcer la 
   taille des entiers à 8 octets.
   
   - au moins dans un premier temps, la version utilisée par 
   défaut reste celle avec la taille des entiers forcée à 8 
   octets (option de compilation lors de la construction de MED).
   
   
   Bilan des problèmes rencontrés avec les entiers courts :
   - sur aster4, si on compile MED avec gcc/gfortran (4.3), 
   énormément de tests plantent. En compilant MED avec icc/ifort, 
   ça se passe beaucoup mieux !
   - sur bull, calibre5, aster4 : les tests utilisant de "gros" 
   maillages plantent. Après correction de l'interface Fortran/C 
   de MED (mauvaise déclaration des longueur des chaînes de 
   caractères en arguments), ils passent partout... sauf sur Bull 
   !
   - valgrind échoue dans l'analyse sur aster4 à l'endroit où le 
   code plante sur Bull...
   
   
   Pour les versions locales :
   - en 32 bits, rien à faire.
   - en 64 bits, si on n'a pas fait la mise à jour 10.2.21, rien 
   à faire.
   - en 64 bits si on est en 10.2.21 (donc avec MED utilisant des 
   entiers courts), il y a 2 choix :
    1. rester en i4 : il faut faire la mise à jour après avoir 
   ajouter _USE_MED_SHORT_INT dans les defined (ligne DEFS du 
   config.txt) au risque d'avoir des plantages sur de gros 
   maillages
    2. repasser en i8 : recompiler MED en forçant les entiers à 8 
   octets (prendre les options utilisées par aster) et indiquer 
   la bibliothèque i8 dans le config.txt.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    tests avec gros maillages
NB_JOURS_TRAV  : 3.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 015798 DU 2010-10-22 13:51:19
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.2.21, les cas-test perf001c, perf001d, perf002c s'arretent en erreur anormale _<F> sur Bull et Cal5
FONCTIONNALITE
   résolue par issue15822
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    tests listxc3xa9s
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 015799 DU 2010-10-22 14:26:28
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.2.21, les cas-test perf008c et perf008d s'arretent en erreur anormale _<F> sur Bull
FONCTIONNALITE
   résolue par issue15822
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    tests listxc3xa9s
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 015800 DU 2010-10-22 14:30:54
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.2.21, le cas-test perf005c s'arrete en test NOOK sur Aster4
FONCTIONNALITE
   On retire l'appel à TEST_TEMPS.
   Le suivi des performances est assuré sur l'ensemble des cas-
   tests sur la page dédiée.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    perf005c
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR delmas       DELMAS Josselin        DATE 10/26/2010 - 10:48:52

--------------------------------------------------------------------------------
RESTITUTION FICHE 015828 DU 2010-10-26 08:21:02
TYPE express concernant Code_Aster (VERSION 10.2)
TITRE
    Oublie d'un test lors de la restitution de issue15308
FONCTIONNALITE
   Lors de la restitution de la fiche issue15308 on a oublié de restitué le cas test validant
   la correction (sdls106d).
   
   On répare cet oubli.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V2.03.106
VALIDATION
    passage du test
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desoza       DE SOZA Thomas         DATE 10/26/2010 - 02:04:11

--------------------------------------------------------------------------------
RESTITUTION FICHE 015723 DU 2010-10-12 15:45:33
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.2.18, le cas-test sdnv105a est NOOK sur Bull.
FONCTIONNALITE
   Anomalie
   ========
   
   Depuis la 10.2.18, le cas-test SDNV105A (rebonds d'un bloc en graphite sur une table
   rigide) est NOOK sur Bull pour une valeur d'énergie cinétique.
   
   Analyse
   =======
   
   Ce cas-test et ses différentes modélisations posent souvent problème car les valeurs de
   référence bien qu'analytiques sont très sensibles. Il y a plusieurs raisons à cela :
   
   - l'impact doit être parfaitement capturé pour que la référence analytique s'applique (on
   pourra bientôt faire beaucoup de pas de temps en utilisant un évènement déclencheur)
   
   - il ne faut pas dissiper numériquement de l'énergie lors des chocs (cf. issue13081)
   
   - ce cas-test comporte peu de mailles (donc de noeuds en contact), la moindre déviation
   sur le nombre de noeuds contactants provoque immédiatement de larges différences.
   
   En étudiant les tableaux de convergence sur Bull de la 10.2.17 et la 10.2.21 on se rend
   compte que les différences sont :
   
   - à certains pas de temps, le nombre d'itérations de l'algorithme de résolution
   (lagrangien 2D contact/frottement) est différent mais le résidu n'est pas impacté
   
   - à certains pas de temps, le nombre de liaisons finales de contact ou de frottement est
   différent et le résidu est impacté
   
   Ces différences s'expliquent par la "discontinuité" des tests réalisés dans le
   contact/frottement (est-ce que le jeu > epsilon ? est-ce que les pressions sont < 0 ?) qui
   vont peu modifier le résultat final (une liaison en plus ou en moins). Mais comme il n'y a
   que 5 noeuds esclaves donc 5 liaisons possibles, c'est assez problématique ici, cela
   modifie beaucoup les réactions de contact par exemple.
   
   En analysant d'où proviennent ces différences (d'une version à l'autre) on constate que le
   fait que les maillages soient compatibles entraîne une incertitude sur la maille appariée.
   
   Correction
   ==========
   
   Pour pallier à cette incertitude, je propose de changer l'appariement de maître esclave
   vers 'NODAL'. Avec cette solution on voit alors que le test est NOOK sur un test (25%
   d'erreur pour 25% de tolérance) mais au moins c'est le même comportement sur *toutes* les
   plateformes en debug comme en nodebug (ce n'était pas le cas avant, par exemple en NEW10
   debug le test n'est pas cassé sur Bull).
   
   J'ajuste donc la tolérance à 26% sur le test fautif.
   
   Remarque : cette correction stabilise les résultats sans toutefois les améliorer
   grandement (certains tests sont meilleurs, d'autre non), ceci devant être traité dans les
   autres fiches citées plus haut.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sdnv105a
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 015656 DU 2010-10-04 12:20:20
TYPE anomalie concernant Code_Aster (VERSION 10.3)
TITRE
    AFFE_CHAR_MECA : temps CPU tres eleve
FONCTIONNALITE
   Anomalie
   ========
   
   En NEW10, le temps d'un AFFE_CHAR_MECA/DDL_IMPO ou FACE_IMPO sur un modèle XFEM a explosé
   par rapport à la STA10 : 
   
   Exemple (sslv313b)
   '''
   STA10.2 : * AFFE_CHAR_MECA           :      61.02 :       0.91 :      61.93 :      61.99 *
   NEW10   : * AFFE_CHAR_MECA           :     402.76 :      34.14 :     436.90 :     440.45 *
   '''
   
   L'AFFE_CHAR_MECA concerné ressemble à :
   
   '''
   SYMETRI = AFFE_CHAR_MECA(MODELE=MODELEK,
                         DDL_IMPO=(
                                   _F(GROUP_NO = 'LH',   DY=0.0,),
                                   _F(GROUP_NO = 'FACE1',DZ=0.0,),
                                  ),
                         FACE_IMPO=_F(GROUP_MA= 'FACE2',
                                       DNOR=0.0,),
                         );
   '''
   
   Analyse
   =======
   
   Le temps passé est du au traitement spécifique pour XFEM dans le cas DDL_IMPO/FACE_IMPO
   
   Un profiling de la STA10 et de la NEW10 sur ce test montre 2 choses :
   
   - en NEW10 on a décuplé le nombre d'appels à l'utilitaire de transformation d'un champs
   aux noeuds en champ simple (CNOCNS). Il semblerait que l'objectif était de réduire le
   nombre d'appels à XDDLIM (qui réalise le traitement XFEM) mais malheureusement on appel du
   coup beaucoup plus de fois CNOCNS qui coûte très cher !
   
   - en STA10 on peut déjà considérer le temps passé dans l'AFFE_CHAR_MECA comme anormal
   (60s). On s'aperçoit via le profiling que l'utilitaire CNOCNS (encore lui) est trop appelé
   : à chacun des appels à XDDLIM on construit des champs simples qui ne dépendent pas des
   entrées de XDDLIM (des invariants de boucles en quelque sorte).
   ==> ceci signifie que la création de ces champs doit être remonté de plusieurs niveaux.
   
   La conclusion finale qui s'impose c'est que lorsque l'on a développé le traitement de
   DDL_IMPO/FACE_IMPO pour XFEM, on aurait du réaliser des routines dédiées : par CAFACI pour
   "FEM" et CAFICX pour "XFEM". On en arrive en effet à alourdir beaucoup CADDLI/CAFACI les
   routines responsables de DDL_IMPO/FACE_IMPO.
   
   Correction
   ==========
   
   Impact : cafaci.f, caddli.f, caddlp.f, afddli.f, xddlim.f
   
   On remonte les créations de champs simples (cham_elem et cham_no) vers CAFACI/CADDLI.
   Il est à mon avis utile de songer à la reprogrammation du traitement XFEM en dehors de ces
   routines.
   
   Validation
   ==========
   
   NEW10 : * AFFE_CHAR_MECA           :      18.21 :       0.26 :      18.47 :      18.46 *
   
   ==> on peut encore gagner en reprogrammant (le profiling de la version "corrigée" montre
   que CNCINV est un invariant de XDDLIM, on pourrait donc passer de 35 appels à 1 seul sur
   SSLV313B)
   
   Remarque
   ========
   
   À l'occasion du profiling, Mathieu a découvert un formidable utilitaire que l'on décrit
   dans la doc D1.06.01 "Mesurer les performances CPU". Il s'agit d'un script python
   "gprof2dot" qui produit (via graphviz) un magnifique graphe en couleur (cf PJ) qui résume
   parfaitement le profiling.
   
   NB_JOURS_TRAV : 1.0 (0.5 MC / 0.5 TdS)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : D1.06.01
VALIDATION
    sslv313b
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 015793 DU 2010-10-22 11:36:39
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.2.21, le cas-test sdnv100g s'arrxc3xaate par non convergence sur Calibre 5 et Aster4
FONCTIONNALITE
   Anomalie
   ========
   
   En 10.2.21, le cas-test SDNV100G s'arrête en non convergence sur Calibre5 et Aster4.
   
   ------------------------------------------------------------------------------------------------------------------------
   |     1        X |     2        X | - SANS OBJET - |     0        X | 5.00000E-01  X |
   3.79936E+30    |TANGENTE        |
   |     1        X |     2        X | - SANS OBJET - |     1        X | 8.78637E-01  X |
   6.67749E+15    |TANGENTE        |
   
   
   Correction
   ==========
   
   Comme on le voit le résidu explose. Il y a en effet une variable non initialisée dans le
   calcul des matrices élémentaires (TE0364, PRFUSU liée à l'usure) depuis 10 mois !!
   
   On initialise cette valeur et tout rentre dans l'ordre.
   
   On profite de l'occasion pour corriger dans TE0365 un petit bug sur SANS_GROUP_NO_FR (on
   ne mettait pas bien à zéro le second membre, ce qui pouvait poser des problèmes dans le
   cas où une seule direction était exclue).
   
   Résultats faux ?
   ================
   
   Il n'y a pas eu de résultats faux car : le jeu n'est utilisé dans la construction des
   matrices élémentaires (TE0364) que pour la compliance or cette dernière n'était plus
   activable depuis la 10.1.3 suite au bug corrigé la semaine dernière. C'est donc ce qui
   explique que ce test (sdnv100g) soit le seul cassé, de surcroît seulement depuis la
   version 10.2.21.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sdnv100g
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 015794 DU 2010-10-22 12:00:47
TYPE aide utilisation concernant Code_Aster (VERSION 9.1)
TITRE
    Problxc3xa8me de convergence avec le comportmement de Chaboche
FONCTIONNALITE
   AOM (suite)
   ===========
   
   '''
   Demande emise dans le cadre de l'AT (Minh-Bao LE, Thésard CIFRE EDF SEPTEN - LMS):
   
   Il nous avait contactés il y a quelques temps pour un problème de convergence (modèle
   fissuré, comportement Chaboche): 
   Cette demande avait fait l'objet de la fiche 15432, dont la conclusion était la suivante:
   a) il n'y a pas d'écrouissage avec la loi et pour les niveaux de déformation atteints cela
   peut poser des problèmes de convergence,
   b) il faut regarder les unités car les vitesses de déformation impliquées sont beaucoup
   trop fortes,
   c)  le chargement extérieur est presque nul : il l'est sur quasiment toute la structure.
   Il ne l'est pas vraiment autour du fond de fissure mais dans cette zone.
   
   L'utilisateur a réduit son modèle à 1 seul élément et a pris en compte ces remarques:
   a) En fait, il n'y a pas d'écrouissage isotrope mais il y a un écrouissage cinématique.
      Le calcul avec le modèle d'1 élément en déplacement imposé arrive à des contraintes max
   de plus de 500 MPa.
   b) Il a changé la durée des cycles à 1000000ms (paramètre DTcycle), le même probème persiste.
   c) Il a ajouté des petits chargements pour éviter ce problème.
   
   Ci-joint un fichier word qui décrit la problématique.
   '''
   
   Analyse
   =======
   
   Tout d'abord l'utilisateur a raison de signaler que le point b) ne servait à rien. En
   effet j'avais mal interprété son fichier de commandes : il utilise la loi VMIS_CIN1_CHAB
   mais celle-ci n'a de composante visqueuse que si onutilise la loi VISC_CIN1_CHAB avec le
   mot-clé LEMAITRE, ce qui n'est pas le cas. La modification de la vitesse de déformation
   n'a donc aucune influence.
   
   La prise en compte de la remarque c) est une bonne chose. En ce qui concerne la remarque
   a) : c'est bien là le problème. La loi est assez complexe et sans écrouissage isotrope,
   elle tend très rapidement (après quelques cycles) vers une loi parfaitement classique ce
   qui pose problème. Néanmoins cf. à la fin de la fiche pour des conseils supplémentaires à
   l'utilisateur.
   
   Revenons au test qui est joint à cette fiche : 
   
   - le calcul en déplacement imposé sur 1 maille en appui plan converge sans problèmes avec
   4 cycles de charge-décharge en traction/compression
   
   - le même calcul avec une contrainte imposée sur le bord ne converge plus à l'instant 0.445
   ==> le premier cycle de charge n'est même pas fini. Tous les pas de temps avant celui-ci
   étaient élastiques (1 itération de Newton)
   
   
   Si on regarde à quelle amplitude du chargement cela correspond on voit que :
   f_mult (t=0.445) = (0.445-0.25)/0.25 * 0.95 + 0.05 = 0.791
   Le chargement en contrainte appliquée à cet instant est donc de : f_mult*280 = 221.48 Mpa
   
   Or la loi utilisée est élastique jusqu'à environ 220 Mpa, donc la non-convergence se
   produit dès que le matériau plastifie.
   
   ==> en consultant le fichier de commandes on voit que c'est normal puisque on a renseigné
   sous le mot-clé NEWTON de STAT_NON_LINE : REAC_INCR=0, REAC_ITER=0, PREDICTION='EXTRAPOL'
   et MATRICE='TANGENTE'.
   C'est donc la matrice élastique qui est en fait utilisée : c'est d'ailleurs cohérent car
   la non-convergence est en fait une convergence très lente, le résidu décroît lentement.
   
   En choisissant REAC_INCR=1, REAC_ITER=1, PREDICTION='ELASTIQUE', MATRICE='TANGENTE' le
   calcul se poursuit jusqu'au bout sans problème.
   
   Je joins le fichier .comm modifié.
   
   Pour aller plus loin
   ====================
   
   Dans la fiche issue15432, on avait donné des conseils (que l'on a rappelé ici) : sauf pour
   la remarque sur la vitesse de déformation, ils restent d'actualité.
   Cependant, conscient des difficultés de l'utilisateur à faire converger son calcul et
   après discussion avec Jean-Michel, voici une nouvelle piste à tester :
   
   On a vu que ce qui pose problème c'est la convergence lorsque le chargement devient nul.
   Le chargement nul est bien détecté mais le problème c'est que la convergence (même en
   autorisant un grand nombre d'itérations avec une matrice 'ELASTIQUE') ne se produit pas.
   
   On a montré que la difficulté était le fait de forces nodales auto-équilibrées à la base
   de la fissure. Ces forces auto-équilibrées sont le résultat de la décharge et du
   comportement non-linéaire du matériau. La fissure est modélisée par une liaison
   unilatérale (idem que du contact).
   
   Pour essayer de découpler les non-linéarités, on propose à l'utilisateur de faire le même
   calcul que la fiche 15432 en changeant *seulement* la loi de comportement en une loi à
   écrouissage isotrope à courbe de traction (VMIS_ISOT_TRAC) qui tend vers un palier
   parfaitement plastique.
   
   ps : merci Christophe de faire suivre ce dernier message à l'utilisateur.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    xc3xa9tude
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR geniaut      GENIAUT Samuel         DATE 10/25/2010 - 06:33:47

--------------------------------------------------------------------------------
RESTITUTION FICHE 015743 DU 2010-10-14 13:26:02
TYPE anomalie concernant Code_Aster (VERSION 10.2)
TITRE
    En NEW10.2.19, les cas-tests ssnd109a et ssnd110a et ssnv139b s'arretent en NO_RESU_FILE sur Bull,Cal5 et Rocks
FONCTIONNALITE
   Problème :
   ----------
   
   Lors de la restitution de la fiche 13550, la syntaxe de DEFI_LIST_INST a changé : le
   re-découpage pour cause d'erreur (contact, pilo, ...) s'appelle désormais 'ERREUR' au lieu
   de 'DIVERGENCE'.
   
   La syntaxe des tests suivants n'a pas été modifiée en conséquence :
   ssnd109a, ssnd110a et ssnv139b 
   
   
   
   Solution :
   ----------
   
   On supprime des .comm les lignes qui déclaraient 'DIVERGENCE'.
   Le comportement par défaut ('ERREUR') est donc enclenché.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssnd109a, ssnd110a et ssnv139b
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR granet       GRANET Sylvie          DATE 10/25/2010 - 01:52:06

--------------------------------------------------------------------------------
RESTITUTION FICHE 015657 DU 2010-10-04 13:49:27
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    calcul de resi_comp_rela pour le 1er pas de temps.
FONCTIONNALITE
   L'utilisation du résidu RESI_COMP_RELA n'a pas de sens pour le premier pas de temps. Dans
   ce cas, on bascule sur le résidu relatif, voir absolu si la charge est absente.
   
   Je me suis aperçue que cette bascule n'était pas systématiquement faite (lorsque la force
   interne initiale était non nulle). Cela n'a pas grand sens. On corrige pour rendre cela
   systématique.
   On valide en faisant passer le cas test wtnp124a en resi_comp_rela.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V7.32.124
VALIDATION
    passage wtnp124a
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR lefebvre     LEFEBVRE Jean-Pierre   DATE 10/26/2010 - 07:16:59

--------------------------------------------------------------------------------
RESTITUTION FICHE 015789 DU 2010-10-21 16:34:31
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    jeimpa se plante sur les collections dispersxc3xa9es
FONCTIONNALITE
   L'impression des attributs des objets JEVEUX échoue dans 
   certains cas.
   
   En instrumentant le test ttnl02a avec la commande IMPR_CO, on 
   obtient effectivement une
   erreur lorsque l'on demande d'imprimer les attributs :
   
      IMPR_CO(CONCEPT=_F(NOM=MOTH),
             NIVEAU=2,
             UNITE=8,
             CONTENU='OUI',
             BASE='G',
             POSITION=1,
             ATTRIBUT='OUI',
             );
   
      
      !----------------------------------------------------------
   -!
      ! <F> <JEVEUX1_04>                                          
   !
      !                                                           
   !
      ! L'attribut LONMAX n'est pas accessible ou non modifiable. 
   !
      !                                                           
   !
      !                                                           
   !
      ! Cette erreur est fatale. Le code s'arrete.                
   !
      !----------------------------------------------------------
   -!
      
   Liste des appels successifs (option -traceback)
   Image              PC        Routine            Line        
   Source             
   asteru             0A29A00B  Unknown               Unknown  
   Unknown
   asteru             0A29962B  Unknown               Unknown  
   Unknown
   libifcore.so.5     402CEFB0  Unknown               Unknown  
   Unknown
   libifcore.so.5     40267FE6  Unknown               Unknown  
   Unknown
   asteru             08197D4D  trabck_                    34  
   trabck.F
   asteru             08175276  u2mesg_                    81  
   u2mesg.f
   asteru             08167CFC  u2mesk_                    35  
   u2mesk.f
   asteru             081619F6  jelira_                   296  
   jelira.f
   asteru             0869B33E  jeimpa_                   188  
   jeimpa.f
   asteru             08C7E9F2  utimco_                    58  
   utimco.f
   asteru             0893A0C9  utimob_                    52  
   utimob.f
   asteru             0850355B  utimsd_                   150  
   utimsd.f
   asteru             08321A76  op0017_                   108  
   op0017.f
   asteru             081EE09E  ex0000_                    99  
   ex0000.f
   asteru             081A86EB  execop_                    86  
   execop.f
   asteru             08157768  expass_                    82  
   expass.f
   asteru             08148012  aster_oper               2589  
   astermodule.c
   Fortran abort routine called
   
   C'est la routine JEIMPA qui est en cause : lors de la 
   suppression de l'attribut ORIG
   (version NEW10.1.19 du 14/04/2010) certains indices n'avaient 
   pas été modifiés : 
         DO 20 K = 1 , NNAO
             ICOL = K - 11
             IF ( NAO(K)(1:3) .EQ. 'LON' ) ILON = 1
             IF ( NAO(K)(1:3) .EQ. 'NOM' ) ILON = 2
             IF ( (K.LE.7)                                           
   .OR.
        &         (K.GT.7 .AND. K.LE.11
        &            .AND. LCONST .AND. TAB3(ILON,JLON) )            
   .OR.
        &         ( (IRET.EQ.1.OR.IRET.EQ.3) .AND. (K.GT.7 .AND. 
   K.LE.11)
        &           .AND. TAB3(ILON,JLON) )                          
   .OR.
        &         ( IRET.EQ.2 .AND. 
   (K.GT.11.AND.TAB2(ICOL,JCOL)))   .OR.
        &         ( IRET.EQ.3 .AND. 
   (K.GT.11.AND.TAB1(ICOL,JCOL)))   .OR.
        &         ( IRET.EQ.1 .AND. (K.GT.11)                    
   ) ) THEN
   ...
         20  CONTINUE
   
   On change 7 en 6 et 11 en 10 et la routine JEIMPA fonctionne 
   de nouveau.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ttnl02a instrumentxc3xa9 avec IMPR_CO
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 015796 DU 2010-10-22 13:40:11
TYPE anomalie concernant Code_Aster (VERSION 10.2)
TITRE
    En NEW10.2.21, le cas-test mumps04a   s'arrete en erreur  _<F> sur Aster4_mpi
FONCTIONNALITE
   Sur le serveur Aster4 (Calibre6) en version IntelMPI le tests mumps04a s'arrete en erreur
   par manque de mémoire dans le solveur : 
   
    ** ERROR RETURN ** FROM DMUMPS INFO(1)= -1
    ** INFO(2)=         1
      
      !-------------------------------------------------------------------!
      ! <F> <FACTOR_53>                                                   !
      !                                                                   !
      ! Solveur MUMPS :                                                   !
      !   Mumps manque de mémoire lors de la factorisation de la matrice. !
      ! Solution :                                                        !
      !   Il faut augmenter la valeur du mot clé  SOLVEUR/PCENT_PIVOT.    !
      ! Remarque : on a le droit de dépasser la valeur 100.               !
      !                                                                   !
      !                                                                   !
      ! Cette erreur est fatale. Le code s'arrete.                        !
      !--------------------------------------------------
   
   En modifiant PCENT_PIVOT=10 par PCENT_PIVOT=30 lors de l'appel au solveur MUMPS, le test
   fonctionne sans problème.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    tests mumps04a en version MPI
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR messier      MESSIER Julien         DATE 10/26/2010 - 02:41:24

--------------------------------------------------------------------------------
RESTITUTION FICHE 015120 DU 2010-05-27 16:46:29
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TMA : CS
TITRE
    X-FEM : PROPA_FISS depend de la numerotation des mailles
FONCTIONNALITE
   L’objet de cette fiche est de modifier la macro python PROPA_FISS afin que le résultat de
   la propagation soit indépendant de la numérotation des mailles réalisée au sein même de
   cette macro. 
   
   En effet, il est (et doit rester) possible de modifier le dénomination des mailles en
   dehors de PROPA_FISS. La macro doit donc simplement vérifier la bonne orientation des
   mailles fournies en entrée et réaliser ensuite sa concaténation avec le maillage créé
   indépendamment de toute autres considérations.
   
   Problème constaté :
   ****************
   La fiche 15075 a mis en évidence, lors du passage de Numerical à Numpy, la forte
   sensibilité de la macro-commande à la numérotation des mailles.
   
   La macro PROPA_FISS appelle MAIL_PY dans l’utilitaire partition.py lors de la création du
   nouveau maillage résultant de la concaténation des nouveaux points créés avec le maillage
   fissuré existant. 
   L’ordre des mailles renvoyé par l’utilitaire est sensible à l’opérateur NP.argsort. 
   L’ajout de kind= « mergesort », permet de retrouver l’ordre de mailles obtenu avec
   l’ancienne librairie de Numerical.
   Or, si l’ordre est perturbé (ici dès la 8ème itération), le résultat l’est fortement, il
   est donc nécessaire de rendre dorénavant la propagation indépendante de la numérotation
   des mailles.
   (Nota : en pratique, l'utilisateur n'a pas accès à cette numérotation, mais simplement au
   nom donné aux groupes de mailles correspondant respectivement au fond et aux lèvres de la
   fissure)
   
   Tâche à réaliser :
   ****************
   Préalablement à la concaténation, on a vérifié la bonne orientation des mailles. 
   
   En 2D, on a ordonné le groupe de nœuds constituant le maillage initial en vérifiant
   simplement qu’ils forment une ligne ouverte et continue. Et, on a utilisé l’opérateur
   Aster DEFI_GROUP/CREA_GROUP_NO, option ‘NOEUD_ORDO’.
   
   PS : en 3D, on ne peut pas utiliser la méthode DEFI_GROUP/CREA_GROUP_NO, option
   ‘NOEUD_ORDO’ car cette option ordonne les nœuds d’un ensemble de mailles formé de
   segments(SEG2, SEG3 ou SEG4).
   
   Ensuite pour le cas 2D et 3D On a vérifié (en supprimant kind= « mergesort ») que les
   résultats des cas-tests sont bien identiques à ceux précédant la modification.
   
   Fichiers modifies:
   *******************
   partition.py  
   propa_fiss_ops.py
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    liste_ct.tout
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR nistor       NISTOR Ionel           DATE 10/26/2010 - 03:22:31

--------------------------------------------------------------------------------
RESTITUTION FICHE 010625 DU 2007-03-09 18:30:09
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    AR02 - rattacher les donnxc3xa9es de construction des matrices xc3xa9lxc3xa9mentaires aux matrice assemblxc3xa9es
FONCTIONNALITE
   Cette fiche proposait il y a un certain temps une évolution de la sd_matr_asse pour stocker des informations 
   attachées actuellement dans la sd_matr_elem (caractéristiques élémentaires et champs matériaux notamment) qui 
   à servi à l’assemblage. 
   Ce besoin a été exprimé par des utilisateurs qui, volontairement, ont détruit les concepts correspondent aux 
   matrices élémentaires dans le fichier de commande et qui, lors d’une analyse dynamique transitoire ou 
   harmoniques sont arrêtés par le message d’erreur :
   !------------------------------------------------------------------------------!
      ! <EXCEPTION> <JEVEUX_26>                                                      !
      !                                                                              !
      ! Objet JEVEUX inexistant dans les bases ouvertes : >NOM_CONCEPT           .XXXX< !
      !      l'objet n'a pas été créé ou il a été détruit                            !
      !------------------------------------------------------------------------------!
   En effet, la sd_matr_asse contient l'objet '.LIME' qui recueille les noms de concepts
   des matrices élémentaires qui ont contribuées à l'assemblage de la matrice.
   Les informations relatives aux caractéristiques élémentaires ou au champ matériau
   sont attachés aux matrices élémentaires et non aux matrices assemblées (autrement serait très compliqué car 
   on peut avoir plusieurs cara_elem et champ_mater).
   Ainsi, lors d'une destruction des concepts matr_elem qui ont produit le concept
   matr_asse, il n'est plus possible ne récuperer les caractéristiques élémentaires ou
   le champ matériau.
   Néanmoins, lors d’une destruction de concept dans le fichier de commande, un message d’information annonce 
   l’utilisateur :
   
   "Destruction de  NOM_CONCEPT           .XXXX"
   
   Si on met bout à bout les deux messages, on a l’explication claire sur le plantage et on peut facilement 
   réparer.
   
   En résumé :
   1.l’évolution suggérée à un moment donné dans l’historique de la fiche (i.e. rattacher les données de 
   construction des matrices élémentaires aux matrice assemblées) n’est pas acceptée par l’équipe de 
   développement car techniquement très onéreuse : stockage d’information en double, heuristique trop onéreuse 
   lorsqu’on a plus d’une cara_elem ou champ_mater
   2.des messages claires existent déjà dans le code pour permettre à l’utilisateur d’aboutir son étude
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    neant
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 015713 DU 2010-10-11 15:01:35
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    alarmes xc3xa0 supprimer lors de la construction d'un squelette pour la restitution sur base physique
FONCTIONNALITE
   Problème:
   ---------------------------------
   Après l'introduction d'une nouvelle alarme (SOUSTRUC2_10 avec la fiche REX 14190)pour eviter les conflits des 
   noms des groupes de mailles dans un squelette, plusieurs cas-tests:
   sdld102a 
   sdll113a
   sdls01c 
   sdls106a 
   sdls106b 
   sdls106c 
   sdlv402a 
   sdnl104b 
   sdnl105d 
   shll100a 
   shll100b 
   shll100c 
   ont commencé à emettre cette alarme. 
   Tous ces cas-tests ont TOUT='OUI' dans DEFI_SQUELETTE et remplisent l'autre conditions LEN
   (nom_gr_maille+nom_sous_struc)>=8.
   
   Solution:
   ----------------------------------
   L'emploi du mot-clé TOUT='OUI' est déjà fortement deconseillé dans la doc car, dans certaines situations 
   (plusieurs maillages avec plusieurs groupes de mailles), il penalise beaucoup la performance de l'opérateur. 
   Neanmoins, on peut pas l'éliminer completement de catalogue car si le(s) maillage(s) d'origine n'ont pas de 
   groupes de mailles définis, c'est lui qui gère la constitution du squelette.
   L'alternative à TOUT='OUI' c'est l'emploi de GROUP_MA ou MAILLE. Alors on va utiliser pour visualisation 
   seulement les groupes de mailles ou les mailles indiqués par l'utilisateur. ça va plus vite et on transporte 
   dans le squelette seulement les parties de la structure globale qui nous interessent.
   Dans les cas-tests cités ci-dessus, j'ai remplacé TOUT='OUI' avec GROUP_MA='TOUT', où TOUT est un groupe avec 
   toute les mailles de maillage d'origine (je le crée si il n'existe pas).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    liste de cas-tests appelant DEFI_SQUELETTE
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR corus        CORUS Mathieu          DATE 10/26/2010 - 03:22:32

--------------------------------------------------------------------------------
RESTITUTION FICHE 015681 DU 2010-10-06 07:44:46
TYPE anomalie concernant Code_Aster (VERSION 10.3)
TITRE
    Erreur lors de la restitution en base physique aprxc3xa8s un calcul par sous-structuration dynamique
FONCTIONNALITE
   Probleme rencontre :
   --------------------
   
   L'erreur intervient lorsqu'on essaie de restituer, sur une sous-structure seulement (sur
   un squelette ça  marche), des résultats issus d'un calcul par sous-structuration dynamique
   en utilisant METHODE='ELIMINE' dans  NUME_DDL_GENE (nouvelle option introduite suite à
   l'evolution de la fiche 14299). Testé avec sdls106a.
   
   Solution proposee :
   -------------------
   
   Effectivement, j'avais modifie la routine REGEGL pour que ca marche avec un squelette,
   mais je n'ai pas modifie REGEEC. Les evolutions ont ete reportees dans REGEEC, et testees
   sur le cas test sdls106a.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sdls106a
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 009949 DU 2006-08-14 15:56:03
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    CREA_CHAMP_GENE/CREA_RESU_GENE
FONCTIONNALITE
   Evolution proposee :
   --------------------
   
   Afin de pouvoir regler une partie des problemes inherents a la distinction numerotation
   generalisee/physique dans Code Aster, il me semble necessaire de disposer des 2 operateurs
   suivants : 
   
   1/ CREA_CHAMP_GENE qui doit permettre de creer un champ_gene (ou vect_asse_gene pour
   trouver une structure apparentée) et ce à partir d'un array python par exemple.
   2/ CREA_RESU_GENE qui doit permettre la concatenation de ces CHAMP_GENE en un resu_gene de
   type tran_gene, mode_gene ou harm_gene.
   
   Solution apportee :
   -------------------
   
   L'interet de cette fiche est nettement moindre, depuis l'introduction dans le code des
   methodes EXTR_VECT_GENE* et RECU_VECT_GENE* pour les concepts issus d'ASSE_VECT_GENE et de
   RECU_GENE, et de l'introduction des methodes EXTR_MATR_GENE et RECU_MATR_GENE. Tout cela,
   combinee avec la possibilite de construire ex nihilo une numerotation generalisee, offre a
   l'utilisateur les possibilites de construire tous les types de champs et de resultats
   generalises qu'il peut desirer. Par exemple :
   
   - pour creer des mode_gene particulier a partir de matrices python, il suffit de
   construire 2 matrices (une de masse et une de raideur) dont le (ou les) mode_gene
   souhaites sont des modes propres. Le passage par MODE_ITER_SIMULT donne ensuite le
   resultat attendu, reutilisable par Aster,
   
   - pour creer un champ_gene, il suffit de construire n'importe quel vecteur generalise, et
   d'aller modifier les valeurs a la main. Ou de recuperer par RECU_GENE un champs issu d'un
   resultat generalise (meme "trivial", en appliquant un effort generalise nul sur n'importe
   quel modele reduit, et en ne demandant qu'un seul pas de temps)
   
   - pour creer le RESU_GENE souhaite, c'est un peu plus contraignant, puisqu'il faut
   reflechir "a l'envers", c'est a dire imaginer un systeme dynamique simple qui donnerait la
   reponse souhaitee si on veut construire un objet de type trans_gene ou harm_gene. En
   python, c'est assez simple, il suffit de construire une "paire" de matrice, d'estimer le
   filtre associe, et de reconstruire, a partir dde ces matrices, l'effort qui produira la
   reponse souhaitee. L'idee est cependant la meme que pour la creation d'un concept de type
   mode_gene. Ca n'est la qu'une indication de solution paliative. Si le beson devait etre
   important, on pourrait envisager d'extrapoler les methodes EXTR_VECT_GENE* et
   RECU_VECT_GENE* aux objets issus de DYNA_TRAN_MODAL et DNA_LINE_HARM.
   
   Je propose donc de fermer cette fiche.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    Aucune
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR sellenet     SELLENET Nicolas       DATE 10/25/2010 - 02:41:33

--------------------------------------------------------------------------------
RESTITUTION FICHE 015752 DU 2010-10-15 13:58:09
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.2.20, le cas-test mtlp103a s'arrete par manque de temps CPU sur Bull
FONCTIONNALITE
   Problème :
   ----------
   """
   En NEW10.2.20, le cas-test mtlp103a s'arrete par manque de temps CPU sur Bull
   """
   
   
   Solution :
   ----------
   On augmente le .para.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    aucune
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------
RESTITUTION FICHE 015741 DU 2010-10-14 13:17:47
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.2.19, le cas-test perfe02a s'arretent par manque de temps CPU  sur Bull, Cal5 et Rocks
FONCTIONNALITE
   Problème :
   ----------
   """
   En NEW10.2.19, le cas-test perfe02a s'arretent par manque de temps CPU  sur Bull, Cal5 et
   Rocks
   """
   
   
   Analyse :
   ---------
   C'est une modification intervenue en 10.2.19 sur la méthode EXTRAPOLE qui cause le
   plantage (fiche 13550).
   
   En version 10.2.21, Samuel est revenu sur la modification (fiche 15733). Du coup, le cas
   test s'est réparé automatiquement.
   
   
   Solution :
   ----------
   On classe la fiche.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    perfe02a
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------
RESTITUTION FICHE 015731 DU 2010-10-12 16:08:39
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.2.18, le cas-test ssnp135d est NOOK sur Cal5.
FONCTIONNALITE
   Problème :
   ----------
   """
   1 NOOK dans le resu:
   
   
   
   --------------------------------------------------------------------------------
    ---- TABLE            NOM_PARA
         DX_A2            DX
         REFERENCE        LEGENDE          VALE_REF                 VALE_CAL                
   ERREUR           TOLE            
   NOOK  NON_REGRESSION   XXXX             -0.10717352257886        -0.10717352257853       
   3.1E-10%         1.0E-10%
   """
   
   
   Solution :
   ----------
   Modification de la tolérance.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    aucune
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST AJOUT sdls106d                       delmas J.DELMAS           301    301      0
 CASTEST MODIF mtlp103a                     sellenet N.SELLENET         864      2      2
 CASTEST MODIF mumps04a                     lefebvre J-P.LEFEBVRE       423     10     10
 CASTEST MODIF perf005c                     courtois M.COURTOIS         118      1     19
 CASTEST MODIF perf005d                     courtois M.COURTOIS         122      1     19
 CASTEST MODIF perf005f                     courtois M.COURTOIS         124      1     19
 CASTEST MODIF sdld102a                       nistor I.NISTOR           892      9      6
 CASTEST MODIF sdld102c                      boiteau O.BOITEAU          419    123     47
 CASTEST MODIF sdll113a                       nistor I.NISTOR           431      8      6
 CASTEST MODIF sdls01c                        nistor I.NISTOR           499      5      3
 CASTEST MODIF sdls106a                       nistor I.NISTOR           419     39      6
 CASTEST MODIF sdls106b                       nistor I.NISTOR           317      6      4
 CASTEST MODIF sdls106c                       nistor I.NISTOR           329      6      5
 CASTEST MODIF sdlv402a                       nistor I.NISTOR           358     12      4
 CASTEST MODIF sdnl104b                       nistor I.NISTOR           496      6      4
 CASTEST MODIF sdnl105d                       nistor I.NISTOR           562      7      5
 CASTEST MODIF sdnv105a                       desoza T.DESOZA          1362      5      4
 CASTEST MODIF shll100a                       nistor I.NISTOR           704      8      6
 CASTEST MODIF shll100b                       nistor I.NISTOR           654      6      4
 CASTEST MODIF shll100c                       nistor I.NISTOR           588      6      4
 CASTEST MODIF ssnd109a                      geniaut S.GENIAUT          261      5     10
 CASTEST MODIF ssnd110a                      geniaut S.GENIAUT          656      3      8
 CASTEST MODIF ssnp135d                     sellenet N.SELLENET         432      2      2
 CASTEST MODIF ssnv139b                      geniaut S.GENIAUT          276      6     16
 CASTEST MODIF wtnp124a                       granet S.GRANET           542     16     19
CATALOPY MODIF commande/defi_part_feti       boiteau O.BOITEAU           64      2      2
CATALOPY MODIF commande/defi_part_pa_ops     boiteau O.BOITEAU           60      2      2
CATALOPY MODIF commande/impr_sturm           boiteau O.BOITEAU           64      3      3
       C MODIF supervis/dll_interface       courtois M.COURTOIS          69      2      1
       C MODIF supervis/dll_umat            courtois M.COURTOIS         165      1      3
       C MODIF supervis/dll_yacs            courtois M.COURTOIS         413     19     26
       C MODIF supervis/dll_zmat            courtois M.COURTOIS         132      2      2
FORTRAN90 MODIF echange/mfchac               courtois M.COURTOIS          42     12      3
FORTRAN90 MODIF echange/mfchai               courtois M.COURTOIS          43     12      3
FORTRAN90 MODIF echange/mfchre               courtois M.COURTOIS          59     14      3
FORTRAN90 MODIF echange/mfchrl               courtois M.COURTOIS          59     15      3
FORTRAN90 MODIF echange/mfcone               courtois M.COURTOIS          61     12      5
FORTRAN90 MODIF echange/mfconl               courtois M.COURTOIS          70     15      6
FORTRAN90 MODIF echange/mfcooe               courtois M.COURTOIS          57     11      3
FORTRAN90 MODIF echange/mfcool               courtois M.COURTOIS          53     13      3
FORTRAN90 MODIF echange/mffamc               courtois M.COURTOIS          49     13      3
FORTRAN90 MODIF echange/mffame               courtois M.COURTOIS          44     12      3
FORTRAN90 MODIF echange/mffami               courtois M.COURTOIS          60     12      5
FORTRAN90 MODIF echange/mffaml               courtois M.COURTOIS          52     10      4
FORTRAN90 MODIF echange/mfferm               courtois M.COURTOIS          39     12      3
FORTRAN90 MODIF echange/mffide               courtois M.COURTOIS          40     12      3
FORTRAN90 MODIF echange/mffien               courtois M.COURTOIS          41     12      3
FORTRAN90 MODIF echange/mffoco               courtois M.COURTOIS          38     13      4
FORTRAN90 MODIF echange/mfgaue               courtois M.COURTOIS          47     13      3
FORTRAN90 MODIF echange/mfgaui               courtois M.COURTOIS          43     12      3
FORTRAN90 MODIF echange/mfgaul               courtois M.COURTOIS          42     12      3
FORTRAN90 MODIF echange/mflfde               courtois M.COURTOIS          40     12      3
FORTRAN90 MODIF echange/mfmaac               courtois M.COURTOIS          43     12      3
FORTRAN90 MODIF echange/mfmaai               courtois M.COURTOIS          44     12      3
FORTRAN90 MODIF echange/mfnatt               courtois M.COURTOIS          42     12      3
FORTRAN90 MODIF echange/mfncha               courtois M.COURTOIS          41     12      3
FORTRAN90 MODIF echange/mfnema               courtois M.COURTOIS          48     13      3
FORTRAN90 MODIF echange/mfnfam               courtois M.COURTOIS          42      9      3
FORTRAN90 MODIF echange/mfngau               courtois M.COURTOIS          40     12      3
FORTRAN90 MODIF echange/mfngro               courtois M.COURTOIS          42     12      3
FORTRAN90 MODIF echange/mfnmaa               courtois M.COURTOIS          40     12      3
FORTRAN90 MODIF echange/mfnome               courtois M.COURTOIS          49     13      3
FORTRAN90 MODIF echange/mfnoml               courtois M.COURTOIS          49     13      3
FORTRAN90 MODIF echange/mfnpdt               courtois M.COURTOIS          43     12      3
FORTRAN90 MODIF echange/mfnpfl               courtois M.COURTOIS          41     12      3
FORTRAN90 MODIF echange/mfnpro               courtois M.COURTOIS          40     12      3
FORTRAN90 MODIF echange/mfnume               courtois M.COURTOIS          51     13      3
FORTRAN90 MODIF echange/mfnval               courtois M.COURTOIS          51     13      3
FORTRAN90 MODIF echange/mfouvr               courtois M.COURTOIS          41     12      3
FORTRAN90 MODIF echange/mfpdti               courtois M.COURTOIS          55     13      3
FORTRAN90 MODIF echange/mfpfle               courtois M.COURTOIS          44     12      3
FORTRAN90 MODIF echange/mfpfll               courtois M.COURTOIS          44     12      3
FORTRAN90 MODIF echange/mfproi               courtois M.COURTOIS          42     12      3
FORTRAN90 MODIF echange/mfveco               courtois M.COURTOIS          39     12      3
FORTRAN90 MODIF echange/mfvedo               courtois M.COURTOIS          43     12      3
FORTRAN90 MODIF echange/mfveli               courtois M.COURTOIS          44     12      3
 FORTRAN AJOUT utilitai/initch              courtois M.COURTOIS          31     31      0
 FORTRAN MODIF algeline/op0032               boiteau O.BOITEAU          255      4      4
 FORTRAN MODIF algeline/op0044               boiteau O.BOITEAU          771      4      5
 FORTRAN MODIF algeline/op0045               boiteau O.BOITEAU         1224      4      5
 FORTRAN MODIF algorith/crsvl2               boiteau O.BOITEAU           97     20     23
 FORTRAN MODIF algorith/crsvmu               boiteau O.BOITEAU          234     19      6
 FORTRAN MODIF algorith/nmcore                granet S.GRANET           260      5      5
 FORTRAN MODIF algorith/regeec                nistor I.NISTOR           282     66      6
 FORTRAN MODIF elements/te0364                desoza T.DESOZA           441      2      1
 FORTRAN MODIF elements/te0365                desoza T.DESOZA           396      2      2
 FORTRAN MODIF jeveux/jeimpa                lefebvre J-P.LEFEBVRE       200     12     12
 FORTRAN MODIF modelisa/afddli                desoza T.DESOZA           171     16     31
 FORTRAN MODIF modelisa/caddli                desoza T.DESOZA           357     50     14
 FORTRAN MODIF modelisa/caddlp                desoza T.DESOZA           260      5      4
 FORTRAN MODIF modelisa/cafaci                desoza T.DESOZA           489     35     19
 FORTRAN MODIF modelisa/lrmmf3              courtois M.COURTOIS         462      3      2
 FORTRAN MODIF modelisa/lrmmno              courtois M.COURTOIS         227      3      1
 FORTRAN MODIF modelisa/xddlim                desoza T.DESOZA           328     11     25
 FORTRAN MODIF prepost/mdexpm               courtois M.COURTOIS         143      2      1
 FORTRAN MODIF utilitai/fetskp               boiteau O.BOITEAU          511     16      2
 FORTRAN MODIF utilitai/uttcpl               boiteau O.BOITEAU          102      2      2
  PYTHON MODIF Macro/propa_fiss_ops          mahfouz D.MAHFOUZ          996     19      3
  PYTHON MODIF Messages/algeline5            boiteau O.BOITEAU          422      5      4
  PYTHON MODIF Messages/utilitai             boiteau O.BOITEAU          387     13      2
  PYTHON MODIF Utilitai/partition            mahfouz D.MAHFOUZ         1324      2      2


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :    2         332       332              +332
 MODIF :   99       25191      1184     593      +591
 SUPPR :    0           0                 0        +0
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :  101       25523      1516     593      +923 
