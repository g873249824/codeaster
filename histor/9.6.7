

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR granet       GRANET Sylvie          DATE 10/05/2010 - 13:36:31

--------------------------------------------------------------------------------
RESTITUTION FICHE 015035 DU 2010-05-05 13:02:44
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   THM - kitdec.f - variable nvith
FONCTIONNALITE
   La variable nvith utilisée dans comthm n'était utile que 
   lorsqu'il y avait les lois de type "Gatmari" resorbées depusi 
   longtemps. Cette variable inutile existe toujours et n'est 
   renseignée nulle part.Elle n'est donc pas initialisée à 0. Or 
   la routine kitdec l'utilise inutilement pour déclarer la 
   longueur du vecteur des variables internes en THM.
   Bref il y a un risque ed tableau mal dimensionné.
   Je résorbee nvith de kitdec.f, comthm.f, coeithm.f et calcme.f.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   passage de tests THM
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 014992 DU 2010-04-26 05:32:53
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW10.1.21, les cas-tests wtna106a,b,c,d , wtnp102a,b,c,d et wtnv102a,b s'arretent en erreur_<F> sur Rocks.
FONCTIONNALITE
   Il y avait une variable non initialisée dans la routine hmlvag. 
   La variable CP22 n'était en effet pas mise à 0.
   Cette routine concerne les lois de comportement liqu_vape_gaz 
   (d'où les cas tests qui plantaient sur rocks).
   On fait l'initialisation et les tests passent sur les différentes 
   machines.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   passage des tests sous rocks
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR proix        PROIX Jean-Michel      DATE 14/05/2010 - 09:05:31

--------------------------------------------------------------------------------
RESTITUTION FICHE 015023 DU 2010-05-04 08:24:32
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   comportement mono-cristal avec chargement cyclique en RUNGE_KUTTA
FONCTIONNALITE
   Problème rencontré :
   --------------------
   
   La comparaison des résultats ASTER-ASTER et ASTER-Zmat sur la simulation du comportement
   MONOCRISTAL pour un chargement cyclique monte que le comportement Aster est faux. Le
   résultat de Zmat est semblable à celui obtenu avec Zébulon.
   
   Correction :
   ------------
   
   Il y a effectivement un problème avec les fortes valeurs du paramètre C (cela n'avait pas
   été constaté jusqu'à maintenant puisque l'on n'utilisait pas ces comportements pour ces
   calculs cyclique). C'est un problème voisin de la fiche 14707. Celle-ci met en évidence
   des difficultés de convergence en implicite. 
   
   Tous ces problèmes disparaissent si C devient plus petit (tous les tests de validation
   utilisent des valeurs de C nulles ou petites, de l'ordre de 10 MPa. Ici C=100000 MPa).
   
   Au passage on ajoute une vérification dans DEFI_COMPOR / POLYCRISTAL : il faut que la
   somme des fractions volumiques soit égale à 1 (à 1.E-3 près) pour que la calcul soit
   licite. Sinon un message d'erreur est émis.
   
   
   Possibilité de résultats faux :
   -------------------------------
   
   On avait des résultats faux pour le MONOCRISTAL et le POLYCRISTAL, seulement en
   RUNGE_KUTTA,et avec de fortes valeurs de C.
   
   Détail de correction :
   ----------------------
   
   C'était dû à une mauvaise utilisation de la routine réalisant la partie cinématique du
   comportement (LCMMFC) : on avait voulu utiliser la routine formulée en implicite (qui est
   correcte dans ce cas) pour l'intégration explicite  (ce qui n'est pas bon). La correction
   consiste à distinguer les deux cas. Une nouvelle routine, LCMMEC, spécifique à
   l'intégration explicite a été introduite. Elle est appelée uniquement par LCMMON
   (Monocristal explicite) et LCMMOP (polycristal), à la place de LCMMFC (réservée au
   monocristal implicite).
   
   Validation :
   -------------
   
   un nouveau test, SSDN109A, inspiré de l'étude ayant exhibé l'anomalie, permet de valider
   l'intégration explicite (et l'intégration implicite en V10) pour C=100000MPa. La solution
   de référence est fournie par Zmat (cf. courbe jointe).
   
   Impact documentaire :
   ---------------------
   
   ajout dans la doc R de la signification de H=0 pour la matrice d'interaction et doc du
   test : V6.08.109.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 9.0.0
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 10.0.0
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V6.08.109, R5.03.11
VALIDATION
   ssnd109a
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR delmas       DELMAS Josselin        DATE 14/05/2010 - 09:05:33

--------------------------------------------------------------------------------
RESTITUTION FICHE 014837 DU 2010-03-23 14:31:32
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Calcul d'erreur impossible
FONCTIONNALITE
   Problème :
   ========
   Au cours de la formation on a vu que dans CALC_ELEM, dans le cas où le concept resultat
   n'est pas réentrant et que l'on a une liste d'options dépendant les unes des autres (par
   exemple on a besoin de SIGM_ELNO_DEPL pour calculer ERRE_ELEM_SIGM), on s'arrête avec le
   message suivant :
   
   ...!----------------------------------------------------------------!
   ...!.<A>.<UTILITAI8_14>.............................................!
   ...!................................................................!
   ...!.Champ..inexistant..SIGM_ELNO_DEPL..............................!
   ...!................................................................!
   ...!...ou..SIEF_ELNO_ELGA...........................................!
   ...!................................................................!
   ...!...ou..SIRE_ELNO_DEPL...........................................!
   ...!................................................................!
   ...!...NUME_ORDRE..1..on.ne.calcule.pas.l'option..ERRE_ELEM_SIGM....!
   ...!................................................................!
   ...!................................................................!
   ...!.Ceci.est.une.alarme..Si.vous.ne.comprenez.pas.le.sens.de.cette.!
   ...!.alarme,.vous.pouvez.obtenir.des.résultats.inattendus.!.........!
   ...!----------------------------------------------------------------!
   
   Analyse :
   =======
   C'est normal, pour calculer l'option ERRE_ELEM_SIGM, on a besoin de SIGM_ELNO_DEPL que
   l'on cherche dans la SD initiale et non la nouvelle.
   
   Correction :
   ==========
   On améliore le message pour dire où on cherche le champ en question et on ajoute un conseil :
   
   ...!.<A>.<UTILITAI8_13>..................................................................!
   ...!.....................................................................................!
   ...!.Dans.la.structure.de.données.resultat.meca,.........................................!
   ...!...le.champ.SIGM_ELNO_DEPL...........................................................!
   ...!.....................................................................................!
   ...!...ou.le.champ.SIEF_ELNO_ELGA........................................................!
   ...!.....................................................................................!
   ...!...ou.le.champ.SIRE_ELNO_DEPL........................................................!
   ...!.....................................................................................!
   ...!...n'existe.pas......................................................................!
   ...!.....................................................................................!
   ...!...Pour.le.numéro.d'ordre.NUME_ORDRE.1,..............................................!
   ...!...l'option.ERRE_ELEM_SIGM.n'est.pas.calculée........................................!
   ...!.....................................................................................!
   ...!...Conseil.:.........................................................................!
   ...!.....Vérifiez.le.nom.de.la.structure.de.donnée.et.vérifiez.que.les.champs.existent...!
   ...!.....Si.le.concept.n'est.pas.réentrant.les.champs.ne.sont.pas.cherchés.dans.meca.....!
   ...!.....................................................................................!
   ...!.....................................................................................!
   ...!.Ceci.est.une.alarme..Si.vous.ne.comprenez.pas.le.sens.de.cette......................!
   ...!.alarme,.vous.pouvez.obtenir.des.résultats.inattendus.!..............................!
   ...!-------------------------------------------------------------------------------------!
   
   Impacts:
   =======
   rsexc2.f
   utilitai8.py
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   affichage message
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR corus        CORUS Mathieu          DATE 14/05/2010 - 09:05:34

--------------------------------------------------------------------------------
RESTITUTION FICHE 014668 DU 2010-02-19 13:01:19
TYPE anomalie concernant Code_Aster (VERSION 10.2)
TITRE
   Liaisonnement des sous-structures dans DEFI_MODELE_GENE
FONCTIONNALITE
   Dans le cas de calcul par sous structuration avec une methode de Craig & Bampton, il est
   necessaire que les interface servant au couplage soient bloquées, ou que, a tout le monde,
   6 DDL bloquant les modes de corps rigides soient definies. Dans le cas contraire,
   l'absence de multiplicateurs de Lagranges pour ces interfaces interdit le calcul. Or, en
   l'etat actuel, on ne teste pas la presence de DDL actifs pourles interfaces.
   
   Dans un cas particulier, on a voulu tester le couplage de sous structure en considerant
   des modes a interface libre, donc sans multiplicateurs de lagranges definis a l'interface.
   Le probleme, initie par l'absence de tests dans la routine ddlatc.f (operateur
   DEFI_INTERF_DYNA), se repercute jusqu'a ce que l'operateur DEFI_MODELE_GENE plante salement.
   
   On teste donc maintenant la presence de DDL actifs dans la routine ddlact.f, et on arrete
   le calcul si on n'en trouve aucun, avec le message suivant :
   
      !----------------------------------------------------------------------------------------!
      ! <EXCEPTION> <ALGORITH15_84>                                                            !
      !                                                                                        !
      ! On n''a pas trouve de DDL actifs pour les interfaces donnees                           !
      !    => On ne pourra pas calculer les modes d'attaches, de contrainte ou de couplage.    !
      !                                                                                        !
      !   CONSEIL : Verifiez la coherence de la definition des interfaces (conditions limites) !
      !             avec la methode retenue :                                                  !
      !              - CRAIGB   : le modele doit etre defini avec des interfaces encastrees,   !
      !              - CB_HARMO : le modele doit etre defini avec des interfaces encastrees,   !
      !              - MNEAL    : le modele doit etre defini avec des interfaces libres.       !
      !----------------------------------------------------------------------------------------!
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test perso
NB_JOURS_TRAV  : 0.25
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR pellet       PELLET Jacques         DATE 14/05/2010 - 09:05:34

--------------------------------------------------------------------------------
RESTITUTION FICHE 014980 DU 2010-04-20 16:47:13
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Resultats bizarres LIAISON_SOLIDE + maillage 2D
FONCTIONNALITE
   Problème:
   ---------
   Un utilisateur du Web s'est aperçu que le mot clé LIAISON_SOLIDE (pour un modèle de coques
   ou de poutres) ne faisait pas ce qu'il devait faire si le maillage était dans un plan Z=Cste.
                                                                                            
                         
   Analyse :
   ---------
   Dans la routine caliso.f (LIAISON_SOLIDE), pour savoir le nombre de mouvements de corps
   solide du groupe, il faut savoir si on est en 2D ou en 3D.
                                                                                            
                         
   Jusqu'à présent, on obtenait la réponse à cette question par :
           CALL DISMOI('F','Z_CST',MOD,'MODELE',NDIMMO,K8BID,IER)
                                                                                            
                         
   Ce qui répond mal à la question si le modèle (de coques ou de poutres) est situé dans un
   plan Z=Cste.
                                                                                            
                         
   Correction :
   ------------
   Je modifie caliso.f pour utiliser maintenant :
           CALL DISMOI('F','DIM_GEOM',MOD,'MODELE',NDIMMO,K8BID,IER)
   Cette question DISMOI est plus pertinente car elle regarde dans les catalogues des
   éléments finis du modèle si leur géométrie est 2D ou 3D.
                                                                                            
                         
                                                                                            
                         
   Détails :
   ---------
   1) J'ai retrouvé le meme problème dans les routines suivantes :
     * caliob.f : LIAISON_OBLIQUE
     * calyrc.f : LIAISON_CYCL
     * caprec.f : RELA_CINE_BP
     * calicp.f : LIAISON_COQUE
     * cafaci.f : FACE_IMPO
     Dans toutes ces routines, j'ai modifié le DISMOI : 'Z_CST' -> 'DIM_GEOM'
                                                                                            
                         
   2) La question 'DIM_GEOM' peut répondre :
     2 : tous les éléments du modèle sont 2D
     3 : tous les éléments du modèle sont 3D
     23: il y a un mélange d'éléments 2D et 3D (par exemple dans le test zzzz120b (GOUJ_2ECH))
     1002 : éléments 2D + macro-élements statiques
     1003 : éléments 3D + macro-élements statiques
     ...
                                                                                            
                         
     Dans toutes les routines modifiées :
       - j'oublie les macro-éléments en faisant : NDIM = MOD(NDIM,1000)
       - j'émets une erreur fatale si NDIM est différent de 2 ou 3
                                                                                            
                         
   Validation :
   ------------
     * passage de l'etude jointe à la fiche
     * passage de certains cas tests utilisant les mots clés d'AFFE_CHAR_MECA impactés par
   cette correction
                                                                                            
                         
                                                                                            
                         
   Résultats faux :
   ----------------
   Dans l'étude fournie par l'utilisateur, la conséquence de ce bug est que l'on n'écrivait
   que 3 relations linéaires (pour DX, DY et DRZ) au lieu d'en écrire 6. Ce qui conduit à des
   résultats faux.
                                                                                            
                         
   Les conséquences du bug ne sont pas les memes selon les mots clés impactés :
                                                                                            
                         
     * LIAISON_SOLIDE : Résultats faux si :
       - le modèle contient des éléments de coque ou de poutre
       - tous les noeuds du maillage ont la meme coordonnée "Z".
       - on veut "soldifier" un groupe de noeuds
                                                                                            
                         
     * LIAISON_OBLIQUE : Résultats faux si :
       - le modèle contient des éléments de coque ou de poutre
       - tous les noeuds du maillage ont la meme coordonnée "Z".
       - on veut imposer sur un groupe de noeuds un déplacement "oblique" qui n'est pas dans
   le plan du maillage.
                                                                                            
                         
   En revanche, il n'y a PAS de résultats FAUX pour les mots clés :
     * RELA_CINE_BP : car ce mot clé est destiné à des modèles de béton précontraint et que
   ces modèles ne peuvent pas etre definis sur un maillage plan Z=cste.
     * LIAISON_CYCL : Ce mot clé est destiné à écrire une condition de répétitivité cyclique.
   Il ne traite que les ddls de translation et ne doit pas etre utilisé pour des modèles de
   coque et/ou poutre.
     * LIAISON_COQUE : Ce mot clé est destiné à écrire une condition de raccord entre 2
   coques incidentes (1 mur et 1 plancher par exemple). Ce genre de modèle ne peut pas etre
   décrit par un maillage Z=cste.
     * FACE_IMPO : Le problème ne concerne que les utilisateurs voulant imposer DNOR ou DTAN
   sur un modèle de type coque dans un plan Z=Cste. Il y aura alors une confusion sur le sens
   du mot "normale" :
        - l'utilisateur doit s'attendre à ce que le normale soit celle de la coque (OZ)
        - le code estimant (à tort) qu'il s'agit d'un modèle 2D ne s'intéresera qu'à la
   normale au "bord" du domaine (les segments). Le code s'arretera alors en erreur fatale car
   il ne saura pas calculer la normale des éléments surfaciques (TRA et QUAD).
                                                                                            
                         
                                                                                            
                         
   NEW9 :
   ------
   Reporter en NEW9 les corrections suivantes :
   caliso.f :
   <       CALL DISMOI('F','Z_CST',MOD,'MODELE',NDIMMO,K8BID,IER)
   <       NDIMMO = 3
   <       IF (K8BID.EQ.'OUI') NDIMMO = 2
   ---
   >       CALL DISMOI('F','DIM_GEOM',MOD,'MODELE',NDIMMO,K8BID,IER)
   >       IF (NDIMMO.GT.1000) NDIMMO=NDIMMO-1000
   >       IF (.NOT.(NDIMMO.EQ.2.OR.NDIMMO.EQ.3))
   >      &    CALL U2MESS('F','MODELISA2_6')
                                                                                            
                         
   caliob.f :
   <       CALL DISMOI('F','Z_CST',MOD,'MODELE',NDIMMO,K8BID,IER)
   <       NDIMMO = 3
   <       IF (K8BID.EQ.'OUI') NDIMMO = 2
   ---
   >       CALL DISMOI('F','DIM_GEOM',MOD,'MODELE',NDIMMO,K8BID,IER)
   >       IF (NDIMMO.GT.1000) NDIMMO=NDIMMO-1000
   >       IF (.NOT.(NDIMMO.EQ.2.OR.NDIMMO.EQ.3))
   >      &    CALL U2MESS('F','MODELISA2_6')
                                                                                            
                         
                                                                                            
                         
    
    
   Liste des fichiers impactés par la correction de la fiche:  14980
     cafaci.f  calicp.f  caliob.f  caliso.f  calyrc.f  caprec.f
     modelisa2.py
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 6.0
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 6.0
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   xc3xa9tude jointe
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR geniaut      GENIAUT Samuel         DATE 14/05/2010 - 09:05:35

--------------------------------------------------------------------------------
RESTITUTION FICHE 015036 DU 2010-05-05 14:26:41
TYPE express concernant Code_Aster (VERSION 10.1)
TITRE
   X-FEM : nb de mailles enrichies limitxc3xa9es
FONCTIONNALITE
   Problème :
   Dans xenrch.f, on limite le nb de mailles enichies à NBMA/10
   
   c'est trop peu pour certaines études.
   
   
   Solution:
   On dimensionne le tableau en question à NBMA, nb de mailles du maillage
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test perso
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 14/05/2010 - 09:05:35

--------------------------------------------------------------------------------
RESTITUTION FICHE 014971 DU 2010-04-19 15:44:19
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TMA : DeltaCad
TITRE
   RECU_TABLE - message d'erreur dxc3xa9veloppeur
FONCTIONNALITE
   Problème
   --------
   Lorsque l'utilisateur souhaite récupérer une table qui 
   n'existe pas, en l'occurence la table ESTI_GLOB. Cette table 
   contient les estimateurs d'erreur globaux. Aster emet un 
   message d'erreur développeur peu explicite.
   
   Modification
   -------------
   => Ajout d'un message plus explicite dans table0.py
   "La table 'ESTI_GLOB' n'existe pas dans le résultat RESU_1."
   
   Modif de la routine ltnotb.f pour prendre en compte le 
   nouveau message
   
   Validation
   ----------
    - Etude fournie
    - Ajout dans le cas-test zzzz257a de 
        RECU_TABLE(CO=RESU,NOM_TABLE='ESTI_GLOB')
   
   4) Documentation
   ----------------
   Modification de la doc U4.71.02 "RECU_TABLE": description de 
   la table ESTI_GLOB
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   zzzz257a
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR abbas        ABBAS Mickael          DATE 14/05/2010 - 09:05:35

--------------------------------------------------------------------------------
RESTITUTION FICHE 014110 DU 2009-10-27 14:22:53
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   'DEPL_CALCULE' et AFFE_CHAR_CINE
FONCTIONNALITE
   En DEPL_CALCULE (ou EXTRAPOL), l'incrément de dépalacement initial n'est pas calculé par
   K.DELTA_U = F mais donné par l'utilisateur -> on ne crée donc pas de matrice K.
   Les algos de contact ne peuvent donc pas travailler ensuite puisqu'il ne peuvent pas
   calculer le complément de Schur (sans matrice K, comment faire ? )
   
   La subtilité, c'est que, d'habitude, on crée quand même une matrice en DEPL_CALCULE pour
   vérifier que les champs sont cinématiquement admissibles, sauf s'il y a du AFFE_CHAR_CINE
   (voir l'alarme MECANONLINE5_48)
   C'est le cas de cet exemple. 
   
   Solution:
   Une évolution consistant à reprojeter les champs cinématiquement admissibles aussi avec
   AFFE_CHAR_CINE.
   La matrice est donc systématiquement construite en prédiction -> plus de bug
   
   Validation:
   Tous les cas-tests faisant du DEPL_CALCULE+PREDICTION
   Modification du zzzz237a (contact avec AFFE_CHAR_CINE) pour valider DEPL_CLACULE avec
   AFFE_CHAR_CINE (+ cotn act, ça ne mange pas de pain): on le coupe en deux, le deuxième
   commence avec un DEPL_CALCULE.
   
   Pour la V9:
   C'est finalement une évolution que l'on propose en v10.
   En v9, il faut interdire la combinaison DEPL_CALCULE+CONTACT+pas de AFFE_CHAR_MECA pour
   les DIRICHLET pour ne pas tomber sur l'objet JEVEUX inexistant.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   comp002i,perfe02a,sdll133b,ssnv115a,forma03b,pynl01a,sdns106a,ssnv206a,zzzz237a
NB_JOURS_TRAV  : 4.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desoza       DE SOZA Thomas         DATE 14/05/2010 - 09:05:35

--------------------------------------------------------------------------------
RESTITUTION FICHE 014956 DU 2010-04-15 15:45:12
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   La prediction ne tient pas compte du contact en formulation continue
FONCTIONNALITE
   Anomalie
   ========
   
   La formulation continue du contact souffrait depuis son introduction dans Code_Aster d'un
   bug entraînant la non prise en compte des forces de contact et de frottement dans la
   prédiction.
   
   Détails
   =======
   
   La recherche de ce bug est détaillée dans le CR-AMA-010.77 à paraître. On y montre en
   particulier que la formulation continue ne travaille en correction qu'au sein de la boucle
   de Newton et que le critère de convergence de Newton devra être adapté pour mieux traiter
   le caractère mixte du problème de C/F.
   
   Le bug avait pour conséquence l'impossibilité de vérifier la condition de Signorini sur le
   jeu dès la prédiction si le jeu initial n'était pas nul. Ainsi cela expliquait pourquoi
   l'on faisait toujours 2 itérations de Newton même en élastique HPP pour atteindre la
   convergence.
   
   En effet les forces de contact/frottement sont calculées à chaque itération mais elles ne
   sont ajoutées qu'aux forces internes après le calcul de celles-ci. Or les forces internes
   ne sont calculées qu'après intégration de la LdC, donc jamais en prédiction.
   En effet en prédiction on calcule les forces internes directement à partir des contraintes
   à l'instant moins : c'est ce que l'on appelle les forces nodales dans Code_Aster qui sont
   calculées par l'option FORC_NODA.
   ==> Comme l'on ajoutait pas les forces de C/F aux forces nodales, elles n'intervenaient
   pas à la prédiction
   
   Correction
   ==========
   
   La correction est très simple, il suffit de modifier l'assemblage de second membre en
   prédiction pour ajouter ces forces (qui on le rappelle étaient déjà calculées !).
   
   Impact : nmassp.f
   
   À faire en V9.
   
   Validation
   ==========
   
   La correction impactant la formulation 'CONTINUE' + 'XFEM' du contact, on a fait un astout
   contact sur ces 2 formulations. Le bilan des tests cassés est le suivant : 
   
   feti008a             NOOK_TEST_RESU         6.60        1.90        8.50
   feti008b             NOOK_TEST_RESU         6.01        0.88        6.89
   feti010a             NOOK_TEST_RESU         7.55        1.40        8.95
   ssnp110d             ERREUR_<F>             5.86        1.88        7.74
   ssnv209b             ERREUR_<F>             4.96        1.01        5.97
   ssnv504d             NOOK_TEST_RESU        24.54        1.60       26.14
   ssnv504j             NOOK_TEST_RESU        44.79        1.70       46.49
   --------  ---------  ----------------  ---------   ---------   ---------
        124    117          7              11961.28      698.49    12659.77
   
   +feti008* : 2 valeurs quasi nulles testées en relatif sont désormais testées en absolu
               5 tests de non-régression dépassent la tolérance fixée à 10^¯4% tout 
               en restant inférieurs à 0.1%. On change les valeurs de référence.
   
   +feti010a : 1 test de non-régression dépasse la tolérance. Même remède que pour feti008*.
   
   +ssnp110d/ssnv209b : déjà cassés en NEW10.
   
   +ssnv504d/ssnv504j : on testait que le nombre d'itérations de Newton à certains pas de
   temps était bien de 2, c'est désormais 1, on change donc les valeurs de référence.
   
   Gain potentiel (ou pas)
   =======================
   
   * On va gagner en perfs : 
   - dans le cas HPP élastique, par exemple cf. SSNA102D, qui fait 2 fois moins d'itérations
   de Newton
   - dans le cas où le jeu initial était non nul ou bien le contact est établi
   progressivement, par exemple cf. SSNV501, 503, 504. On gagne dans ces tests une poignée
   d'itérations (5%)
   
   * On ne va pas gagner en perfs :
   - en dynamique, en effet les forces internes interviennent déjà en prédiction. Cela
   explique pourquoi en dynamique on ne faisait qu'une seule itération de Newton, cf SDNL111E
   - dans le cas où les solides sont initialement en contact, le jeu est donc nul, et ne pas
   tenir des forces de contact revient à imposer un variation de jeu nulle.
   
   
   Modifications en version 9 :
   - ajustement des valeurs de référence de non-régression de feti010a
   - correction du maillage du ssnv506e (maillage identique à celui de la v10).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : R5.03.52
VALIDATION
   astout continu+xfem
NB_JOURS_TRAV  : 12.0
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST AJOUT ssnd109a                      macocco K.MACOCCO          211    211      0
 CASTEST MODIF feti008a                      macocco K.MACOCCO          155      9      9
 CASTEST MODIF feti008b                      macocco K.MACOCCO          160      9      9
 CASTEST MODIF feti010a                      macocco K.MACOCCO          291      6      6
 CASTEST MODIF ssnv171c                      macocco K.MACOCCO          421      3      3
 CASTEST MODIF ssnv504d                      macocco K.MACOCCO          296      9      9
 CASTEST MODIF ssnv504j                      macocco K.MACOCCO          267      3      3
 CASTEST MODIF ssnv506e                      macocco K.MACOCCO          257      5      1
 FORTRAN AJOUT algorith/lcmmec               macocco K.MACOCCO           82     82      0
 FORTRAN MODIF algorith/calcme                granet S.GRANET           530      4      4
 FORTRAN MODIF algorith/comthm                granet S.GRANET           224      4      4
 FORTRAN MODIF algorith/ddlact               macocco K.MACOCCO          186     13      1
 FORTRAN MODIF algorith/hmlvag                granet S.GRANET           368      2      1
 FORTRAN MODIF algorith/kitdec                granet S.GRANET            72      3      3
 FORTRAN MODIF algorith/lcmmon               macocco K.MACOCCO          173      3      3
 FORTRAN MODIF algorith/lcmmop               macocco K.MACOCCO          342      3      3
 FORTRAN MODIF algorith/nmprde               macocco K.MACOCCO          241      6      2
 FORTRAN MODIF algorith/nsassp               macocco K.MACOCCO          201     28      8
 FORTRAN MODIF algorith/xenrch               macocco K.MACOCCO          408      2      2
 FORTRAN MODIF modelisa/caliob               macocco K.MACOCCO          298      5      4
 FORTRAN MODIF modelisa/caliso               macocco K.MACOCCO          262      5      4
 FORTRAN MODIF modelisa/op0059               macocco K.MACOCCO          369      7      2
 FORTRAN MODIF utilitai/ltnotb               macocco K.MACOCCO          103      7      2
 FORTRAN MODIF utilitai/rsexc2               macocco K.MACOCCO           96     11      8
  PYTHON MODIF Messages/compor1              macocco K.MACOCCO          371      7      1
  PYTHON MODIF Messages/mecanonline5         macocco K.MACOCCO          215      8      1
  PYTHON MODIF Messages/modelisa2            macocco K.MACOCCO          399     12      1
  PYTHON MODIF Messages/soustruc2            macocco K.MACOCCO           60     13      1
  PYTHON MODIF Messages/table0               macocco K.MACOCCO           85      6      1
  PYTHON MODIF Messages/utilitai8            macocco K.MACOCCO          270     14      4


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :    2         293       293              +293
 MODIF :   28        7120       207     100      +107
 SUPPR :    0           0                 0        +0
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :   30        7413       500     100      +400 
