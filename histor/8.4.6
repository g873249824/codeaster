

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR devesa       DEVESA Georges         DATE 06/06/2007 - 15:47:12

--------------------------------------------------------------------------------
RESTITUTION FICHE 010770 DU 2007-04-06 15:13:22
TYPE anomalie concernant Code_Aster (VERSION 8.4)
TITRE
   format d'xc3xa9criture des impxc3xa9dances de sol par MACRO_MISS_3D
FONCTIONNALITE
   Dans la commande IMPR_MACR_ELEM au format MISS3D, on prévoit maintenant un 
   nouveau mot-clé FORMAT_R attendant le format actuel par défaut 1PE12.5 ainsi 
   que le nouveau format 1PE16.9 qui sera actif avec la version 1.4 de PROMISS3D.
   Dans ce but, et pour préparer la réalisation de la fiche 10761 associée à la 
   livraison de cette version avec la STA8.5, on prévoit dès maintenant dans le 
   catalogue de MACRO_MISS_3D d'avoir la version V1_4 et de mettre la version 
   V1_3 par défaut. La version V1_2 n'est plus accessible. Ce branchement 
   nécessaire maintenant côté Aster sera actif côté MISS3D lorsque la version 
   1.4 de PROMISS3D sera installée en juin.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U7.03.11 U7.04.33
VALIDATION
   test ZZZZ108A
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 010627 DU 2007-03-09 19:24:31
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TITRE
   Energie potentielle des xc3xa9lxc3xa9ments DKTG
FONCTIONNALITE
   Pour calculer en V8 l'option EPOT_ELEM_DEPL pour les 
   éléments supportant une modélisation DKTG, il faut 
   modifier ainsi la ligne 89 dans la routine DXEFGT afin de 
   pouvoir utiliser des éléments MEDKTG3 et MEDKQG4:
          ELSEIF(NOMTE(1:8).NE.'MEDKTR3 ' .AND.
        &        NOMTE(1:8).NE.'MEDSTR3 ' .AND.
        &        NOMTE(1:8).NE.'MEDKQU4 ' .AND.
        &        NOMTE(1:8).NE.'MEDKTG3 ' .AND.
        &        NOMTE(1:8).NE.'MEDKQG4 ' .AND.
        &        NOMTE(1:8).NE.'MEDSQU4 ' .AND.
        &        NOMTE(1:8).NE.'MEQ4QU4 ' ) THEN
   
   R: cette modif est inutile en V9 où on ne teste pas NOMTE.
   On joint le texte de la routine DXEFGT en V8
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   xc3xa9tude avec DKTG
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR voldoire     VOLDOIRE François      DATE 06/06/2007 - 15:47:13

--------------------------------------------------------------------------------
RESTITUTION FICHE 010911 DU 2007-05-29 11:53:26
TYPE express concernant Code_Aster (VERSION 2.x)
TITRE
   catalogue de MACRO_MISS_3D : version V1_4
FONCTIONNALITE
   Cf. Réalisation de la fiche 10761 associée à la 
   livraison de cette version avec la STA8.5, 
   
   on prévoit dès maintenant dans le catalogue de MACRO_MISS_3D d'avoir la version V1_4 et de
   mettre la version 
   V1_3 par défaut. La version V1_2 n'est plus accessible. Ce branchement 
   nécessaire maintenant côté Aster sera actif côté MISS3D lorsque la version 
   1.4 de PROMISS3D sera installée en juin.
   
   Cf. fiche 10770 (EDA du 29/05/2007). 
   FV
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ras
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR abbas        ABBAS Mickael          DATE 06/06/2007 - 15:47:13

--------------------------------------------------------------------------------
RESTITUTION FICHE 010637 DU 2007-03-12 15:02:15
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TITRE
   plantage avec RESI_REFE_RELA
FONCTIONNALITE
   L'utilisateur fait appel à l'option RESI_REFE_RELA sans donner une contrainte de 
   référence (SIGM_REFE, EPSI_REFE, FLUX_THER_REFE, VARI_REFE, FLUX_HYD1_REFE ou 
   FLUX_HYD2_REFE).
   Ces données étant initialisées à R8VIDE, erreur FPE au moement du calcul des forces 
   nodales de référence (REFE_FORC_NODA).
   On blinde le catalogue STAT_NON_LINE et DYNA_NON_LINE:
   
   b_refe_rela    =BLOC(condition = "RESI_REFE_RELA != None",
                regles=(AU_MOINS_UN('SIGM_REFE','EPSI_REFE','FLUX_THER_REFE',
                                     'FLUX_HYD1_REFE','FLUX_HYD2_REFE','VARI_REFE'),),
                SIGM_REFE       =SIMP(statut='f',typ='R'),
                EPSI_REFE       =SIMP(statut='f',typ='R'),
                FLUX_THER_REFE  =SIMP(statut='f',typ='R'),
                FLUX_HYD1_REFE  =SIMP(statut='f',typ='R'),
                FLUX_HYD2_REFE  =SIMP(statut='f',typ='R'),
                VARI_REFE       =SIMP(statut='f',typ='R'),                     
              ),
   
   Correction à faire aussi en 8.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   cas-test
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 010368 DU 2006-12-07 16:34:07
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TITRE
   AFFE_CHAR_CINE seul + STAT_NON_LINE : non convergence
FONCTIONNALITE
   Lorsque l'on a un AFFE_CHAR_CINE seul avec aucun chargement en force, le résidu 
   relatif (RESI_GLOB_RELA) est incalculable (division par zéro) et Aster le met à -1. 
   Il ne converge donc jamais.
   Dans ce cas, on arrête l'utilsiateur avec le message suivant:
   
   99: _("""
     -> Le chargement ext?eur est nul (?a pr?sion pr?.
        Or vous avez demand?ne convergence avec le crit? relatif (RESI_GLOB_RELA). 
     -> Risque & Conseil : V?fier bien que votre chargement doit ?e nul ?et 
   instant 
        Le chargement est "nul" dans le cas de l'utilisation d'AFFE_CHAR_CINE en 
   particulier.
        Il vous faut changer votre crit? de convergence: RESI_GLOB_MAXI ou 
   RESI_REFE_RELA
   """), 
   
   On modifie sslp100c pour passer ce cas (on met AFFE_CHAR_CINE + RESI_GLOB_MAXI)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   cas-test lui meme
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 06/06/2007 - 15:47:14

--------------------------------------------------------------------------------
RESTITUTION FICHE 010577 DU 2007-02-26 06:53:17
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TITRE
   LIRE_MAILLAGE (FORMAT='MED')
FONCTIONNALITE
   La lecture d'un maillage MED plantait si un nom de groupe contenait des accents.
   
   On ajoute un utilitaire pour ne conserver que les caractères alphanumériques d'une chaine
   de caractères : LXNOAC (dans la lignée de LXCAPS, LXMINS).
   
   Suite à la lecture des noms de groupes, on ajoute une vérification supplémentaire (après
   le renommage demandé par l'utilisateur, la longueur limitée à 8 caractères des noms de
   groupes).
   Si le nom de groupe contient des caractères interdits, on remplace ces caractères et on
   émet une alarme pour prévenir l'utilisateur qu'il doit le nom de groupe modifié.
   
   Liste des caractères autorisés (voir la routine lxnoac.f) : [a-z] [A-Z] [0-9]
   
   Le caractère de remplacement est "_" (underscore).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   lecture du fichier med joint
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 010791 DU 2007-04-17 14:06:59
TYPE anomalie concernant Code_Aster (VERSION 8.4)
TITRE
   Lecture de fichiers MED
FONCTIONNALITE
   Le fichier med en question est invalide : le nom du maillage est "Coupe 1                
          " (avec des blancs à la fin).
   
   L'interface fortran/C de med_fichier enlève systématiquement les blancs en fin de chaine
   fortran.
   Le fichier a donc probablement été créé via les routines C de la bibliothèque med, mais
   curieux que la chaine contienne des blancs...
   
   Si on renomme le nom du maillage dans Salomé (en prenant soin de ne pas mettre de blancs à
   la fin), on le relit sans problème dans Aster.
   
   Amélioration du message d'erreur :
   
   !------------------------------------------------------------------------!
      ! <F> <MODELISA5_14>                                                     !
      !                                                                        !
      !                                                                        !
      !  MED : Erreur lors de l'appel à EFNEMA, code retour = -1               !
      !                                                                        !
      !   -> Risque & Conseil :                                                !
      !     Vérifier l'intégrité du fichier MED avec medconforme/mdump.        !
      !     Si le maillage a été produit par un code externe, vérifier que les !
      !     noms de maillage, de groupes, de familles ne contiennent pas de    !
      !     blancs à la fin.                                                   !
      !     Dans Salomé, on peut renommer ces entités et supprimer les espaces !
      !     invalides.                                                         !
      !                                                                        !
      !                                                                        !
      !                                                                        !
      ! Cette erreur est fatale. Le code s'arrete.                             !
      !------------------------------------------------------------------------!
      
   
   Voir fiche n°20 dans le bugtracker de med.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   lecture du fichier corrigxc3xa9 dans Salomxc3xa9
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 010406 DU 2006-12-21 12:37:13
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TITRE
   messages en version 8
FONCTIONNALITE
   Il y a deux demandes dans la fiche.
   
   1. Le tableau récapitulatif des temps cpu passés dans chaque commande n'est pas affiché en
   cas d'erreur <S> :
   
   - modif dans N_JDC.py pour afficher le tableau y compris en cas d'erreur <S>.
   
   => on fait en version 8 et en version 9.
   
   
   2. Ajouter le nom de la commande dans les messages :
   
   - Ce n'est pas si évident que çà. Utmess peut maintenant être appelé de n'importe où
   (opérateurs, macro-commandes et aussi entre deux commandes).
   - Pour savoir dans quelle commande on est quand un message donné est émis, il suffit de
   regarder le .mess !
   - Pourquoi pas en version de développement, mais ce serait plutôt une évolution avec trop
   de différences pour le reporter sans risque en version d'exploitation.
   
   => on ne fait rien pour ce point.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   astout
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 010399 DU 2006-12-19 14:47:14
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TITRE
   CALC_FONCTION mot clxc3xa9 enveloppe : une autre en moins clair !!!
FONCTIONNALITE
   L'utilisateur fait CALC_FONCTION/ENVELOPPE à partir de deux fonctions dont une a été
   définie avec INTERPOL='NON'.
   
   Le message d'erreur n'est effectivement pas très clair du fait que les opérations sur les
   fonctions sont effectuées dans le module t_fonction non pas sur les concepts fonction
   eux-mêmes mais sur les objets t_fonction (après conversion).
   
   Dans t_fonction, on ajoute des exceptions plus spécialisées pour remonter les problèmes
   d'interpolation, de prolongement ou sur les paramètres des fonctions.
   Dans CALC_FONCTION (ops), on stocke le nom de la ou des fonctions que l'on est en train de
   traiter pour pouvoir afficher un message précis en cas d'erreur.
   
   Dans le cas signalé ici, on obtient ce message :
      
      !-------------------------------------------------------------------------!
      ! <F> <FONCT0_27>                                                         !
      !                                                                         !
      !                                                                         !
      ! Un problème d'interpolation a été rencontré.                            !
      ! Fonctions concernées : DZ0A_0, F_NULLE                                  !
      !                                                                         !
      !   -> Risque & Conseil :                                                 !
      !       Vérifier les valeurs fournies derrière le mot-clé 'INTERPOL' lors !
      !       de la création de cette(ces) fonction(s).                         !
      !                                                                         !
      !   -> Debug :                                                            !
      !       abscisse = 0.005, intervalle = [0.005, 0.01]                      !
      !                                                                         !
      !                                                                         !
      !                                                                         !
      ! Cette erreur est fatale. Le code s'arrete.                              !
      !-------------------------------------------------------------------------!
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   xc3xa9tude jointe + tests calc_fonction
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 009995 DU 2006-09-05 17:46:21
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TITRE
   Pb d?impression de SIXX, SIYY avec IMPR_RESU format MED
FONCTIONNALITE
   L'utilisateur essaie d'imprimer au format MED deux composantes d'un même champ en faisant
   deux IMPR_RESU dans le même fichier.
   Le nom du champ écrit dans le fichier MED est construit automatiquement sans y inclure le
   nom de la (des) composante(s) retenue(s).
   Le code s'arrêtait alors en erreur fatale avec un message peu clair.
   
   On modifie le message pour plus de clarté et on transforme l'erreur fatale en erreur <S>
   pour que la base soit sauvegardée.
   
   
   Nouveau message :
   
   
      !-------------------------------------------------------------------------------!
      ! <EXCEPTION> <PREPOST2_5>                                                      !
      !                                                                               !
      !                                                                               !
      ! Ce champ existe déjà dans le fichier MED. On ne peut pas le créer de nouveau. !
      !                                                                               !
      ! Nom MED du champ : "U2______SIEF_ELNO_ELGA__________"                         !
      !                                                                               !
      !   -> Risque & Conseil :                                                       !
      !       Si vous essayez d'imprimer les différents composantes d'un champ,       !
      !       ne faites qu'un seul IMPR_RESU avec la liste des composantes à          !
      !       retenir derrière le mot-clé NOM_CMP.                                    !
      !                                                                               !
      !                                                                               !
      !                                                                               !
      !                                                                               !
      !-------------------------------------------------------------------------------!
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   erreur reproduite sur un test de la base
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desroches    DESROCHES Xavier       DATE 06/06/2007 - 15:47:17

--------------------------------------------------------------------------------
RESTITUTION FICHE 010510 DU 2007-02-06 15:25:24
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TITRE
   Contraintes fausses dans les plaques avec excentrement
FONCTIONNALITE
   La correction dans te0033 n'est pas suffisante.
   Il faut aussi introduire l'excentrement dans dktcol, 
   dstcol, etc...
   et dxdmul (cas des multicouches).
   Je corrige le fortran et enrichit le cas-test ssls112 dans
   lequel je teste SIGM_ELNO_DEPL sur les multicouches 
   excentrés et compare avec un calcul de référence en 
   multicouche non excentré. Les résultats sont bien les 
   memes.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 8.1
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 8.1
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   SSLS112
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR pellet       PELLET Jacques         DATE 06/06/2007 - 15:47:17

--------------------------------------------------------------------------------
RESTITUTION FICHE 010857 DU 2007-05-14 07:46:24
TYPE anomalie concernant Code_Aster (VERSION 8.4)
TMA : CS
TITRE
   Message d'alarme non explicite
FONCTIONNALITE
   Version 8
   =========
   
   Dans l'étude jointe, l'alarme est injustifiée et provient d'un bug dans le calcul du
   chargement de dilatation thermique.
   
   On profite de cette fiche pour s'assurer que le bug n'existe pas dans d'autres routines
   te00ij et on passe la liste des cas tests pour vérifier que les résultats n'ont pas bougé.
   
   RESU_FAUX :
   ------------
   Ce bug a pour conséquence des résultats FAUX dans le cas suivant :
   
   - le calcul est thermo-mécanique.
   - le modèle contient des coques
   - le champ de température fourni au calcul mécanique ne comporte comme ddl que TEMP (et
   pas TEMP_SUP ni TEMP_INF)
   
   
   Les résultats sont alors vraiment faux car les températures ne sont pas initialisées et
   valent n'importe quoi.
   
   Remarque : Ces résultats faux sont accompagnés d'une alarme qui doit inquiéter l'utilisateur.
   
   
   
   Validation :
   ------------
   On valide sur le cas test hpla100c en modifiant la création du champ de température :
   
   T_FIN2=CREA_CHAMP( OPERATION='AFFE', TYPE_CHAM='NOEU_TEMP_R',
          MAILLAGE=MA, AFFE=_F( TOUT='OUI',        NOM_CMP=('TEMP_INF', 'TEMP','TEMP_SUP'),
          VALE=   (    0.1   ,  0.1 ,    0.1   ), ), )
   
   devient :
   
   T_FIN2=CREA_CHAMP( OPERATION='AFFE', TYPE_CHAM='NOEU_TEMP_R', MAILLAGE=MA,AFFE=_F(
   TOUT='OUI',NOM_CMP='TEMP',                            VALE=   0.1   ), )
   
   Détails :
   ---------
   On en profite pour améliorer le message d'alarme en recopiant le message actuel de la
   version 9 :
   
     -> Les variables de commandes initiales induisent des contraintes incompatibles.
     -> Risque & Conseil : Ce message apparait si l'état initial
       (avant le premier instant de calcul) est tel que les variables de commande
   (température, hydratation, séchage...) conduisent à des contraintes non équilibrées. Dans
   le cas de la température, vérifiez que la valeur TEMP_REF correspond à la température de
   l'état initial.
   
   
   Ce message est temporaire car une fiche dédiée existe déjà pour ce point particulier
   (fiche 10545).
   
   Version 9
   =========
   Le bug a été corrigé lors du passage de la temperature en variable de commande "new look".
   Le message en v9 est celui qui est présenté ci-dessus.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 4.2.10
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   xc3xa9tude fournie + hpla100c
--------------------------------------------------------------------------------
RESTITUTION FICHE 010891 DU 2007-05-23 15:26:32
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TITRE
   test mac3c01a cassxc3xa9 en 9.0.23
FONCTIONNALITE
   Problème :
   ----------
                                                                                                
    Le test mac3c01a est cassé depuis la version 9.0.23
                                                                                            
    Correction :
   ------------
    Un petit bug a été introduit en 9.0.23 dans la routine te0150.f.
    Je le corrige :
                                                                                            
                           
   434c434
   <                FFE(I+NC) = FFE(I+NC) + BSM(I+NC,J+6) * DE(J+NC)
   ---
   >                FFE(I+NC) = FFE(I+NC) + BSM(I+NC,J+NC) * DE(J+NC)
                                                                                           
                           
   Détail:
   -------
   Lionel Salmona m'a fait remarqué qu'il existait (depuis longtemps)une faute de frappe dans
   te0150 :
   383c383
   <                CALL RCVARC(' ','SECH','+','RIGI',IGAU,1,
   ---
   >                CALL RCVARC(' ','HYDR','+','RIGI',IGAU,1,
                                                                                            
                           
   Cette erreur donne des résultats faux si on fait des calculs d'hydratation sur les poutres
   (pou_d_em et pou_d_tgm).
   Heureusement, il n'y a aucun test de cette nature !
   
                                                                                            
   RESU_FAUX :
   -----------
   Des résultats faux ont pu être obtenus à partir de la version 8.3.10 si le modèle contient
   des éléments de POU_D_EM (ou POU_D_TGM) et que le calcul mécanique utilise un chargement
   d'hydratation : AFFE_MATERIAU/AFFE_VARC/NOM_VARC='HYDR'.
                           
    
   Version NEW8 :
   ===============
   reporter la correction :
   383c383
   <                CALL RCVARC(' ','SECH','+','RIGI',IGAU,1,
   ---
   >                CALL RCVARC(' ','HYDR','+','RIGI',IGAU,1,
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 8.3.2
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test mac3c01a
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 06/06/2007 - 15:47:18

--------------------------------------------------------------------------------
RESTITUTION FICHE 010327 DU 2006-11-29 17:23:01
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TITRE
   erreurs de programmation JEVEUO/'L'/'E' risque de rxc3xa9sultats faux
FONCTIONNALITE
   Jacques avait détecté des accès en écriture à des objets jeveux déclarés en lecture.
   
   Variables concernées :
   
   calfig.f variable: IDTHE
   nmdoet.f variable: JDEPOL
   mxmajd.f variable: JACCGM
   mxmajd.f variable: JDEPGM
   mxmajd.f variable: JVITGM
   mxmajd.f variable: JVITGP
                                                                                            
                           
   mechc1.f variable: ICESL
   mechc1.f variable: ICESV
   mtmchc.f variable: JCCJJ   
   
   
   Pour calfig : on supprime les lignes inutiles en 2ème partie de fichier.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   liste restreinte
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR pellet       PELLET Jacques         DATE 06/06/2007 - 15:47:19

--------------------------------------------------------------------------------
RESTITUTION FICHE 010701 DU 2007-03-27 15:30:20
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TITRE
   Temperature et COQUE_3D
FONCTIONNALITE
   Problème :
   ==========
   Les éléments de coque "3D" mettent la température à 0. (indument) sur certains points de
   Gauss.
                                                                                            
                           
   Le problème a été relevé par Lionel Salmona lors du passage de la température en variable
   de commande "new look" (9.0.15).
   Il a observé (en faisant des write) dans vdesga.f que la température récupérée sur
   certains points de gauss était prise =0. sans aucune raison.
                                                                                            
                           
   Ce problème a été résolu en NEW9 (9.0.15) par une reprogrammation assez complète de la
   façon de récupérer la température, mais un doute subsistait concernant la version 8.
                                                                                            
                           
                                                                                            
                           
   Solution :
   ==========
                                                                                            
                           
   Il y a en réalité 2 problèmes distincts révélés par cette fiche :
   1) PB1 : Le problème initial de température = 0. (en version NEW8 seulement)
   2) PB2 : Un problème plus général de mauvais rangement des contraintes dans les champ
   SIEF_ELGA[_DEPL]. (en NEW8 et NEW9)
      Les points et les sous-points ne sont pas rangés correctement :
         - tous éléments      : P1/SP1 P1/SP2 ... P1/SPn   P2/SP1 P2/SP2 ....
         - éléments coque 3D  : P1/SP1 P2/SP1 ... Pn/SP1   P1/SP2 P2/SP2 ....
                                                                                            
                           
   Ces 2 problèmes sont corrigés.
                                                                                            
                           
                                                                                            
                           
   Détails :
   =========
                                                                                            
                           
   PB1 :
   -----
   Le problème observé par Lionel est bien réel. La raison en est l'appel à btldth.f dans
   vdxsig.f : il y a une confusion du à un double sens de la variable INDIC :
     - parfois elle veut dire : "il faut calculer le  second membre de dilatation"
     - parfois elle veut dire : "il faut utiliser un schéma d'intégration réduit"
                                                                                            
                           
   Du coup, dans vdxsig.f, on croyait utiliser le schéma d'intégration complet, mais en fait
   on utilisait les fonctions de forme du schéma réduit. Pour un QUAD9, la température ainsi
   calculée pour les points de Gauss 5 à 9 était nulle.
                                                                                            
                           
   Pour corriger ce problème, j'ai du dissocier l'argument INDIC de btldth.f en 2 arguments
   distincts : REDUIT et EFFORT.
   En conséquence, j'ai du modifier les 2 appelants de cette routine.
                                                                                            
                           
                                                                                            
                           
   PB2 :
   -----
   Après la correction de PB1, je me suis dit que le chargement de dilatation ne devait pas
   etre beaucoup testé dans les coques 3D (puisqu'on n'avait jamais vu ce bug datant de
   1998). J'ai donc réalisé un petit test simple :
                                                                                            
                           
   Une plaque carrée soumise à un gradient de température et encastrée sur son bord.
   La solution analytique est évidente.
                                                                                            
                           
   Je me suis alors aperçu qu'il y avait un autre problème : pour le champ SIEF_ELGA_DEPL,
   les points de Gauss et les "sous-points" dans l'épaisseur n'étaient pas rangés correctement.
   Le bug vient de la routine vdxsig.f :
   161c161
   <           K1=6*(KPGS-1)
   ---
   >           K1=6*((INTSN-1)*NPGE+INTE - 1)
                                                                                            
                           
   Suite à cette correction, le test m'a semblé OK mais j'ai préféré émettre une fiche d'EL
   (10925) pour demander un complément de validation pour ces éléments.
                                                                                            
                           
   Le problème relevé dans vdxsig.f existe aussi dans vdxnlr.f, fornpd.f, te0415.f et te0402.f.
   Il concerne toutes les contraintes aux points de gauss en linéaire et en non linéaire.
   Mais comme le (mauvais) rangement était cohérent dans toutes les routines des éléments de
   coque, cela n'entraine pas de résultats faux dans les calculs "chainés" : STAT_NON_LINE
   (sigma- -> sigma+), flambement d'Euler, ...
                                                                                            
                           
                                                                                            
                           
   Validation:
   ===========
   PB1 :
   Un petit test perso de plaque encastrée soumise à un gradient de température (en NEW8)
                                                                                            
                           
   PB2 :
   La liste des 91 tests de coque 3D sur bull en NEW9  (sauf hpla100c cassé en ce moment et
   ssnv505a trop long (900s)).
   Seuls 2 tests doivent etre modifiés car ils testaient la valeur des sous-points : hsns100a,b.
   Je modifie 1 valeur de référence (non-regression) dans ces 2 tests.
                                                                                            
                           
                                                                                            
                           
                                                                                            
                           
   Résultats faux :
   ================
                                                                                            
                           
   PB2 :
   -----
   Pour les éléments de coque 3D, les contraintes de SIEF_ELGA_DEPL (ou SIEF_ELGA) étaient
   mal rangées depuis la version 5.0.5.
   Mais ce n'est pas forcément grave car le rangement était cohérent entre les différentes
   options qui s'enchainent.
   Le seul problème concerne donc l'affichage de ces contraintes dans le fichier résultat et
   son éventuelle utilisation dans des post-traitements (par exemple le suivi des contraintes
   sur une couche précise NUME_COUCHE / NIVE_COUCHE).
                                                                                            
                           
   PB1 :
   -----
   Le procblème est plus restreint (mais plus grave).
                                                                                            
                           
   Conditions pour avoir des résultats faux :
      - modele coque 3D
      - calcul linéaire avec MECA_STATIQUE
      - chargement de température
   Nature des résultats faux :
      - contraintes SIEF_ELGA_DEPL
      - charges de flambement d'Euler
                                                                                            
                           
                                                                                            
                           
   Report en version NEW8 (pour CS) :
   ===================================
                                                                                            
                           
   pour PB1 :
   ----------
   J'ai joint un fichier NEW8.tar.gz contenant les 3 routines à modifier.
                                                                                            
                           
                                                                                            
                           
   Pour PB2 :
   ----------
   Je donne ci-dessous les corrections (minimes) apportées en version 9
   fornpd.f:167c167
   fornpd.f:<           K1=6*(KPGS-1)
   fornpd.f:---
   fornpd.f:>           K1=6*((INTSN-1)*NPGE*NBCOU + (ICOU-1)*NPGE +INTE - 1)
                                                                                            
                           
   te0402.f:109c109
   te0402.f:<       INTEGER     NPGE , NPGSN
   te0402.f:---
   te0402.f:>       INTEGER     NPGE , NPGSN, K1
   te0402.f:239a240
   te0402.f:>             K1=6*((INTSN-1)*NPGE+INTE - 1)
   te0402.f:243,244c244,245
   te0402.f:<             SIGMTD ( 1 )=ZR ( ICONTR - 1 + ( KPGS - 1 ) * 6 + 1 )
   te0402.f:<             SIGMTD ( 2 )=ZR ( ICONTR - 1 + ( KPGS - 1 ) * 6 + 2 )
   te0402.f:---
   te0402.f:>             SIGMTD ( 1 )=ZR ( ICONTR - 1 + K1 + 1 )
   te0402.f:>             SIGMTD ( 2 )=ZR ( ICONTR - 1 + K1 + 2 )
   te0402.f:246c247
   te0402.f:<             SIGMTD ( 3 )=ZR ( ICONTR - 1 + ( KPGS - 1 ) * 6 + 4 )
   te0402.f:---
   te0402.f:>             SIGMTD ( 3 )=ZR ( ICONTR - 1 + K1 + 4 )
   te0402.f:248,249c249,250
   te0402.f:<             SIGMTD ( 4 )=ZR ( ICONTR - 1 + ( KPGS - 1 ) * 6 + 5 )
   te0402.f:<             SIGMTD ( 5 )=ZR ( ICONTR - 1 + ( KPGS - 1 ) * 6 + 6 )
   te0402.f:---
   te0402.f:>             SIGMTD ( 4 )=ZR ( ICONTR - 1 + K1 + 5 )
   te0402.f:>             SIGMTD ( 5 )=ZR ( ICONTR - 1 + K1 + 6 )
                                                                                            
                           
   te0415.f:116c116
   te0415.f:<               K1 = 6* (KPGS-1)
   te0415.f:---
   te0415.f:>               K1=6*((INTSN-1)*NPGE*NBCOU + (ICOU-1)*NPGE +INTE - 1)
                                                                                            
                           
   vdxnlr.f:229c229
   vdxnlr.f:<             K1 = 6* (KPGS-1)
   vdxnlr.f:---
   vdxnlr.f:>             K1=6*((INTSN-1)*NPGE*NBCOU + (ICOU-1)*NPGE +INTE - 1)
                                                                                            
                           
   vdxsig.f:161c161
   vdxsig.f:<           K1=6*(KPGS-1)
   vdxsig.f:---
   vdxsig.f:>           K1=6*((INTSN-1)*NPGE+INTE - 1)
                                                                                            
                           
   hsns100a.comm:222c222
   hsns100a.comm:<                    VALE=-166.65,
   hsns100a.comm:---
   hsns100a.comm:>                    VALE=2.2899500136923E+02,
                                                                                            
                           
   hsns100b.comm:219,221c217,218
   hsns100b.comm:<         MAILLE = 'M5', POINT = 1, SOUS_POINT=14, NOM_CMP = 'SIYY', VALE =
   -1.6592E+02),
   hsns100b.comm:---
   hsns100b.comm:>         MAILLE = 'M5', POINT = 1, SOUS_POINT=14, NOM_CMP = 'SIYY', VALE =
   2.2834158979305E+02),
   
   Version 8 uniquement : ssls200a : on corrige les valeurs de référence.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 5.0.5
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 5.0.5
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test perso + tous les tests coque 3D
NB_JOURS_TRAV  : 1.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR delmas       DELMAS Josselin        DATE 06/06/2007 - 15:47:19

--------------------------------------------------------------------------------
RESTITUTION FICHE 010807 DU 2007-04-23 14:39:25
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TITRE
   Inversion dans le calcul des termes globaux de l'erreur en rxc3xa9sidu
FONCTIONNALITE
   Il y a une inversion dans le calcul global des termes normaux et de saut.
   L'erreur est faite dans zzglob.f lorsqu'on somme les termes élémentaires.
   
   Cette erreur a peu d'impact car ces termes globaux servent principalement à être imprimés
   dans le fichier .resu. Ils sont aussi stockés dans des paramètres de la structure de
   donnée et sont testés dans deux cas-tests.
   
   La correction est faite en :
   - remplaçant :
     TERMSA = TERMSA + ZR(IAD+6-1)**2
     TERMNO = TERMNO + ZR(IAD+8-1)**2
    par :
     TERMNO = TERMNO + ZR(IAD+6-1)**2
     TERMSA = TERMSA + ZR(IAD+8-1)**2
   
   - inversant deux valeurs dans deux TEST_RESU de deux cas-tests.
   
   Modifications dans :
   zzglob.f
   sslv113c.comm
   sslv113d.comm
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 8.1.22
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 9.0.0
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   Cas-tests perso + cas-tests de la base
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR pellet       PELLET Jacques         DATE 06/06/2007 - 15:47:20

--------------------------------------------------------------------------------
RESTITUTION FICHE 010912 DU 2007-05-29 12:42:34
TYPE express concernant Code_Aster (VERSION 2.x)
TITRE
   poursuite de calcul de thermo-hydratation
FONCTIONNALITE
   On ajoute le test zzzz221a :
                                                                                            
                           
   # TITRE CALCUL THERMO HYDRATATION ET SECHAGE BETON EN 2 LEVEES (2D AXIS)
   #=========================================================================
                                                                                            
                           
   Ce test montre comment réaliser avec Code_Aster un calcul de thermo-hydratation
   en simulant la dépose de 2 levées de béton.
   Le problème est de fabriquer l'état initial de la pousuite du calcul en assemblant
   2 champs : un état déjà calculé sur la 1ère levée et un état "vierge" sur la 2eme levée.
                                                                                            
                           
   Ce test dure 10 secondes sur clpaster.
   
   On peut également ajouter ce test en version 8
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   zzzz221a
NB_JOURS_TRAV  : 0.3
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR tardieu      TARDIEU Nicolas        DATE 06/06/2007 - 15:47:20

--------------------------------------------------------------------------------
RESTITUTION FICHE 010937 DU 2007-06-01 12:45:40
TYPE express concernant Code_Aster (VERSION 8.4)
TITRE
   Stanley + Salomxc3xa9 : pb quand on visualise un champ avec plusieurs xc3xa9tudes ouvertes
FONCTIONNALITE
   Quand depuis Stanley, on visualise un champ dans Salomé et que plusieurs études sont
   ouvertes, on propose à l'utilisateur dans une petite fenêtre de sélectionner l'étude où
   faire la visualisation. Pb : cette fenêtre était dimensionnée à 3 lignes en dure... 
   On modifie donc la fenêtre pour lui ajouter une barre d'ascenseur.
   
   Sources modifiées:
   graphiqueTk.py  salomeVisu.py
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   Test IHM
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR boyere       BOYERE Emmanuel        DATE 06/06/2007 - 15:47:21

--------------------------------------------------------------------------------
RESTITUTION FICHE 010579 DU 2007-02-26 08:32:21
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TITRE
   Grappe_Fluide : Calcul des forces fluides dans les mxc3xa9canismes
FONCTIONNALITE
   Des différences dans les initialisations entre le module GRAPPE_FLUIDE de Code_Aster et le
   code dont le module est issu, PEGASE, ont été décelées par Elisabeth Longatte et corrigées.
   Une fois ces corrections apportées, on observe une meilleure cohérences des résultats
   entre les deux codes.
   J'en profite pour créer un catalogue d'erreur spécifique au calcul des forces fluides de
   grappes de commande : grappefluide.py.
   
   eb
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V8.02.100
VALIDATION
   fdnl100a
NB_JOURS_TRAV  : 3.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR gnicolas     NICOLAS Gérald         DATE 06/06/2007 - 15:47:21

--------------------------------------------------------------------------------
RESTITUTION FICHE 010782 DU 2007-04-16 11:47:04
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TITRE
   DYNA_LINE_TRAN et sensibilitxc3xa9
FONCTIONNALITE
   Le problème apparaissait dans op0048, programme pilotant DYNA_LINE_TRAN. Les
   initialisations des calculs sensibles écrasaient l'initialisation du calcul standard. La
   correction a consisté à faire un gros travail de modularisation des programmes concernés
   pour gérer correctement les structures de données liées à la sensibilité.
   Pas de changement dans les cas-tests actuels car ils n'étaient pas impactés par l'erreur.
   
   En NEW8, on ne corrige pas. On mettra un arrêt fatal pour le cas où il y aurait
   cohabitation de sensibilité et d'état initial non nul.
   Le cas-test sensd04a est supprimé en version 8.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 7.2.19
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 9.00.00
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   xc3xa9tude fournie
NB_JOURS_TRAV  : 8.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR michel       MICHEL-PONNELLE Sylvie   DATE 06/06/2007 - 15:47:22

--------------------------------------------------------------------------------
RESTITUTION FICHE 010316 DU 2006-11-27 15:49:58
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TMA : CS
TITRE
   calc_elem option epfp_elno et epvc_elno
FONCTIONNALITE
   Routine celfpg.f :
   remplacement du JENUNO
           CALL JENUNO(JEXNUM('&CATA.TM.NOFPG',KFPG),NOFPG)
   par
           IF (KFPG.GT.0) THEN
             CALL JENUNO(JEXNUM('&CATA.TM.NOFPG',KFPG),NOFPG)
           ELSE
             CALL CODENT(KFPG,'G',NOFPG)
           ENDIF
   Correction deja réalisée en V9
   
   Validation :
   test ssnv180a, le CALC_ELEM est calculé sur la maille M1
   U=CALC_ELEM(reuse=U,  
               RESULTAT=U, MAILLE = 'M1',
               OPTION=('EPSI_ELNO_DEPL','EPVC_ELGA','EPVC_ELNO','EPFP_ELNO','EPFD_ELNO'),)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ssnv180a
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR galenne      GALENNE Erwan          DATE 06/06/2007 - 15:47:22

--------------------------------------------------------------------------------
RESTITUTION FICHE 010592 DU 2007-03-01 09:09:10
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
   CALC_G, option CALC_K_G et comportement non-linxc3xa9aire
FONCTIONNALITE
   Problème : 
   le calcul de K et de G en 3D avec X-FEM n'a été développé que pour les lois de
   comportement linéaires (opérateur CALC_G, option CALC_K_G).
   Les vérification ne sont pas sufisantes dans le fortran, et un calcul avec une loi de type
   ELAS_VMIS_LINE est possible mais donne des résultats faux !
   
   Correction :
   On vérifie dans le TE0295 quelle est la loi de comportement et on s'arrete en erreur si
   elle n'est pas linéaire.
   
   Perspectives : 2 fiches d'évolution émises
   - développement du calcul de G pour les modélisations X-FEM pour les lois de comportement
   élastiques non linéaires (fiche 10870)
   - vérification de la cohérence entre la loi de comportement utilisée pour le calcul et
   celle définie par l'utilisateur pour le post-traitement (fiche 10869)
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 8.0
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 9.0
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.82.03
VALIDATION
   cas test perso
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR pellet       PELLET Jacques         DATE 06/06/2007 - 15:47:23

--------------------------------------------------------------------------------
RESTITUTION FICHE 010860 DU 2007-05-15 07:44:24
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TMA : CS
TITRE
   NEW8.4.5, le test zzzz119a s'arrete dans FIN
FONCTIONNALITE
   Problème :
   -----------
   le test zzzz119a s'arrete en erreur fatale en 8.4.5
   
   Solution :
   ----------
   On corrige une faute de frappe dans op0166.f : confusion entre les 2 SD_RESULTAT LERES0 et
   LERES1.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   zzzz119a
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR adobes       ADOBES André           DATE 06/06/2007 - 15:47:23

--------------------------------------------------------------------------------
RESTITUTION FICHE 009678 DU 2006-04-13 07:50:34
TYPE anomalie concernant Code_Aster (VERSION 8.2)
TMA : CS
TITRE
   CALC_FLUI_STRU / POST_DYNA_ALEA
FONCTIONNALITE
   La routine pasfre.f calculait automatiquement les fréquences min et max, ainsi 
   que le nombre de points de discrétisation fréquentielle du spectre d'excitation 
   quand l'utilisateur ne précisait pas ces données d'entrée. Cette routine 
   n'était pas suffisamment générale et induisait des dysfonctionnements, 
   notamment dans le cas du traitement des modes doubles, voire très rapprochés. 
   Elle a été débranchée de Code_aster mais conservée de manière à pouvoir être 
   réactivée le cas échéant ultérieurement. Dans le catalogue des commandes, on a 
   donc rendu obligatoires l'introduction pas l'utilisateur des 3 paramètres 
   d'entrée sus-mentionnés.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V2.02.110 V2.02.117 V2.02.136 V2.02.501 V2.02.502 V2.02.503 V2.02.504 V2.02.505 V2.02.506 V2.02.507 V2.02.508 V5.02.112
VALIDATION
   passage des tests PROJ_SPEC_BASE
--------------------------------------------------------------------------------
RESTITUTION FICHE 010143 DU 2006-10-17 10:36:19
TYPE anomalie concernant Code_Aster (VERSION 8.3)
TITRE
   Test sdll506a en version NEW8.3.17 sous linux Rocks et Calibre 4
FONCTIONNALITE
   La correction faite dans le cadre de la fiche 9678 a permis de corriger le 
   problème qui était lié à une mauvaise estimation du spectre d'excitation en 
   présence de modes doubles.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   Passage du cas-test
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 010455 DU 2007-01-18 09:43:21
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TITRE
   test sdll136a en version NEW9.0.5 sous linux Calibre 4
FONCTIONNALITE
   Suite à la correction de la fiche 9678, il était nécessaire de renseigner dans l'opérateur 
   PROJ_SPEC_BASE le nombre de points de discrétisation du spectre. Après avoir choisi ce 
   nombre de points en concordance avec celui qui était calculé automatiquement par code_aster 
   avant la correction de la fiche 9678, le cas-test est ok.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   Passage du cas-test
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR pellet       PELLET Jacques         DATE 06/06/2007 - 15:47:25

--------------------------------------------------------------------------------
RESTITUTION FICHE 010601 DU 2007-03-02 13:17:53
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TMA : CS
TITRE
   Messages d'erreur pour les calculs de champs
FONCTIONNALITE
   Anomalie :
   -----------
   Si on veut calculer un champ pour une sd resultat qui ne peut pas être calculé (par manque
   de données), le message d'erreur est parfois obscur.
   Exemple : calcul de EPSI_NOEU_DEPL sur un mode_meca.
   Le message d'erreur est :
   
      !----------------------------------------------
      ! <F> <UTILITAI_50>                           
      !                                              
      !                                              
      !  cham_elem inexistant:  MODEAIR .012.000001  
      !                                              
      !                                             
      ! Cette erreur est fatale. Le code s'arrete.   
      !----------------------------------------------
   
   
   Correction proposée:
   ---------------------
   on teste le code restour de RSEXCH avant l'appel à DISMOI.
   si le code retour est non nul.
   
   le code émet le message d'Alarme :
   
   !-------------------------------------------------------------------
   ! <A> <PREPOST5_4>                                                            
   ! Champ inexistant EPSI_ELNO_DEPL numero d'ordre 1 pour le calcul
   ! de l'option EPSI_NOEU_DEPL.
   ! Cette option n'est donc pas calculée.
   !                                                              
   ! Ceci est une alarme. Si vous ne comprenez pas le sens de cette              
   ! alarme, vous pouvez obtenir des résultats inattendus !                       
   !-------------------------------------------------------------------
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ssll110a modifixc3xa9
--------------------------------------------------------------------------------
RESTITUTION FICHE 010905 DU 2007-05-25 13:40:29
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TMA : CS
TITRE
   NEW9.0.27, les tests sdnl130a, yyyy103a et c s'arretent en ERREUR
FONCTIONNALITE
   Problème :
   ----------
   Ces tests sont devenus NOOK car la modification de la température par défaut : 0. ->
   -9.99D299 a révélé un bug dans le te0160.f :
   
   La dilatation thermique vaut alpha*T
   au lieu de alpha*(T-TREF)
   
   Solution :
   ----------
   On corrige le te0160 pour tenir compte de TREF.
   
   
   Resultats faux :
   -----------------
   
   Conditions :
      - modelisation 'CABLE'
      - température affectée sur les éléments de cable
      - utilisation de STAT_NON_LINE / DYNA_NON_LINE
   
   nature des résultats faux :
       - champs de déplacement, de contraintes, ...  
   
   A corriger également en version 8
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 3.0
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 3.0
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sdnl130a, yyyy103a et c
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR cano         CANO Valérie           DATE 06/06/2007 - 15:47:26

--------------------------------------------------------------------------------
RESTITUTION FICHE 010002 DU 2006-09-07 11:14:23
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TMA : CS
TITRE
   bug dans la routine nzcizi.f (mxc3xa9tallurgie du zircaloy)
FONCTIONNALITE
   DETAILS
   
      ROUTINE NZISFW.F : Ecrouissage isotrope en HPP pour 
   l'acier
         
         1) modification de la présentation générale pour 
   que les 6 routines sur les
         lois de comportement avec métallurgies soient 
   identiques
            - supprimer l'appel des déclarations JEVEUX
            - calcul de SEUIL changé de place
            - DVIN(5) devient DVIN
            - des noms de variables ont changé
            - changé la manière de calculer la contrainte 
   élastique 
              car très compliquée pour rien
            - ajout de la variable VI(5)         
            - pour ne pas modifier VIM(1) à VIM(5), on fait
              avant VIM(I)=VIM(I)+DVIN(I)-DS
              maitenant VIM(I) reste VIM(I) et VI(I)=VIM(I)
   +DVIN(I)-DS
         
         2) bug sans conséquence         
            - modification de la routine pour que le calcul 
   de la matrice tangente
              RIGI_MECA_TANG soit avec les coefficents pris 
   à l'instant moins  
         
         3) bug avec conséquence
            - dans le cas d'un modèle visqueux, on peut 
   également activer la restauration
              d'écrouissage. Les coefficients C et M ne sont 
   pas obligatoires et dans le cas
              où ils ne sont pas présents dans le fichier de 
   commande, on choisit C=0 et M=20
              ce qui implique que la restauration n'est pas 
   prise en compte.
              Lorsque on appelle la routine RCVALA, le code 
   retour est 'F ' 
              ce qui implique que si ces 2 coefficients sont 
   absents, le fichier s'arrête 
              en erreur fatale ce qui n'a pas lieu d'être.
            - Test sur les variables qui donnent la 
   proportion de phases 
              (renvoi à la modification faite par jean-
   michel Proix fiche)
            - 2 Erreurs dans le calcul de DVIN(5) :
              pas de sommation sur les 4 autres phases
              pour calculer VIM(5), on utilise les 4 VIM(K). 
   Or ceux-ci ont été modifiés
              avant et valent VIM(K)=VIM(K)+DVIN(K) ce qui 
   est faux.
            - dans le cas d'un écrouissage non linéaire, on 
   ne prenait pas en compte le nombre
              de point de la courbe pour la perlite.
            - le calcul de l'écrouissage moyen VIP(7)=(1-
   FMEL)*R(5)+FMEL/ZALPHA*(Z(K)*R(K)) 
              est faux car R(I) n'est pas recalculée pour la 
   variable r(K) 
              de chaque phase correspondant à l'instant plus
   
      ROUTINE NZEDGA.F : Ecrouissage isotrope en HPP pour le 
   Zircaloy
         
         1) modification de la présentation générale pour 
   que les 6 routines sur les
         lois de comportement avec métallurgies soient 
   identiques
            - supprimer l'appel des déclarations JEVEUX
            - calcul de SEUIL changé de place
            - DVIN(3) devient DVIN
            - des noms de variables ont changé
            - changé la manière de calculer la contrainte 
   élastique 
              car très compliquée pour rien
            - ajout de la variable VI(3)         
            - pour ne pas modifier VIM(1) à VIM(3), on fait
              avant VIM(I)=VIM(I)+DVIN(I)-DS
              maitenant VIM(I) reste VIM(I) et VI(I)=VIM(I)
   +DVIN(I)-DS
         
         2) bug sans conséquence         
            - Tableau mal dimensionné
              VALRES(14),NOMRES(14) et CODRET(14) => VALRES
   (12),NOMRES(12),CODRET(12)
              KPT(3) => KPT(2)
              NOMCLE(5) => NOMCLE(3) 
            - modification de la routine pour que le calcul 
   de la matrice tangente
              RIGI_MECA_TANG soit avec les coefficents pris 
   à l'instant moins  
         
         3) bug avec conséquence
            - dans le cas d'un modèle visqueux, on peut 
   également activer la restauration
              d'écrouissage. Les coefficients C et M ne sont 
   pas obligatoires et dans le cas
              où ils ne sont pas présents dans le fichier de 
   commande, on choisit C=0 et M=20
              ce qui implique que la restauration n'est pas 
   prise en compte.
              Lorsque on appelle la routine RCVALA, le code 
   retour est 'F ' 
              ce qui implique que si ces 2 coefficients sont 
   absents, le fichier s'arrête 
              en erreur fatale ce qui n'a pas lieu d'être.
            - Test sur les variables qui donnent la 
   proportion de phases 
              (renvoi à la modification faite par jean-
   michel Proix fiche)
            - 2 Erreurs dans le calcul de DVIN(3) :
              pas de sommation sur les 2 autres phases
              pour calculer VIM(3), on utilise les 2 VIM(K). 
   Or ceux-ci ont été modifiés
              avant et valent VIM(K)=VIM(K)+DVIN(K) ce qui 
   est faux.
            - le calcul de l'écrouissage moyen VIP(5)=(1-
   FMEL)*R(3)+FMEL/ZALPHA*(Z(K)*R(K)) 
              est faux car R(I) n'est pas recalculée pour la 
   variable r(K) 
              de chaque phase correspondant à l'instant plus
      
      ROUTINE LCGDPM.F : Ecrouissage isotrope en grande 
   déformation pour l'acier
        
         1) modification de la présentation générale pour 
   que les 6 routines sur les
         lois de comportement avec métallurgies soient 
   identiques
            - J => JP
            - calcul de SEUIL changé de place
            - MAXVAL+2 => MAXVAL
            - DVIN(5) devient DVIN
            - des noms de variables ont changé
            - pour ne pas modifier VIM(1) à VIM(5), on fait
              avant VIM(I)=VIM(I)+DVIN(I) et VI(I)=VIM(I)-DS
              maitenant VIM(I) reste VIM(I) et VI(I)=VIM(I)
   +DVIN(I)-DS
         
         2) bug sans conséquence
            - tableau mal dimensionné
               DZ(5) devient DZ(4)
               DZ1(5) => DZ1(4)
               DZ2(5) => DZ2(4)
               KPT(5) => KPT(4)
            - erreur lorque qu'on calcule la pente 
   d'écrouissae à l'instant t-
              (conséquence uniquement sur la matrice 
   tangente avec RIGI_MECA)
              pour la phase 4 : PHASP au lieu de  PHASM  
         
         3) bug avec conséquence
            - dans le cas d'un modèle visqueux, on peut 
   également activer la restauration
              d'écrouissage. Les coefficients C et M ne sont 
   pas obligatoires et dans le cas
              où ils ne sont pas présents dans le fichier de 
   commande, on choisit C=0 et M=20
              ce qui implique que la restauration n'est pas 
   prise en compte.
              Lorsque on appelle la routine RCVALA, le code 
   retour est 'F ' 
              ce qui implique que si ces 2 coeffcients sont 
   absents, le fichier s'arrête 
              en erreur fatale ce qui n'a pas lieu d'être.
            - Test sur les variables qui donnent la 
   proportion de phases 
              (renvoi à la modification faite par jean-
   michel Proix fiche)
            - Lorsqu'on calcule VIM(K) K=1,4, on utilise VIM
   (5). Or celui-ci a été modifié
              avant et vaut VIM(5)=VIM(5)+DVIN(5) ce qui est 
   faux.
            - dans le cas d'un écrouissage non linéaire, on 
   ne prenait pas en compte le nombre
              de point de la courbe pourla perlite.
            - dans le cas non linéaire, une fois calculé 
   l'incrément de déformation plastique,
              on vérifie si on a pris la bonne pente 
   d'écrouissage pour chacune des phases.
              Programation actuelle
              TEST=1
              Si Z(5) > 0 : Si Pente=OK TEST=0, Si PENTE=NO 
   OK TEST=1
              Boucle sur les 4 autres phases
               Si Z(K) > 0 : Si Pente=OK TEST=0, Si PENTE=NO 
   OK TEST=1
              Faux car pour recalculer Dp, il faut au plus 
   qu'un seul TEST soit égal à 1  
              
      ROUTINE NZGDZI.F : Ecrouissage isotrope en grande 
   déformation pour le Zircaloy
         
         1) modification de la présentation générale pour 
   que les 6 routines sur les
         lois de comportement avec métallurgies soient 
   identiques
            - J => JP
            - calcul de SEUIL changé de place
            - MAXVAL+2 => MAXVAL
            - DVIN(3) devient DVIN
            - des noms de variables ont changé
            - pour ne pas modifier VIM(1) à VIM(3), on fait
              avant VIM(I)=VIM(I)+DVIN(I) et VI(I)=VIM(I)-DS
              maitenant VIM(I) reste VIM(I) et VI(I)=VIM(I)
   +DVIN(I)-DS
         
         2) bug sans conséquence
            - tableau mal dimensionné
              VALRES(14),NOMRES(14) et CODRET(14) => VALRES
   (12),NOMRES(12) et CODRET(12)  
            - lorqu'on récupère les coefficients de 
   plasticité de transformation, il traine
              dans l'appel de RCVALA un CODRET(9)
            
         3) bug avec conséquence
            - dans le cas d'un modèle visqueux, on peut 
   également activer la restauration
              d'écrouissage. Les coefficients C et M ne sont 
   pas obligatoires et dans le cas
              où ils ne sont pas présents dans le fichier de 
   commande, on choisit C=0 et M=20
              ce qui implique que la restauration n'est pas 
   prise en compte.
              Lorsque on appelle la routine RCVALA, le code 
   retour est 'F ' 
              ce qui implique que si ces 2 coeffcients sont 
   absents, le fichier s'arrête 
              en erreur fatale ce qui n'a pas lieu d'être.
            - Test sur les variables qui donnent la 
   proportion de phases 
              (renvoi à la modification faite par jean-
   michel Proix fiche)
            - Lorsqu'on calcule VIM(K) K=1,2, on utilise VIM
   (3). Or celui-ci a été modifié
              avant et vaut VIM(3)=VIM(3)+DVIN(3) ce qui est 
   faux.
            - dans le cas non linéaire, une fois calculé 
   l'incrément de déformation plastique,
              on vérifie si on a pris la bonne pente 
   d'écrouissage pour chacune des phases.
              Programmation actuelle
              TEST=1
              Si Z(3) > 0 : Si Pente=OK TEST=0, Si PENTE=NO 
   OK TEST=1
              Boucle sur les 2 autres phases
               Si Z(K) > 0 : Si Pente=OK TEST=0, Si PENTE=NO 
   OK TEST=1
              Faux car pour recalculer Dp, il faut 
   uniquement qu'un seul TEST vale 1  
    
   
      ROUTINE NZCIFW.F : Ecrouissage cinématique linéaire en 
   HPP pour l'acier
         
         1) modification de la présentation générale pour 
   que les 6 routines sur les
         lois de comportement avec métallurgies soient 
   identiques
            - supprimer l'appel des déclarations JEVEUX
            - calcul de SEUIL changé de place
            - DVIN(30) devient DVIN
            - des noms de variables ont changé
            - changé la manière de calculer la contrainte 
   élastique 
              car très compliquée pour rien
            - appel parfois de comportement isotrope 
   linéaire ou non (donc on supprime)        
            - pour ne pas modifier VIM(1) à VIM(30), on fait
              avant VIM(I)=VIM(I)+DVIN(I)-DS
              maitenant VIM(I) reste VIM(I) et VI(I)=VIM(I)
   +DVIN(I)-DS
              donc ajout de la variable VI(30) 
         
         2) bug sans conséquence
            - Tableau mal dimensionné
              VIMT(37) => VIMT(30)    
            - modification de la routine pour que le calcul 
   de la matrice tangente
              RIGI_MECA_TANG soit avec les coefficents pris 
   à l'instant moins  
         
         3) bug avec conséquence
            - Tableau mal dimensionné
              KPT(3) => KPT(4)
            - dans le cas d'un comportement élastique, on 
   met à jour les variables
              d'écrouissage VIM(1) à VIM(30) en ajoutant un 
   racine de 2 (pour I=4,6) 
              et on appelle PLASTI=VIM(37). Or ces variables 
   n'existent pas en élasticité. 
            - dans le cas d'un modèle visqueux, on peut 
   également activer la restauration
              d'écrouissage. Les coefficients C et M ne sont 
   pas obligatoires et dans le cas
              où ils ne sont pas présents dans le fichier de 
   commande, on choisit C=0 et M=20
              ce qui implique que la restauration n'est pas 
   prise en compte.
              Lorsque on appelle la routine RCVALA, le code 
   retour est 'F ' 
              ce qui implique que si ces 2 coefficients sont 
   absents, le fichier s'arrête 
              en erreur fatale ce qui n'a pas lieu d'être.
            - Test sur les variables qui donnent la 
   proportion de phases 
              (renvoi à la modification faite par jean-
   michel Proix fiche)
            - 3 Erreurs dans le calcul de DVIN(24+I) 
   (I=1,2*NDIM) :
              pas de sommation sur les 4 autres phases
              pour calculer DVIN(24+I), on utilise les 4 VIM
   (K). Or ceux-ci ont été modifiés
              avant et valent VIM(K)=VIM(K)+DVIN(K) ce qui 
   est faux.
              dans la formule de DVIN, il y a un VIM(J*K) a 
   remplacé par VIM(L) avec
              L=I+(K-1)*6
            - Erreur dans le calcul de VIM
              on a VIM=VIM+DVIN-2*DS au lieu d'avoir 
   VIM=VIM+DVIN-DS (en dehors du 3/2)
            - Remise au format de X mais erreur si 
   comportement élastique
            - pas de remise au format de XMOYK=Somme Z(i)*XK
   (I) pour K=4 * 2*NDIM
          
          4) Erreur du modèle
            - a mon avis, erreur pour modéliser la 
   restauration d'écrouissage d'origine
              visqueuse 
              ce qui est programmé d(alpha)/dt=d(epsp)/dt -
   (C*alphaeq)**m * alpha/alphapeq
              avec alpha=Somme Z(I)*alpha(I) (à mon avis il 
   manque le 3/2)
              ce qui est écrit dans le Lemaitre -Chaboche
              d(alpha)/dt=d(epsp)/dt -1.5*(C*Xeq)**m * X/Xeq
              
      ROUTINE NZCIZI.F : Ecrouissage cinématique linéaire en 
   HPP pour le Zircaloy
        
         1) modification de la présentation générale pour 
   que les 6 routines sur les
         lois de comportement avec métallurgies soient 
   identiques
            - supprimer l'appel des déclarations JEVEUX
            - calcul de SEUIL changé de place
            - DVIN(37) devient DVIN
            - des noms de variables ont changé
            - changé la manière de calculer la contrainte 
   élastique 
              car très compliquée pour rien
            - appel parfois de comportement isotrope 
   linéaire ou non (donc on supprime)        
            - pour ne pas modifier VIM(1) à VIM(18), on fait
              avant VIM(I)=VIM(I)+DVIN(I)-DS
              maitenant VIM(I) reste VIM(I) et VI(I)=VIM(I)
   +DVIN(I)-DS
              donc ajout de la variable VI(18) 
         
         2) bug sans conséquence
            - Tableau mal dimensionné
              VIMT(37) => VIMT(18)
              PHASM(4) et PHASP(4) => PHASM(3) et PHASP(3) 
              Pratiquement toutes les données matériaux sont 
   dimensionnées pour l'acier   
            - modification de la routine pour que le calcul 
   de la matrice tangente
              RIGI_MECA_TANG soit avec les coefficents pris 
   à l'instant moins 
            - lorqu'on récupère les coefficients de 
   plasticité de transformation, il traine
              dans l'appel de RCVALA un CODRET(9) 
         
         3) bug avec conséquence
            - dans le cas d'un comportement élastique, on 
   met à jour les variables
              d'écrouissage VIM(1) à VIM(30) en ajoutant un 
   racine de 2 (pour I=4,6) 
              et on appelle PLASTI=VIM(37). Or ces variables 
   n'existent pas en élasticité. 
            - dans le cas d'un modèle visqueux, on peut 
   également activer la restauration
              d'écrouissage. Les coefficients C et M ne sont 
   pas obligatoires et dans le cas
              où ils ne sont pas présents dans le fichier de 
   commande, on choisit C=0 et M=20
              ce qui implique que la restauration n'est pas 
   prise en compte.
              Lorsque on appelle la routine RCVALA, le code 
   retour est 'F ' 
              ce qui implique que si ces 2 coefficients sont 
   absents, le fichier s'arrête 
              en erreur fatale ce qui n'a pas lieu d'être.
            - Test sur les variables qui donnent la 
   proportion de phases 
              (renvoi à la modification faite par jean-
   michel Proix fiche)
            - 1 erreur dans le calcul de DVIN pour les 2 
   phases. On utilise VIM(24+J)
              or il s'agit de VIM(12+J)
            - 4 Erreurs dans le calcul de DVIN(12+I) 
   (I=1,2*NDIM) :
              on calcule VIM(24+J) au lieu de VIM(12+J)
              pas de sommation sur les 2 autres phases
              pour calculer DVIN(12+I), on utilise les 2 VIM
   (K). Or ceux-ci ont été modifiés
              avant et valent VIM(K)=VIM(K)+DVIN(K) ce qui 
   est faux.
              dans la formule de DVIN, il y a un VIM(J*K) a 
   remplacé par VIM(L) avec
              L=I+(K-1)*6
            - autre erreur liée au calcul de VIM => on prend 
   THETA(4+K) au lieu de THETA(2+K)
            - Erreur dans le calcul de VIM
              on a VIM=VIM+DVIN-2*DS au lieu d'avoir 
   VIM=VIM+DVIN-DS (en dehors du 3/2)
            - 2 erreurs dans le calcul de SYK
              SYALPH=PHASP(1)*SY(1)+PHASP(2)*SY(2)+PHASP(3)
   *SY(3) => mis la phase chaude
              SYK=(1-FMEL)*SY(5)+FMEL*SYALP/ZALPHA au lieu 
   de SY(3)
            - Remise au format de X mais erreur si 
   comportement élastique
            - pas de remise au format de XMOYK=Somme Z(i)*XK
   (I) pour K=4 * 2*NDIM
          
          4) Erreur du modèle
            - a mon avis, erreur pour modéliser la 
   restauration d'écrouissage d'origine
              visqueuse 
              ce qui est programmé d(alpha)/dt=d(epsp)/dt -
   (C*alphaeq)**m * alpha/alphapeq
              avec alpha=Somme Z(I)*alpha(I) (à mon avis il 
   manque le 3/2)
              ce qui est écrit dans le Lemaitre -Chaboche
              d(alpha)/dt=d(epsp)/dt -1.5*(C*Xeq)**m * X/Xeq
         
         5) Cas test HSNV126A (test de non regression)
         Je chande des valeurs de TEST_RESU
   
   Test Hsnv126a
   Il manquait dans le fichier de commande la laeur de 
   reférence VALE_REF=20
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V7.22.126,R4.04.02
VALIDATION
   hsnv126a
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST AJOUT zzzz221a                      salmona L.SALMONA          263    263      0
 CASTEST MODIF fdnl100a                      salmona L.SALMONA          466     33     21
 CASTEST MODIF hsns100a                      salmona L.SALMONA          271      2      2
 CASTEST MODIF hsns100b                      salmona L.SALMONA          262      2      2
 CASTEST MODIF hsnv126a                      salmona L.SALMONA          384      3      3
 CASTEST MODIF htna100a                      salmona L.SALMONA         1194      3      3
 CASTEST MODIF sdll110a                      salmona L.SALMONA          485     15     32
 CASTEST MODIF sdll110b                      salmona L.SALMONA          487     15     32
 CASTEST MODIF sdll115a                      salmona L.SALMONA         1437      1      1
 CASTEST MODIF sdll115b                      salmona L.SALMONA          783      1      1
 CASTEST MODIF sdll116a                      salmona L.SALMONA         4989      1      1
 CASTEST MODIF sdll117a                      salmona L.SALMONA         1426     82    130
 CASTEST MODIF sdll136a                      salmona L.SALMONA          655     11      7
 CASTEST MODIF sdll501a                      salmona L.SALMONA          498     15     32
 CASTEST MODIF sdll502a                      salmona L.SALMONA          490     15     32
 CASTEST MODIF sdll503a                      salmona L.SALMONA          327      6      5
 CASTEST MODIF sdll503b                      salmona L.SALMONA          362      6      4
 CASTEST MODIF sdll503c                      salmona L.SALMONA          455     14     29
 CASTEST MODIF sdll504a                      salmona L.SALMONA          517     27     40
 CASTEST MODIF sdll505a                      salmona L.SALMONA          405     18     28
 CASTEST MODIF sdll506a                      salmona L.SALMONA          488     14     29
 CASTEST MODIF sdll507a                      salmona L.SALMONA          345      6      4
 CASTEST MODIF sdll508a                      salmona L.SALMONA          347      6      4
 CASTEST MODIF sdll508b                      salmona L.SALMONA          347      6      4
 CASTEST MODIF sdll508c                      salmona L.SALMONA          354      7      9
 CASTEST MODIF sdls105a                      salmona L.SALMONA          315      5     16
 CASTEST MODIF sdls105b                      salmona L.SALMONA          294      3     13
 CASTEST MODIF sdls107a                      salmona L.SALMONA          397      3     16
 CASTEST MODIF sdnl112a                      salmona L.SALMONA          299     13     13
 CASTEST MODIF sdnl112b                      salmona L.SALMONA          454     12     48
 CASTEST MODIF sdnl112c                      salmona L.SALMONA          485     16     43
 CASTEST MODIF ssls112a                      salmona L.SALMONA          452     99     15
 CASTEST MODIF ssls200a                      salmona L.SALMONA          257      2      2
 CASTEST MODIF sslv113c                      salmona L.SALMONA          203      5      5
 CASTEST MODIF sslv113d                      salmona L.SALMONA          203      5      5
 CASTEST MODIF ssnv180a                      salmona L.SALMONA          336      2      2
 CASTEST MODIF yyyy103a                      salmona L.SALMONA          333      1      1
 CASTEST MODIF yyyy103c                      salmona L.SALMONA          284      1      1
 CASTEST MODIF zzzz108a                      salmona L.SALMONA          990      5      3
 CASTEST MODIF zzzz119a                      salmona L.SALMONA           83      1      1
 CASTEST SUPPR sensd04a.comm                 salmona L.SALMONA          264      0    264
CATALOPY MODIF commande/dyna_non_line        salmona L.SALMONA          417      6      1
CATALOPY MODIF commande/dyna_tran_expli      salmona L.SALMONA          351      7      1
CATALOPY MODIF commande/impr_macr_elem       salmona L.SALMONA           60      2      1
CATALOPY MODIF commande/macro_miss_3d        salmona L.SALMONA           66      2      2
CATALOPY MODIF commande/proj_spec_base       salmona L.SALMONA           39      5      6
CATALOPY MODIF commande/stat_non_line        salmona L.SALMONA          387      6      1
 FORTRAN AJOUT utilifor/lxnoac               salmona L.SALMONA           81     81      0
 FORTRAN MODIF algorith/dltini               salmona L.SALMONA          263     55      3
 FORTRAN MODIF algorith/gfcomm               salmona L.SALMONA          447     31     26
 FORTRAN MODIF algorith/gfdash               salmona L.SALMONA          271     15     10
 FORTRAN MODIF algorith/gfguid               salmona L.SALMONA          246     15     18
 FORTRAN MODIF algorith/lcgdpm               salmona L.SALMONA          926    457    505
 FORTRAN MODIF algorith/mxmajd               salmona L.SALMONA          132      5      5
 FORTRAN MODIF algorith/nmconv               salmona L.SALMONA          703      3      1
 FORTRAN MODIF algorith/nmdoet               salmona L.SALMONA          411      2      2
 FORTRAN MODIF algorith/nmgrfl               salmona L.SALMONA          697     19     20
 FORTRAN MODIF algorith/nzcifw               salmona L.SALMONA          731    493    500
 FORTRAN MODIF algorith/nzcizi               salmona L.SALMONA          707    490    489
 FORTRAN MODIF algorith/nzedga               salmona L.SALMONA          733    509    495
 FORTRAN MODIF algorith/nzgdzi               salmona L.SALMONA          900    441    493
 FORTRAN MODIF algorith/nzisfw               salmona L.SALMONA          758    515    506
 FORTRAN MODIF algorith/op0048               salmona L.SALMONA          396      3      2
 FORTRAN MODIF algorith/op0166               salmona L.SALMONA          257      2      2
 FORTRAN MODIF assembla/mtmchc               salmona L.SALMONA          232      2      2
 FORTRAN MODIF calculel/celfpg               salmona L.SALMONA          134      5      1
 FORTRAN MODIF calculel/mechc1               salmona L.SALMONA          241      3      3
 FORTRAN MODIF calculel/zzglob               salmona L.SALMONA          291      3      3
 FORTRAN MODIF elements/btldth               salmona L.SALMONA           74     13     22
 FORTRAN MODIF elements/dkqcol               salmona L.SALMONA          330      5      4
 FORTRAN MODIF elements/dktcol               salmona L.SALMONA          329      9      4
 FORTRAN MODIF elements/dsqcol               salmona L.SALMONA          624      5      4
 FORTRAN MODIF elements/dstcol               salmona L.SALMONA          444      5      4
 FORTRAN MODIF elements/dxdmul               salmona L.SALMONA          189      6      3
 FORTRAN MODIF elements/dxefgt               salmona L.SALMONA          162      3      1
 FORTRAN MODIF elements/fornpd               salmona L.SALMONA          273      2      2
 FORTRAN MODIF elements/q4gcol               salmona L.SALMONA          417      5      4
 FORTRAN MODIF elements/te0033               salmona L.SALMONA          368     10      5
 FORTRAN MODIF elements/te0150               salmona L.SALMONA          351      2      2
 FORTRAN MODIF elements/te0160               salmona L.SALMONA          179      6      4
 FORTRAN MODIF elements/te0295               salmona L.SALMONA          552      4      3
 FORTRAN MODIF elements/te0402               salmona L.SALMONA          446      8      7
 FORTRAN MODIF elements/te0415               salmona L.SALMONA          527      2      2
 FORTRAN MODIF elements/te0419               salmona L.SALMONA          205     25     16
 FORTRAN MODIF elements/vdxnlr               salmona L.SALMONA          466      2      2
 FORTRAN MODIF elements/vdxsig               salmona L.SALMONA          279      6     16
 FORTRAN MODIF modelisa/cagrf1               salmona L.SALMONA          251     14     17
 FORTRAN MODIF modelisa/lrmmf3               salmona L.SALMONA          429     16      2
 FORTRAN MODIF modelisa/rebdfr               salmona L.SALMONA          139      3      1
 FORTRAN MODIF prepost/calfig                salmona L.SALMONA          353      1      7
 FORTRAN MODIF prepost/ircmcc                salmona L.SALMONA          131      2      2
 FORTRAN MODIF prepost/op0106                salmona L.SALMONA          830     19      1
 FORTRAN MODIF utilitai/iredm1               salmona L.SALMONA          450     28      3
  PYTHON AJOUT Messages/grappefluide         salmona L.SALMONA           84     84      0
  PYTHON MODIF Macro/calc_fonction_ops       salmona L.SALMONA          408    165     90
  PYTHON MODIF Macro/macro_miss_3d_ops       salmona L.SALMONA          141      4      4
  PYTHON MODIF Messages/algorith11           salmona L.SALMONA          350      8      1
  PYTHON MODIF Messages/algorith6            salmona L.SALMONA          427      9      2
  PYTHON MODIF Messages/maillage             salmona L.SALMONA           79      7      1
  PYTHON MODIF Messages/modelisa5            salmona L.SALMONA          421     10      2
  PYTHON MODIF Messages/prepost2             salmona L.SALMONA          425     11      2
  PYTHON MODIF Noyau/N_JDC                   salmona L.SALMONA          459      2      1
  PYTHON MODIF Stanley/graphiqueTk           salmona L.SALMONA          581     23      6
  PYTHON MODIF Stanley/salomeVisu            salmona L.SALMONA          510      3      3
  PYTHON MODIF Utilitai/t_fonction           salmona L.SALMONA          656     69     49


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :    3         428       428              +428
 MODIF :  101       47210      4090    4036       +54
 SUPPR :    1         264               264      -264
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :  105       47902      4518    4300      +218 
