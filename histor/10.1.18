

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 06/04/2010 - 17:22:49

--------------------------------------------------------------------------------
RESTITUTION FICHE 014862 DU 2010-03-26 09:11:55
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   La mxc3xa9thode python getvectjev ne fonctionne pas avec les INTEGER*4 FORTRAN
FONCTIONNALITE
   Problème
   --------
   
   Suite à la restitution de la fiche issue14159, et comme 
   annoncé, les tests shll102a, sdll123a, sdll123b et sdll123c 
   s'arrêtent en erreur.
   
   
   Correction
   ----------
   
   Les tests s'arrêtent lors de la récupération des valeurs du 
   nume_ddl. En effet, depuis la 10.1.17, pour gagner de la 
   place mémoire, certains objets sont stockés dans des 
   INTEGER*4.
   aster.getvectjev doit évoluer pour cela. C'est ce qui est 
   fait ici.
   
   Dans getcon.f, on gère maintenant le type jeveux 'S'.
   Dans aster_depend.h, on ajoute le type INTEGER4 (qui vaut 
   "int") et getvectjev/getcolljev dans astermodule.c sont 
   modifiés en conséquence.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sdll123a, sdll123b, sdll123c, shll102a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 014887 DU 2010-04-01 08:10:02
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW10.1.17 les cas-tests sdll123a,b,c et shll102a s'arretent anormalement sur toutes les machines
FONCTIONNALITE
   voir issue14862
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   4 tests en erreur
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 014889 DU 2010-04-01 08:30:48
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW10.1.17 le cas-test ssnv209k s'arrete en erreur fatale par manque de temps CPU sur Bull
FONCTIONNALITE
   Problème
   --------
   Le test ssnv209k est en arrêt cpu sur Bull.
   
   
   Correction
   ----------
   Test rentré la semaine dernière qui a tourné en 558 secondes dans le pre_eda. 600 s dans
   le .para.
   On passe à 660 s.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ssnv209k
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR debonnieres  DE BONNIERES Philippe   DATE 01/04/2010 - 17:08:59

--------------------------------------------------------------------------------
RESTITUTION FICHE 014864 DU 2010-03-26 11:55:26
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   nouveau test pour la loi RAG
FONCTIONNALITE
   Restitution du test de robustesse comp003a pour la loi RAG de comportement du beton, sur 
   le modele des tests comp00x de Jean-Michel.
   J'ai utilise SUPPORT = 'ELEMENT' a cause de la dependance par rapport a la temperature.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V6.07.103
VALIDATION
   COMP003A
NB_JOURS_TRAV  : 20.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR geniaut      GENIAUT Samuel         DATE 06/04/2010 - 17:19:01

--------------------------------------------------------------------------------
RESTITUTION FICHE 014643 DU 2010-02-16 17:20:23
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   RUPT : bug possible dans POST_K1_K2_K3 si NB_POINT_FOND
FONCTIONNALITE
   Problème :
   ----------
   
   Bug dans POST_K1_K2_K3 si on utilise NB_POINT_FOND (uniquement avec un modèle X-FEM).
   
   La fonction d'interpolation des points en fond de fissure (appelée lorsque NB_POINT_FOND
   est présent dans POST_K1_K2_K3) renvoie 3 valeurs dans certains cas alors que l'on devrait
   renvoyer 4 valeurs.
   
   
   
   Solution :
   ----------
   
   On rajoute la dernière valeur, qui est l'abscisse curviligne.
   
   Les résultats étaient parfois faux en post-traitement d'un calcul XFEM, en utilisant le
   mot-clé NB_POINT_FOND. Les valeurs étaient décalées dans la table produite.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 9.3.11
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 9.3.11
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   etude CENAERO
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR haelewyn     HAELEWYN Jessica       DATE 07/04/2010 - 08:32:55

--------------------------------------------------------------------------------
RESTITUTION FICHE 014830 DU 2010-03-22 14:35:14
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   Intégration de l'hydratation dans THER_HYDR
FONCTIONNALITE
   Dans l'option THER_HYDR, l’hydratation est intégrée en utilisant le theta-méthode comme :
   
   HYDR(+)= HYDR(-) + THETA *DELTAT* A(HYDR+)*exp(-ARR/T+)
                                     ^^^^^^^^
                    +(1.D0-THETA)*DELTAT*A(HYDR-)* exp(-ARR/T-)
   
   1) Dans cette formule, on ne peut pas évaluer la fonction affinité A(HYDR+) car HYDR+, l'hydratation à 
   t+dt, n'est pas connue. Actuellement, A(HYDR+) est remplacée par A(HYDR-) ce qui peut engendrer une 
   erreur d'intégration.
   
   2) L'exponentielle est écrite 'en dur' dans le fortran.
   
   Propositions de solutions:
   ------------------------
   1) L'hydratation ne peut pas être intégrée comme la température, car elle fait partie du second membre 
   et rajoute une inconnue au problème.
   On propose donc de garder une intégration explicite de l'hydratation mais de passer à un schéma Runge-
   Kutta d'ordre 6.
   
   A titre d'exemple, quelques améliorations observées sur le cas-test tpnl301c :
   Les différences par rapport à un calcul avec dt=0.25 sont :
        pour dt =        0.5     1        2
   theta   erreur sur h  3.5%    10%      20%
                      T  0.7%     2%     4.5%
   RK6     erreur sur h  0.6%   1.5%       3%
                      T 0.03%   0.1%     0.2%
   Les résultats avec RK6 semblent plus stables. En multipliant le pas de temps par ~10, on s'éloigne de 3% 
   (contre 20% avec la theta-methode) en HYDR et de 0.2% en TEMP (contre 4.5% avec la theta-methode).
   Les différences par rapport à une solution semi-analytique sont :
        pour dt =        0.5     1        2
   theta   erreur sur h  2.5%    8%      17%
                      T  0.8%    2%     4.5%
   RK6     erreur sur h  3.5%   3.3%     3.2%
                      T  1.1%   1.1%     1.1%
   De même, les résultats avec RK6 sont plus stables.
   
   Le temps de calcul n'est pas modifié par le passage à RK6. Par contre, RK6 permet d'utiliser un pas de 
   temps plus grand pour obtenir le même résultat. Le temps de calcul peut donc être fortement réduit.
   
   2) On propose de rentrer la fonction A (AFFINITE) comme une nappe de 2 parametres (HYDR,TEMP) au lieu de 
   HYDR seul. Ceci donne à l'utilisateur la possibilité d'utiliser d'autres fonctions que l'exponentielle.
   => modification de defi_materiau.capy pour la suppression du paramètre QSR_K (constante d'Arrenius) présente 
   dans l'exponentielle qui ne sert plus.
   
   Les développements sont effectués dans le cadre du projet BILOBA et concernent :
   te0243.f
   te0283.f
   defi_materiau.capy 
   ajout de runge6.f dans algorith
   
   Validation sur les castests utilisant THER_HYDR :
   tpnl301a,b,c,d
   ttnl03a,b,c,d
   zzzz221a
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 9.0.0
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 9.0.0
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : u4.43.01, v4.42.301, v4.22.003
VALIDATION
   ttnl03,tpnl301,zzzz221a
NB_JOURS_TRAV  : 5.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR lefebvre     LEFEBVRE Jean-Pierre   DATE 06/04/2010 - 13:26:29

--------------------------------------------------------------------------------
RESTITUTION FICHE 014131 DU 2009-11-04 07:07:35
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Problxc3xa8me version aster avec profiling
FONCTIONNALITE
   C'est le même problème que dans la fiche 14412. Lors de l'édition des liens qui échoue, on
   obtient des messages du type :
   /aster/NEW10/prof/lib/libaster.a(trigd.o)(.text+0xc0): In function `trigd_':
   : relocation truncated to fit: GPREL22 trigd_$IND2$0$0
   Un moyen de contournement consiste à supprimer les appels à PETSc dans le code. Mais une
   version plus récente de ld permet de construire un exécutable. 
   
   J'ai modifié le fichier de configuration /aster/NEW10/config.prof pour refaire un
   exécutable avec l'environnement complet comprenant PETSc en 
   ajoutant l'appel au script /aster/agla/tool/init_binutils-2.20.sh  qui positionne le PATH
   avec /logiciels/public/binutils-2.20/bin pour aller chercher la nouvelle version de ld.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   construction de asterp
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 014865 DU 2010-03-26 15:22:26
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   STA9_mpi : plantage a l'ouverture d'une base en poursuite
FONCTIONNALITE
   Après analyse du problème, je constate que le job s'arrête en raison d'un problème de
   mémoire. L'exécutable en version MPI sur BULL nécessite toujours plus de mémoire que la
   version séquentielle, au moins au chargement, ceci est dû à l'environnement ELAN
   (librairies mpi). 
   Dans le fichier output on a la remontée suivante :
   
    CR phase d'initialisation
   0    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   0    ! erreur non prevue et non traitee prevenir la maintenance fort.1               !
   0    ! Traceback (most recent call last):                                            !
   0    !    File "./Eficas/Noyau/N_JDC.py", line 203, in exec_compile                  !
   0    !     exec self.proc_compile in self.g_context                                  !
   0    !    File "fort.1", line 5, in ?                                                !
   0    !     POURSUITE(IGNORE_ALARM='SUPERVIS_1',PAR_LOT='NON',FORMAT_HDF='OUI',);     !
   0    !    File "./Eficas/Noyau/N_MACRO.py", line 149, in __call__                    !
   0    !     return etape.Build_sd(nomsd)                                              !
   0    !    File "./Eficas/Noyau/N_MACRO_ETAPE.py", line 146, in Build_sd              !
   0    !     l=traceback.format_exception(sys.exc_info()[0],sys.exc_info()[1],         !
   0    ! sys.exc_info()[2])                                                            !
   0    !    File "/aster/local/Python-2.4.5//lib/python2.4/traceback.py", line 142, in !
   0    ! format_exception                                                              !
   0    !     list = list + format_tb(tb, limit)                                        !
   0    !    File "/aster/local/Python-2.4.5//lib/python2.4/traceback.py", line 76, in  !
   0    ! format_tb                                                                     !
   0    !     return format_list(extract_tb(tb, limit))                                 !
   0    !    File "/aster/local/Python-2.4.5//lib/python2.4/traceback.py", line 101, in !
   0    ! extract_tb                                                                    !
   0    !     line = linecache.getline(filename, lineno)                                !
   0    !    File "/aster/local/Python-2.4.5//lib/python2.4/linecache.py", line 14, in  !
   0    ! getline                                                                       !
   0    !     lines = getlines(filename)                                                !
   0    !    File "/aster/local/Python-2.4.5//lib/python2.4/linecache.py", line 40, in  !
   0    ! getlines                                                                      !
   0    !     return updatecache(filename)                                              !
   0    !    File "/aster/local/Python-2.4.5//lib/python2.4/linecache.py", line 101, in !
   0    ! updatecache                                                                   !
   0    !     lines = fp.readlines()                                                    !
   0    !  MemoryError                                                                  !
   0    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   0 fin CR phase d'initialisation
   
   J'ai relancé l'étude avec 4096Mo de mémoire, la première phase avec lecture de la base au
   format HDF s'exécute sans problème et j'ai interrompu le job dans la seconde phase (cf
   fichier joint).
   
   J'ai constaté la présence d'une alarme dans le fichier due à l'abscence du répertoire
   /aster/STA9/bibpyt/Cata_Utils, je corrige le fichier /aster/STA9/config.mpi.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   xc3xa9tude jointe
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 014881 DU 2010-03-31 14:53:50
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Souci avec IMPR_CO
FONCTIONNALITE
   La commande IMPR_CO est utilisée sur une structure de données s'appuyant sur le type S
   (INTEGER*4). La commande s'arrête brutalement dans la routine JJIMPO.
   Sur une plate-forme 32 bits, les entiers sont limités à 2147483647 (2**31-1). L'erreur est
   due à la taille globale de l'étude, à une manipulation des adresses en octets et une
   division mal placée. On manipule des entiers supérieurs à la valeur maximale, leur contenu
   prend une valeur négative et provoque une erreur dans l'accès au tableau I4ZON.
   
   Dans JJIMPO l'instruction à la ligne 119 :
               JI = 1 + ((JISZON +KADM-1)*LOIS+IDECI)*2/LOR8 + LADM*2/LOR8
   est remplacée par :
               JI = 1 + ((JISZON +KADM-1)/LOR8)*2*LOIS+ IDECI/LOR8*2 + 
        &               LADM/LOR8*2
   pour éviter d'exploser la valeur de l'entier.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   Etude fournie
NB_JOURS_TRAV  : 0.25
--------------------------------------------------------------------------------
RESTITUTION FICHE 014905 DU 2010-04-06 05:31:22
TYPE express concernant Code_Aster (VERSION 10.1)
TITRE
   Informations concernant les volumes de donnxc3xa9es manipulxc3xa9es par JEVEUX
FONCTIONNALITE
   Les informations imprimées par JEVEUX lors de la fermeture des bases ne sont pas précises.
   Je propose d'ajouter le volume de données accédé en écriture et en lecture sur chaque base :
   
        FERMETURE DE LA BASE
   
        NOM DE LA BASE                          :  VOLATILE
        NOMBRE D'ENREGISTREMENTS UTILISES       :  3
        NOMBRE D'ENREGISTREMENTS MAXIMUM        :  62914
        LONGUEUR D'ENREGISTREMENT (OCTETS)      :  819200
        NOMBRE TOTAL D'ACCES EN LECTURE         :  14278
        VOLUME DES ACCES EN LECTURE             :  11154.69 Mo.
        NOMBRE TOTAL D'ACCES EN ECRITURE        :  10793
        VOLUME DES ACCES EN ECRITURE            :  8432.03 Mo.
        NOMBRE D'IDENTIFICATEURS UTILISES       :  48
        TAILLE MAXIMUM DU REPERTOIRE            :  2000
        POURCENTAGE D'UTILISATION DU REPERTOIRE :  2 %
   
   En cours de calcul la base VOLATILE peut être détruite entre les commandes, je modifie le
   message imprimé à cette occasion :
   
   
    Critère de destruction du fichier (1.00 %) associé à la base VOLATILE dépassé 10.03 %  
    Nombre d'enregistrements utilisés : 6311 
    Volume disque occupé              : 4930 Mo.
    Nombre maximum d'enregistrements  : 62914  
   
   En fin de calcul, dans le bilan des appels au mécanisme de libération, on fait apparaître
   le volume des données en lecture et en écriture : 
   
      STATISTIQUES CONCERNANT L'ALLOCATION DYNAMIQUE :
        TAILLE CUMULEE MAXIMUM            :                  1346  Mo.
        TAILLE CUMULEE LIBEREE            :                 23480  Mo.
        NOMBRE TOTAL D'ALLOCATIONS        :                124885
        NOMBRE TOTAL DE LIBERATIONS       :                124885
        APPELS AU MECANISME DE LIBERATION :                    33
        TAILLE MEMOIRE CUMULEE RECUPEREE  :                 15299  Mo.
        VOLUME DES LECTURES               :                     0  Mo.
        VOLUME DES ECRITURES              :                  8492  Mo.
   
   History
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.50.01
VALIDATION
   tests de performance
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR messier      MESSIER Julien         DATE 06/04/2010 - 14:36:11

--------------------------------------------------------------------------------
RESTITUTION FICHE 014826 DU 2010-03-19 16:06:20
TYPE anomalie concernant Code_Aster (VERSION 10.2)
TITRE
   AFFE_CHAR_MECA / ROTATION modxc3xa9lisation XFEM.
FONCTIONNALITE
   L'objectif de cette fiche est de valider la fonctionnalité AFFE_CHAR_MECA/ROTATION en modélisation XFEM.
   Pour mémoire, la modélisation 2D-AXI n'est pas encore développée avec la méthode XFEM.
   On valide donc, dans le cadre de cette fiche, un chargement en rotation en 2D et 3D (perspective de la 
   fiche 12470).
   
   **** Impact Fortran ****
   La tache réalisée, côté FEM, par la te0084 est réalisée, côté XFEM par la te0441.
   On duplique, de l'une à l'autre, la vérification ajoutée par Xavier, interdisant, en 2D, la présence 
   d'un axe de rotation coplanaire à la structure.
   ************************
   
   Aucun cas-test XFEM n'existe avec un chargement en rotation.
   Pourtant, ce type de chargement peut être la cause de propagation de fissure par fatigue, sur les 
   machines tournantes notamment.
   On juge donc particulièrement opportun de profiter de cette fiche pour créer ce type de cas-test en 2D 
   et 3D! (On choisira systématiquement un centre de rotation distinct de l'origine du repère cartésien)
   
   **** Cas-test 3D **** 
   On crée 2 nouvelles modélisations (s et t) au cas-test ssnv185, correspondant respectivement à une 
   propagation par la méthode simplexe et la méthode upwind.
   La rotation est réalisée suivant un axe parallèle au front de fissure et confondu avec une arête de la 
   base de la structure.
   On réalise 3 itérations de propagation. On vérifie la propagation de la fissure. Les valeurs obtenues 
   sont de non régression.
   **********************
   
   **** Cas-test 2D ****
   On cherche un problème de corps fissuré en rotation pour lequel on disposerait d'une solution analytique 
   pour la valeur de K. Tada, Irwin et Paris en proposent une pour le cas d'une fissure radiale débouchante 
   sur une disque tournant.
   On crée donc un nouveau cas-test : sslp323a.
   Ce test propage la fissure en 3 itérations avec la méthode simplexe.
   On compare, à chaque itération, la valeur de K1 trouvé avec la solution analytique.
   L'erreur est au maximum de 2.3%.
   **********************
   
   En résumé : 
   - on modifie le te0441, 
   - on restitue 2 nouvelles modélisation 3D : ssnv185s et ssnv185t
   - on restitue 1 nouveau cas-test 2D : ssnp323a
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V6.04.185, V3.02.323
VALIDATION
   ssnv185s, ssnv185t, sslp323a
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR tardieu      TARDIEU Nicolas        DATE 06/04/2010 - 18:01:13

--------------------------------------------------------------------------------
RESTITUTION FICHE 014804 DU 2010-03-17 13:17:27
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Tests wtnl100a en explicite - diffxc3xa9rence de comportement des solveurs
FONCTIONNALITE
   Problème :
   ----------
   Sébastien a modifié un peu le test wtnl100a. Ensuite, il a eu la curiosité de changer de
   solveur. Il obtient des comportement différents :
                                                                                            
                                                                                     
   1) MULT_FRONT et MUMPS : OK
   2) LDLT                : arret "PIVOT NUL"
   3) PETSC + SOR         : ECHEC DANS L'INTEGRATION DE LA LOI DE COMPORTEMENT
                                                                                            
                                                                                     
   Analyse :
   ---------
   Sébastien a eu de la chance : le solveur par défaut (MULT_FRONT) aurait pu également lui
   faire des misères !
                                                                                            
                                                                                     
   En effet, les solveurs traditionnels (LDLT/LU et MULT_FRONT) ne pivotent pas pendant la
   factorisation. Ce qui est problématique dès que la matrice de rigidité n'est pas >= 0.
                                                                                            
                                                                                     
   La modélisation utilisée D_PLAN_HM est sans doute très intéressante scientifiquement, mais
   elle conduit à des matrices élémentaires moyennement sympas :
     - non symétriques
     - avec des 0. sur la diagonale
     - avec des valeurs propres négatives.
                                                                                            
                                                                                     
   De plus, les C.L. cinématiques sont dualisées. La méthodologie des doubles Lagranges
   permet d'utiliser LDLT ou MULT_FRONT sans permutation avec les 2 conditions suivantes (Cf
   R3.03.01) :
      - la matrice doit etre symétrique
      - la matrice doit etre >= 0
   Remarque : je compte ajouter dans R3.02.01 un petit paragraphe (2 contre-exemples) qui
   montre que ces conditions sont nécessaires.
                                                                                            
                                                                                     
   Tous les ingrédients sont donc réunis pour avoir des ennuis
                                                                                            
                                                                                     
   Conseils :
   ----------
   En toute rigueur, il faut utiliser MUMPS pour ce genre de modélisation.
   Sinon, je conseille à Sébastien d'éliminer ses C.L. (AFFE_CHAR_CINE)
                                                                                            
                                                                                     
   Détails :
   ---------
   J'ai calculé les valeurs propres d'une matrice élémentaire correspondant à RIGI_MECA_TANG
   / QUAD8 (D_PLAN_HM).
   Il y a 20 ddls par QUAD8 : 8 * (DX,DY) + 4 * PRE1.
   Lorsqu'on met un module d'Young de 1. (pour que les unités de PRE1 et DX soient
   comparables), on obtient :
     12 valeurs propres > 0
      4 valeurs propres < 0
      4 valeurs propres = 0  (3 mvts de corps solide + 1 lié à  PRE1 ?)
                                                                                            
                                                                                     
                                                                                            
                                                                                     
   Concernant PETSC :
   ------------------
   Dans la routine bibf90/apetsr.F d'interface avec la librairie PETSc, il manquait le test
   d'un code retour. Le préconditionneur SOR utilise en effet les termes de la diagonale de
   la matrice pour réaliser des divisions. D'où l'impossibilité de résoudre. Cela dit, le
   problème était donné par un message d'erreur PETSc : 
   
   [0]PETSC ERROR: --------------------- Error Message ------------------------------------
   [0]PETSC ERROR: Arguments are incompatible!
   [0]PETSC ERROR: Zero diagonal on row 4!
   [0]PETSC ERROR: ------------------------------------------------------------------------
   
   
   J'ajoute le test du code retour incriminé et le message d'erreur suivant :
     
   !--------------------------------------------------------------------------------------------------------------------------------------!
      ! <F> <PETSC_13>                                                                      
                                                   !
      !                                                                                     
                                                   !
      !                                                                                     
                                                   !
      ! Solveur PETSc :                                                                     
                                                   !
      !   La résolution a échoué ; consultez le message ci-dessus.                          
                                                   !
      !   Cela peut être due à une propriété particulière de la matrice du système non
   supportée par l'algorithme choisi.                     !
      !   Par exemple, une matrice avec des zéros sur la diagonale et l'algorithme SOR, qui
   utilise ces entrées pour réaliser des divisions. !
      !                                                                                     
                                                   !
      !                                                                                     
                                                   !
      !                                                                                     
                                                   !
      ! Cette erreur est fatale. Le code s'arrete.                                          
                                                   !
     
   !--------------------------------------------------------------------------------------------------------------------------------------!
   
   Sources modifiées :
   -------------------
   bibf90/apetsr.F
   Messages/petsc.py
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   Passage du test
NB_JOURS_TRAV  : 1.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR torkhani     TORKHANI Mohamed       DATE 07/04/2010 - 11:18:43

--------------------------------------------------------------------------------
RESTITUTION FICHE 014822 DU 2010-03-19 09:01:34
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   Validation de l'amortissement gyroscopique pour les rotors xc3xa0 section circulaire variable
FONCTIONNALITE
   FONCTIONNALITE
      Avant la resitution de la fiche 13126, la fonctionnalité gyroscopie n'était 
   pas disponible dans Code_Aster pour les poutres à section variable. On finissait 
   alors par un message d'erreur du type "la matrice gyroscopique n'est pas 
   disponible pour l'élément MECA_POU_D_T". Depuis, E. Boyere a rendu cette option 
   (très utile pour les calculs de LA) disponible. Elle est introduite en faisant 
   l'approximation que l'inertie moyenne de la poutre est la moyenne de ses 
   inerties aux deux extrémités. 
   La pseudo-validation est alors réalisée dans le cas-test SDLL141d où on calcule 
   toujours un arbre à section constante mais en utiliant des POU_D_E à section 
   homothétique. 
   La méthode de validation proposée ici pour mesurer l’effet de cette hypothèse 
   est purement numérique. En effet, les résultats de référence sont obtenus par 
   une discrétisation en éléments de poutre à section circulaire constante. 
   Les valeurs de référence ont été encadrées par les résultats de deux 
   modélisations :
   1)- La première, approchant la solution exacte par valeurs inférieures, consiste 
   à affecter à chaque élément 
   la section circulaire constante de diamètre égal au diamètre du rotor étudié au 
   droit du nœud initial de l'élément.
   2)- La deuxième, approchant la solution exacte par valeurs supérieures, consiste 
   à affecter à chaque élément la section circulaire constante de diamètre égal au 
   diamètre du rotor étudié au droit du nœud final de l'élément.
   
   Un nouveau cas-test SDLL127 est ajouté avec 3 modélisations a/b/c :
   - SDLL127a : Calcul modal avec amortissement gyroscopique d'un rotor à section 
   circulaire variable
   - SDLL127b : Valeurs de référence (borne SUP) du calcul modal avec gyroscopie 
   d'un rotor à section circulaire variable
   - SDLL127c : Valeurs de référence (borne INF) du calcul modal avec gyroscopie 
   d'un rotor à section circulaire variable
   
   IMPACT_DOCUMENTAIRE : 
   - DOC V2.02.127 : Calcul des modes en rotation d'une ligne d'arbres avec rotor à 
   section circulaire variable
   - DOC U2.06.31 : Notice d'utilisation de l'amortissement gyroscopique dans Aster
   
   VALIDATION
      SDLL127a/b/c
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V2.02.127
VALIDATION
   cas-test SDLL127
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 014823 DU 2010-03-19 09:09:31
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   Prise en compte des paliers xc3xa0 caractxc3xa9ristiques variables en fonction de la vitesse de rotation
FONCTIONNALITE
   FONCTIONNALITE
      Pour les calculs de lignes d'arbres, il est très fréquent d'avoir recours à 
   des paliers dont les caractéristiques en raideur et amortissement dépendent de 
   la vitesse de rotation. 
   La fiche d'évolution 12769 porte sur la prise en compte de matrices de rigidite 
   et d'amortissement fonction de la vitesse de rotation. Il a été préconisé de 
   faire une sorte de boucle sur les N vitesses de rotation. 
   Celà devrait suffire dans une première version pour valider l'iso-fonctionnalité 
   Cadyro-Aster (fonctionnalité caractéristiques paliers en fonction de la vitesse 
   de rotation). Mais comme à terme c'est les calculs dynamiques transitoires qui 
   nous intéressent, une solution plus viable qu'une macro Python est à rechercher 
   (par exemple, évaluer l'intérêt de l'équivalent d'un fonc_mult pour les matrices 
   dans les cataloques de la commande DYNA_TRAN_MODAL ou autre). 
   Ce qui a été convenu dans un premier temps c'est de valider la fonctionnalité 
   paliers à vitesse variable par un cas-test via une boucle python sur les 
   vitesses de rotation. La restitution du cas-test en question fait 
   l'objet de cette fiche.
   
   Un nouveau cas-test SDLL128 est ajouté avec 1 modélisation a :
   - SDLL128a : Calcul modal d'un rotor avec paliers à caractéristiques variables 
   en fonction de la vitesse de rotation
   
   IMPACT_DOCUMENTAIRE : 
      DOC V2.02.128 : Calcul des modes en rotation d'une ligne d'arbres avec rotor 
   à section circulaire variable
   
   VALIDATION
      SDLL128a
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V2.02.128
VALIDATION
   cas-test SDLL128
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST AJOUT comp003a                   debonnieres P.DE-BONNIERES     270    270      0
 CASTEST AJOUT sdll127a                     torkhani M.TORKHANI         430    430      0
 CASTEST AJOUT sdll127b                     torkhani M.TORKHANI       10226  10226      0
 CASTEST AJOUT sdll127c                     torkhani M.TORKHANI       10227  10227      0
 CASTEST AJOUT sdll128a                     torkhani M.TORKHANI         825    825      0
 CASTEST AJOUT sslp323a                      messier J.MESSIER          223    223      0
 CASTEST AJOUT ssnv185s                      messier J.MESSIER          210    210      0
 CASTEST AJOUT ssnv185t                      messier J.MESSIER          204    204      0
 CASTEST MODIF ssnv209k                     courtois M.COURTOIS         535      3      3
 CASTEST MODIF tpnl301a                     haelewyn J.HAELEWYN         447     69     54
 CASTEST MODIF tpnl301b                     haelewyn J.HAELEWYN         313     48     38
 CASTEST MODIF tpnl301c                     haelewyn J.HAELEWYN         450     71    174
 CASTEST MODIF tpnl301d                     haelewyn J.HAELEWYN         463     69     58
 CASTEST MODIF ttnl03a                      haelewyn J.HAELEWYN         547     95     69
 CASTEST MODIF ttnl03b                      haelewyn J.HAELEWYN         566     91     53
 CASTEST MODIF ttnl03c                      haelewyn J.HAELEWYN         479     96     37
 CASTEST MODIF ttnl03d                      haelewyn J.HAELEWYN         619    109     36
 CASTEST MODIF zzzz221a                     haelewyn J.HAELEWYN         345     67     19
CATALOPY MODIF commande/defi_materiau       haelewyn J.HAELEWYN        3043      1      2
       C MODIF supervis/astermodule         courtois M.COURTOIS        4132     46     79
FORTRAN90 MODIF petsc/apetsr                  tardieu N.TARDIEU          350      4      1
 FORTRAN AJOUT algorith/runge6              haelewyn J.HAELEWYN         148    148      0
 FORTRAN MODIF elements/te0243              haelewyn J.HAELEWYN         290      7     12
 FORTRAN MODIF elements/te0283              haelewyn J.HAELEWYN         234      6     11
 FORTRAN MODIF jeveux/jedebu                lefebvre J-P.LEFEBVRE       289      8      4
 FORTRAN MODIF jeveux/jedisp                lefebvre J-P.LEFEBVRE       106      2      2
 FORTRAN MODIF jeveux/jefini                lefebvre J-P.LEFEBVRE       149      8      5
 FORTRAN MODIF jeveux/jeimpd                lefebvre J-P.LEFEBVRE       194      2      2
 FORTRAN MODIF jeveux/jeinfo                lefebvre J-P.LEFEBVRE        54      2      2
 FORTRAN MODIF jeveux/jeinif                lefebvre J-P.LEFEBVRE       620      2      2
 FORTRAN MODIF jeveux/jelibf                lefebvre J-P.LEFEBVRE       384     12     16
 FORTRAN MODIF jeveux/jelihd                lefebvre J-P.LEFEBVRE       609      3      3
 FORTRAN MODIF jeveux/jereou                lefebvre J-P.LEFEBVRE        84     10      4
 FORTRAN MODIF jeveux/jjalls                lefebvre J-P.LEFEBVRE       520      2      2
 FORTRAN MODIF jeveux/jjimpo                lefebvre J-P.LEFEBVRE       213      3      4
 FORTRAN MODIF jeveux/jjldyn                lefebvre J-P.LEFEBVRE       269     22     15
 FORTRAN MODIF jeveux/jjlidy                lefebvre J-P.LEFEBVRE        67      2      2
 FORTRAN MODIF jeveux/jxecrb                lefebvre J-P.LEFEBVRE       120      4      2
 FORTRAN MODIF jeveux/jxlirb                lefebvre J-P.LEFEBVRE       109      4      2
 FORTRAN MODIF supervis/getcon              courtois M.COURTOIS         218     13      3
       H MODIF include/aster                courtois M.COURTOIS          79      1      1
       H MODIF include/aster_depend         courtois M.COURTOIS         150      3      1
  PYTHON MODIF Macro/post_k1_k2_k3_ops       geniaut S.GENIAUT         1294      3      3
  PYTHON MODIF Messages/jeveux              lefebvre J-P.LEFEBVRE       548     11      7
  PYTHON MODIF Messages/petsc                tardieu N.TARDIEU          109      8      1


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :    9       22763     22763            +22763
 MODIF :   36       18998       907     729      +178
 SUPPR :    0           0                 0        +0
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :   45       41761     23670     729    +22941 
