

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR delmas       DELMAS Josselin        DATE 24/08/2009 - 16:23:19

--------------------------------------------------------------------------------
RESTITUTION FICHE 013015 DU 2009-01-05 09:46:08
TYPE anomalie concernant Code_Aster (VERSION 9.4)
TITRE
   Erreur en quantite d'interet
FONCTIONNALITE
   Problème :
   ========
   Dans l'étude jointe, on plante salement dans CALC_ELEM / OPTION='QIRE_ELEM_SIGM' sans
   remontée d'erreur.
   
   Analyse :
   =======
   Un problème similaire (fiche 13556) fourni une remontée d'erreur et permet de montrer que
   le problème se situe dans le te0368.
   
   Un gentil développeur (G. Nicolas) a vu qu'il y avait un gros cafouillage dans le
   dimensionnement de certains tableaux. On range le résultat d'opérations d'additions et de
   soustraction sur des tableaux dans des tableaux sous dimensionnés.
   REAL*8 ADD(3), A(15), B(15)
   DO 10 I=1,15
     ADD(I)=A(I)+B(I)
   10 CONTINUE
   D'où un bel écrasement (passé inaperçu dans les tests jusque là...).
   
   Corrections :
   ===========
   On redimensionne tous les tableaux posant problème (taille de 9 correspondant au nombre
   max de noeuds sur une face).
   
   Validation :
   ==========
   Passage de l'étude jointe + étude fiche 13556
   Passage liste tests erreur
   
   Impacts :
   =======
   calnor.f
   ermeb3.f
   ermes3.f
   intega.f
   te0368.f
   te0375.f
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 8.2.16
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 8.2.16
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   passage de l'?de + liste erreur
NB_JOURS_TRAV  : 3.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 013556 DU 2009-06-23 15:36:45
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
   Arret brutal dans CALC_ELEM pour QIRE_ELEM_SIGM
FONCTIONNALITE
   Problème :
   ========
   Dans l'étude jointe, on plante salement dans CALC_ELEM / OPTION='QIRE_ELEM_SIGM'.
   
   Analyse :
   =======
   Le problème est similaire à la fiche 13015. Il y avait un gros cafouillage dans le
   dimensionnement de certains tableaux. On range le résultat d'opérations d'additions et de
   soustraction sur des tableaux dans des tableaux sous dimensionnés.
   
   Corrections :
   ===========
   On redimensionne tous les tableaux posant problème (taille de 9 correspondant au nombre
   max de noeuds sur une face).
   
   Validation :
   ==========
   Passage de l'étude jointe
   Passage liste tests erreur
   
   Impacts :
   =======
   calnor.f
   ermeb3.f
   ermes3.f
   intega.f
   te0368.f
   te0375.f
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 8.2.16
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 8.2.16
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   passage de l'?de + liste erreur
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 013691 DU 2009-08-07 12:51:42
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
   En NEW10.0.12, certains cas-tests ssnp50* s'arretent en erreur_<F> sur Bull, Calibre4, Calibre 5 et Rocks.
FONCTIONNALITE
   Problème :
   ========
   En NEW10.0.12, certains cas-tests ssnp50* s'arrêtent en erreur_<F> sur Bull, Calibre4,
   Calibre 5 et Rocks. 
   Les cas-tests concernés sont:
   ssnp503d,
   ssnp503f,
   ssnp503j,
   ssnp504d,
   ssnp504f.
   
   Analyse :
   =======
   Ces erreurs interviennent suite aux développements de Sébastien Meunier où il introduit
   MATINI pour initialiser les tableaux. Auparavant, cela était fait dans le TE0366 par deux
   boucles imbriquées pour i,j = NDDL < 120 (taille de la matrice). En passant par MATINI,
   l'initialisation restreinte à i,j = NDDL ne se passe pas de la même manière et produit une
   initialisation erronée.
   
   Exemple d'une matrice 3x3 dont on veut initialiser i,j pour 1,2 :
   
   matrice.......Boucle........MATINI
   X..X..X.......0..0..X.......0..0..X
   X..X..X.......0..0..X.......0..X..X
   X..X..X.......X..X..X.......0..X..X
   
   Correction :
   ==========
   Il est nécessaire d'initialiser complètement la matrice en donnant la taille de la matrice
   en argument de MATINI.
   
   Impacts :
   =======
   te0366.f
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   tests incrimin?
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 013695 DU 2009-08-07 13:52:00
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
   En NEW10.0.12, le cas-test fdlv111a s'arrete en erreur_<F> sur Bull, Calibre4, Calibre5 et Rocks.
FONCTIONNALITE
   Problème :
   ========
   En NEW10.0.12, le cas-test fdlv111a s'arrete en erreur_<F> sur Bull, Calibre4, Calibre5 et
   Rocks.
   
   Analyse :
   =======
   Le problème est identique à la fiche 13691 (usage de MATINI pour initialiser les matrices).
   
   Correction :
   ==========
   <      CALL MATINI(NDI,NDI,0.D0,A)
   >      CALL MATINI(18,18,0.D0,A)
   
   Impact :
   ======
   te0555.f
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   passage test
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 013703 DU 2009-08-12 07:44:44
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
   Fichiers .para de tests incorrects
FONCTIONNALITE
   Problème :
   ========
   Les fichiers .para des tests  suivants ont une syntaxe incorrecte. La
   mémoire indiquée derrière le mot clé mem_job doit préciser l'unité 
   
   forma11c, perf001c, sdld34a , sdll123a
   sdll123b, sdll123c, sdll124a, sdll125a
   sdll126a, sdll126b, sdll126c, sdll140a
   
   Correction :
   ==========
   On indique l'unité de la mémoire.
   ex : sdll126a mem_job 900  -> mem_job 900Mo
   
   Impacts :
   =======
   *.para des tests incriminés.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   *
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR geniaut      GENIAUT Samuel         DATE 24/08/2009 - 16:17:28

--------------------------------------------------------------------------------
RESTITUTION FICHE 013654 DU 2009-07-24 15:37:23
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
   X-FEM : bug dans une interpolation lineaire
FONCTIONNALITE
   Problème :
   ----------
   
   On cherche la valeur d'un champ nodal LST sur un point C d'une arete AB.
   
   Pour cela, on interpole linéairement le champ nodal LST entre les points A et B
   
      LST(C) = LST(A) + ( LST(B)-LST(A) ) * ( C-A ) / ( B-A )
   
   Le mieux est de faire l'interpolation le long de l'arête, en calculant une abscisse
   curviligne pour C.
   
   Mais dans xstano.f, on choisit un axe pour faire cette interpolation (pour des raisons de
   simplicité).
   
   si X(A) différent de X(B), alors on prend l'axe X, la formule devient donc : 
   
      LST(C) = LST(A) + ( LST(B)-LST(A) ) * ( X(C)-X(A) ) / ( X(B)-X(A) )
   
   sinon, si Y(A) différent de Y(B), alors on prend l'axe Y, ...
   
   
   Dans certains cas, on peut avoir X(A) très légèrement différent de X(B)
   X(A)-X(B) = 1e-14 dans le cas présent
   et donc le point C a aussi le même X, donc X(C)-X(A) est très faible aussi.
   ce qui donne 0/0 -> valeur indéterminée, dans noter cas, une valeur complètement fausse,
   mais qui ne provoque pas le plantage, donc le calcul continue normalement.
   En fait, cela provoque des statut d'enrichissement des noeuds incompatibles avec la
   position du fond de fissure, ce qui finit par faire planter le calcul proprement par un
   call assert dans xenrch.f, mais le message d'erreur ne permet pas bien de comprendre l'erreur.
   
   
   Solution :
   ----------
   
   1ere solution : On recherche avant de faire l'interpolation la direction de l'espace où
   l'écart entre A et B est le plus grand. On fait ensuite l'interpolation suivant cet axe.
   
   2eme solution : on utilise le produit scalaire AB.AC / || AB || comme abscisse curviligne
   du segment AB. 
      LST(C) = LST(A) + ( LST(B)-LST(A) ) * AB.AC / || AB ||
   
   On retient la 2eme solution
   
   impact : 
   xstano.f
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test perso
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 013670 DU 2009-07-31 15:06:23
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
   En NEW 10.0.11, le cas-test ssnv112b s?arrete par manque de convergence sur Rocks
FONCTIONNALITE
   Problème :
   ----------
   
   En NEW 10.0.11, le cas-test ssnv112b s?arrete par manque de convergence sur Rocks.
   
    
   INSTANT DE CALCUL :  1.000000000E+00
    
   --------------------------------------------------------------------------------------
   |   ITERATIONS   |     RESIDU     |     RESIDU     |     RESIDU     |     OPTION     |
   |     NEWTON     |     RELATIF    |     ABSOLU     |  PAR REFERENCE |   ASSEMBLAGE   |
   |                | RESI_GLOB_RELA | RESI_GLOB_MAXI |  CONTRAINTES   |                |
   --------------------------------------------------------------------------------------
   |     0        X | 4.74717E-04    | 1.63212E-06    | 7.40706E+00  X |TANGENTE        |
   |     1        X | 1.97636E-01    | 6.85650E-04    | 5.67767E+02  X |TANGENTE        |
   |     2        X | 3.26000E-03    | 1.12078E-05    | 1.87950E+01  X |TANGENTE        |
   |     3        X | 2.75528E-03    | 9.47487E-06    | 1.97537E+01  X |TANGENTE        |
   |     4        X | 2.98559E-03    | 1.02675E-05    | 1.49088E+01  X |TANGENTE        |
   |     5        X | 3.21055E-03    | 1.10404E-05    | 2.09118E+01  X |TANGENTE        |
   |     6        X | 3.24259E-03    | 1.11488E-05    | 1.71066E+01  X |TANGENTE        |
   |     7        X | 2.93966E-03    | 1.01073E-05    | 2.48864E+01  X |TANGENTE        |
   |     8        X | 2.68283E-03    | 9.22509E-06    | 3.44607E+01  X |TANGENTE        |
   |     9        X | 3.11654E-03    | 1.07172E-05    | 3.24638E+01  X |TANGENTE        |
   |    10        X | 3.76780E-03    | 1.29564E-05    | 3.38122E+01  X |TANGENTE        |
   --------------------------------------------------------------------------------------
    
   NOMBRE MAXIMUM D'ITERATIONS ATTEINT                                   
    
      
   
   
   Solution :
   ----------
   
   ce qui est bizarre, c'est que ce plantage n'est pas intervenu directement apres la modif
   dans INCREMENT en 10.0.10.
   
   sur la bull, la convergence ne mose aucun pb :
   INSTANT.DE.CALCUL.:..1.000000000E+00
   .
   --------------------------------------------------------------------------------------
   |...ITERATIONS...|.....RESIDU.....|.....RESIDU.....|.....RESIDU.....|.....OPTION.....|
   |.....NEWTON.....|.....RELATIF....|.....ABSOLU.....|..PAR.REFERENCE.|...ASSEMBLAGE...|
   |................|.RESI_GLOB_RELA.|.RESI_GLOB_MAXI.|..CONTRAINTES...|................|
   --------------------------------------------------------------------------------------
   |.....0........X.|.4.74717E-04....|.1.63212E-06....|.7.40706E+00..X.|TANGENTE........|
   |.....1..........|.1.35421E-10....|.4.65355E-13....|.8.15191E-05....|TANGENTE........|
   --------------------------------------------------------------------------------------
   
   Pour que le test tourne sous Rocks, il faut autoriser le sous-découpage (commande
   DEFI_LIST_INST).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ssnv112b
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 013671 DU 2009-07-31 15:20:00
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
   En NEW 10.0.11, le cas-test ssna118a s?arrete en CPU_LIMIT sur Bull
FONCTIONNALITE
   Problème :
   ----------
   
   En NEW 10.0.11, le cas-test ssna118a s?arrete en CPU_LIMIT sur Bull.
   
   
   Solution :
   ----------
   
   Le test tournait en 2000 secondes jusqu'en 10.0.9.
   En 10.0.10, il est passé à 2450 s.
   Il s'arrête en 10.0.11 car le .para est à 2500 s.
   
   j'ai commis une erreur en modifiant la syntaxe du sous-découpage :
   
   avant :  SUBD_PAS=4 et SUBD_NIVEAU=6
   apres modifs en 10.0.10, j'ai mis : SUBD_PAS=6 et SUBD_NIVEAU=4
   
   je corrige donc :
   SUBD_PAS=4 et SUBD_NIVEAU=6
   
   on revient vers le temps initial (environ 1900 s)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ssna118a
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 010744 DU 2007-04-03 09:18:36
TYPE evolution concernant Code_Aster (VERSION 2.x)
TITRE
   STAT_NON_LINE  (VISCOCHAB)
FONCTIONNALITE
   Problème :
   ----------
   
   La loi de comportement VISCOCHAB introduit par MMC en 1996 n'a pas de doc R et n'est pas
   maintenu. Or le projet Fatigue a besoin de ce modèle.
   
   
   Solution :
   ----------
   
   Prise en charge par T64 (avec appui JMP)
   
   Autoriser le sous-découpage (cf fiche 11384)
   Amélioration de la robustesse (cf fiche 12536)
   Correction de bug dans la programmation (cf fiche 12982)
   Création des fiches matériaux (cf fiche 13002)
   
   Validation : un nouveau cas test a été restitué avec la fiche 12536 : comp002i
   Documentation : la documentation de référence a été écrite (R5.03.12)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : R5.03.12
VALIDATION
   comp002i
NB_JOURS_TRAV  : 20.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 012276 DU 2008-07-07 14:39:40
TYPE evolution concernant Documentation (VERSION )
TITRE
   Conseils en Meca rupture
FONCTIONNALITE
   Suite à la diffusion de la note H-T64-2008-00047-FR "Convergences en mécanique de la
   rupture : validation des éléments finis classiques et X-FEM dans Code_Aster" : 
   
   impact U2.05.01 : 
   - re-re-dire que les éléments de Barsoum permettent une amélioration considérable de la
   solution.
   - lien vers la doc X-FEM U2.05.02.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : U2.05.01
VALIDATION
   aucun
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 011876 DU 2008-03-25 14:47:25
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   X-FEM : faciliter la dxc3xa9finition d'interfaces
FONCTIONNALITE
   Problème :
   ----------
   
   Pour certaines applications, on a besoin de définir une interface X-FEM (et non une fissure). 
   exemple : deux solides en contact, failles géologiques, inclusion dans un bimatériau.
   
   pour le moment, on passe toujours par la procédure standard de définition de fissure de
   DEFI_FISS_XFEM : une level set normale et une level set tangente.
   
   Pour une interface, on pourrait se satisfaire de la level set normale. La donnée de la
   level set tangente perturbe l'utilisateur et ne sert pas à grand chose (de mémoire,
   seulement pour la définition de la base covariante des facettes de contact).
   
   On pourrait faire évoluer la commande DEFI_FISS_XFEM pour traiter les interfaces de
   manière plus sympa.
   par exemple, ajout d'un mot-clé : TYPE_DISCONTINUITE : 'FISSURE' ou 'INTERFACE' (il
   faudrait aussi prévoir le cas des interfaces des bimatériaux).
   Si TYPE_DISCONTINUITE = 'FISSURE', on a besoin des deux level sets.
   Si TYPE_DISCONTINUITE = 'INTERFACE', on a besoin que de la level set normale.
   
   De plus, cette distinction pourrait offrir un catalogues de fissures/interfaces adapté.
   
   Cela permettrait aussi de supprimer l'alarme qui dit qu'aucun point de fond de fissure n'a
   été trouvé. Cette alarme serait transformée en erreur F si TYPE_DISCONTINUITE = 'FISSURE',
   et ne serait pas émise si TYPE_DISCONTINUITE = 'INTERFACE'.
   
   
   
   Solution :
   ----------
   
   On rajoute deux mot-clés dans DEFI_FISS_XFEM :
   TYPE_DISCONTINUITE  =SIMP(statut='f',typ='TXM',into=("FISSURE","INTERFACE",)
   ,defaut="FISSURE",position='global'),
   CHAM_DISCONTINUITE  =SIMP(statut='f',typ='TXM',into=("DEPL","SIGM"),defaut="DEPL" ), si
   interface
   CHAM_DISCONTINUITE  =SIMP(statut='f',typ='TXM',into=("DEPL",),defaut="DEPL" ), si fissure
   
   
   De plus, on adapte les mot-clés de DEFI_FISS_XFEM suivant le type de discontinuité à traiter.
   par ex :
   - la donnée de la LST (FONC_LT ou GROUP_MA_FOND) n'est plus possible si on traite une
   interface
   - on aurait voulu avoir un catalogue de fissure/interface adapté mais FORM_FISS ne peut
   pas être dans un bloc conditionnel car il sert dans une règle de 1er niveau
   - la donnée de ORIE_FOND n'est pas possible si on traite une interface
   - la donnée de TYPE_ENRI_FOND, RAYON_ENRI, NB_COUCHES n'est pas possible si on traite une
   interface
   
   Par contre, on ne peut pas créer les règles adéquats suivant le cas à traiter dans le capy :
   
   #       b_fissure           =BLOC(condition = "TYPE_DISCONTINUITE == 'FISSURE'
   ",fr="Regles pour les fissures",           
   #                 regles    =(ENSEMBLE('FONC_LN','FONC_LT'),
   #                             ENSEMBLE('CHAM_NO_LSN','CHAM_NO_LST'),
   #                             ENSEMBLE('GROUP_MA_FISS','GROUP_MA_FOND')),
   #                                ),
   # 
   #       b_interface           =BLOC(condition = "TYPE_DISCONTINUITE == 'INTERFACE'
   ",fr="Regles pour les interfaces",           
   #                 regles    =(PRESENT_ABSENT('FONC_LN','FONC_LT'),
   #                             PRESENT_ABSENT('CHAM_NO_LSN','CHAM_NO_LST'),
   #                             PRESENT_ABSENT('GROUP_MA_FISS','GROUP_MA_FOND')),
   #                                ),
   
   Les 2 infos en plus sont stockées dans un nouveau vecteurs K19 (longueur = 2) dans la
   sd_fis_xfem :
   '.INFO', auquel on accède par un dismoi 
        CALL DISMOI('F','TYPE_DISCONTINUITE',FISS,'FISS_XFEM',IBID,TYPDIS,IRET)
        CALL DISMOI('F','CHAM_DISCONTINUITE',FISS,'FISS_XFEM',IBID,CHADIS,IRET)
   
   Dans le cas d'une interface, on crée quand même une LST bidon = -1 partout
   
   Validation :
   ------------
   
   informatique : tous les tests-xfem
   de plus, on modifie le test sslp317a afin de remplacer une fissure par une interface
   de manière à tester la commande RAFF_XFEM (raffinement automatique) en présence d'une
   interface :
   on raffine les mailles où LSN est proche de 0.
   
   
   impact :
   --------
   
   raff_xfem_ops.py  sd_xfem.py  xfem.py
   
   defi_fiss_xfem.capy
   
   dismxf.f  op0041.f  xenrch.f  xinils.f  xls2d.f  xls3d.f
   
   
   tests:
   ssnv173b.comm  ssnv173j.mess  ssnv186c.comm  ssnv195a.comm  ssnv209d.comm
   ssnp503d.comm  ssnv173c.comm  ssnv182a.comm  ssnv186d.comm  ssnv195b.comm  ssnv209e.comm
   sslp317a.comm       ssnp503f.comm  ssnv173d.comm  ssnv182b.comm  ssnv186e.comm 
   ssnv195c.comm  ssnv209g.comm
   sslp317a.datg       ssnp503h.comm  ssnv173e.comm  ssnv182c.comm  ssnv186f.comm 
   ssnv195d.comm  ssnv209h.comm
   ssnp503j.comm  ssnv173f.comm  ssnv182d.comm  ssnv186g.comm  ssnv201a.comm
   ssnp504b.comm  ssnv173g.comm  ssnv182e.comm  ssnv186h.comm  ssnv203a.comm
   ssnp504d.comm  ssnv173h.comm  ssnv182f.comm  ssnv191a.comm  ssnv203b.comm
   ssnp504f.comm  ssnv173i.comm  ssnv186a.comm  ssnv191b.comm  ssnv209b.comm
   ssnp503b.comm       ssnv173a.comm  ssnv173j.comm  ssnv186b.comm  ssnv191c.comm  ssnv209c.comm
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.82.08, U2.05.02, V3.02.317
VALIDATION
   ssnp317a + tous les tests X-FEM
NB_JOURS_TRAV  : 4.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 012682 DU 2008-10-21 14:50:14
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   X-FEM : performances de DEFI_FISS_XFEM (HPC inside)
FONCTIONNALITE
   Contexte :
   ----------
   
   Pendant son stage, Agnès Marion a fait des calculs sur des relativement gros modèles, où
   de nombreuses mailles étaient des mailles X-FEM :
   si on part d'un maillage initial, apres 5 itérations d'Homard qui raffinent les mailles en
   fond de fissure, on atteint un maillage de 278 000 noeuds, 1 600 000 TETRA4.
   
   Le temps passé dans DEFI_FISS_XFEM est de 2300s.
   On trouve 1124 points en fond de fissure, et plus de 70 000 mailles sont fissurées.
   
   On ne peut pas comparer avec le temps de STAT_NON_LINE car aucun calcul n'a été lancé avec
   ce maillage.
   
   
   Par contre, avec le maillage n°4 : 190 000 noeuds, 1 000 000 de TETRA4
   on trouve 566 points en fond de fissure, et 40 000 mailles fissurées.
   temps dans DEFI_FISS_XFEM : 500s
   temps dans STAT_NON_LINE : 1700s
   
   Je trouve qu'on passe quand même pas mal de temps dans DEFI_FISS_XFEM.
   C'est p-e tolérable, mais j'ai peur que ca explose vite (à moins de prévoir une version
   parallélisable de cette commande ?). Pour se faire, une idée, j'ai joint en annexe la
   courbe d'éovlution du temps.
   A mon avis, il faudrait pousser plus loin l'analyse et voir dans quelle partie de
   DEFI_FISS_XFEM on passe bcp de temps : calcul des level sets, de leur gradient, recherche
   des points en fond de fissure ...???
   
   
   
   Problème:
   ---------
   
   Une étude de performances a été menée en 10.0.11 sur le maillage n°4 :
   
    COMMAND........:..USER....:.SYSTEM.:.USER+SYS.:.ELAPSED
   DEFI_FISS_XFEM.:..376.32..:...4.13.:...380.45.:..404.46 sur Bull
   DEFI_FISS_XFEM.:..289.45..:...6.47.:...295.92.:..388.60 sur Cal5
   
   et a montré que la plus grande partie du temps est passée dans xstano.f (gprof).
   Cette routine calcule le statut des noeuds (type d'enrichissement) suivant le min et le
   max des lst et lsn sur le support du noeud.
   
   Or cette routine est (très) mal programmée.
   
   on fait à l'heure actuelle :
   - boucle sur les noeuds de GROUP_ENRI
       - boucle sur les mailles de MAFIS
            - boucle sur les noeuds de la maille courante
            - fin boucle
            - calcul des min et max des lsn et lst
       - fin boucle
       - calcul du statut du noeud courant
   - fin boucle
   
   
   
   Solution :
   ----------
   
   On propose plutôt :
   
   - création d'un vecteur temporaire LMAFIS de longueur nbma
   - boucle sur les mailles de MAFIS
        on met à 1 la case correspondante à cette maille dans LMAFIS
   - fin boucle
   - calcul de la connectivité inverse sur tout le maillage : CNCINV
   - boucle sur les noeuds de GROUP_ENRI
        - boucle sur le support du noeud courant
             si LMAFIS = 0 pour cette maille, on va à l'itération suivante
             sinon on calcule le min et max de lst, lsn
        - fin boucle
        - calcul du statut du noeud courant
   - fin boucle
   
   On obtient alors sur le maillage n4 les temps suivants (sur Cal5) :
   
   COMMAND..................:.......USER.:.....SYSTEM.:...USER+SYS.:....ELAPSED.*
   DEFI_FISS_XFEM...........:......41.90.:.......5.69.:......47.59.:......87.49.*
   
   
   Si l'on compare les temps USER+SYST avant et après, on constate une amélioration du temps
   total passé dans la commande DEFI_FISS_XFEM d'un facteur 6.
   Je n'ai pas fait d'étude du gain systématique pour tous les cas tests X-FEM de la base.
   Le gain y sera forcément moindre car le nombre de mailles fissurées des tests est assez
   faible.
   Mais le gain sera plus conséquent pour des maillages encore plus gros (cf. étude frettes
   alternateur de L. May)
   
   
   
   impact :
   -------
   
   xenrch.f, xstano.f, xptfon.f
   en fait, avant, on calculait CNXINV dans xptfon.
   maitenant, le remonte dans xenrch qui le passe en argument à xstano et xpfton
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   etude fournie + test X-FEM
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR colombo      COLOMBO Daniele        DATE 24/08/2009 - 16:17:30

--------------------------------------------------------------------------------
RESTITUTION FICHE 013447 DU 2009-05-20 17:03:35
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   PROPA_FISS : developpement de la methode Upwind
FONCTIONNALITE
   Le développement de la méthode upwind pour la propagation des fissures X-FEM a été réalisé
   d'abord dans le cadre de l'opérateur PROPA_XFEM (op0010.f). Ensuite toutes les méthodes de
   propagation disponibles (projection, simplexe et, maintenant, upwind) ont été unifiées par
   l'opérateur PROPA_FISS (macro python). L'opérateur PROPA_XFEM peut calculer la propagation
   d'une seule fissure à la fois et il est appelé plusieurs fois par PROPA_FISS, une fois
   pour chaque fissure à propager.
   
   
   
   -----------------------------
   IMPLEMENTATION METHODE UPWIND
   -----------------------------
   
   La méthode upwind a été implémentée dans PROPA_XFEM par les nouvelles routines fortran
   suivantes (plus de détails dans la documentation R7.02.12.):
   
   * XPRUPW.F
   Cette subroutine calcule la réinitialisation et la réorthogonalisation des level sets en
   utilisant la méthode upwind. À différence de la méthode simplexe, les deux phases sont
   gérées par la même subroutine. À chaque appel une seule phase peut être gérée.
   
   *XPRCNU.F
   La méthode upwind utilise une grille très régulière pour la représentation des level sets.
   Cette routine est appelée avant l'utilisation de la méthode upwind (xprupw.f) et elle
   analyse la grille pour calculer les grandeurs suivantes:
   1. base locale de la grille
   2. disposition des points de la grille selon les trois directions de la base locale
   3. distance entre deux noeuds consécutifs de la grille
   4. détermination des noeuds qui sont sur le bord de la grille. Cela est nécessaire pour la
   correcte application des conditions aux limites.
   
   * XPRPLS.F
   Cette subroutine projette les level sets entre la grille auxiliaire (ou level sets) et le
   maillage physique:
   1. détermination du domaine à utiliser pour la grille auxiliaire et le maillage physique.
   Cela permit de rendre la projection très rapide.
   2. projection entre les deux domaines selectionnés.
   3. calcul des gradients des level sets sur le maillage physique.
   4. conservation des valeurs des anciens level sets (avant la projection) pour tous les
   points du maillage physique à l'extérieur du domaine de projection.
   
   * XPRCYC.F
   Dans le cadre de propagation des plusieurs fissures dans le même modèle, cette subroutine
   gère correctement la propagation:
   1. lecture des valeurs des grandeurs énergétiques dans les tableaux issus par CALC_G
   2. détermination du point du fond des fissures qui propage plus vite
   3. calcul de nombre de cycle de fatigue pour avoir l'avance maximale DA_MAX (donnée par
   l'utilisateur) de la fissure qui propage plus vite et calcul de l'avance maximale de la
   fissure à propager
   4. calcul de la vitesse de propagation pour les points du fond de la fissure à propager
   5. gestion des options du PROPA_XFEM liées à la vitesse de propagation et au rapport de
   charge du cycle de fatigue: NB_POINT_FOND, COMP_LINE, LOI_PROPA, TEST_MAIL
   
   * XPRDIS.F
   L'opérande TEST_MAIL a été ajouté à l'opérateur PROPA_FISS. Il permit de vérifier si le
   maillage utilisé pour la représentation des level sets est suffisamment raffiné et s'il
   peut donc bien représenter les level sets pendant la propagation. Cela est obtenu en
   utilisant une vitesse de propagation constante pour tous les points du fond des fissures
   du modèle. À chaque propagation, donc, on obtient un fond homothétique au fond initial.
   Cette propriété est utilisée pour vérifier si le maillage est suffisamment raffiné.
   Dans ce cadre, cette subroutine calcule la distance minimale et maximale entre les points
   du fond de fissure après la propagation et le fond initiale et vérifie si ces distances
   sont proches à la distance attendue (propagation imposée).
   
   
   
   ------------------------------
   MODIFICATIONS DU CODE EXISTANT
   ------------------------------
   
   Pour ajouter au code existant les nouveaux développements décrits ci-dessus, les
   subroutines de l'opérateur PROPA_XFEM et la macro python PROPA_FISS ont été modifiées.
   
   * OP0010.F (PROPA_XFEM)
   
   PROJECTION ENTRE LE MAILLAGE LEVEL SET ET LE MAILLAGE PHYSIQUE
   
   La nouvelle méthode upwind utilise une grille très régulière pour résoudre les équations
   de mise à jour des level sets. La solution est calculée par plusieurs itérations sur cette
   grille et ensuite elle est projetée sur le maillage physique. La projection est gérée par
   la nouvelle subroutine xprpls.f. Toutefois l'utilisation de la grille level sets n'est pas
   obligatoire et on peut utiliser le maillage physique si quelques conditions sont respectées.
   La séquence de calcul est toujours la même pour les deux cas. Pour gérer efficacement le
   calcul, l'opérateur PROPA_XFEM (op0010.f) a été modifié. Toutes les subroutines de calcul
   sont appelées en utilisant des noms virtuelles pour les structures de données (modèles,
   fissures, vitesses, level sets...). Au début du calcul, l'opérateur assigne la valeur
   correcte à ces noms, c'est à dire le nom des structures de données du modèle level sets ou
   du modèle physique. Cela dépende de l'utilisation ou pas de la grille auxiliaire. À la fin
   du calcul, l'opérateur appelle la subroutine xprpls.f pour gérer la projection si cela est
   nécessaire.
   Cette solution est très versatile parce qu'elle permit d'utiliser la grille level sets
   pour la méthode simplexe aussi sans rien changer dans le code. Cela permit de gagner
   beaucoup de temps de calcul en présence de grands modèles (physiques).
   
   AVANCE MAXIMALE CHOISIE PAR L'UTILISATEUR
   
   En conséquence des modifications apportées à la subroutine d'intégration des équations de
   mise à jour des level sets (voir xprls.f ci-dessous), l'utilisateur peut maintenant
   choisir l'avance maximale de la fissure qu'il veut imposer à chaque appel de l'opérateur
   PROPA_FISS. Cela détermine le temps total d'intégration  des équations. Ce temps est
   maintenant calculée dans op0010.f en utilisant la valeur maximale de la vitesse de
   propagation évaluée par la subroutine xpraju.f et le nombre de cycles de fatigue à
   appliquer calculé par la subroutine xprcyc.f.
   
   CALCUL DE LA CONDITION CFL
   
   Le calcul de la condition CFL à respecter pour l'intégration des équation de mise à jour
   est maintenant fait dans op0010.f en utilisant les informations calculées par xpraju.f et
   xprcfl.f. En fait la première routine élabore chaque noeud du maillage pour vérifier si la
   composante normale de la vitesse doit être changée ou pas et donc elle peut déterminer
   aussi la plus grande composante de vitesse dans le maillage. La deuxième routine calcule
   la longueur de la plus petite arête du maillage. La condition CFL pour la phase de mise à
   jour des level sets peut donc être calculée dans op0010.f en utilisant les deux grandeurs
   donné en sortie par les deux routines (CFL=h_min/V_max).
   Avant cette modification, le calcule de la condition CFL était fait par la routine
   xprcfl.f. Cet routine était appelée avant la modification de la composante normale de la
   vitesse par la routine xpraju.f. En plus cet calcule prenait en compte seulement la
   composante tangentielle de la vitesse. En conséquence la condition CFL calculée n'était
   pas correcte et des problèmes d'instabilité se manifestaient pendant l'intégration pour
   toutes les cas de propagation en mode mixte. Pour un calcul correct de la condition CFL il
   n'était pas suffisant d'appeler la routine xprcfl.f après la modification de la vitesse
   normale par xpraju.f parce que seulement la composante tangentielle de la vitesse était
   considérée par xprcfl.f. On a décidé de ne pas modifier cet dernière routine pour prendre
   en compte la composante normale de vitesse aussi parce que le calcul de la plus grande
   composante de la vitesse peut être fait en façon très simple et très rapide dans xpraju.f.
   Donc tous les calculs liés à la vitesse ont été supprimés dans la routine xprcfl.f.
   
   * XPRAJU.F
   
   Dans le cadre du calcul de la condition CFL à respecter pour l'intégration des équations
   de mise à jour des level sets, on doit calculer la plus grande composante de la vitesse
   pour les noeuds du maillage. Cet calcul a été fait dans xprcfl.f et la valeur trouvée
   n'est pas toujours correcte. En fait, pour faire évoluer convenablement la level set
   normale, la valeur de la composante normale est changée dans xpraju.f après l'appel à
   xprcfl.f.
   On change donc xpraju.f pour évaluer la valeur maximale des composantes après leur
   modification.
   
   * XPRINI.F
   
   La nouvelle méthode upwind, utilisée pour résoudre les équations de mise à jour des level
   sets, a besoin de une grille de calcul trés réguliére. Les points de cette grille doivent
   étre ordonnés selon les trois directions d'une base locale et la distance entre deux
   points successifs doit étre calculée au début de l'utilisation de la méthode.
   On modifie donc xprini.f pour inclure ces calculs dans la phase de initialisation de la
   mise à jour des level sets. Si la méthode upwind a été choisie par l'utilisateur, on
   appelle xprcnu.f qui s'occupe de tous les calculs d'initialisation de la grille.
   
   * XPRLS0.F
   
   A) Cette subroutine calcule la level set normale pour tous les éléments qui sont coupés
   par la iso-zero de la level set elle-même. Toutefois elle ne gère pas correctement les cas
   où la fissure passe par un noeud et la level set normale à ce noeud n'est pas exactement
   égal à zéro (après quelques itération de propagation). Dans ces cas, la level set normale
   est calculée pour le noeud et une valeur pas nulle est lui affectée. Cela cause des
   petites fausses déviations dans le parcours de propagation de la fissure qui peuvent
   s'accumuler dans les itérations suivantes et qui peuvent générer des résultats faux.
   Pour éviter cet erreur, la subroutine doit identifier correctement les cas ci-dessus. On
   utilise donc une tolérance plus grande pour vérifier si la level set normale est nulle ou
   pas en changeant la valeur actuelle (R8PREM). La nouvelle tolérance est prise égale au 1%
   de la plus petite arrête du maillage. Cette valeur est déjà utilisée dans les routines de
   enrichissement.
   
   B) Dans cette parte du code on calcule les level sets à proximité des iso-zéros. Le calcul
   est réalisé pour chaque noeud des mailles coupées ou tangentées par l'iso-zéro de la level
   set normale (lsn): on calcule la distance minimale entre le noeud et chaque triangle qu'on
   peut former en utilisant les points d'intersection entre l'iso-zéro de la lsn et les
   arêtes des éléments coupés.
   Cet algorithme marche bien seulement en 3D parce qu'en 2D on ne peut pas former des
   triangles (deux points d'intersection maximum peuvent être détectés pour chaque élément).
   Une correction a été apportée au code (fiche 13080) (ligne 540) mais elle est limitée aux
   éléments QUAD. En plus elle n'utilise pas le code déjà présent (et déjà testé) pour le cas 3D.
   On propose donc d'utiliser une solution plus générale et qui permit d'utiliser le même
   code qu'en 3D. En fait dans le cas 2D, on peut former un triangle en utilisant deux points
   d'intersection (A et B) et un point virtuel (C). Celui-ci est pris en façon tale que le
   triangle formé est dans un plan orthogonal au plan du modèle (plan X-Y). Pour éviter des
   problèmes numériques, les coordonnés du point virtuel (C) sont calculées comme ceci: 
   (X,Y)=coordonnés du point central de l'arête reliant les deux points d'intersection (A et B)
   Z=distance entre les deux points d'intersection (A et B)
   
   * XPRLS.F
   
   Les modifications suivantes ont été apportées à la subroutine:
   
   1. l'intégration des équations de mise à jour des level sets a été changée en façon tale
   que plusieurs intégrations sont maintenant calculées à chaque appel de la subroutine. Cela
   permit de intégrer sur un temps quelconque et il permit à l'utilisateur de spécifier
   l'avance maximale de la fissure.
   Avant cette modification du code, l'intégration était calculée sur un temps égal à la
   valeur de la condition CFL. Cela est très restrictif parce qu'en présence de propagation
   en mode mixte, la condition CFL a une valeur très petite et l'avance de la fissure qu'on
   obtient est considérablement inférieure à la longueur de la plus petite arête du maillage.
   Dans ce cas on doit donc appeler plusieurs fois l'opérateur PROPA_XFEM pour avoir l'avance
   voulue. Cette restriction rende l'opérateur inutilisable en pratique. 
   
   2. l'équation de mise à jour des level set a été modifié. En fait, si la fissure propage
   en mode mixte, les résultats obtenus en utilisant cette équation sont affectés par des
   erreurs qui sont liés au nombre d'itérations d'intégration utilisé dans la subroutine. En
   conséquence de ces erreurs, la position du fond de fissure après la propagation n'est pas
   correcte.
   Pour l'application de la nouvelle équation (décrit dans la documentation R7.02.12) on doit
   calculer le vecteur vitesse de propagation pour chaque noeud du maillage au début de la
   première itération d'intégration. Ce vecteur ne change pas pendant toutes les itérations.
   Le calcul du vecteur est fait en utilisant les composantes normale et tangentielle déjà
   évaluées par la subroutine xprvit.f. La subroutine xprls.f calcule la base à utiliser pour
   chaque noeud du maillage (base locale de la projection du noeud sur le fond de fissure ou
   gradients des level sets) et ensuite calcule le vecteur en utilisant la valeur des
   composantes de la vitesse et la base choisie.
   
   * XPRREI.F
   
   En conséquence des modifications apportées à la subroutine xprls0.f (voir ci-dessus), le
   nombre des paramètres à passer à cette subroutine a été changé. On modifie donc les CALL
   XPRLS0 dans xprrei.f pour passer les paramètres correctes.
   
   * XPRVIT.F
   
   Plusieurs modifications ont été apportées au calcul de la vitesse de propagation de chaque
   noeud du maillage en conséquence des changements affectés à l'équation de mise à jour des
   level sets (voir xprls.f):
   
   1. pour chaque point d'intersection entre le fond du fissure et les faces des éléments du
   maillage, on calcule le vecteur vitesse de propagation et ses composantes normale et
   tangentielle à la surface de la fissure à partir des résultats calculés par CALC_G. Ce
   vecteur est défini dans la base utilisée pour le maillage. Avant les modifications de
   l'équation de mise à jour, les seules composantes de la vitesse étaient calculées.
   
   2. pour chaque arrête reliant deux points d'intersection consécutifs entre le fond du
   fissure et les faces des éléments du maillage, on calcule l'axe et la rotation d'Euler
   pour passer du repère local au premier point au repère local du deuxième point. Cette
   rotation est utilisée pour calculer le repère local pour un point quelconque de l'arête.
   Ce dernier point est la projection sur le fond de fissure d'un noeud du grille de calcul
   (voir ci-dessous)
   
   3. pour chaque noeud de la grille de calcul, on calcule la projection sur le fond de la
   fissure. Ensuite on calcule le vecteur vitesse de propagation et le repère local pour le
   point obtenu par la projection. Le vecteur vitesse est obtenu par interpolation des
   vecteur vitesse des deux points du fond plus proches. Le repère local est obtenu par une
   rotation rigide du repère d'un des deux points utilisés pour le calcul de la vitesse.
   L'angle et l'axe d'Euler calculés ci-dessus pour les points du fond de fissure sont
   utilisés pour cette rotation.
   
   * XPTFON.F
   
   Un message de debug oublié dans la subroutine a été éliminé.
   
   
   
   -----------------------
   OPERANDES DE PROPA_FISS
   -----------------------
   
   En conséquence des développements décrits ci-dessus, des nouveaux opérandes ont été ajoutés:
   
   1) Mot clé facteur FISSURE=on donne une liste des fissures à propager. Pour chaque fissure
   dans la liste:
      - FISS_ACTUELLE=fissure à propager
      - FISS_PROPAGEE=fissure propagée crée par PROPA_FISS
      - GRILLE_AUX=grille auxiliaire à utiliser pour la représentation
        des level sets
      - TABLE=table issue par CALC_G
      - NB_POINT_FOND=si NB_POINT_FOND a été utilisé dans CALC_G, on
        l'utilise dans PROPA_FISS aussi
   
   2) DA_MAX=on donne l'avance maximale des fissures du modèle
   
   3) Mot clé facteur COMP_LINE=si le comportement du modèle fissuré est linéaire, on donne
   les conditions de chargement maximal et minimal du cycle de fatigue:
      - COEF_MULT_MINI=constant par laquelle on doit multiplier les chargements
        de la condition de référence pour avoir la condition de chargement
        minimal du cycle de fatigue
      - COEF_MULT_MAXI=constant par laquelle on doit multiplier les chargements de
        la condition de référence pour avoir la condition de chargement
        maximale du cycle de fatigue
   
   4) TEST_MAIL=on peut faire des tests pour vérifier si le maillage de la structure et/ou le
   maillage de la grille auxiliaire sont suffisamment raffinés pour bien représenter les
   fissures du modèle.
   
   
   
   --------
   CAS TEST
   --------
   
   * Cas test existantes
   ---------------------
   
   La syntaxe de l'opérateur PROPA_FISS dans le fichier .comm des cas tests suivantes a été
   mis à jour:
   sslv314a
   sslv315a
   ssnv185j
   
   La résolution par les méthodes upwind, upwind+grille auxiliaire et/ou simplexe+grille
   auxiliaire a été ajoutée pour les cas tests existantes suivantes:
   sslv314d
   sslv315d
   sslp315c
   sslp315d
   sslp315e
   ssnv185q
   
   * Nouveaux cas test
   -------------------
   
   Les nouveaux cas test suivants ont été crées:
   
   - FISSURATION A PROPAGATION IMPOSEE AVEC XFEM
     sslv316a - méthode upwind sans grille auxiliaire
     sslv316b - méthode upwind avec grille auxiliaire
     sslv316c - méthode simplexe sans grille auxiliaire
     sslv316d - méthode simplexe avec grille auxiliaire
   
     On impose une avance connue (DA_MAX et angle) et on vérifie que la nouvelle position du
   fond de fissure calculée par PROPA_FISS est celle qui on s'attend.
   
   - PROPAGATION D'UNE FISSURE XFEM NON DEBOUCHANTE SOLLICITE EN MODE I
     sslp318a - méthode upwind
     sslp318b - méthode simplexe
   
     On vérifie que le code gère correctement le cas d'une fissure avec deux fonds
   (multifissuration: fond défini par deux morceaux)
   
   - PROPAGATION DE DEUX FISSURES XFEM DEBOUCHANTES SOLLICITEE EN MODE I
     sslp319a - méthode upwind
     sslp319b - méthode simplexe
   
     On vérifie que le code gère correctement le cas de deux fissures (multifissuration: deux
   fissures)
   
   - VALIDATION DE L'OPTION TEST_MAIL DANS PROPA_FISS
     zzzz255a - méthode upwind
     zzzz255b - méthode simplexe
   
     On vérifie que l'option TEST_MAIL marche bien pour les deux méthodes
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : R7.02.12,U4.82.11,V3.04.316,V3.02.318,V3.02.319,V1.01.255,U2.05.02
VALIDATION
   sslv314a,d,sslv315a,d,sslp315c,d,e,sslv316a,b,c,d,sslp318a,b,sslp319a,b,ssnv185j,q,zzzz255a,b
NB_JOURS_TRAV  : 190.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR geniaut      GENIAUT Samuel         DATE 24/08/2009 - 16:17:30

--------------------------------------------------------------------------------
RESTITUTION FICHE 013675 DU 2009-08-03 13:20:39
TYPE express concernant Code_Aster (VERSION 10.1)
TITRE
   X-FEM : cas tests de propagation
FONCTIONNALITE
   Cette fiche s'inscrit dans le cadre de la propagation de fissure avec X-FEM en 2D. Il
   existe en effet actuellement un seul cas test de ce type (SSLP314).L'objectif de cette
   fiche est donc l'apport de trois nouveaux cas tests 2D permettant la validation de
   l'opérateur PROPA_FISS.
   Plus précisément, il existe trois méthodes pour faire propager la fissure dans PROPA_FISS
   : méthode maillage, simplexe et upwind. On souhaite valider les trois méthodes à travers
   les cas tests présentés.
   
   Voici une description succinte des trois cas tests :
   SSLP320 : Propagation d'une fissure X-FEM débouchante sollicitée en Mode I.
   Il s'agit ici de faire propager une fissure débouchante dans une plaque et de comparer les
   valeurs de KI et KII aux valeurs théoriques données par Tada, Paris et Irwin pour les
   trois méthodes. En parallèle et pour la méthode maillage uniquement, on contrôle les
   coordonnées du fond de fissure.
   
   SSLP321 : Propagation d'une fissure X-FEM dans une plaque en flexion 3 points.
   On fait propager une fissure dans une plaque soumise à une flexion trois points. Le
   chargement appliqué est une force nodale. On contrôle ici pour les trois méthodes les KI
   et KII et le trajet de propagation pour la méthode maillage (avec l'article de Mariani et
   Perego).
   
   SSLP322 : Propagation d'une fissure X-FEM dans une plaque en flexion 3 points avec 3 trous.
   On fait propager une fissure dans une plaque soumise à une flexion trois points avec 3
   trous. Le chargement appliqué est une force nodale. On contrôle, pour la méthode maillage
   uniquement, les KI et KII et le trajet de propagation (avec les articles de Bittencourt et
   de Ventura).
   
   (PJ) : animations des propagations)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V3.02.320, V3.02.321, V3.02.322, U2.05.02
VALIDATION
   sslp320a, b, c, sslp321a, b, c, sslp322a
NB_JOURS_TRAV  : 6.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR durand       DURAND Christophe      DATE 24/08/2009 - 16:17:31

--------------------------------------------------------------------------------
RESTITUTION FICHE 013667 DU 2009-07-31 13:05:57
TYPE aide utilisation concernant Code_Aster (VERSION 7.0)
TITRE
   Impossibilite de Convergence THER_NON_LINE
FONCTIONNALITE
   La non-convergence se produit au pas de temps numéro 35.
   Si on imprime le champ de température aux instants immédiatement précédents, on s'aperçoit
   que la température au point chaud monte, monte jusqu'à atteindre 1450.°C au pas de temps 34.
   
   Or la lecture de la fonction enthalpie (beta) montre que c'est précisément à partir de là
   que les choses sérieuses commencent (j'entends par là la non-linéarité).
   
   Le hic, c'est que l'algorithme de thermique (contrairement à stat_non_line), ne découpe
   pas automatiquement le pas de temps. Je vais émettre une demande d'évolution en ce sens.
   
   Il faut donc traiter le passage de la non-linéarité par les outils classiques : raffiner
   la liste d'insta nts à ce moment là, employer les outils de gestion de la convergence
   (matrice tangente, recherche linéaire ...).
   
   beta=DEFI_FONCTION (NOM_PARA  = 'TEMP',
                             VALE      = (20.,   0.,
                                    100.,    300.212E-03,
                                    200.,    703.902E-03,
                                    300.,    1127.3295E-03,
                                    400.,    1562.132E-03,
                                    500.,    2004.232E-03,
                                    600.,    2451.282E-03,
                                    700.,    2905.107E-03,
                                    800.,    3373.557E-03,
                                    900.,    3860.257E-03,
                                    1000.,   4357.392E-03,
                                    1200., 5361.377E-03,
                                    1450., 6603.346E-03,
                                    1500., 8658.636E-03,
                                    1600., 9131.044E-03,
                                    1700., 9598.790E-03,
                                    1800., 1.0062E+01,),
                  PROL_DROITE =	'LINEAIRE',					
                  PROL_GAUCHE = 'LINEAIRE', ) ;
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   n?t
NB_JOURS_TRAV  : 0.3
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR audebert     AUDEBERT Sylvie        DATE 24/08/2009 - 16:17:31

--------------------------------------------------------------------------------
RESTITUTION FICHE 006848 DU 2003-03-19 00:00:00
TYPE evolution concernant Code_Aster (VERSION 7.0)
TITRE
   validation du mot cle MULT_APPUI
FONCTIONNALITE
   Voici la référence des quelques cas-tests qui ont permis la validation du multi-appui 
   avec COMB_SISM_MODAL.
   v201030 : cas-test sdld30
   v2010301 : cat-test sdld301
   v202023 : cas-test sdll23
   v202112 : cas-test sdll112
   v205300 : cas-test sdlx300
   V201033 : cas-test sdld333
   Cette fiche est considérée résolue.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V2.02.112
VALIDATION
   sdll112
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR galenne      GALENNE Erwan          DATE 24/08/2009 - 16:17:31

--------------------------------------------------------------------------------
RESTITUTION FICHE 013735 DU 2009-08-20 14:11:14
TYPE express concernant Code_Aster (VERSION 10.1)
TITRE
   Ajout de NUME_FOND dans la table produite par CALC_G
FONCTIONNALITE
   On ajoute une colonne, intitulée NUME_FOND, dans le tableau résultat produit par
   l'opérateur CALC_G dans le cas d'une fissure non maillée. Cette colonne indique le numéro
   du fond de fissure considéré.
   Cela concerne les options CALC_G et CALC_K_G.
   
   Cette petite évolution facilite l'utilisation de l'opérateur PROPA_FISS (propagation
   automatique de fissure).
   
   Routines impactées : op0100, cgcrtb, mecalg, mecagl, meficg, cakg3d.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.82.03
VALIDATION
   cas test CALC_G
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR brie         BRIE Nicolas           DATE 24/08/2009 - 16:17:32

--------------------------------------------------------------------------------
RESTITUTION FICHE 013692 DU 2009-08-07 13:01:32
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
   En NEW10.0.12, le cas-test sdll136a s'arrete en erreur_<F> sur Rocks.
FONCTIONNALITE
   J ai fait tourner ce cas-test sur Rocks en NEW10 (10.0.13) et tout a bien marché (ENDED
   ALARM) comme sur les autres machines. Il semble donc que le probleme se soit autorepare au
   passage de la version 10.0.12 vers 10.0.13.
   Apres analyse du message d erreur avec Emmanuel, l arret a lieu dans la methode d
   integration ITMI de DYNA_TRAN_MODAL. Le bug ne doit donc pas etre lie a la fiche 13576 qui
   concernait POST_DYNA_MODA_T.
   Je propose donc de fermer la fiche.
   
   Ce cas-test d interaction fluide structure semble par ailleurs assez instable, du moins
   sensible a la machine d execution : une recherche dans le REX montre que c'est la 3eme
   fois qu il plante avec le meme message, a chaque fois sur une seule machine (Calibre 4 ou
   Rocks selon le cas). Par exemple, la derniere fois que j ai fait une restitution dans DTM
   (fiche 13377), cela l avait casse sur Calibre 4, Ionel l avait corrige en diminuant tres
   legerement le pas de temps (fiche 13415).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   neant
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR delmas       DELMAS Josselin        DATE 27/08/2009 - 09:09:47

--------------------------------------------------------------------------------
RESTITUTION FICHE 013157 DU 2009-02-23 11:08:38
TYPE anomalie concernant Code_Aster (VERSION 9.4)
TMA : DeltaCad
TITRE
   IMPR_RESU / FORMAT='CASTEM' pour les champs VARI_R
FONCTIONNALITE
   Problème :
   ========
   Lorsque l'on précise une composante dans IMPR_RESU / FORMAT='CASTEM', aucune impression
   n'est realisée et le code renvoie le message :
    <A> <IMPR_RESU> <IRCECA> ON NE TROUVE PAS LA COMPOSANTE >V1      <  DANS LA             
                                              
        GRANDEUR  >VARI_R  <                                                                
                                          
   Analyse :
   =======
   Le code plantait précisément avec une grandeur de type VARI_R car on vérifie la cohérence
   de la composante fournie par l'utilisateur (V1 par exemple) avec les composantes
   existantes dans le catalogue. Or, dans le catalogue, la seule composante de VARI_R est VARI.
   La commande fonctionnait lorsqu'on ne précisait aucune composante car on ne fait pas de
   vérification dans le code.
   
   Correction:
   ==========
   On modifie les routines irceca.f, irdeca.f telles qu'on vérifie la cohérence de la
   composante donnée par l'utilisateur (V + [0 à N]) et que l'on dit que VN correspond à la N
   composante du catalogue pour la grandeur VARI_R.
   
   Vérification  :
   ============
   On vérifie que cela marche (impression dans perf004 de VARI_ELNO_ELGA restreinte à V1).
   Le comportement est homogène aux autre formats.
   
   Passage de l'étude fournie et vérification du contenu du fichier cast.
   Passage d'une liste restreinte a IMPR_RESU/format CASTEM (82 cas-tests)
   
   Impacts :
   =======
   irceca.f
   irdeca.f
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   IMPR_RESU / format CASTEM
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR sellenet     SELLENET Nicolas       DATE 24/08/2009 - 15:47:37

--------------------------------------------------------------------------------
RESTITUTION FICHE 008534 DU 2005-03-31 00:00:00
TYPE evolution concernant Code_Aster (VERSION 8.0)
TITRE
   TEST_FONCTION
FONCTIONNALITE
   Demande :
   ---------
   "En dynamique notamment, il se trouve que les solutions analytiques ne sont pas facilement
   atteignables par un algorithme d'integration temporelle avec une grande precision, et de
   plus les resultats sont sensibles a de legeres variations (algo, plate-forme...).
   C'est pourquoi, je propose un developpement qui consisterait a tester une valeur moyenne
   de la fonction sur un intervalle donne du parametre."
   
   
   Evolution :
   -----------
   Portage de TEST_FONCTION en macro python pour permettre l'utilisation de CALC_FONCTION et
   ajout de la fonctionnalité INTERVALLE.
   
   Correction d'une petite imprécision dans focrr2.f (routine qui extrait une fonction d'une
   SD résultat). Cette routine écrivait une mauvaise valeur dans le '.PROL'[1] de la fonction
   retournée. Le  '.PROL'[1] précise quel type d'interpolation est autorisée pour la
   fonction. La valeur était écrite 'NON     ' au lieu de 'NON NON '.
   
   Fichiers modifiés :
   co_fonction.py
   focrr2.f
   N_ASSD.py
   test_fonction.capy
   t_fonction.py
   
   Ajout du fichier test_fonction_ops.py
   Suppression de OP0135.
   
   Validation :
   Tous les cas tests utilisant TEST_FONCTION.
   Ajout d'un TEST_FONCTION sur un intervalle dans zzzz100a.
   
   
   Utilisation :
   -------------
   On remplace VALE_PARA par INTERVALLE.
   INTERVALLE      =SIMP(statut='f',typ='R'  ,validators=NoRepeat(),min=2,max=2)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.92.02
VALIDATION
   cas tests TEST_FONCTION
NB_JOURS_TRAV  : 20.0
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST AJOUT sslp315c                      geniaut S.GENIAUT          322    322      0
 CASTEST AJOUT sslp315d                      geniaut S.GENIAUT          299    299      0
 CASTEST AJOUT sslp315e                      geniaut S.GENIAUT          322    322      0
 CASTEST AJOUT sslp318a                      geniaut S.GENIAUT          268    268      0
 CASTEST AJOUT sslp318b                      geniaut S.GENIAUT          268    268      0
 CASTEST AJOUT sslp319a                      geniaut S.GENIAUT          282    282      0
 CASTEST AJOUT sslp319b                      geniaut S.GENIAUT          280    280      0
 CASTEST AJOUT sslp320a                      geniaut S.GENIAUT          278    278      0
 CASTEST AJOUT sslp320b                      geniaut S.GENIAUT          243    243      0
 CASTEST AJOUT sslp320c                      geniaut S.GENIAUT          266    266      0
 CASTEST AJOUT sslp321a                      geniaut S.GENIAUT          225    225      0
 CASTEST AJOUT sslp321b                      geniaut S.GENIAUT          223    223      0
 CASTEST AJOUT sslp321c                      geniaut S.GENIAUT          223    223      0
 CASTEST AJOUT sslp322a                      geniaut S.GENIAUT          241    241      0
 CASTEST AJOUT sslv314d                      geniaut S.GENIAUT          230    230      0
 CASTEST AJOUT sslv315d                      geniaut S.GENIAUT          218    218      0
 CASTEST AJOUT sslv316a                      geniaut S.GENIAUT          315    315      0
 CASTEST AJOUT sslv316b                      geniaut S.GENIAUT          342    342      0
 CASTEST AJOUT sslv316c                      geniaut S.GENIAUT          315    315      0
 CASTEST AJOUT sslv316d                      geniaut S.GENIAUT          342    342      0
 CASTEST AJOUT ssnv185q                      geniaut S.GENIAUT          263    263      0
 CASTEST AJOUT zzzz255a                      geniaut S.GENIAUT          110    110      0
 CASTEST AJOUT zzzz255b                      geniaut S.GENIAUT          110    110      0
 CASTEST MODIF sslp317a                      geniaut S.GENIAUT          248     24      5
 CASTEST MODIF sslv314a                      geniaut S.GENIAUT          219     28     11
 CASTEST MODIF sslv315a                      geniaut S.GENIAUT          206     15     11
 CASTEST MODIF ssna118a                      geniaut S.GENIAUT          304      4      2
 CASTEST MODIF ssnp503h                      geniaut S.GENIAUT          279      7     16
 CASTEST MODIF ssnv112b                      geniaut S.GENIAUT          236      5      4
 CASTEST MODIF ssnv173a                      geniaut S.GENIAUT          284     13     46
 CASTEST MODIF ssnv173b                      geniaut S.GENIAUT          620      6     33
 CASTEST MODIF ssnv173c                      geniaut S.GENIAUT          162      4     11
 CASTEST MODIF ssnv173d                      geniaut S.GENIAUT          239      4     11
 CASTEST MODIF ssnv173e                      geniaut S.GENIAUT          643      3      9
 CASTEST MODIF ssnv173f                      geniaut S.GENIAUT          285      4      5
 CASTEST MODIF ssnv173g                      geniaut S.GENIAUT          213      4      5
 CASTEST MODIF ssnv173h                      geniaut S.GENIAUT          272      4      5
 CASTEST MODIF ssnv173i                      geniaut S.GENIAUT          229      3      8
 CASTEST MODIF ssnv173j                      geniaut S.GENIAUT          284      5      7
 CASTEST MODIF ssnv182a                      geniaut S.GENIAUT          263      6     12
 CASTEST MODIF ssnv182b                      geniaut S.GENIAUT          282      5     12
 CASTEST MODIF ssnv182c                      geniaut S.GENIAUT          228      5     11
 CASTEST MODIF ssnv182d                      geniaut S.GENIAUT          230      4      5
 CASTEST MODIF ssnv182e                      geniaut S.GENIAUT          214      4      7
 CASTEST MODIF ssnv182f                      geniaut S.GENIAUT          220      5      9
 CASTEST MODIF ssnv185j                      geniaut S.GENIAUT          261     12      7
 CASTEST MODIF ssnv186a                      geniaut S.GENIAUT          196      6     11
 CASTEST MODIF ssnv186b                      geniaut S.GENIAUT          226      5     11
 CASTEST MODIF ssnv186c                      geniaut S.GENIAUT          197      5     11
 CASTEST MODIF ssnv186d                      geniaut S.GENIAUT          194      5     11
 CASTEST MODIF ssnv186e                      geniaut S.GENIAUT          186      4     13
 CASTEST MODIF ssnv186f                      geniaut S.GENIAUT          200      4      8
 CASTEST MODIF ssnv186g                      geniaut S.GENIAUT          208      4      8
 CASTEST MODIF ssnv186h                      geniaut S.GENIAUT          211      4      9
 CASTEST MODIF ssnv191a                      geniaut S.GENIAUT          780      4      8
 CASTEST MODIF ssnv191b                      geniaut S.GENIAUT         1154      3      6
 CASTEST MODIF ssnv191c                      geniaut S.GENIAUT         1124      3      5
 CASTEST MODIF ssnv195a                      geniaut S.GENIAUT          380      7     21
 CASTEST MODIF ssnv195b                      geniaut S.GENIAUT          320      7     24
 CASTEST MODIF ssnv195c                      geniaut S.GENIAUT          465      7     23
 CASTEST MODIF ssnv195d                      geniaut S.GENIAUT          340      5      5
 CASTEST MODIF ssnv201a                      geniaut S.GENIAUT          389      4     12
 CASTEST MODIF ssnv203a                      geniaut S.GENIAUT          367      3      5
 CASTEST MODIF ssnv203b                      geniaut S.GENIAUT          319      5      9
 CASTEST MODIF ssnv209b                      geniaut S.GENIAUT          586      3      3
 CASTEST MODIF ssnv209c                      geniaut S.GENIAUT          490      3      3
 CASTEST MODIF ssnv209d                      geniaut S.GENIAUT          504      3      3
 CASTEST MODIF ssnv209e                      geniaut S.GENIAUT          505      3      3
 CASTEST MODIF ssnv209g                      geniaut S.GENIAUT          488      4      9
 CASTEST MODIF ssnv209h                      geniaut S.GENIAUT          446      4      9
 CASTEST MODIF zzzz100a                     sellenet N.SELLENET        1990      5      1
CATALOPY MODIF commande/defi_fiss_xfem       geniaut S.GENIAUT          151     77     14
CATALOPY MODIF commande/propa_fiss           geniaut S.GENIAUT          125     47     13
CATALOPY MODIF commande/propa_xfem           geniaut S.GENIAUT           67     31      7
CATALOPY MODIF commande/test_fonction       sellenet N.SELLENET          95      8      3
 FORTRAN AJOUT algorith/xprcnu               geniaut S.GENIAUT          571    571      0
 FORTRAN AJOUT algorith/xprcyc               geniaut S.GENIAUT          981    981      0
 FORTRAN AJOUT algorith/xprdis               geniaut S.GENIAUT          227    227      0
 FORTRAN AJOUT algorith/xprpls               geniaut S.GENIAUT          447    447      0
 FORTRAN AJOUT algorith/xprupw               geniaut S.GENIAUT          507    507      0
 FORTRAN MODIF algorith/cakg3d               geniaut S.GENIAUT          431     11      8
 FORTRAN MODIF algorith/op0010               geniaut S.GENIAUT          641    385     65
 FORTRAN MODIF algorith/op0041               geniaut S.GENIAUT          340     37      9
 FORTRAN MODIF algorith/xenrch               geniaut S.GENIAUT          429     33     12
 FORTRAN MODIF algorith/xinils               geniaut S.GENIAUT          591     59     16
 FORTRAN MODIF algorith/xls2d                geniaut S.GENIAUT          272     13      3
 FORTRAN MODIF algorith/xls3d                geniaut S.GENIAUT          336     13      3
 FORTRAN MODIF algorith/xpraju               geniaut S.GENIAUT          134     45     23
 FORTRAN MODIF algorith/xprcfl               geniaut S.GENIAUT           96     12     31
 FORTRAN MODIF algorith/xprini               geniaut S.GENIAUT          257     32     15
 FORTRAN MODIF algorith/xprls0               geniaut S.GENIAUT          658     42     61
 FORTRAN MODIF algorith/xprls                geniaut S.GENIAUT          427    202     61
 FORTRAN MODIF algorith/xprrei               geniaut S.GENIAUT          576      4      4
 FORTRAN MODIF algorith/xprvit               geniaut S.GENIAUT          748    577     80
 FORTRAN MODIF algorith/xptfon               geniaut S.GENIAUT          391      7     12
 FORTRAN MODIF algorith/xstan2               geniaut S.GENIAUT          257      2      2
 FORTRAN MODIF algorith/xstano               geniaut S.GENIAUT          225     60     57
 FORTRAN MODIF calculel/cgcrtb               geniaut S.GENIAUT          354     63     34
 FORTRAN MODIF calculel/mecagl               geniaut S.GENIAUT          478     17      6
 FORTRAN MODIF calculel/mecalg               geniaut S.GENIAUT          507     11      8
 FORTRAN MODIF calculel/meficg               geniaut S.GENIAUT          430     11     10
 FORTRAN MODIF calculel/op0100               geniaut S.GENIAUT         1060      8     16
 FORTRAN MODIF elements/ermeb3                delmas J.DELMAS           287     16     14
 FORTRAN MODIF elements/ermes3                delmas J.DELMAS           179      4      5
 FORTRAN MODIF elements/intega                delmas J.DELMAS            80      8      5
 FORTRAN MODIF elements/te0118               geniaut S.GENIAUT          486     11     24
 FORTRAN MODIF elements/te0366                delmas J.DELMAS           337      7      6
 FORTRAN MODIF elements/te0368                delmas J.DELMAS           605     26     21
 FORTRAN MODIF elements/te0375                delmas J.DELMAS           509     15     10
 FORTRAN MODIF elements/te0555                delmas J.DELMAS           161      2      2
 FORTRAN MODIF prepost/irceca                rezette C.REZETTE          491     15      1
 FORTRAN MODIF prepost/irdeca                rezette C.REZETTE          277     12      1
 FORTRAN MODIF utilitai/calnor                delmas J.DELMAS           343      5      5
 FORTRAN MODIF utilitai/dismxf               geniaut S.GENIAUT           79      6      8
 FORTRAN SUPPR prepost/op0135               sellenet N.SELLENET         546      0    546
  PYTHON AJOUT Macro/test_fonction_ops      sellenet N.SELLENET         729    729      0
  PYTHON MODIF Macro/propa_fiss_ops          geniaut S.GENIAUT          833    210     30
  PYTHON MODIF Macro/raff_xfem_ops           geniaut S.GENIAUT          197      2      2
  PYTHON MODIF Messages/elements3             delmas J.DELMAS           283      1      5
  PYTHON MODIF Messages/indicateur            delmas J.DELMAS           140      6      1
  PYTHON MODIF Messages/xfem2                geniaut S.GENIAUT          474    330      6
  PYTHON MODIF Messages/xfem                 geniaut S.GENIAUT          239     30     13
  PYTHON MODIF Noyau/N_ASSD                 sellenet N.SELLENET         140      1      1
  PYTHON MODIF SD/co_fonction               sellenet N.SELLENET         343     11      1
  PYTHON MODIF SD/sd_xfem                    geniaut S.GENIAUT          143      4      3
  PYTHON MODIF Utilitai/t_fonction          sellenet N.SELLENET         733     24      9


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :   29        9447      9447             +9447
 MODIF :   96       36121      2837    1229     +1608
 SUPPR :    1         546               546      -546
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :  126       46114     12284    1775    +10509 
