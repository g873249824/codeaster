

-----------------------------------------------------------------------
--- AUTEUR assire A.ASSIRE   DATE  le 29/11/2004 a 13:15:48

------------------------------------------------------------------------------
RESTITUTION HORS AREX
   INTERET_UTILISATEUR : OUI
   FONCTIONNALITE  Developpements/corrections autour du partitionnement en 3D
   RESU_FAUX_VERSION_EXPLOITATION   :    NON
   RESU_FAUX_VERSION_DEVELOPPEMENT  :    NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
   Passage de tous le feti00* + un cas 3D perso
   DETAILS
   Quelques amenagements autour du partitionnement :
   - fetcrf.f (commande DEFI_PART_OPS) :
      . correction d'un bug en 3D : le nombre de DDL total etait mal calculé
        (la sdfeti etait contruite, le calcul FETI fonctionnait mais les
        resultats etaient faux).
      . reste encore un bug pour les mailles 3D quadratiques (--> NEW8)
   - partition.py :
      . correction d'un bug en 3D : les mailles de bords de type SEG etaient
        mal reinjectée dans les SD.
   - defi_part_ops.py (macro-commande DEFI_PART_FETI) :
      . correction d'un bug lorsque Metis produit moins de SD que demandé par
        l'utilisateur : avant ca plantait, maintenant on continue avec moins
        de SD.
      . le nom des clés des collections de la sdfeti est maintenant le nom des
        SD donné par l'utilisateur (NOM_GROUP_MA).

   NB_JOURS_TRAV  : 3.

------------------------------------------------------------------------------
CLASSEMENT SANS SUITE AL 2004-318
   INTERET_UTILISATEUR : NON
   TITRE  xmgrace et demo001a sur Linux / Calibre
   FONCTIONNALITE
   JPL constatait des problemes sur ce test sur la machine clp50a8.
   IMPACT_DOCUMENTAIRE : NON
   DETAILS
   Il n'y a pas de probleme. Plus vraisemblablement, ceux-ci ont disparus avec
   les corrections de l'AL2004-294.

   NB_JOURS_TRAV  : 0.5

------------------------------------------------------------------------------



-----------------------------------------------------------------------
--- AUTEUR boyere E.BOYERE   DATE  le 29/11/2004 a 18:20:55

CORRECTION AL 2004-435
INTERET_UTILISATEUR : OUI
TITRE
Erreur dans la programmation de REST_BASE_PHYS
restreint à un NOEU ou un GROUP_NOEU
   FONCTIONNALITE
En debugjeveux le cas test SDNL112b plante dans REST_BASE_PHYS,
mettant en evidence une erreur dans la programmation de REST_BASE_PHYS.
La correction entraine une modification de la programmation de CALC_ELEM.

!!!L'erreur pouvait entrainer des resultats faux dans le cas
de restitution sur une partie des noeuds du maillage
(mots clefs NOEU ou GROUP_NO de REST_BASE_PHYS).

   RESU_FAUX_VERSION_EXPLOITATION   :   OUI   DEPUIS : 1.0.0
   RESU_FAUX_VERSION_DEVELOPPEMENT  :   OUI   DEPUIS : 1.0.0
   RESTITUTION_VERSION_EXPLOITATION  :   OUI
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
cas tests SDNL112b et SDNL32a + astout sur les tests de dynamique
en poutre avec CALC_ELEM
   DETAILS
Dans tran75 (REST_BASE_PHYS) on taille maintenant correctement
le profil de stockage du champ resultat pour qu'il corresponde
au nombre de noeuds demandes dans NOEU ou GROUP_NO.

Dans mecalm (CALC_ELEM), pour les poutres en dynamique,
on recupere directement le profil de stockage du resultat,
sans passer par le profil de la matrice de masse.
Ces deux stockages ne se correspondent evidemment pas lorsqu'on
a restreint le resultat a un sous-ensemble de noeuds.
   NB_JOURS_TRAV  : 3.5
------------------------------------------------------------------------------
RESTITUTION HORS AREX (SUITE de l'AL 2004-257)
   INTERET_UTILISATEUR : NON
   FONCTIONNALITE
test SDLL503b NOOK
Le probleme dans SDLL503b est le meme que dans SDLL503b :
on teste des valeurs dependant de l'angle des modes multiples.
Or cet angle peut varier selon bien des parametres du calcul
modal, bien que la base modale choisise reste tout aussi exacte.
La solution n'est pas unique.
On supprime les tests qui ne sont pas pertinents.
Les tests interessants sont ceux qui ne dependent pas de l'angle.
Ils restent valides.
   RESU_FAUX_VERSION_EXPLOITATION   :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT  :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
   DETAILS
   NB_JOURS_TRAV  : 0.5
------------------------------------------------------------------------------


-----------------------------------------------------------------------
--- AUTEUR d6bhhhh M.ASA   DATE  le 30/11/2004 a 19:21:09

------------------------------------------------------------------------------
RESTITUTION HORS AREX
   INTERET_UTILISATEUR : OUI
   FONCTIONNALITE
   Retassage des bases
   RESU_FAUX_VERSION_EXPLOITATION   :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT  :   NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   DETAILS
   Lors de restitution 7.2.13 l'appel à la fonction cpfile a été modifié pour
   ajouter un argument : M pour déplacer les fichiers (mv), C pour copier les
   fichiers (cp). Le source Fortan a bien été modifié mais la fonction C n'a
   pas été restituée. Le retassage des bases n'est donc plus actif depuis cette
   modification.
   Aucun test ne mettait en oeuvre cette fonction, on modifife donc le test
   zzzz127a pour activer le retassage.
   NB_JOURS_TRAV  : 0.5
   VALIDATION
   zzzz127a


-----------------------------------------------------------------------
--- AUTEUR d6bhhjp J.P.LEFEBVRE   DATE  le 30/11/2004 a 07:11:35

CORRECTION AL 2004-437
   NB_JOURS_TRAV  : 2
   INTERET_UTILISATEUR : NON
   TITRE : Lecture base HDF
   FONCTIONNALITE :
   Il n'était pas possible de relire une base au format HDF après la
   commande CALC_MATR_ELEM OPTION RIGI_GEOM
   DETAILS :
   Corrigé dans la routine jjlchd.f : les structures de données créées dans
   l'étude d'Olivier contenaient une collection de longueurs variables dont
   les 20 premiers objets n'étaient pas associés à un segment de valeurs.
   Ce cas est licite, il n'avait pas été prévu d'où l'arrêt brutal et les messages
   d'alarme de la part de Hdf.
   RESU_FAUX_VERSION_EXPLOITATION    : NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   : NON
   RESTITUTION_VERSION_EXPLOITATION  : NON
   RESTITUTION_VERSION_DEVELOPPEMENT : OUI
   IMPACT_DOCUMENTAIRE:  NON
   VALIDATION :
   Sur l'étude fournie par Olivier
--------------------------------------------------------------------------------
CORRECTION AO 2004-430
   NB_JOURS_TRAV  : 1
   INTERET_UTILISATEUR : NON
   TITRE : bases hdf
   FONCTIONNALITE :
   AGLA
   DETAILS :
   Corrigé dans la version 5.18 de l'AGLA. Le script/aster/agla/v4/tool/rcp_bases
   traitait mal la liste des fichiers glob.n et bhdf.n lorsqu'elle était en
   remote.
   RESU_FAUX_VERSION_EXPLOITATION    : NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   : NON
   RESTITUTION_VERSION_EXPLOITATION  : NON
   RESTITUTION_VERSION_DEVELOPPEMENT : OUI
   IMPACT_DOCUMENTAIRE:  NON
   VALIDATION :
--------------------------------------------------------------------------------
CORRECTION AO 2004-439
   NB_JOURS_TRAV  : 1
   INTERET_UTILISATEUR : NON
   TITRE : taille des lignes des sources python
   FONCTIONNALITE :
   AGLA + procédures de mise à jour
   DETAILS :
   Corrigé dans la version 5.18 de l'AGLA. Le traitement des sources python
   dans les procédures de restitution et de mise à jour était incorrect. Les
   sources python sont concaténés puis redécoupés en fonction des informations
   présentes dans la carte MODIF. C'est l'exécutable casplit qui utilisait mal
   la fonction fgetc pour relire le fichier source. Il faut préciser une valeur
   cohérente avec la longueur maximum des lignes autorisées (256 caractères)
   mais en tenant compte de l'ajout des caratères \n et \0.

   Le source C de /aster/adm/agla/casplit/casplit.c est modifié et l'exécutable
   reconstruit
   RESU_FAUX_VERSION_EXPLOITATION    : NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   : NON
   RESTITUTION_VERSION_EXPLOITATION  : NON
   RESTITUTION_VERSION_DEVELOPPEMENT : OUI
   IMPACT_DOCUMENTAIRE:  NON
   VALIDATION :
   Sur les sources ayant révélé le problème lors de la mise à jour 7.3.30
------------------------------------------------------------------------------
RESTITUTION HORS AREX
   INTERET_UTILISATEUR : OUI
   FONCTIONNALITE
   parametre -max_base sur plate-forme 32 bits et AlphaServer
   RESU_FAUX_VERSION_EXPLOITATION   :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT  :   NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   DETAILS
   Lors de restitution 7.3.6 un facteur 1024 sur la taille passée en argument
   du paramètre -max_base a été laissé dans la routine JEDEBU. Du coup il
   était impossible de limiter la taille totale des bases sur plate-forme 32 bits
   à moins du maximum (12 582 912 Ko). Et lorsque qu'on essayait de passer un
   argument derrière -max_base on pouvait obtenir un arret brutal dans JJALLS.

   Sur AlphaServer, cette erreur conduisait à surdimensionner un des objets
   système JEVEUX et l'on perdait ainsi de place mémoire et de la place disque.
   NB_JOURS_TRAV  : 0.5
   VALIDATION



-----------------------------------------------------------------------
--- AUTEUR durand C.DURAND   DATE  le 30/11/2004 a 09:25:54

------------------------------------------------------------------------------
CORRECTION AL 2004-428
   NB_JOURS_TRAV  : 0.5
   FONCTIONNALITE : utcomm.f
   INTERET_UTILISATEUR : NON
   TITRE : purge de la base volatile quand levée d'exception
   DETAILS :
   Plantage du test zzzz107a en mode debugjeveux : lors du deuxieme
   STAT_NON_LINE (dans le except) : RCVALA / comportement non trouvé.
   Un print du nom de comportement dans le rcvala montre qu'on pointe sur
   une adresse invalide. En effet, le matériau codé est créé sur la base
   volatile par RCMACO. Or, s'il existe déjà (jeexin) : on récupère
   l'adresse sans le recréer. Le problème venait du fait de l'execution
   "try" précédente : quand on sort en exception, on ne purgeait pas
   totalement la base volatile (comme elle l'est désormais entre chaque
   commande par un jedetv) : seuls les objets &&* et _* l'étaient.

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION : zzzz107a en mode debug
--------------------------------------------------------------------------
CORRECTION AL 2004-436
   NB_JOURS_TRAV  : 0.5
   INTERET_UTILISATEUR : NON
   TITRE
     calc_elem en reuse
   FONCTIONNALITE CALC_ELEM
   DETAILS
   Le problème vient de l'op0058 : pour déterminer si le calcul est "reuse"
   ou pas (donc si on doit créer la SD par rscrsd), on compare le nom du
   concept (GETRES) et celui de la SD RESULTAT fournie.

   Dans le cas présent, pb :
   tutu=CREA_RESU()
   toto=CALC_ELEM(RESULTAT=tutu)
   toto=CALC_ELEM(reuse=toto,RESULTAT=tutu)

   Dans le dernier cas, bien qu'on soit en reuse, le fait que toto ne soit
   pas l'evol_elas de référence le perturbe : requete de création d'un
   objet déjà existant sous rscrsd.

   Correction par CALL JEEXIN sur le toto.DESC

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
     modification de shlv100j : ajout d'un deuxieme calc_elem
------------------------------------------------------------------------------


-----------------------------------------------------------------------

--- AUTEUR f6bhhbo P.DEBONNIERES   DATE  le 29/11/2004 a 13:26:52

CORRECTION AL 2004-062

   INTERET_UTILISATEUR : OUI

   TITRE Installation d'un verrou (cas du chargement thermique)


   FONCTIONNALITE  MECA_STATIQUE  -  Mot-cle SENSIBILITE

   On introduit une alarme dans le cas ou l'on derive par
   rapport a un parametre materiau et ou la structure est
   soumise a un chargement thermique (thermoelasticite).
   Le programme ne plante pas mais le calcul de derivee
   n'est pas effectue dans ce cas.

   VALIDATION

   RESU_FAUX_VERSION_EXPLOITATION : NON
   RESU_FAUX_VERSION_DEVELOPPEMENT : NON
   RESTITUTION_VERSION_EXPLOITATION  : NON
   RESTITUTION_VERSION_DEVELOPPEMENT : OUI
   IMPACT_DOCUMENTAIRE : OUI
   DOC_U : U4.50.02
   EXPL_ : Preciser que la sensibilite ne fonctionne pas
           en meca avec un chargement thermique
   NB_JOURS_TRAV : 1.
   DETAILS
   Modification de la routine mereso.
--------------------------------------------------------------------------
RESTITUTION HORS AREX
   INTERET_UTILISATEUR : OUI
   TITRE Installation d'un verrou (cas du chargement thermique)

   FONCTIONNALITE  STAT_NON_LINE  -  Mot-cle SENSIBILITE

   On introduit une alarme comme pour MECA_STATIQUE dans le
   cas non-lineaire.

   VALIDATION

   RESU_FAUX_VERSION_EXPLOITATION : NON
   RESU_FAUX_VERSION_DEVELOPPEMENT : NON
   RESTITUTION_VERSION_EXPLOITATION  : NON
   RESTITUTION_VERSION_DEVELOPPEMENT : OUI
   IMPACT_DOCUMENTAIRE : OUI
   DOC_U : U4.50.02
   EXPL_ : Preciser que la sensibilite ne fonctionne pas
           en meca avec un chargement thermique
   NB_JOURS_TRAV : 0.5
   DETAILS

   Modification de la routine nmsens.


-----------------------------------------------------------------------
--- AUTEUR galenne E.GALENNE   DATE  le 29/11/2004 a 10:52:08

CORRECTION AL 2004-444
   INTERET_UTILISATEUR : NON
   TITRE : CALC_G* sous Linux
   FONCTIONNALITE
   Suite à la restitution hors Arex de la semaine précédente (prise en compte des fonctions
   multiplicatrices), une partie des cas test de Calc_g* a été cassée sous LINUX.
   L'erreur provenait d'une mauvaise initialisation dans l'opérateur mecalg : on détruisait
   systématiquement une grandeur qui n'était initialisée que sous certaines conditions.

   RESU_FAUX_VERSION_EXPLOITATION   :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT  :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
   Passage sous Linux des cas test suivant :
   sslv110a, hplp101b, sslv312b, hplp100b, sslp102b, sslv311a, hpla310a, sdlv123a,
   ssnp103a, ssnp110b, ssnp311a, ssnp312b
   NB_JOURS_TRAV  : 0.5


-----------------------------------------------------------------------
--- AUTEUR kbbhhdb G.DEBRUYNE   DATE  le 29/11/2004 a 14:21:26


--------------------------------------------------------------------------
CORRECTION AL 2004-438
   NB_JOURS_TRAV  : 2.
   INTERET_UTILISATEUR : NON
   TITRE  Loi de Barcelone
   FONCTIONNALITE
     Deux anomalies traitées : 1) on rend les contraintes de Coussy telles que
     utilisées dans THM au lieu des  contraintes de Bishop (terme different
     Somme (Sdpc) au lieu de Spc)

     2)un terme était manquant dans la réactualisation des contraintes après
     franchissement du seuil mécanique
   DETAILS
    - nmbarc.f  pour prendre les deux corrections.
    - hmliga.f pour lire le terme en pression capillaire de la contrainte
    - hmllvag.f pour lire le terme en pression capillaire de la contrainte
    - calcme.f pour lire le terme en pression capillaire de la contrainte
   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 7.3.30
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
      wtnv123a, wtnv123b, wtnv123c, wtnv124a, wtnv126a, wtnv126b
--------------------------------------------------------------------------
CORRECTION AL 2004-441
   Restitution pour le compte de S.PONNELLE
   INTERET_UTILISATEUR : NON
   TITRE  STAT_NON_LINE et ssnp126a
   FONCTIONNALITE
   J'avais demandé à Norberto d'internaliser le calcul des déformations dans la
   routine de comportement lcjoba au lieu de faire le calcul dans nmfi2d, propre à
   l'élément de joint. Le problème c'est qu'il utilisait toujours l'incrément de
   déformation DEPS alors que celui-ci n'était plus défini (on passait RBID).
   RESU_FAUX_VERSION_EXPLOITATION   :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT  :   OUI   DEPUIS : 7.3.30
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
   passage test sur Compaq et Linux + ssna112a
   DETAILS
   Je supprime le paramètre DEPS de l'appel à la loi de comportement lcjoba et je fais
   un peu de ménage sur les tenseurs de déformations utilisés : un seul vecteur de
   dimension 2 (au lieu de 4) tel que : EPS(1)=EPS_N et EPS_(2)=EPS_T
   NB_JOURS_TRAV  : 0.5
-------------------------------------------------------------------------
   CORRECTION AL 2004-442
   Restitution pour le compte de S.PONNELLE
   INTERET_UTILISATEUR : NON
   TITRE  STAT_NON_LINE et ssna112a
   FONCTIONNALITE
   cf. AL2004-442
   RESU_FAUX_VERSION_EXPLOITATION   :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT  :   OUI   DEPUIS : 7.3.30
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
   passage test sur Compaq et Linux + ssna112a
   DETAILS
   NB_JOURS_TRAV  : 0.



-----------------------------------------------------------------------
--- AUTEUR lebouvie F.LEBOUVIER   DATE  le 29/11/2004 a 15:41:34

------------------------------------------------------------------------------
CORRECTION AL 2004-165
   INTERET_UTILISATEUR : NON
   TITRE
   Test impertinent dans SDLL118a
   FONCTIONNALITE
   Dans le cas test SDLL118a, on teste les valeurs
   des matrices généralisées (modifiées pour tenir
   compte du couplage fluide/structure).
   Malheureusement, les matrices sont projetées
   sur une base modale faite de modes doubles.
   Or, comme le choix de cette base n'est pas unique,
   et qu'elle peut changer selon l'humeur de la machine,
   cela n'a pas de sens de tester ces valeurs.
   Ce qui compte est de retrouver à la fin du calcul
   des valeurs physiques indépendantes de la machine.
   Ce qui doit être ici le cas pour les fréquences
   et les amortissements des modes fluides/élastiques.

   RESU_FAUX_VERSION_EXPLOITATION   :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT  :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
   DETAILS
   NB_JOURS_TRAV  : 2.5
-------------------------------------------------------------------------------
CORRECTION AL 2004-395
   POUR LE COMPTE DE :  X. DESROCHES
   INTERET_UTILISATEUR : OUI
   TITRE : POST_RELEVE_T
   FONCTIONNALITE :
   DETAIL :
   Lors de son post-traitement avec POST_RELEVE_T, l'utilisateur obtient le
   message suivant:
    <S> <JJLIRS04> ECRASEMENT AVAL POSSIBLE ADRESSE >   2433832
          >TAB1               .0019        <
   - Dans cette commande, il fait dans l'ordre les 3 dépouillements suivants:
     les contraintes, les déplacements et les variables internes.
   - Si on ne prend que les 2 derniers dépouillements dans l'ordre suivant:
     déplacements, variables internes Aster se plante, si on les inverse ça
     marche.
   - Si on ne prend que les 2 derniers dépouillements dans l'ordre suivant:
     déplacements, variables internes avec non plus TOUT_CMP mais avec NOM_CMP
     avec toutes les composantes ça marche.

   Le plantage se situe dans la routine TBAJLI à la ligne 133, au moment ou l'on
   essaie d'écrire une valeur réelle, en dehors des dimensions de l'objet, contenant
   les valeurs du paramètre associé. Le problème se situe au moment ou l'on
   vérifie s'il faut rallonger ces objets, on test si la longueur est bonne sur
   le premier objet, on suppose que les autres objets sont tous de même
   longueur, ce qui n'était pas le cas pour les objets contenant les valeurs des
   paramètres associés au champ VARI_ELNO_ELGA avec TOUT_CMP.

   On a donc ajouté dans la routine TBAJPA, permettant l'ajout de paramètres a
   une table,les lignes suivantes afin que les objets associés aux paramètres
   soient correctement dimensionnés:
C
C        IL FAUT INITIALISER LES COLONNES AU LONMAX ET NON PAS A NBLIGN
C        QUI EST LE NOMBRE DE LIGNES EVENTUELLEMENT REMPLIES
C        ON RECUPERE LE PREMIER PARAMETRE DE LA TABLE
C
         J = 1
         CALL CODENT ( J ,'D0',KNUME)
         NOMJV = NOMTAB(1:17)//'LG.'//KNUME
         CALL JELIRA ( NOMJV, 'LONMAX', NBLIGN, K8B)

   Fichier modifié
     - Fortran : tbajpa

   RESU_FAUX_VERSION_EXPLOITATION    : NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   : NON
   RESTITUTION_VERSION_EXPLOITATION  : NON
   RESTITUTION_VERSION_DEVELOPPEMENT : OUI
   VALIDATION : Passage de l'étude, et de la liste restreinte
   IMPACT_DOCUMENTAIRE : NON
   NB_JOURS_TRAV : 3.5
-------------------------------------------------------------------------------



-----------------------------------------------------------------------
--- AUTEUR mabbas M.ABBAS   DATE  le 29/11/2004 a 13:52:35

-----------------------------------------------------------------------
CORRECTION AL 2004-429

   INTERET_UTILISATEUR : NON
   TITRE
    ssnv128i en mode debug jeveux

   FONCTIONNALITE
   en version 7.3.29, le test ssnv128i plante en mode debugjeveux.

   RESU_FAUX_VERSION_EXPLOITATION   :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT  :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI

   IMPACT_DOCUMENTAIRE : NON

   VALIDATION
    Tous les cas-tests de contact/frottement en lagrangien et  LDLT

   DETAILS
    Erreur JEVEUX. L'objet '.ABLO' (emplacement des blocs pour la
   matrice LDLT de frottement) etait en lecture seulement alors
   qu'on ecrivait dedans dans PROSLC, via la routine tri UTTTRI.
   La matrice tangente etait donc incorrecte et on tapait parfois
   (toujours en fait) dans une mauvaise zone memoire.

   * Contexte de declenchement de l'erreur:
       Contact/frottement 3D avec methode lagrangienne
       Solveur LDLT
       Plus d'un bloc pour stocker la matrice
       Topologie particuliere des matrices de frottement

   * Corrections de l'erreur:
       Changement du CALL JEVEUO
         CALL JEVEUO(KABLO,'L',IDABLO)
       En
         CALL JEVEUO(KABLO,'E',IDABLO)

   * Consequences de l'erreur:
       Plantage en debug JEVEUX
       Mauvaise estimation de la matrice tangente-> risque de non
      convergence.

    Apres correction, on passe de 44 a 22 iterations de Newton.

   NB_JOURS_TRAV  : 3
-----------------------------------------------------------------------
RESTITUTION HORS AREX
   INTERET_UTILISATEUR : OUI

   TITRE
    Surcharge memoire pour methode de contact continue

   FONCTIONNALITE
    Contact methode continue

   RESU_FAUX_VERSION_EXPLOITATION   :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT  :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI

   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
    Cas-tests methode continue
   DETAILS

   La routine CRSDCO cree les structures de donnees resultats pour
   le contact.
   Pour la methode continue, ces objets sont inutiles.
   Un mauvais test dans CRSDCO creait neanmoins ces objets, surchargeant
   inutilement la memoire.

   * Contexte de declenchement de l'erreur:
       Contact/frottement avec methode continue
       DEPUIS 7.3.12

   * Correction de l'erreur:
      On change --->
       IF (TYPALC.EQ.3) THEN
         GOTO 9999
       ENDIF
      En --->
       IF (ABS(TYPALC).EQ.3) THEN
          GOTO 9999
       ENDIF

   * Consequences de l'erreur:
       Trop de memoire utilisee par la creation d'objets inutiles

   NB_JOURS_TRAV  : 0.5

-----------------------------------------------------------------------
RESTITUTION HORS AREX
   INTERET_UTILISATEUR : OUI

   TITRE
    CONTACT - Defaut d'initialisation des variables

   FONCTIONNALITE
    Contact toutes methodes sans frottement

   RESU_FAUX_VERSION_EXPLOITATION   :   NON    DEPUIS :
   RESU_FAUX_VERSION_DEVELOPPEMENT  :   NON    DEPUIS :
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI

   IMPACT_DOCUMENTAIRE : NON

   VALIDATION
    Cas-tests contact
   DETAILS

   La routine CAZOCO cree les structures de donnees  pour
   le contact.
   Pour l'objet CARACF, le remplissage etait parfois incorrect du fait
   de la non initialisation des variables reelles.

   * Contexte de declenchement de l'erreur:
       Contact/frottement toutes methodes

   * Corrections de l'erreur:
       Initialisation a zero des valeurs reelles

   * Consequences de l'erreur:
       Variables reelles a NaN mais variables inutilisees
       Plantages lors de debug a la Jacot

   NB_JOURS_TRAV  : 0.5

-----------------------------------------------------------------------
RESTITUTION HORS AREX
   INTERET_UTILISATEUR : OUI

   TITRE
    CONTACT CONTINU - Limitation en dur du nombre de noeuds de contact

   FONCTIONNALITE
    Contact continu

   RESU_FAUX_VERSION_EXPLOITATION   :   OUI DEPUIS : 6.1.0
   RESU_FAUX_VERSION_DEVELOPPEMENT  :   OUI DEPUIS : 7.0.0
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI

   IMPACT_DOCUMENTAIRE : NON

   VALIDATION
    Cas-tests contact methode  continue

   DETAILS
   La routine MISAZL utilise un tableau de dimension fixe pour
   stocker les composantes des noeuds en contact.

   * Contexte de declenchement de l'erreur:
       Contact/frottement methode continue
       Plus de 333 noeuds de contact en 3D, 500 en 2D
       DEPUIS: au moins 6.1.18

   * Correction de l'erreur:
       Remplacement du tableau de taille fixe
          INTEGER NOO(1000)
       Par un objet JEVEUX
          CALL WKVECT('&&MISAZL.NNO','V V I',3*NTNO,JTAB)

   * Consequences de l'erreur:
       Ecrasement memoire avec consequences habituelles (soit plantage
           soit resultats aleatoires)

   NB_JOURS_TRAV  : 0.5


-----------------------------------------------------------------------
--- AUTEUR mcourtoi M.COURTOIS   DATE  le 30/11/2004 a 13:04:56

REALISATION EL 2004-184
   INTERET_UTILISATEUR : NON
   TITRE
      AOM : Mise en route d'Aster au CNPE du Blayais
   FONCTIONNALITE
      Cette fiche traduit un manque formation du stagiaire, et que c'est le
      début de l'utilisation d'Aster sur ce site.
      Il avait besoin d'être orienté dans la documentation Aster, doc R sur les
      comportements, signification des paramètres matériaux.
      Problèmes d'installation et accès au serveur Aster : reporté car ils
      avaient commencé avec la version windows, et devraient passer sous linux
      en 2005.
   RESU_FAUX_VERSION_EXPLOITATION  :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   NON
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
   DETAILS
   NB_JOURS_TRAV  : 3
------------------------------------------------------------------------------
CORRECTION AL 2004-445
   INTERET_UTILISATEUR : NON
   TITRE
      demo001a et zzzz140a cassés
   FONCTIONNALITE
      demo001a plante dans IMPR_FONCTION / ABSCISSES-ORDONNEES car la méthode
      get_name n'existe que pour les ASSD et pas les listes Python.
      On l'utilise pour donner une légende par défaut.
   RESU_FAUX_VERSION_EXPLOITATION   :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT  :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
   DETAILS
   NB_JOURS_TRAV  : 0.5
------------------------------------------------------------------------------
CORRECTION AL 2004-447
   INTERET_UTILISATEUR : NON
   TITRE
      Décalage des colonnes dans IMPR_TABLE
   FONCTIONNALITE
      Pour éviter le décalage, on récupère la largeur maxi de la colonne pour
      chaque paramètre qui est le maximum de :
         len(parametre),
         len(un entier écrit avec le format entier    dform['formI']),
         len(un réel écrit avec le format réel        dform['formR']),
         len(un caractère écrit avec le format chaine dform['formK']),
   RESU_FAUX_VERSION_EXPLOITATION   :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT  :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
   DETAILS
   NB_JOURS_TRAV  : 0.5
------------------------------------------------------------------------------
CORRECTION AL 2004-448
   INTERET_UTILISATEUR : NON
   TITRE
      IMPR_TABLE : problème avec le critère ABS_MAXI
                et impression au format 'XMGRACE'
   FONCTIONNALITE
      ABS_MAXI : évidemment, il faut extraire les lignes dont la valeur vaut
       abs_maxi ou -abs_maxi ! (c'était correct pour ABS_MINI).
      Les mots-clés de mise en forme n'étaient pas passés à l'objet Graph
      et il y avait un bug dans le TRI qui est un mot-clé du graphique et non
      pour chacune courbe.
   RESU_FAUX_VERSION_EXPLOITATION   :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT  :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
   DETAILS
   NB_JOURS_TRAV  : 0.5
------------------------------------------------------------------------------
RESTITUTION HORS AREX
   INTERET_UTILISATEUR : NON
   FONCTIONNALITE
      UTMESS Python : pour faire le DEFI_FICHIER (sur l'unité 8), on n'utilisait
      le jdc passé en argument :
         - Ok pour les macros mais çà fait un argument de plus,
         - pas possible dans les autres modules Graph, Table, stanley...
      On récupère maintenant la commande par un import du cata.py.
   RESU_FAUX_VERSION_EXPLOITATION   :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT  :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
   DETAILS
      Utmess.py
      impr_fonction_ops.py  impr_table_ops.py  stanley_ops.py  xmgrace.py
   NB_JOURS_TRAV  : 0.5
------------------------------------------------------------------------------


-----------------------------------------------------------------------
--- AUTEUR vabhhts J.PELLET   DATE  le 25/11/2004 a 12:59:08

------------------------------------------------------------------------------
CORRECTION AL 2004-434
   NB_JOURS_TRAV : 1
   INTERET_UTILISATEUR : OUI

   TITRE "LIAISON_MAILLE / DNOR peut provoquer des résultats faux"

   FONCTIONNALITE
   Lorsque l'utilisateur utilisait plusieurs occurrences de LIAISON_MAILLE
   et qu'un occurrence 'DNOR' était suivie d'une occurrence non-'DNOR', les
   relations de la deuxième occurrences étaient fausses et entrainaient donc
   des résultats faux.

   RESU_FAUX_VERSION_EXPLOITATION   :   OUI   DEPUIS : 6.0.0
   RESU_FAUX_VERSION_DEVELOPPEMENT  :   OUI   DEPUIS : 7.0.0
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
   DETAILS

   1) Fausseté des relations : le problème venait du fait que dans la routine
      calirc.f, on ne remettait pas à "0" le tableau ZR(IDIMEN) et que donc
      celui-ci conservait les valeurs de l'occurence 'DNOR' (2 ou 3). Ce tableau
      sert à indiquer à la routine afrela.f que la relation doit etre changée
      de repère (avec le tableau ZR(IDIREC)). En conséquence, au lieu d'écrire
      2 (ou 3) relations identiques pour DX, DY, DZ, on écrivait 3 fois la meme
      relation dans les directions du précédent DNOR ! En effet la routine AFRELA
      oubliait de vérifier que si DIRECT est utilisé, il faut que DDL='DEPL' ou 'ROTA'
      Je corrige AFRELA pour qu'elle vérifie cela.

   2) Dans sa fiche, l'utilisateur s'étonnait également de messages d'alarmes du genre :

 <A> <AFFE_CHAR_MECA> <CANORT> L'ANGLE FORME PAR LE VECTEUR NORMAL COURANT A 1
     FACE ET LE VECTEUR NORMAL MOYENNE, AU NOEUD NO637699, EST SUPERIEUR A 10
     DEGRES ET VAUT 23.      DEGRES.

     Après avoir régardé le fortran de CANORT, je me suis aperçu qu'il est assez
     difficile de ne pas avoir ce genre d'alarme lorsque les faces chargées
     étaient courbes. En effet, l'angle affiché par CANORT (qui déclanche l'alarme
     au delà de 10 degrés), est calculé en "linéarisant" les facettes : on oublie
     la courbure éventuelle de ces facettes.

     Pour un cercle maillé régulièrement en éléments quadratique, l'alarme se
     déclanchera dès que l'on utilisera moins de 18 éléments.
     Pour un maillage cylindrique avec 18 elements quadratiques dans la circonférence,
     on trouve un angle de :
        - 10 degrés si on linéairise les éléments
        - 0.1 degrés si on tient compte de leur courbure

     Ce problème n'est pas seulement un problème de message d'alarme plus ou moins
     précis. Les normales calculées par CANORT servent aussi au calcul : les relations
     linéaire écrites si DNOR sont un peu fausses. Par exemple, si on maille un cylindre
     avec des éléments de tailles différentes : soit un élement d'angle au centre alpha
     suivi d'un élément de longueur double. L'erreur faite sur la normale au noeud de
     raccord de ces 2 éléments est de alpha/2 si on ne tient pas compte de la courbure
     de ces éléments. Ce qui n'est pas négligeable.

     J'émets aujourd'hui une fiche de demande d'évolution pour voir si on ne pourrait pas
     améliorer la qualité du calcul de ces normales
   Liste des fichiers modifiés:
     afrela.f  calirc.f

------------------------------------------------------------------------------
REALISATION EL 2004-135
(partiel : examen de la fiche par JP avant transert à S. Ghavamian)
   NB_JOURS_TRAV : 2
   INTERET_UTILISATEUR : NON

   TITRE "PROJ_CHAMP imprécis avec des mailles quadratiques courbes"

   FONCTIONNALITE
   Dans la note HT-25/03/025/A
   "Projet MECEN - PACE-900 ... 1ère phase : calculs thermo-mécaniques Linéaires d'APRP ..."

   Les auteurs signalent un problème d'oscillation de la contrainte radiale liée
   semble-t-il à une projection imparfaite de la température calculée sur une autre maillage (linéaire).

   L'étude a pu néanmoins etre menée à bien en "doublant" la discrétisation circonférentielle
   du maillage thermique.

   La démonstration du problème observé est imparable :
   1) On constate que la contrainte radiale en peau interne (qui devrait valoir la pression interne = 0.38 MPa)
      fluctue fortement en azimut : variation de -2 MPa à +3 MPa
   2) cette fluctuation disparait quasiment si on retire le chargement thermique.
   3) cette fluctuation disparait quasiment si on supprime la courbure de l'enceinte.
   4) cette fluctuation persiste même si on retire le côté "bi-matériau" (en retirant le liner métallique).
   5) cette fluctuation disparait quasiment si on double la discrétisation circonférentielle
      du maillage thermique.

   On est donc naturellement conduit à suspecter la projection du champ de température du maillage
   thermique vers le maillage mécanique.

   En se penchant sur le résultat de la projection, on constate effectivement que la procédure de projection
   d'une maille linéaire (à bords droits) vers une maille quadratique à bords courbes entraine une "erreur
   de projection" illustrée sur la figure 34 de la note (p65). Mais cette "erreur" n'est pas liée au programme
   de projection : elle est inhérente aux 2 maillages. Certains noeuds milieu de la maille courbe de la face
   interne du cylindre, se retrouvent à l'intérieur de la maille linéaire correspondante dans le maillage
   thermique. La température calculée sur ces noeuds est donc celle qui existe un peu en profondeur et non
   pas celle de la surface.

   Dans l'étude incriminée, cette "erreur" est d'ailleurs très faible car la courbure du cylindre est très faible
   vis à vis de la taille des mailles. La note indique une erreur en température de 7.e-5 : oscillation des
   températures entre 2.9998 et 3.0000 à l'instant t=0.

   Ce qui est incompréhensible, ce n'est pas l'observation d'une très faible oscillation de la température,
   c'est l'oscillation qu'elle semble provoquer sur la contrainte radiale !

   J'ai essayé de reproduire sur un petit maillage ces observations mais jusqu'à présent,
   je n'y arrive pas :
   L'oscillation thermique est plus importante que celle de la note (T varie de 1.30000E+02 à 1.29127E+02)
   mais pourtant les contraintes calculées restent désespéremment stables en circonférence !
   (SRR varie de -3.80098E-01 à -3.79933E-01) Elles sont même plus stables que la température !

   Le code se serait-il corrigé (involontairement) entre la STA6 et la NEW7 ?



   RESU_FAUX_VERSION_EXPLOITATION  :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   NON
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
   DETAILS

   Liste des fichiers modifiés:

------------------------------------------------------------------------------
RESTITUTION HORS AREX   (H1)
   NB_JOURS_TRAV : 0.5
   INTERET_UTILISATEUR : NON

   FONCTIONNALITE
   "cas test sslv134b se plante en debug_jeveux dans POST_K1_K2_K3 "
   Le mode debug_jeveux provoquait un plantage dans POST_K1_K2_K3 car le groupe
   de noeuds produit par DEFI_GROUP/SEGM_DROI_ORDO était faux (mal ordonné).

   RESU_FAUX_VERSION_EXPLOITATION   :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT  :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION  : passage du test en debug_jeveux
   DETAILS

 Pb dans la routine cgnoso.f :
 -----------------------------
 On demande l'adresse de LISNOE en lecture alors que oreino.f est sensé modifier
 cet objet.
 Ce bug a pour effet que la commande DEFI_GROUP/CREA_GROUP_NO/SEGM_DROI_ORDO
 ne réordonnait pas les noeuds comme elle devait le faire.

 Ce bug (provoqué en debug_jeveux) NE POUVAIT PAS provoquer de résultats faux
 car cet objet libéré en fin de cgnoso.f était immédiatement
 ramené en mémoire dans sscgno.f pour être recopié dans MA//.GROUPENO

   Liste des fichiers modifiés:
  cgnoso.f


-----------------------------------------------------------------------
--- AUTEUR ylepape Y.LEPAPE   DATE  le 30/11/2004 a 14:04:16

------------------------------------------------------------------------------
RESTITUTION HORS AREX
   INTERET_UTILISATEUR : OUI
   TITRE Vérification de la bonne prise en compte du cisaillement dans le modèle
   BETON_UMLV_FP

   FONCTIONNALITE
     Suite à la fiche d'anomalie AL 2004-337, on avait pas restitué le cas test
     correspondant. C'est chose faite.

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI

   IMPACT_DOCUMENTAIRE : OUI
     DOC_V : V6.04.181 SSNV181 - Vérification de la prise en compte du
     cisaillment dans le modèle BETON_ULMV_FP

   VALIDATION
     nouveau cas-test : SSNV181 (solution analytique, 1 modélisation : 3D)

   DETAILS
     aucuns

   NB_JOURS_TRAV  : 1.5
------------------------------------------------------------------------------


========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

       C MODIF utilitai/cpfile               d6bhhhh M.ASA              100     11     18
 CASTEST AJOUT ssnv181a                      ylepape Y.LEPAPE           200    200      0
 CASTEST MODIF sdll118a                     lebouvie F.LEBOUVIER        417      1     28
 CASTEST MODIF sdll503b                       boyere E.BOYERE           356      2    115
 CASTEST MODIF sdnl112b                       boyere E.BOYERE           490      3      3
 CASTEST MODIF sensm04a                      f6bhhbo P.DEBONNIERES      455      1      1
 CASTEST MODIF shlv100j                       durand C.DURAND           244     34     27
 CASTEST MODIF sslp102b                      galenne E.GALENNE          275      1      1
 CASTEST MODIF wtnv123a                      kbbhhdb G.DEBRUYNE         445      5      5
 CASTEST MODIF wtnv123b                      kbbhhdb G.DEBRUYNE         454      5      5
 CASTEST MODIF wtnv123c                      kbbhhdb G.DEBRUYNE         741     15     61
 CASTEST MODIF wtnv124a                      kbbhhdb G.DEBRUYNE         552      9      9
 CASTEST MODIF wtnv126a                      kbbhhdb G.DEBRUYNE         791      5      5
 CASTEST MODIF wtnv126b                      kbbhhdb G.DEBRUYNE         774      5      5
 CASTEST MODIF zzzz127a                      d6bhhhh M.ASA              192      2      2
 CASTEST MODIF zzzz140a                     mcourtoi M.COURTOIS         131      2      2
CATALOPY MODIF entete/accas                 mcourtoi M.COURTOIS         652      7      4
 FORTRAN MODIF algorith/calcme               kbbhhdb G.DEBRUYNE         861      7      2
 FORTRAN MODIF algorith/calvol                durand C.DURAND            85      1      2
 FORTRAN MODIF algorith/crsdco                mabbas M.ABBAS            599      7      5
 FORTRAN MODIF algorith/hmliga               kbbhhdb G.DEBRUYNE         455      7      2
 FORTRAN MODIF algorith/hmlvag               kbbhhdb G.DEBRUYNE         533      9      3
 FORTRAN MODIF algorith/lcjoba               kbbhhdb G.DEBRUYNE         369     22     44
 FORTRAN MODIF algorith/mereso               f6bhhbo P.DEBONNIERES      266     21      3
 FORTRAN MODIF algorith/misazl                mabbas M.ABBAS            151     18     10
 FORTRAN MODIF algorith/nmbarc               kbbhhdb G.DEBRUYNE        1021     12     11
 FORTRAN MODIF algorith/nmcomp               kbbhhdb G.DEBRUYNE         673      2      2
 FORTRAN MODIF algorith/nmfi2d               kbbhhdb G.DEBRUYNE         217      2      5
 FORTRAN MODIF algorith/nmsens               f6bhhbo P.DEBONNIERES      244     21      3
 FORTRAN MODIF algorith/tran75                boyere E.BOYERE           668      6      6
 FORTRAN MODIF calculel/mecalg               galenne E.GALENNE          464      3      1
 FORTRAN MODIF calculel/mecalm                boyere E.BOYERE          2257      6      6
 FORTRAN MODIF calculel/op0058                durand C.DURAND           120      3      2
 FORTRAN MODIF jeveux/jedebu                 d6bhhjp J.P.LEFEBVRE       270      2      2
 FORTRAN MODIF jeveux/jjlchd                 d6bhhjp J.P.LEFEBVRE       227      5      3
 FORTRAN MODIF modelisa/afrela               vabhhts J.PELLET           426      9      9
 FORTRAN MODIF modelisa/calirc               vabhhts J.PELLET           504     10      1
 FORTRAN MODIF modelisa/cazoco                mabbas M.ABBAS            568     17      1
 FORTRAN MODIF modelisa/cgnoso               vabhhts J.PELLET           113      2      2
 FORTRAN MODIF modelisa/proslc                mabbas M.ABBAS            378      2      2
 FORTRAN MODIF modelisa/tfimpr                durand C.DURAND           255      2      2
 FORTRAN MODIF utilifor/utcomm                durand C.DURAND           146      2      3
 FORTRAN MODIF utilitai/tbajpa              lebouvie F.LEBOUVIER        186     11      2
  PYTHON MODIF Macro/impr_fonction_ops      mcourtoi M.COURTOIS         393     20     38
  PYTHON MODIF Macro/impr_table_ops         mcourtoi M.COURTOIS         232      9      7
  PYTHON MODIF Macro/lire_fonction_ops      mcourtoi M.COURTOIS         254     18     21
  PYTHON MODIF Macro/lire_table_ops         mcourtoi M.COURTOIS         173     16     20
  PYTHON MODIF Macro/macr_ascouf_mail_ops   mcourtoi M.COURTOIS        2849    109     96
  PYTHON MODIF Macro/macro_mode_meca_ops    mcourtoi M.COURTOIS         139      4      1
  PYTHON MODIF Macro/stanley_ops            mcourtoi M.COURTOIS          66      7      2
  PYTHON MODIF Stanley/xmgrace              mcourtoi M.COURTOIS         267      7      2
  PYTHON MODIF Utilitai/Graph               mcourtoi M.COURTOIS        1058     35      7
  PYTHON MODIF Utilitai/Table               mcourtoi M.COURTOIS         702     62     24
  PYTHON MODIF Utilitai/Utmess              mcourtoi M.COURTOIS          66     10      6
  PYTHON MODIF Utilitai/partition             assire A.ASSIRE          1210     82     80


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :    1         200       200              +200
 MODIF :   54       26534       696     729       -33
 SUPPR :    0           0                 0        +0
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :   55       26734       896     729      +167 
