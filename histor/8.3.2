

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR boiteau      BOITEAU O.             DATE 19/06/2006 - 14:22:07

--------------------------------------------------------------------------------
RESTITUTION FICHE 009842 DU 2006-06-14 13:32:25
TYPE anomalie concernant Code_Aster (VERSION 2.x)
NB_JOURS_TRAV  : 0.1
TITRE
   tests ssnv182b ssnv185d ssnv185j ssnv186b ssnv186e mumps et X-FEM
FONCTIONNALITE
   Contexte-Fonctionnalite:
   -----------------------
   Lors de la restit de lundi dernier, j'ai effectue des "copier-coller" un peu rapides et
   n'ai pas remarque que l'initialisation du mot-cle RESI_RELA du bloc MUMPS etait
   differente
   suivant les operateurs. Et ce afin de tenir compte de la moindre exigence de la qualite
   de
   solution d'un systeme lineaire, a chaque etape d'un processus non-lineaire.
   Tous les op. ont la valeur RESI_RELA=10-6 sauf
   STAT_NON_LINE et THER_NON_LINE qui ont RESI_RELA=-1 (valeur <0 donc pas de test et
   d'arret
   fatal en cas de qualite ne repondant pas au critere)
   Du coup j'ai applique la meme logique a DYNA_NON_LINE qui avait ete oublie.
   
   Rq sur l'impact documentaire
   -----------------------------
   Ne pas oublier de mettre a jour la doc U4.50.01 avec UNE VALEUR PAR DEFAUT DEPENDANT DE
   L'OPERATEUR pour RESI_RELA !
   
   Tests:
   ------
   cas-tests X-FEM
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.50.01
VALIDATION
   les 12 tests casses sous Linux et TRU64
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR boyere       BOYERE E.              DATE 20/06/2006 - 16:28:05

--------------------------------------------------------------------------------
RESTITUTION FICHE 009329 DU 2006-01-06 09:20:03
TYPE anomalie concernant Code_Aster (VERSION 8.3)
NB_JOURS_TRAV  : 5.0
TITRE
   DYNA_TRAN_MODAL : routine ssdt74.f
FONCTIONNALITE
   Jacques en reperant un tableau mal dimmensionne dans SSDT74 a mis le doigt sur une
   vieille
   erreur de programmation.
   Dans une partie de cette routine, la lecture des informations modales y etait basee sur
   l'idee que, dans le stockage des modes, tous les modes dynamiques de l'ensemble des
   sous-structures etaient places en premier, puis tous les modes d'interface et les ddl de
   lagrange. Malheureusement c'est faux en sous-structuration dynamique. On stocke
   sous-structure par sous-structure les informations modales : d'abord les modes dynamiques
   de la premiere sous-structure, puis les modes d'interface de la premiere sous-structure,
   puis les ddl de lagrange de la premiere sous-structure, ensuite vient la deuxieme
   sous-structure avec le meme classement et ainsi de suite.
   
   Heureusement il n'y a pas de resultats faux a proprement dit car la boucle en question
   sert a retrouver les pulsations modales, qui ne sont pas, a priori, exploitees dans la
   suite du code.
   
   J'en profite pour corriger un appel a MDPTEM, la routine de verification du pas de
   temps,
   qui oubliait une partie des modes.
   Soit dit en passant, on peut douter de l'interet de l'appel a cette routine dans
   SSDT74.
   Elle est en effet concue pour le cas direct.
   Or en SSD, la stabilite des schemas n'est pas directement calculable a partir des
   frequences de chaque sous-structure.
   En effet les equations differentielles en temps ne sont pas decouplees et il faudrait
   tenir compte des modes d'interface (a frequence nulle). J'ai pu le verifier sur le cas
   test sdll113a.
   Le calcul par SSD dans DYNA_TRAN_MODAL necessite un pas de temps nettement plus petit que
   le calcul direct.
   
   Il y avait aussi un petit probleme dans le calcul des amortissements critiques. On ne
   faisait pas la difference entre modes dynamiques et modes d'interface. Or il va de soit
   que la notion d'amortissement critique ne fait pas sens pour un mode statique.
   
   Enfin une derniere remarque sur l'amortissement modal par sous-structure.
   On peut se demander la pertinence de cette notion puisque ce type d'amortissement ne peut
   pas etre equivalent a un amortissement habituel sur le systeme global, que ce soit un
   amortissement modal ou un amortissement structurel (par exemple de type Rayleigh).
   Il faudrait pour cela introduire un amortissement sur les modes d'interface, notion qui
   reste a definir.
   Par manque de possibilite de comparaison avec une methode directe, je n'ai pas comble
   la
   lacune de validation qui reste sur l'amortissement en SSD introduit sous la forme d'un
   amortissement modal reduit, sous-structure par sous-structure.
   Si j'aboutis dans la solution analytique d'un cas simple, pourquoi pas ?
   
   Emmanuel
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   aucune
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR boyere       BOYERE E.              DATE 19/06/2006 - 19:23:46

--------------------------------------------------------------------------------
RESTITUTION FICHE 009534 DU 2006-03-08 13:32:02
TYPE evolution concernant Code_Aster (VERSION )
TMA : CS
TITRE
   DYNA_TRAN_MODAL mot-cle choc
FONCTIONNALITE
   Pour simplifier l'utisation des chocs dans DYNA_TRAN_MODAL et harmoniser leur
   modelisation
   avec DYNA_NON_LINE, la fiche EL a introduit la possibilite d'entrer les couples de noeuds
   de choc sous forme de SEG2 dans le maillage.
   Cependant le traitement des chocs se faisait encore choc par choc, avec autant de mots
   clefs facteurs dans DYNA_TRAN_MODAL qu'il n'y avait de lieux de choc.
   Pour accelerer la mise en donnees des etudes ou il y a de tres nombreux lieux de
   choc, on
   restitue maintenant la possibilite d'entrer les noeuds de choc sous la forme d'une liste
   de mailles SEG2.
   
   On en profite pour decouper la routine MDCHOC et la rendre plus lisible.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.53.21
VALIDATION
   sdnl105a
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR galenne      GALENNE E.             DATE 19/06/2006 - 15:01:52

--------------------------------------------------------------------------------
RESTITUTION FICHE 009814 DU 2006-06-01 14:22:47
TYPE anomalie concernant Code_Aster (VERSION 8.4)
NB_JOURS_TRAV  : 0.5
TITRE
   DEFI_FOND_FISS : pb avec fond double
FONCTIONNALITE
   Probleme pour calculer K avec POST_K1_K2_K3 en relachement de noeuds (= avec deux groupes
   de noeuds coincidents definissant le fond de fissure) : les noeuds sur les directions
   normales au fond de fissure sont mal determines dans l'operateur DEFI_FOND_FISS, ce qui
   fait ensuite planter POST_K1_K2_K3.
   
   Le probleme se trouvait dans la routine gnormf : dans une des operations permettant
   d'identifier, de classer et de sauvegarder les noeuds sur les directions normales, on
   prenait le premier element d'un vecteur qui n'etait pas forcement le noeud du fond de
   fissure (selon numerotation des noeuds dans le maillage).
   
   Validation : etude F. Hasnaoui + cas test sslv134g
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sslv134g
--------------------------------------------------------------------------------
RESTITUTION FICHE 009823 DU 2006-06-07 14:37:54
TYPE anomalie concernant Code_Aster (VERSION 8.4)
NB_JOURS_TRAV  : 0.5
TITRE
   POST_K1_K2_K3 - maillage libre
FONCTIONNALITE
   Probleme dans POST_K1_K2_K3 avec TYPE_MAILLAGE = 'LIBRE' repere par Ludovic May :
   
   La direction de propagation de la fissure est determinee a partir de la tangente au
   fond
   de fissure et du vecteur VECT_K1, normale aux levres de la fissure fournie par
   l'utilisateur. Il apparait que la routine (python) actuelle ne permet pas de determiner
   de
   facon sure le sens de la propagation... d'ou des K tous nuls si on se trompe de sens !
   
   Solution : on verifie le sens de la propagation de la fissure en s'appuyant sur les
   mailles des levres.
   Details : a partir d'une maille quelconque de la levre superieure, on determine les
   coordonnees d'un point des levres. A partir de ce point, du point origine et
   extremite de
   la fissure et de la normale au plan de la fissure, on verifie et on corrige si besoin est
   le sens de la normale au fond.
   (Rem : si la normale a l'origine et a l'extremite sont fournies dans DEFI_FOND_FISS,
   on ne
   les verifie pas car on suppose que l'utilisateur connait son maillage...)
   
   Validation : etude perso + cas test sslb134b
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sslv134b
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR mabbas       ABBAS M.               DATE 19/06/2006 - 16:18:59

--------------------------------------------------------------------------------
RESTITUTION FICHE 008962 DU 2005-09-06 00:00:00
TYPE evolution concernant Code_Aster (VERSION 8.1)
TMA : CS
TITRE
   Combinaison lineaire de matrices non symetriques
FONCTIONNALITE
   Un peu de menage du cote des combinaisons lineaires de matrices :
   -----------------------------------------------------------------
   1) on resorbe MTCOMB -> MTCMBL
   2) on supprime certains arguments redondants dans MTCMBL.
   3) on permet la combinaison de toutes les matrices ayant le meme stockage
   (routine cbvale.f) :
   - symetrique ou non
   - complexe ou reelle
   - avec coef complex ou reel
   - matrice resulat complexe ou reelle
   4) concernant les matrices de stockages differents (objet de la fiche
   d'evolution : routine cbval2.f) :
   - on ne traite que les matrices reelles et les coefficienst reels
   - mais on accepte maintenant de combiner des matrices symetriques et
   non symetriques.
   
   Validation :
   -------------
   Le test sdnv103d s'arretait en erreur fatale (dans cbval2) si on laissait
   SYME='NON' dans DYNA_NON_LINE.
   Maintenant, il va jusqu'au bout et les resultats sont les memes qu'avec
   SYME='OUI'.
   Seul le JEU est tres legerement modifie (0.001%).
   
   Le nombre d'iterations de convergence ne change pas. (et les residus
   obtenus sont quasiment les memes)
   Je propose de modifier ce test pour valider cette nouvelle fonctionalite de
   combinaison.
   Je modifie la valeur de reference (non-regression) pour le JEU tres
   legerement modifie.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sdnv103d
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR vabhhts      PELLET Jacques         DATE 19/06/2006 - 16:19:03

--------------------------------------------------------------------------------
RESTITUTION FICHE 009356 DU 2006-01-13 12:57:40
TYPE anomalie concernant Code_Aster (VERSION 8.2)
NB_JOURS_TRAV  : 1.0
TITRE
   CALC_MATR_AJOU ne cree pas une vraie MATR_ASSE_GENE
FONCTIONNALITE
   J'ai emis une nouvelle fiche (9808) concernant le probleme general de la
   non coherence des doc D des SD avec la realite des sources fortran d'Aster.
   
   Je suggere dans cette nouvelle fiche de developper une nouvelle routine
   VERISD pour verifier cette coherence a la fin des operateurs. Par exemple,
   a la fin de l'operateur ma=LIRE_MAILLAGE(...), cette routine verifiera que
   les objets JEVEUX composant la SD ma correspondent bien a la description
   qui en est faite dans la doc D4.06.01.
   
   Dans le cadre de cette fiche, je me contente de restituer le "cadre" de
   cette verification :
   1) on ajoute le mot cle :
   DEBUG=_F( SDVERI=  /'OUI'
   /'NON'   [DEFAUT] )
   dans les commandes DEBUT et POURSUITE
   
   Ce mot cle declanche la verification des SD produites par les operateurs.
   
   2) Impact documentaire :
   U4.11.01 : commande DEBUT      : nouveau mot cle SDVERI
   U4.11.03 : commande POURSUITE  : nouveau mot cle SDVERI
   D6.00.01 : ajouter verisd a la liste des utilitaires
   
   3) Programmation d'un debut de verisd pour les SD :
   'MAILLAGE'      'LIGREL'        'MODELE'        'MODELE_GENE'
   'CARTE'         'CHAM_NO'       'CHAM_ELEM'     'RESUELEM'
   'CHAM_NO_S'     'CHAM_ELEM_S'   'TABLE'         'RESULTAT'
   'LIGREL'        'FONCTION'      'RESULTAT'      'MATRICE'
   'MATR_ASSE'     'MATR_ASSE_GENE''SOLVEUR'       'PROF_GENE'
   'PROF_CHNO'     'NUME_EQUA'     'NUME_DDL'
   'NUME_DDL_GENE' 'STOCKAGE'      'STOC_LCIEL'    'STOC_MORSE'
   'STOC_MLTF'     'VECT_ASSE_GENE'
   
   
   Pour la verification precise des SD MATR_ASSE_GENE et NUME_DDL_GENE (objet
   initial de la fiche), on attendra que les SD de niveau inferieur
   (MODELE_GENE, MACR_ELEM_DYNA, ...) soient traitees.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.11.01,U4.11.03, D6.00.01
VALIDATION
   rien
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR bodel        BODEL Charles          DATE 19/06/2006 - 16:19:05

--------------------------------------------------------------------------------
RESTITUTION FICHE 009603 DU 2006-03-27 15:32:39
TYPE evolution concernant Code_Aster (VERSION )
NB_JOURS_TRAV  : 3.0
TITRE
   Transmission des informations modales pour PROJ_MESU_MODAL, REST_BASE_PHYS, et PROJ_CHAMP
FONCTIONNALITE
   des modifications ont ete apportees aux trois operateurs suivants :
   - REST_BASE_PHYS : la plupart des parametres etaient deja copies dans la sd
   resultat. On
   a juste ajoute un ligne demandant de copier les amortissements generalises, ce qui
   pour
   l'instant n'etait pas fait. op concerne : regene.f
   - PROJ_MESU_MODAL : modification de la routine mdallr.f. On ajoute dans le catalogue de
   la commande un mot cle 'NOM_PARA' permettant a l'utilisateur de copier dans la sd
   resultat les donnees qu'il souhaite concerner. Par defaut, l'operateur copie les
   donnees
   qui l'etaient deja avant (telles que la frequence propre).
   - PROJ_CHAMP : on a modifie la routine pjefpr.f de la meme maniere, avec l'ajout du
   meme
   mot cle dans le catalogue
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.72.05-E , U4.73.01-C
VALIDATION
   103 cas tests utilisant les operateurs concernes
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR vabhhts      PELLET Jacques         DATE 19/06/2006 - 16:19:08

--------------------------------------------------------------------------------
RESTITUTION FICHE 009612 DU 2006-03-29 12:24:26
TYPE evolution concernant Code_Aster (VERSION 8.2)
NB_JOURS_TRAV  : 3.5
TITRE
   AFFE_CHAR_CINE + matrice non symetrique => problemes
FONCTIONNALITE
   Les "charges cinematiques" (AFFE_CHAR_CINE) sont
   maintenant possibles avec les matrices non symetriques.
   
   
   
   
   Details :
   ---------
   En NEW8 :
   =========
   la routine ASMCHC a ete modifiee pour traiter les
   matrices non symetriques.
   
   Suite a l'evolution de ASMCHC, je me suis apercu que
   cette correction etait insuffisante pour le test que
   j'avais choisi. En effet, pour obtenir une matrice non-
   symetrique, j'avais choisi des "forces suiveuses".
   Dans le cas des forces suiveuses, on assemble dans une
   matrice qui existe deja d'autres matrices elementaires
   (ASMATR/CUMUL='CUMU').Il y avait alors collision entre
   les appels a ASMCHC en fin d'ASMATR et les resultats
   etaient faux. Il fallait modifier l'assemblage / 'CUMU'
   pour bien tenir compte des charges cinematiques.
   
   Je me suis alors convaincu qu'il serait plus simple de
   faire le traitement des charges cinematiques (recopie de
   KLI dans .CCVA, mise a 1 de la diagonale, ...) le plus
   tard possible. Cela permet d'ignorer les objets des
   charges cinematiques lors des combinaisons lineaires et
   de l'assemblage / 'CUMU'.
   On fait donc maintenant appel a ASMCHC au dernier
   moment : au debut de la resolution (PRERES) ou au debut
   du produit matrice*vecteur (MRMULT).
   
   J'ai aussi developpe une routine MTMCHC permettant
   de "retablir" (partiellement) le .VALM d'une matrice a
   partir du .CCVA pour que l'on puisse encore combiner une
   matrice ayant servi a une produit matrice*vecteur ou une
   resolution. Cette fonctionalite est necessaire aux
   calculs modaux : on fait : F=M*U, F=K*U puis recherche
   des modes propres de (K+s*M).
   
   
   IMPACT_DOC :
   - SD matr_asse (D4.06.10) :
   REFA(3)= / 'ELIMF'  -> la matrice a des ddls
   elimines et  l'elimination (appel a ASMCHC) a ete faite
   / 'ELIML'  -> la matrice a des ddls
   elimines et  l'elimination est "latente" (pas encore
   faite)
   / ' '      -> la matrice n'a pas de ddls
   elimines.
   - D6.00.01 : liste des utilitaires :
   -ajouter MTMCHC : traitement des charges
   cinematiques : passage .VALM -> .CCVA et reciproquement
   
   
   
   Validation :
   -----------
   Ajout d'un nouveau test (zzzz213b) pour valider
   AFFE_CHAR_CINE sur les matrices non-symetriques.
   Il s'agit d'un probleme de coques avec forces
   suiveuses.
   La validation se fait en comparant les resultats
   obtenus avec ceux d'AFFE_CHAR_MECA.
   Ce test dure environ 8s.
   
   Passage (sur clpaster) de tous les tests (30)
   utilisant les charges cinematiques (hors MUMPS).
   
   En NEW7 :
   =========
   On se contente d'arreter l'utilisateur par un message
   d'erreur fatale car le traitement des charges
   cinematiques a ete entierement revu en NEW8.
   La routine NEW7 modifiee est fournie en piece jointe ci-
   dessous.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : D4.06.10 D6.00.01
VALIDATION
   nouveau test (zzzz213b)
--------------------------------------------------------------------------------
RESTITUTION FICHE 009616 DU 2006-03-29 15:56:55
TYPE anomalie concernant Code_Aster (VERSION 8.2)
NB_JOURS_TRAV  : 1.0
TITRE
   nouveaux catalogues d'element gener_medpl2_x et autres
FONCTIONNALITE
   On fusionne certains catalogues semblables :
   ---------------------------------------------
   1) Les triangles a 6 noeuds qui sont separes des autres
   depuis toujours sans que quelqu'un
   se rappelle pourquoi !
   2) Les "faux" elements XFEM (modelisations 3D_XFEM,
   D_PLAN_X et C_PLAN_X) qui sont en
   principe les memes
   elements que ceux des modelisations 3D, D_PLAN et
   C_PLAN sauf que leurs mailles sont
   quadratiques
   alors que les ddls sont portes par les noeuds des
   elements lineaires.
   
   
   
   Remarque :
   ---------
   Pour fusionner les elements XFEM et les elements
   ordinaires, on fait une "fausse"
   complication des
   elements ordinaires en leur declarant un ensemble de
   noeuds EN1 qui contient en fait tous
   les noeuds
   de l'element. Et ca a l'air de marcher ...
   
   
   
   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   ENTETE__ ELEMENT__ MEDPTR6          MAILLE__ TRIA6
   ELREFE__  TR6       GAUSS__  RIGI=FPG3  MASS=FPG6
   GANO=FPG3  ...
   ENS_NOEUD__  EN1     =     1  2  3  4  5  6
   ENTETE__ ELEMENT__ MEDPTR6_X        MAILLE__ TRIA6
   ELREFE__  TR3       GAUSS__  RIGI=FPG1  MASS=FPG3
   GANO=FPG3  ...
   ENS_NOEUD__  EN2     =     4  5  6
   ENS_NOEUD__  EN1     =     1  2  3
   
   
   
   MODE_LOCAL__
   DDL_MECA = DEPL_R   ELNO__ DIFF__
   EN1   (DX
   DY       )
   EN2   ()
   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   
   
   
   
   
   
   Finalement :
   gener_medpl2.cata    gener_medpl2_x.cata
   medptr6.cata           ->  gener_medpl2.cata
   gener_mecpl2.cata    gener_mecpl2_x.cata
   mecptr6.cata           ->  gener_mecpl2.cata
   gener_me3d_3.cata
   gener_me_x.cata                              ->
   gener_me3d_3.cata
   gener_me3d_2.cata
   gener_me_x_2.cata                            ->
   gener_me3d_2.cata
   
   
   
   Suite a ces fusions, quelques TEST_RESU deviennent
   legerement NOOK (1.e-9) mais je ne
   comprends pas pourquoi ...
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   liste restreinte
--------------------------------------------------------------------------------
RESTITUTION FICHE 009726 DU 2006-05-02 08:14:26
TYPE evolution concernant Code_Aster (VERSION )
NB_JOURS_TRAV  : 2.0
TITRE
   champ de materiau "aux noeuds"
FONCTIONNALITE
   Champ de materiau "aux noeuds"
   -------------------------------
   
   1) Impact utilisateur :
   ------------------------
   
   CHMAT0=AFFE_MATERIAU(   MAILLAGE=MAIL,
   AFFE=        _F( TOUT = 'OUI',
   MATER = MATERIAU),
   AFFE_NOEUD=  _F( TOUT = 'OUI',
   MATER = MATERIAU),       <- nouveau mot cle facteur
   )
   
   2) imapct DOCD :
   ----------------
   D4.06.18 :
   On enrichit la SD CHAM_MATER d'un cham_no (NEUT_F)
   CHAM_MATER//'.CHAMP_MATN'
   
   2) Validation :
   ----------------
   Un essai perso  a partir du  test wtnv111c (D_PLAN_THM)
   - ajout du parametre PMATERN a l'option RAPH_MECA
   - verification que l'on peut acceder aux
   caracteristiques du materiau des noeuds dans te0600.f
   
   
   4) Details :
   ------------
   Contrairement a ce qui avait ete evoque avec C. Durand,
   je ne cree pas une nouvelle commande AFFE_MATERIAU_NOEU
   
   Il me semble que cette voie nous empechera de mixer
   plutard des modelisations "materiau aux moeuds" et des
   modelisations "materiau aux mailles" car les commandes
   globales attendent toujours un seul cham_mater.
   
   Je propose donc d'en rester a :
   
   cham_mater= AFFE_MATERIAU( MAILLAGE=MA
   
   AFFE=_F( ... MATER= mater , TEMP_REF= tref)    #
   materiau et TEMP_REF definis par mailles
   AFFE_VARC= _F(...)                             #
   variables de commandes definies par mailles
   
   AFFE_NOEUD=_F( GROUP_MA='G1', MATER=mater)     #
   materiau defini par noeuds
   
   Remarques :
   ------------
   R1) Seul les parametres materiaux deviennent
   accessibles aux noeuds des elements.
   R2) La temperature de reference reste affectee par
   mailles (ainsi que les variables de commande).
   R3) C. Chavant (et S. Granet) ne souhaitent pas que
   le coefficient de dilatation (ELAS_FO/ALPHA) soit
   modifie pour tenir compte d'une eventuelle difference
   entre TEMP_REF et TEMP_DEF_ALPHA (travail de la routine
   alfint.f).
   Pour cela, le modifie la routine alfint.f :
   - si materiau "aux noeuds" : TREF=TDEF => la
   transformation faite par alfint est l'identite.
   J'ai verifie (test perso) que le ALPHA recupere
   dans le materiau par noeud etait bien celui donne par
   l'utilisateur (ELAS_FO/ALPHA). Dans ce cas,
   TEMP_DEF_ALPHA ne sert donc a rien.
   Il faudra se souvenir de cette particularite le
   jour ou le materiau "par noeuds" servira a d'autres
   elements que les elements THM.
   
   Restitution :
   --------------
   Pour "clore" cette fiche (qui ne servira vraiment que
   lorsqu'une modelisation THM saura s'en servir), je
   restitue :
   - le catalogue et le fortran de AFFE_MATERIAU
   - quelques catalogues d'options et de type_elem
   (ajout du parametre PMATERN : materiau "aux noeuds") :
   forc_noda.cata       gener_medh42.cata
   rigi_meca_tang.cata
   full_meca.cata       gener_medh52.cata
   gener_meah42.cata    raph_meca.cata
   - un petit bloc de fortran dans TE0600 (en
   commentaire) pour verifier que l'on peut bien acceder au
   materiau "par noeuds".
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : D4.06.18
VALIDATION
   test perso
--------------------------------------------------------------------------------
RESTITUTION FICHE 009752 DU 2006-05-12 12:53:40
TYPE evolution concernant Code_Aster (VERSION )
NB_JOURS_TRAV  : 1.0
TITRE
   Resolution avec des matrices generalisees complexes et non symetriques
FONCTIONNALITE
   Introduction de 2 nouvelles routines TLDUC8 et RLDUC8
   pour resoudre les systemes lineaires complexes non
   symetriques avec le solveur LDLT.
   
   Je n'introduis pas de test de cette nouvelle
   fonctionnalite car je ne sais pas produire de telles
   matrices (complexes et non-symetriques). Mais Georges
   Devesa semble vouloir sen servir ... donc le test
   viendra en son temps.
   
   Au passage, je supprime une dissymetrie des routines
   RLDLR8 et RLDLC8 : dans la version complexe, on avait
   supprime la possibilite de ne resoudre le systeme
   lineaire que sur ses n premieres inconnues (NEQ). Je le
   fais moins pour l'interet de la possibilite que pour
   retablir une bonne lisibilite  : les routines complexes
   sont les memes que les routines reelles en changeant R8 -
   > C16
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   aucune
--------------------------------------------------------------------------------
RESTITUTION FICHE 009779 DU 2006-05-18 14:21:39
TYPE evolution concernant Code_Aster (VERSION )
NB_JOURS_TRAV  : 0.7
TITRE
   PROJ_CHAMP 3D + 1D thermique
FONCTIONNALITE
   Le probleme souleve par l'utilisateur est du au fait
   que Code_Aster (en mecanique) peut prendre en compte
   l'effet de la temperature sur les elements 3D et les
   elements de structure.
   En revanche, les operateurs de thermiques de Code_Aster
   ne savent pas calculer d'evolution thermique sur les
   elements de poutre.
   
   Quand on a un modele thermo-mecanique mixte, il est
   donc obligatoire de creer (a la main actuellement en
   attendant la realisation de la fiche 9772) un evol_ther
   mixte qui servira de donnee pour le calcul mecanique
   (AFFE_CHAR_MECA/TEMP_CALCULEE).
   
   Pour constituer cet evol_ther, il faut :
   - fabriquer un 1er evol_ther (evoth1) sur les
   elements de poutre (CREA_RESU)
   - calculer un 2eme evol_ther (evoth2) sur les
   elements volumiques (THER_LINEAIRE)
   - "assembler" les 2 evol_ther pour en faire un
   mixte : evoth1 + evoth2 -> evoth3  (boucle python :
   CREA_CHAMP / CREA_RESU)
   
   Apres cela, l'utilisateur envisage de changer de
   maillage :
   - maillage lineaire pour la thermique
   - maillage quadratique pour la mecanique
   
   Pour cela, il utilise PROJ_CHAMP :
   
   rtlvq = PROJ_CHAMP(METHODE='ELEM',
   MODELE_1=mot,
   RESULTAT=rtlv,
   MODELE_2=motq,
   VIS_A_VIS=(_F
   (GROUP_MA_1='VTUY',GROUP_MA_2='VTUY'),
   _F(GROUP_MA_1=
   ('LTM','LTV'),
   GROUP_MA_2=
   ('LTM','LTV'),)),
   TOUT_ORDRE='OUI',);
   
   Mais il est arrete par un message du style : "<F>
   PJCO6D : pas de noeuds a projeter".
   ----------
   -----------------------------
   
   La raison de ce message est la suivante :
   -----------------------------------------
   Parfois, il existe dans le maillage des noeuds (voire
   des mailles) de construction qui ne servent pas au
   modele. Par exemple avec GIBI, les neuds de "point de
   vue" des visualisations qui peuvent etre tres eloignes.
   Ces elements "indesires" peuvent degrader enormement les
   performances de PROJ_CHAMP qui decoupe l'espace
   geomerique entourant le maillage en petites briques.
   Nous avons donc fait une evolution de PROJ_CHAMP pour
   eliminer de la projection toutes les mailles et tous les
   noeuds qui ne font pas partie des modeles (MODELE_1 et
   MODELE_2).
   
   Quand l'utilisateur projette les GROUPE_MA_1=
   ('LTM','LTV') qui sont des groupes de "poutre", on
   enleve de ces groupes TOUTES les mailles car il n'existe
   pas d'elements finis dans le modele (mot) concernant ces
   mailles puisqu'il n'y a pas d'elements fini de
   thermique "poutre".
   PROJ_CHAMP s'arrete alors en erreur fatale car il ne
   trouve rien a projeter.
   
   
   Comment s'en sortir ?
   -----------------------
   Le probleme est que PROJ_CHAMP retire de l'ensemble des
   mailles a projeter toutes celles qui ne font pas partie
   des modeles. Mais dans PROJ_CHAMP, la vraie nature des
   modeles ne sert a rien : les fonctions de forme utilisee
   pour la projection ne dependent que des types de mailles
   et pas des types d'elements finis. On va donc "tromper"
   PROJ_CHAMP en lui fournissant des modeles "mecaniques"
   que l'on va artificiellement associer aux evol_ther.
   
   On va faire :
   
   rtlvq = PROJ_CHAMP(METHODE='ELEM',
   MODELE_1=mom,
   RESULTAT=rtlv,
   MODELE_2=momq,
   VIS_A_VIS=(_F
   (GROUP_MA_1='VTUY',GROUP_MA_2='VTUY'),
   _F(GROUP_MA_1=
   ('LTM','LTV'),
   GROUP_MA_2=
   ('LTM','LTV'),)),
   TOUT_ORDRE='OUI',);
   C'est a dire que l'on a remplace (mot) et (motq) par
   (mom) et (momq) qui sont des modeles "mecaniques"
   (lineaires et quadratiques) avec des elements finis de
   poutre sur les GROUP_MA 'LTM' et 'LTV'.
   
   Avec les fichiers fournis dans la fiche, on peut alors
   mener les calculs jusqu'au bout et on obtient le
   resultat :
   ---- RESULTAT:  rm       NUME_ORDRE:   7 NOM_CHAM:
   DEPL     (t=450s)
   REFERENCE: (calcul lineaire)
   OK  DX           RELA    -0.092 % VALE:
   2.1405314075211E-03
   N13962   TOLE     0.100 % REFE:
   2.1425083133040E-03
   On constate que sur le noeud observe ( GROUP_NO
   = 'PVV'), le deplacement obtenu sur le maillage
   quadratique differe de mooins de 0.1% de celui obtenu
   avec le modele lineaire.
   
   IMPACT_DOC :
   ---------------
   Faire un petit paragraphe dans la doc de PROJ_CHAMP pour
   expliquer que l'on peut projeter un evol_ther sur un
   modele mecanique.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : U4.72.05
VALIDATION
   test perso
--------------------------------------------------------------------------------
RESTITUTION FICHE 009812 DU 2006-05-31 07:43:49
TYPE anomalie concernant Code_Aster (VERSION 8.2)
NB_JOURS_TRAV  : 1.5
TITRE
   probleme avec le solveur MULT_FRONT dans stat_non_line
FONCTIONNALITE
   Quelques essais :
   ------------------
   1) J'ai observe (comme Vincent) que la relation lineaire sur DZ(N388)
   n'etait pas verifiee au pas de temps incrimine avec le solveur
   MULT_FRONT/METIS.
   
   1bis) Avec le solveur MULT_FRONT/MDA, en revanche tout est OK.
   
   2) J'ai verifie qu'il n'y avait pas d'ecrasement JEVEUX avec
   MULT_FRONT/METIS
   
   
   
   3) Avec MUMPS, le calcul va au bout mais si on ecrit l'estimation de
   l'erreur relative sur la solution, on obtient des valeurs inquietantes :
   jusqu'a 600% d'erreur !!!
   
   4) J'ai essaye les iterations de "refinement" de MUMPS pour ameliorer la
   solution et ca marche plutot bien :
   - Quand MUMPS decide de faire de telles iterations d'amelioration,
   l'erreur descend en dessous de 1.d-9 (en 1 iteration !).
   - En revanche, MUMPS ne decide pas toujours d'iterer et cela se traduit
   par des erreurs pouvant aller jusqu'a 2% d'erreur.
   
   5) Je suis entre en contact avec J-Y L'Excellent de l'equipe MUMPS pour
   pouvoir "forcer" ces iterations de "refinement". Il m'a dit qu'en effet, la
   doc utilisateur n'etait pas tres claire a ce sujet mais qu'il esperait
   qu'avec les prochaines versions de MUMPS, on n'aurait meme plus a se
   preoccuper ce ces iterations (grace en particulier au pivotage 2x2 qui
   devrait ameliorer la qualite de la solution des systemes symetriques non
   definis positifs).
   
   6) Je vais donc essayer d'installer prochainement la version 4.6 de MUMPS
   (pour remplacer notre 4.3.1)
   
   
   
   
   
   
   Conclusions :
   -------------
   1) Dans l'etude concernee par cette fiche, je n'ai pas observe
   d'ecrasements JEVEUX avec MULT_FRONT.
   2) Les essais avec MUMPS me conduisent a penser que les systemes lineaires
   a resoudre dans l'etude sont "difficiles".
   Pourtant, le conditionnement des matrices n'est pas enorme (1.D5 ->
   1.D7).
   Il s'agit donc de difficultes numeriques (ordre d'elimination des
   inconnues).
   3) Je propose de classer la fiche "sans suite" avec l'argument : "c'est la
   faute a pas de chance !" :
   Le systeme lineaire est difficile a resoudre et sa solution est
   imprecise avec MULT_FRONT/METIS. Elle est tellement imprecise qu'une
   condition aux limite est manifestement violee (30%) et ca se voit !
   Il est difficile d'incriminer la programmation de MULT_FRONT puiqu'elle
   ne depend pas de la methode de renumerotaion choisie (MDA/METIS).
   La numerotation est une donnee pour MULT_FRONT. Quand on a de la chance
   (MDA) tout va bien. Quand on manque de pot, ca diverge.
   On ne peut pas pas non plus suspecter une erreur grossiere de METIS
   (oubli de ddls par exemple) car la numerotaion METIS permet tout de meme de
   calculer correctement les premiers pas de temps.
   
   
   
   4) Le probleme souleve par cette fiche est que certains modeles mecaniques
   conduisent a des systemes mal resolus par MULT_FRONT (solveur par defaut)
   et que l'utilisateur n'en est pas averti. (Il ne peut l'etre qu'avec le
   solveur MUMPS). Heureusement que cette etude utilise STAT_NON_LINE (et non
   pas MECA_STATIQUE) car une mauvaise resolution n'empeche pas forcement la
   convergence de Newton et si la convergence ne se fait pas ... le code
   s'arrete en erreur fatale.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   etude jointe
--------------------------------------------------------------------------------
RESTITUTION FICHE 009818 DU 2006-06-02 14:44:27
TYPE anomalie concernant Code_Aster (VERSION 2.x)
NB_JOURS_TRAV  : 0.3
TITRE
   Pb dans prise en compte des charges cinematiques
FONCTIONNALITE
   Sans suite :
   ---------------
   
   L'erreur (de programmation) se produisait dans la
   routine MTCOMB que je resorbe par ailleurs (fiche 8962).
   
   J'ai refait passer l'etude avec le fortran que je vais
   restituer pour 8962 (et 9612 : charges cinematiques avec
   matrices non symetriques) et le calcul de
   MODE_ITER_SIMULT va jusqu'au bout. J'en conclus qu'en
   corrigeant 8962 et 9612, j'ai corrige (involontairement)
   cette anomalie.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   passage de l'etude
--------------------------------------------------------------------------------
RESTITUTION FICHE 009838 DU 2006-06-13 14:30:29
TYPE evolution concernant Code_Aster (VERSION )
NB_JOURS_TRAV  : 1.0
TITRE
   Projection d'un resultat 2D axi sur un maillage 3D
FONCTIONNALITE
   Projection de champ avec transformation geometrique du
   maillage "2"
   --------------------------------------------------------
   ------------
   
   Le besoin exprime dans la fiche est celui de "projeter"
   un maillage 2D axis sur un  maillage 3D (probablement
   axis mais pas forcement regle en azimut).
   
   Concretement, il faut donc affecter une solution 2D sur
   un maillage 3D en faisant "tourner" cette solution
   autour de l'axe de revolution.
   
   C. Durand m'a suggere d'elargir la demande pour traiter
   egalement le cas d'une solution 2D que l'on
   voudrait "etendre" dans une direction donnee. Par
   exemple, on calculerait la section circulaire d'un
   cylindre et on affecterait cette solution sur toute la
   longueur de ce cylindre.
   
   Pour repondre (positivement) a ces 2 demandes, je
   propose d'ajouter un nouveau mot cle (TRANSF_GEOM_2=
   (fx,fy,[fz])) dans la commande CREA_CHAMP.
   
   L'utilisateur donnera 2 (resp.3) fonctions si le
   MAILLAGE_2 est 2D (resp. 3D) permettant de definir la
   transformation geometrique a appliquer aux noeuds du
   maillage_2 AVANT de faire la projection.
   
   IMPACT_DOC_U : U4.72.05  PROJ_CHAMP :
   - ajouter un comentaire sur les 2 nouveaux mots
   cles :
   ---     / TRANSF_GEOM_2
   VIS_A_VIS / TRANSF_GEOM_2
   
   
   Exemples d'utilisation :
   -------------------------
   
   ex1) : en 2D : le maillage 2 a ete fait en mm et le
   maillage 1 en m :
   --------------------------------------------------------
   ----------------
   La transformation geometrique a faire est une
   homothetie de rapport 1/1000.
   On renseignera donc :
   fx=x/1000.
   fy=y/1000.
   
   ex2) : en 2D : le maillage 2 a ete fait dans un repere
   tourne de 45 degres (par rapport au maillage 1):
   --------------------------------------------------------
   -----------------------------------------------
   La transformation geometrique a faire est une rotation
   de -45.
   On renseignera donc :
   alpha= pi/4.
   fx= cos(alpha)*x - sin(alpha)*y
   fy= sin(alpha)*x + cos(alpha)*y
   
   
   ex3) : maillage_1 (AXIS) -> maillage_2 (3D) (demande de
   Nabila Sellali) :
   --------------------------------------------------------
   -----------------
   En axis, le maillage 2D est forcement xOy. Oy est l'axe
   de symetrie. Le maillage doit etre dans le demi-plan x
   >=0.
   
   Supposons que le maillage 3D soit un solide d'axe OZ
   
   La transformation geometrique a faire est
   un "ecrasement" du solide 3D sur le maillage "2D axis".
   On renseignera donc :
   fx= sqrt(x**2 + yy**2)
   fy= z
   fz= 0.
   
   Validation :
   -------------
   On complete le test zzzz110a pour traiter l'exemple ex3)
   ci-dessus.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.72.05
VALIDATION
   zzzz110a
--------------------------------------------------------------------------------
RESTITUTION FICHE 009844 DU 2006-06-15 10:56:19
TYPE express concernant Code_Aster (VERSION 2.x)
NB_JOURS_TRAV  : 0.5
TITRE
   une routine pour recuperer les variables de commande de "reference"
FONCTIONNALITE
   1) Realisation d'une routine utilitaire (VRCREF) pour
   calculer les variables de commandes de "reference"
   (SECH_REF, TEMP_REF, ...)
   IMPACT_DOC_D : signaler VRCREF dans D6.00.01
   
   2) Correction de plusieurs bugs dans
   AFFE_MATERIAU/AFFE_VARC si :
   - utilisation de GROUP_MA et/ou MAILLE
   - et/ou melange de plusieurs VARC
   - et/ou utilisation de VALE_REF
   
   Remarque : Ces corrections ne sont pas a faire en
   NEW7 car AFFE_VARC n'existe pas en NEW7
   
   3) Une petite modification de jjimpo.f car l'impression
   d'un vecteur de K16 etait pourrie sur clapster:
   
   3.1) j'initialise (a tout hasard) la variable
   FMT= ' '
   75a76
   >       FMT=' '
   3.2) je "casse" une double boucle implicite :
   177,178c178,179
   <             WRITE ( UNIT , '(I7,'' -
   '','//FMT//')')
   <      &              ( NB*(L-1)+1,
   ---
   >             DO 1,L=1,NL
   >                WRITE ( UNIT , '(I7,'' -
   '','//FMT//')')  NB*(L-1)+1,
   180c181,182
   <
   &                                       K= 1,NB ) , L =
   1,NL )
   ---
   >      &         K= 1,NB)
   >  1          CONTINUE
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : D6.00.01
VALIDATION
   essai perso utilisant plusieurs occurences de AFFE_VARC et plusieurs VARC
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST AJOUT zzzz213b                      vabhhts J.PELLET            91     91      0
 CASTEST MODIF sdls112a                      vabhhts J.PELLET           314     16      1
 CASTEST MODIF sdnl105a                      cibhhlv L.VIVAN            405      9     24
 CASTEST MODIF sdnv103d                      vabhhts J.PELLET           242      5      6
 CASTEST MODIF sslv134b                      galenne E.GALENNE          780     27      2
 CASTEST MODIF zzzz110a                      vabhhts J.PELLET           162     36     17
 CASTEST MODIF zzzz213a                      vabhhts J.PELLET           234      2      2
CATALOGU MODIF options/forc_noda             vabhhts J.PELLET            92      3      1
CATALOGU MODIF options/full_meca             vabhhts J.PELLET            86      3      2
CATALOGU MODIF options/raph_meca             vabhhts J.PELLET            84      3      2
CATALOGU MODIF options/rigi_meca_tang        vabhhts J.PELLET            86      3      2
CATALOGU MODIF typelem/gener_me3d_2          vabhhts J.PELLET           196     20      2
CATALOGU MODIF typelem/gener_me3d_3          vabhhts J.PELLET           667    168    136
CATALOGU MODIF typelem/gener_meah42          vabhhts J.PELLET           200      8      3
CATALOGU MODIF typelem/gener_mecpl2          vabhhts J.PELLET           609    142    109
CATALOGU MODIF typelem/gener_medh42          vabhhts J.PELLET           196      6      5
CATALOGU MODIF typelem/gener_medh52          vabhhts J.PELLET           193      5      4
CATALOGU MODIF typelem/gener_medpl2          vabhhts J.PELLET           626    141    107
CATALOGU SUPPR typelem/gener_me_x            vabhhts J.PELLET           617      0    617
CATALOGU SUPPR typelem/gener_me_x_2          vabhhts J.PELLET           163      0    163
CATALOGU SUPPR typelem/gener_mecpl2_x        vabhhts J.PELLET           568      0    568
CATALOGU SUPPR typelem/gener_medpl2_x        vabhhts J.PELLET           563      0    563
CATALOGU SUPPR typelem/mecptr6               vabhhts J.PELLET           557      0    557
CATALOGU SUPPR typelem/medptr6               vabhhts J.PELLET           567      0    567
CATALOPY MODIF commande/affe_materiau        vabhhts J.PELLET           157     13      3
CATALOPY MODIF commande/debut                vabhhts J.PELLET            84      3      1
CATALOPY MODIF commande/dyna_non_line        boiteau O.BOITEAU          375      3      3
CATALOPY MODIF commande/dyna_tran_modal      cibhhlv L.VIVAN            209      3      3
CATALOPY MODIF commande/poursuite            vabhhts J.PELLET            81      3      1
CATALOPY MODIF commande/proj_champ           vabhhts J.PELLET           117     10      1
CATALOPY MODIF commande/proj_mesu_modal      vabhhts J.PELLET            62      2      1
CATALOPY MODIF commande/stat_non_line        boiteau O.BOITEAU          345      3      3
CATALOPY MODIF commande/ther_non_line        boiteau O.BOITEAU          118      2      2
 FORTRAN AJOUT algeline/cbvalc               vabhhts J.PELLET           101    101      0
 FORTRAN AJOUT algeline/cbvalr               vabhhts J.PELLET           101    101      0
 FORTRAN AJOUT algeline/rlduc8               vabhhts J.PELLET           214    214      0
 FORTRAN AJOUT algeline/tlduc8               vabhhts J.PELLET           412    412      0
 FORTRAN AJOUT algorith/mdchan               cibhhlv L.VIVAN            255    255      0
 FORTRAN AJOUT algorith/mdchdl               cibhhlv L.VIVAN            109    109      0
 FORTRAN AJOUT algorith/mdchge               cibhhlv L.VIVAN            245    245      0
 FORTRAN AJOUT algorith/mdchre               cibhhlv L.VIVAN            141    141      0
 FORTRAN AJOUT algorith/mdchst               cibhhlv L.VIVAN            379    379      0
 FORTRAN AJOUT assembla/mtmchc               vabhhts J.PELLET           232    232      0
 FORTRAN AJOUT calculel/pjeftg               vabhhts J.PELLET            98     98      0
 FORTRAN AJOUT calculel/vrcref               vabhhts J.PELLET           169    169      0
 FORTRAN AJOUT modelisa/rcmatn               vabhhts J.PELLET           103    103      0
 FORTRAN MODIF algeline/cbval2               vabhhts J.PELLET           157     85    148
 FORTRAN MODIF algeline/cbvale               vabhhts J.PELLET           232    107    173
 FORTRAN MODIF algeline/cbvali               vabhhts J.PELLET            23      4    141
 FORTRAN MODIF algeline/cidia1               vabhhts J.PELLET            23      4     93
 FORTRAN MODIF algeline/deteli               vabhhts J.PELLET            23      4     49
 FORTRAN MODIF algeline/diagav               vabhhts J.PELLET           150      5      2
 FORTRAN MODIF algeline/mcmult               vabhhts J.PELLET           106      5      2
 FORTRAN MODIF algeline/mrmult               vabhhts J.PELLET           108      5      2
 FORTRAN MODIF algeline/mtcmbl               vabhhts J.PELLET           218    107    133
 FORTRAN MODIF algeline/mtcomb               vabhhts J.PELLET            23      4    204
 FORTRAN MODIF algeline/mtcopy               vabhhts J.PELLET           101      4      9
 FORTRAN MODIF algeline/mtdefs               vabhhts J.PELLET           127     41     44
 FORTRAN MODIF algeline/mtdscr               vabhhts J.PELLET           201     11     10
 FORTRAN MODIF algeline/op0031               vabhhts J.PELLET           178     58     97
 FORTRAN MODIF algeline/pcldlt               vabhhts J.PELLET           224      8      2
 FORTRAN MODIF algeline/rldlc8               vabhhts J.PELLET           203     25      6
 FORTRAN MODIF algeline/rldlg3               vabhhts J.PELLET           100      7      3
 FORTRAN MODIF algeline/rrssm2               vabhhts J.PELLET            85     58    129
 FORTRAN MODIF algeline/tldlg2               vabhhts J.PELLET           485     27    180
 FORTRAN MODIF algeline/tldlg3               vabhhts J.PELLET           336     17      3
 FORTRAN MODIF algeline/vereli               vabhhts J.PELLET            22      4    115
 FORTRAN MODIF algeline/vpfopc               vabhhts J.PELLET           100      5      9
 FORTRAN MODIF algeline/vpshif               vabhhts J.PELLET            70      4      4
 FORTRAN MODIF algeline/wp1inv               vabhhts J.PELLET           225      5      8
 FORTRAN MODIF algeline/wp1mul               vabhhts J.PELLET           197      9     14
 FORTRAN MODIF algeline/wpfopc               vabhhts J.PELLET           109      6     10
 FORTRAN MODIF algeline/wpfopr               vabhhts J.PELLET           151      7     16
 FORTRAN MODIF algeline/wpnorm               vabhhts J.PELLET           176     12     12
 FORTRAN MODIF algorith/ajlagr               vabhhts J.PELLET           196      7      8
 FORTRAN MODIF algorith/ascima               vabhhts J.PELLET            84     25     21
 FORTRAN MODIF algorith/camoch               vabhhts J.PELLET           234      2      2
 FORTRAN MODIF algorith/cffrot               vabhhts J.PELLET            99      4      6
 FORTRAN MODIF algorith/dlnewi               vabhhts J.PELLET           783      6      7
 FORTRAN MODIF algorith/mdallr               vabhhts J.PELLET           142     35     33
 FORTRAN MODIF algorith/mdchoc               cibhhlv L.VIVAN            418     87    766
 FORTRAN MODIF algorith/mdtr74               cibhhlv L.VIVAN            735     40      8
 FORTRAN MODIF algorith/merimo               vabhhts J.PELLET           469      9      3
 FORTRAN MODIF algorith/mptran               vabhhts J.PELLET           375      9      6
 FORTRAN MODIF algorith/mxmass               vabhhts J.PELLET           203      6      7
 FORTRAN MODIF algorith/nmasfr               vabhhts J.PELLET           105      3      6
 FORTRAN MODIF algorith/nmmatr               vabhhts J.PELLET           430      7      9
 FORTRAN MODIF algorith/op0060               vabhhts J.PELLET           627      5      7
 FORTRAN MODIF algorith/rcmfmc               vabhhts J.PELLET           240    108     21
 FORTRAN MODIF algorith/regene               vabhhts J.PELLET           313     15      9
 FORTRAN MODIF algorith/ssdt74                boyere E.BOYERE           360     29     14
 FORTRAN MODIF assembla/asmatr               vabhhts J.PELLET           245     28     19
 FORTRAN MODIF assembla/asmchc               vabhhts J.PELLET           314    109     44
 FORTRAN MODIF assembla/asschc               vabhhts J.PELLET           116     29     25
 FORTRAN MODIF assembla/assmam               vabhhts J.PELLET          1143      1      5
 FORTRAN MODIF assembla/assmmn               vabhhts J.PELLET           899      1      5
 FORTRAN MODIF assembla/op0012               vabhhts J.PELLET           108      2      2
 FORTRAN MODIF calculel/imptou               vabhhts J.PELLET           102      3      1
 FORTRAN MODIF calculel/pjefpr               vabhhts J.PELLET           222     35      7
 FORTRAN MODIF calculel/pjefte               vabhhts J.PELLET           247     27     13
 FORTRAN MODIF elements/gnormf               galenne E.GALENNE          468      5      3
 FORTRAN MODIF elements/te0600               vabhhts J.PELLET           544     31      4
 FORTRAN MODIF jeveux/jjimpo                 vabhhts J.PELLET           212      8      6
 FORTRAN MODIF modelisa/alfint               vabhhts J.PELLET           229     17      4
 FORTRAN MODIF modelisa/op0006               vabhhts J.PELLET           283     18     10
 FORTRAN MODIF modelisa/prosmo               vabhhts J.PELLET           382     45     32
 FORTRAN MODIF modelisa/rcmaco               vabhhts J.PELLET           352     21      7
 FORTRAN MODIF supervis/execop               vabhhts J.PELLET           134      6      2
 FORTRAN MODIF supervis/ibdbgs               vabhhts J.PELLET           159     17      1
 FORTRAN MODIF supervis/op9999               vabhhts J.PELLET           152      2      1
 FORTRAN MODIF utilitai/copisd               vabhhts J.PELLET           312      1      1
 FORTRAN MODIF utilitai/idenob               vabhhts J.PELLET           338      8      4
 FORTRAN MODIF utilitai/sdusdp               vabhhts J.PELLET            66      1      1
 FORTRAN MODIF utilitai/veris3               vabhhts J.PELLET            40      6      2
 FORTRAN MODIF utilitai/verisd               vabhhts J.PELLET           539     26      8
FORTRAN90 MODIF mumps/amumps                  vabhhts J.PELLET           262      7      1
  PYTHON MODIF Macro/post_k1_k2_k3_ops       galenne E.GALENNE          924     38      5


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :   14        2650      2650             +2650
 MODIF :   97       25478      2166    3207     -1041
 SUPPR :    6        3035              3035     -3035
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :  117       31163      4816    6242     -1426 
