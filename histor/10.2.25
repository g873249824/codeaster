

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR assire       ASSIRE Aimery          DATE 11/16/2010 - 08:42:28

--------------------------------------------------------------------------------
RESTITUTION FICHE 015902 DU 2010-11-15 08:17:54
TYPE express concernant Code_Aster (VERSION 9.1)
TITRE
    Affichages rxc3xa9siduels "debug" dans MACR_RECAL
FONCTIONNALITE
   Il y a des affichages parasites dans MACR_RECAL, activés par une variable Python "debug",
   involontairement mise à True avant la dernière restitution. On corrige.
   
   De plus, on corrige quelques bricoles comme le message d'erreur qui apparait lorsqu'un
   calcul esclave plante (avant on disait "au moins un calcul esclave a planté", maintenant
   on dit lequel et on donne le chemin vers l'output du job).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    zzzz159, ssna110a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 015891 DU 2010-11-12 07:35:17
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.2.24, le cas-test zzzz159b s'arrete en <F>_ERROR sur Rocks et Aster 4
FONCTIONNALITE
   Sur Aster-4, le mode DISTRIBUTION / BATCH de MACR_RECAL ne fonctionnait pas.
   
   Il y a un premier problème qui ne concerne pas Aster mais la configuration du gestionnaire
   de batch. Les jobs esclaves sont soumis en batch par le job maitre mais la classe par
   défaut etait mal configurée et les jobs ne partaient pas.
   
   De plus, le mot-clé CLASSE permet d'adresser un groupe de classe particulier. Si on met
   CLASSE='distr' alors on rentre dans les classes dédiées aux calculs distribués, permettant
   d'executer 20 (petits) jobs simultanéments.
   
   D'autre part, même en corrigeant le gestionnaire de batch, il restait un problème : les
   mots-clés MEMOIRE et TEMPS, qui définissent les caratéristiques batch des jobs esclaves,
   étaient mal pris en compte car s'ajoutaient aux caractéristiques batch du job maitre. En
   clair, les caractéristiques les plus contraignantes des deux étaient prises en compte.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    zzzz159b
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR audebert     AUDEBERT Sylvie        DATE 11/16/2010 - 03:42:34

--------------------------------------------------------------------------------
RESTITUTION FICHE 015710 DU 2010-10-11 12:36:01
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    COMB_SISM_MODAL
FONCTIONNALITE
   Analyse sismique spectrale : utilisation de la correction statique via 
   le calcul du pseudo-mode relativement à l'opérateur COMB_SISM_MODAL
   
   PB. décrit par SEPTEN : 
   La doc R4.05.03 spécifie que la contribution du pseudo-mode est la 
   valeur lue sur le spectre de pseudo-accélération pour la dernière 
   fréquence propre de la base modale retenue. Or, il apparait que 
   la pseudo-accélération réellement prise en compte est celle 
   correspondant à la fréquence de coupure du spectre.
   La comparaison entre un calcul avec Code_Aster et avec Hercule a permis 
   de montrer ceci.
   
   Constat : tel que c'est codé dans Code_Aster, lorsqu'on tronque la base 
   modale avant la fréquence de coupure et qu'on effectue une correction 
   via le pseudo-mode (pratique de l'ingénierie non recommandée par la 
   R&D), on n'est plus majorant. Le source n'est pas en cohérence avec la 
   doc. R. Il est cohérent avec ce que fait CASTEM par rapport auquel on 
   s'est comparé. Cette anomalie existe depuis le début de l'existence de 
   Code_Aster.
   Il existe des cas-tests discriminants, c'est-à-dire visant à mettre en 
   évidence l'effet du pseudo-mode mais, soit les valeurs de référence 
   sont des moyennes de codes qui se basent certainement sur la même 
   hypothèse, soit les valeurs de référence sont analytiques, mais les 
   calculs analytiques se basent également sur cette même hypothèse.
   
   Correction : la correction consiste à mettre le source en cohérence 
   avec la doc. R, c'est-à-dire à considérer le pseudo-mode calculé à 
   partir de la valeur lue sur le SRO à la dernière fréquence de la base 
   modale considérée.
   Les cas-tests analytiques SDLD30 et SDLD301 sont repris avec la 
   formulation corrigée et la modification est validée.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : v2.01.30, v2.01.301, v2.01.25, v2.02.23, v2.02.131, R04.05.03
VALIDATION
    astout sur COMB_SISM_MODAL
NB_JOURS_TRAV  : 12.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 014235 DU 2009-11-25 16:51:42
TYPE evolution concernant Documentation (VERSION )
TITRE
    [U4.84.01]  COMB_SISM_MODAL : impact fiche 14230
FONCTIONNALITE
   Un utilisateur a été arrêté par une erreur fatale dans COMB_SISM_MODAL car il essayait de
   l'utiliser avec des masses ajoutées (fluides). Or ce cas n'est pas prévu. Un message
   d'erreur spécifique a été implementé (cf fiche 14230).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : U4.84.01
VALIDATION
    sans objet
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 011812 DU 2008-02-28 08:44:34
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Cas test sdll23b : validation des résultats REAC_NODA
FONCTIONNALITE
   Dans le cadre du chantier poutre, le passage de poutres d'Euler à poutres de Timoshenko a mis 
   en évidence des différences notables sur certaines valeurs de réactions nodales.
   
   Le cas-test SDLL23, qui comportait une seule modélisation A, a donc été enrichi et comporte 
   maintenant 3 modélisations :
   - modélisation A : modélisation initiale, référence résultats guide VPCS non publié, 
   comparaison de divers codes. 
   - modélisation B : modélisation que j'ai ajoutée, car la modélisation A n'est pas suffisamment 
   raffinée pour représenter 6 modes. Même calcul qu'en modélisation A, avec maillage raffiné, 
   référence non régression;
   - modélisation C : modélisation de Timoshenko, rajoutée suite à l'étude de J.L. Fléjou (les 
   modélisations A et B sont en Euler), référence non régression.
   
   Une brève étude paramétrique a montré que les résultats relatifs à la modélisation C 
   (réactions nodales surtout) sont très sensibles aux valeurs de coefficients de cisaillement : 
   les écarts constatés entre les modélisations POU_DE et POU_D_TG ne semblent pas anormaux.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : v2.02.023.odt
VALIDATION
    sdll23
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR bodel        BODEL Charles          DATE 11/16/2010 - 03:28:48

--------------------------------------------------------------------------------
RESTITUTION FICHE 015158 DU 2010-06-04 15:26:27
TYPE anomalie concernant Code_Aster (VERSION 10.2)
TITRE
    Plantages non controles dans CALC_ESSAI a l'import d'une table
FONCTIONNALITE
   Probleme : les tables table_fonction sont mal gerees par CALC_ESSAI, et dans certains cas,
   on risque des plantages sales.
   
   Solution proposee : dans meidee_cata.py, dans la classe MeideeObjects, on importe tous les
   concepts aster existants, et on les instancie dans des classes adaptees. 
   On ajoute a cette classe la methode test_table, qui verifie, pour toutes les table_fonction : 
    - si ce sont des fonctions relles ou complexes
    - si ce sont des fonctions temporelles ou frequentielles (ou autre)
   Les tables contenant des fonctions temporelles et frequentielles sont ensuite instanciees
   respectivement dans les classes InterSpectre et Tempo.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sdlv125a,
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 015566 DU 2010-09-17 16:52:20
TYPE anomalie concernant Code_Aster (VERSION 10.2)
TITRE
    Utilisation de Salomxc3xa9 pour l'affichage de courbes et champs dans CALC_ESSAI
FONCTIONNALITE
   Probleme : l'affichage de champs de deformees et de courbe dans Salome depuis CALC_ESSAI
   fonctionne assez mal, en particulier sur Calibre 5.
   
   La situation s'ameliore nettement en utilisant des procedures de lancement de l'affichage
   utilisees dans STANLEY. On arrive, avec les developpements proposes, au constat suivant : 
    - Avant, les resultats s'affichaient dans une nouvelle fenetre de Salome. Aujourd'hui, on
   recupere la fenetre Salome associee au port donne
    - Si deux fichiers Salome sont ouverts sur le meme port, une fenetre propose a
   l'utilisateur de choisir entre les deux fenetre pour l'affichage,
    - Pour que l'affichage se fasse, il faut cependant que le module VISU soit actif. Si ce
   n'est pas le cas, un message le signal a l'utilisateur dans la fentre Salome.
    - l'affichage fonctionne en mode local et distant.
   
   Le foctionnement est maintenant iso-fonctionnel avec STANLEY. Ce mode de fonctionnement
   est provisoire, puisqu'on prevoit la suppression du module pylotage et une simplification
   des procedures de communication entre Aster et Salome.
   La validation se fera conformement a la procedure de recettage qui sera ecrite dans la
   documentation informatique de CALC_ESSAI.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    graphique
NB_JOURS_TRAV  : 5.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 015900 DU 2010-11-15 07:36:44
TYPE anomalie concernant Code_Aster (VERSION 10.2)
TITRE
    EXTR_MODE : recopie de champs multiples issus de MODE_STATIQUE
FONCTIONNALITE
   Probleme :
   ----------
   Lorsqu'on fait un MODE_STATIQUE, on laisse vide le champ NUME_MODE, car ce ne
   sont pas de modes propres comme les modes dynamiques. Mais quand on fait un
   EXTR_MODE ensuite, on reordonne les modes de la sd resultat selon le NUME_MODE,
   qui n'existe pas. Dans ce cas, on se retrouve a recopier N fois le mode statique
   1 (ou N est le nombre de modes attendu).
   
   Solution :
   ----------
   On choisit de recopier dans MODE_STATIQUE (dans arch93.f) un champ NUME_MODE,
   comme pour les modes dynamiques. 
   C'est la solution la plus simple, qui permet d'eviter le bug dans EXTR_MODE par
   la suite.
   Cette solution peut n'etre que provisoire. Une solution definitive pourrait etre
   de reordonner les modes statiques par ordre alpha-num des NOEUD_CMP, mais cela
   demande un travail plus consequent...
   
   Validation : 
   ------------
   Une nouvelle version du cas-test sdls139 (sdls139b) est creee, avec expansion modale sur
   une base de modes statiques
   
   Modifications :
   ---------------
    - arch93.f : ajout de la recopie de NUME_MODE
    - sdls112 : ajout de la modelisation b
    - V2.03.112 : ajout de la descritption de la modelisation
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 10.0.2
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V2.03.112
VALIDATION
    sdls112b
NB_JOURS_TRAV  : 0.8
--------------------------------------------------------------------------------
RESTITUTION FICHE 015896 DU 2010-11-12 11:17:56
TYPE anomalie concernant Code_Aster (VERSION 10.2)
TITRE
    EXTR_MODE : les caracteristiques modales des modes statiques sont mal recopiees
FONCTIONNALITE
   Probleme :
   ----------
   Quand on fait un EXTR_MODE sur une base de modes statiques, les informations
   suivantes ne sont pas stockees dans le mode_meca resultat : 
    - le TYPE_MODE : il est mis part defaut a 'MODE_DYN' pour tous les mode_meca.
    - le champ NOEUD_CMP : il n'est pas complete
   
   Solution :
   ----------
   Dans op0168.f et dans vpstor.f, on ajoute les champs de parametre TYPE_MODE et
   NOEUD_CMP. On recupere les champs associes dans vprecu.f, et on les recopie dans
   vpstor.f : 
   
   AVANT : 
   C ----- ON STOCKE 'TYPE_MODE' POUR LES MODES PROPRES 'MODE_MECA'
   C
           IF ( TYPCON(1:9).EQ.'MODE_MECA'.OR.
        &       TYPCON(1:9).EQ.'MODE_GENE') THEN
   
              CALL RSADPA(MODES,'E',1,NOPAST(3),NORDR,0,LADPA,K8B)
              ZK16(LADPA)= 'MODE_DYN'
   
           ENDIF
   
   
   APRES :
   C ----- ON STOCKE 'TYPE_MODE' POUR LES MODES PROPRES 'MODE_MECA'
   C
           IF ( TYPCON(1:9).EQ.'MODE_MECA'.OR.
        &       TYPCON(1:9).EQ.'MODE_GENE') THEN
            
              IRANG = INDK24(NOPARA(NBPARI+1),NOPAST(3),1,NBPARK)
              IF ( IRANG .GT. 0 ) THEN
                CALL RSADPA(MODES,'E',1,NOPAST(3),NORDR,0,LADPA,K8B)
                ZK16(LADPA)= RESUFK(KMODE,IRANG)
              ENDIF
   
           ENDIF
   
   Et pour le champ NOEUD_CMP, on ajoute les lignes suivantes (syntaxe idem que pour les
   autres champs de parametres) :
   C ----- ON STOCKE 'NOEUD_CMP'
   C
           IRANG = INDK24(NOPARA(NBPARI+1),NOPAST(4),1,NBPARK)
           IF ( IRANG .GT. 0 ) THEN
              CALL RSADPA(MODES,'E',1,NOPAST(4),NORDR,0,LADPA,K8B)
              WRITE(6,*) 'I', IRANG,' RE=',RESUFK(KMODE,IRANG)
              WRITE(6,*) 'NOPAST(4) = ', NOPAST(4)
              ZK16(LADPA) = RESUFK(KMODE,IRANG)
           ENDIF
   
   Impact : 
   --------
    - op0168.f : ajout de TYPE_MODE et NOEUD_CMP dans la liste des parametres
    - vpstor.f : idem
    - cas-test sdls112 : ajout de la modelisation b 
    - DOC V2.03.112 : ajout de la modelisation b
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V2.03.112
VALIDATION
    sdls112b
NB_JOURS_TRAV  : 0.8
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR boiteau      BOITEAU Olivier        DATE 11/15/2010 - 02:47:49

--------------------------------------------------------------------------------
RESTITUTION FICHE 012850 DU 2008-11-19 17:40:52
TYPE anomalie concernant Code_Aster (VERSION )
TITRE
    MOD2 - Vxc3xa9rification de la norme d'erreur des modes
FONCTIONNALITE
   PROBLEME
   ========
     Lors d'un calcul modal avec MODE_ITER_SIMULT, lorsque le solveur modal rencontre
     un pb numérique ds sa résolution, il restitue ds le .mess une erreur_F ou E qui 
     détaille ce pb mais 
            - il s'arrête sur un CALL ASSERT ou même plus salement,
            - SURTOUT, il n'affiche pas l'information spectrale dont il dispose déjà
              alors que celle-ci peut aider l'utilisateur a mieux re-paramétrer son
              prochain calcul.
   
   ANALYSE
   =======
      1/ Périmètre:
       Ce type de pb n'intervient que pour les méthodes SORENSEN et QZ. Pour TRI_DIAG et
       JACOBI, il n'est pas prévu (il me semble) d'arrêts de ce type, en cours de
       résolution. Ces méthodes (telles qu'elles sont programmées) ont qqes arrêts
       prévus sur critère numérique mais on perd alors toutes l'infos précédemment exhu
       mées (même si celle-ci est licite). Si jamais j'ai oublié un arrêt ds ces routines
       on pourra le rattacher facilement au même mécanisme que pour SORENSEN et QZ.
   
     2/ Mécanisme:
       On remplace les UTMESS_F incriminés par par un UTMESS_E (erreur du type
       pas assez de modes convergés...) ds les routines de calcul modal (VPSORN, VPQZLA..
       ) et on le garde en mémoire ds la routine chef d'orchestre (via le logical FLAGE).
       Si FLAGE est activé on s'arrête en fin d'op par un nouveau msg ALGELINE5_75 (voir
       plus bas).
   
     3/ Cohérence d'ensemble:
       Ce type de mécanisme rétabli une certaine cohérence avec ce qui est fait pour 
       les autres critères d'arrêt de l'op (filtrage ds la 'BANDE', critère de Sturm, 
       norme d'erreur...) et avec la philosophie générale du code: 
                        mesg d'alerte + arrêt propre
       + informations sur les données déjà validées + stockage ds la base.
   
   IMPACT UTILISATEUR
   ==================
      Informations plus riches et arrêts propres pour certains pb numériques prévus dans
      MODE_ITER_SIMULT.
   
   VALIDATION
   ==========
       cas-test fourni ds la fiche (sdls111a) + sdlx201a (sur Bull seq nodebug).
       Par exemple, au lieu d'un arrêt du type:
   
      !------------------------------------------------------------------------------!
      ! <E> <ALGELINE5_49>                                                           !
      !                                                                              !
      ! nombre de valeurs propres convergées  3 < nombre de fréquences demandées  16 !
      !  erreur ARPACK numéro :  1                                                   !
      !  --> le calcul continue, la prochaine fois                                   !
      !  -->   augmenter DIM_SOUS_ESPACE =  20                                       !
      !  -->   ou NMAX_ITER_SOREN =  1                                               !
      !  -->   ou PREC_SOREN =  0.000000                                             !
      !                                                                              !
      !                                                                              !
      ! Cette erreur sera suivie d'une erreur fatale.                                !
      !------------------------------------------------------------------------------! 
      .....  
      !-------------------------------------------------------!
      ! <F> <DVP_2>                                           !
      !                                                       !
      ! Erreur numérique (floating point exception).          !
      !                                                       !
      !                                                       !
      ! Cette erreur est fatale. Le code s'arrete.            !
      ! Il y a probablement une erreur dans la programmation. !
      ! Veuillez contacter votre assistance technique.        !
      !-------------------------------------------------------!
   
       On a maintenant:
   
   
      !------------------------------------------------------------------------------!
      ! <E> <ALGELINE5_49>                                                           !
      !                                                                              !
      ! nombre de valeurs propres convergées  3 < nombre de fréquences demandées  16 !
      !  erreur ARPACK numéro :  1                                                   !
      !  .....
      
   ------------------------------------------------------------------------
      LES FREQUENCES CALCULEES INF. ET SUP. SONT: 
         FREQ_INF :  6.76126E+02
         FREQ_SUP :  7.32138E+02
   ------------------------------------------------------------------------
          CALCUL MODAL:  METHODE D'ITERATION SIMULTANEE
                         METHODE DE SORENSEN
   
       NUMERO    FREQUENCE (HZ)    NORME D'ERREUR
           11      6.76126E+02       2.43178E-15
           12      6.78594E+02       1.70196E-15
           13      7.32138E+02       1.40282E-15
    NORME D'ERREUR MOYENNE:  0.18455E-14
   ------------------------------------------------------------------------
             VERIFICATION A POSTERIORI DES MODES
   
      DANS L'INTERVALLE ( 6.74434E+02, 7.33966E+02) 
      IL Y A BIEN    3 FREQUENCE(S) 
   ------------------------------------------------------------------------
      
   !---------------------------------------------------------------------------------!
   ! <F> <ALGELINE5_75>                                                              !
   !                                                                                 !
   ! Le solveur modal utilisé par MODE_ITER_SIMULT n'a pas réussi à capturer tous    !
   ! les modes propres souhaités avec le niveau de convergence requis.               !
   ! Conseil:                                                                        !
   ! =======                                                                         !
   ! Relancer le calcul en tenant compte des précisions du message précédent.        !
   ! Pour améliorer la convergence des algorithmes modaux vous pouvez par exemple:   !
   !    - Diminuer le nbre de modes recherchés à chaque fois en découpant votre      !
   !      calcul modal en plusieurs bande (à la main ou via MACRO_MODE_MECA). Cela   !
   !      améliore aussi souvent grandement les performances des calculs.            !
   !    - Avec la méthode de Sorensen, augmenter la taille de l'espace de projection !
   !      (DIM_SOUS_ESPACE/COEF_DIM_ESPACE) ou jouer sur les paramètres numériques   !
   !       qui pilote la convergence (PREC_SOREN et NMAX_ITER_SOREN).                !
   !    - Avec la méthode QZ, diminuer NMAX_FREQ ou changer de variante (TYPE_QZ)    !
   (                                                                                 !
   ! Cette erreur est fatale. Le codes'arrete.                                       !
   !---------------------------------------------------------------------------------!
   
   SOURCES RESTITUEES
   ==================
   op0045.f, vpqzla.f
   algeline5.py
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    informatique, non-regression
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 015838 DU 2010-10-27 15:22:34
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Planton MUMPS sur Aster4 seq pour resoudre des systemes de taille 1
FONCTIONNALITE
   PROBLEME
   =========
      Sur Aster4, le solveur MUMPS plante salement lorsqu'il doit résoudre un système
      linéaire de taille 1.
   ANALYSE
   =======
     MUMPS plante dans la routine [SDCZ]MUMPS_181 du fait du défaut d'initialisation de
     la variable INBLEAF. Après avoir circonscrit le pb, je l'ai fait remonté à l'équipe
     de dévt de MUMPS qui m'a confirmé le diagnostic.
       --> C'est un pb qu'il avait déjà récemment identifié et qui sera corrigé ds leur
      prochaine release (dans 3 ou 4 mois). Mais il on apprécié ce Rex attentif :-) !
   
     Par chance, ce type de pb est trés peu courant ds les études. On s'en est 
     aperçut, que sur une plate-forme donnée, pour les cas-tests de calcul modal de
     modes généralisés qui sont branchés (depuis mi-octobre) automatiquement sur 
     MUMPS (chantier solveurs linéaires + solveurs modaux).
   
     On propose donc:
      - de ne pas surcharger la version de MUMPS actuelle et d'attendre leur prochaine
      release sachant que ce pb n'impacte que très rarement les études et il ne conduit
       pas à des résultats faux mais à un planton sec.
      - en cas de calcul modal + MATR_GENE, si l'utilisateur n'a pas choisit sciemment
       MUMPS ou LDLT, on continue de choisir pour lui l'un des 2. Mais au lieu de lui
       imposer MUMPS à tous les coup, on impose
              - LDLT si la taille du pb < 100,
              - MUMPS sinon.
   
     Du coup, j'ai changé le msg ALGELINE5_72
   
   72: _("""
       Les matrices utilisées ne s'appuient pas sur des données issues d'un maillage.
       Dans ce cas on doit utiliser, soit le solveur linéaire LDLT, soit celui MUMPS.
       On a donc changé le paramétrage pour vous et selectionné, suivant la taille du
       problème, l'un des deux solveurs préconisés.
       Conseil:
       ========
       La prochaine fois, dans une telle situation (NUME_DDL_GENE...), paramétrer
       explicitement SOLVEUR/METHODE='MUMPS' (problème de taille >100) ou 'LDLT'
       (problèmes de taille =<100).
   """),
   
     RQ/ Ce type de choix automatique pourrait être décliné ds le cas général avec un
      choix du solveur linéaire qui serait METHODE='AUTO'. A charge pour le code de
     choisir le bon solveur et sa bonne combinaison de paramètres en fonction des don
     nées du pb (taille, proportion de Lagranges, RAM disponible, symétrique...).
   
   VALIDATION
   ===========
     Cas-tests fdlv103a et fdlv100a.
   
   SOURCES RESTITUEES
   ==================
   crsvl2.f  op0032.f  op0044.f  op0045.f
   algeline5.py
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    informatique, non-regression
NB_JOURS_TRAV  : 1.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 015888 DU 2010-11-10 17:17:38
TYPE express concernant Code_Aster (VERSION 9.1)
TITRE
    Affichage faux ds le monitoring MUMPS (INFO=2)
FONCTIONNALITE
   PROBLEME
   =========
   L'affichage de la colonne du nbre de mailles ds le tableau de monitoring MUMPS
   (si SOLVEUR/METHODE='MUMPS' + INFO=2) était faux, en séquentiel comme en parallèle
   (qq soit les modes de //).Il s'agissait d'un compteur mal initialisé ds CRSVMU.f.
   
   VALIDATION
   ===========
     mumps01a et sdlx201a
   
   SOURCE RESTITUEE
   ================
   crsvmu
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    informatique, non-regression
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 015894 DU 2010-11-12 08:12:50
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.2.24, les cas-tests sdls105a, sdls105b et sdls107a s'arretent <F>_ABNORMAL_ABORT sur Aster 4.
FONCTIONNALITE
   ANALYSE
   ========
   Ce problème est résolu par solution apportée par la fiche 15888.
   
   VALIDATION
   ===========
     Cas-test sdls105a/b et sdls107a sur Aster4 (seq nodebug)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    informatique, non-regression
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desoza       DE SOZA Thomas         DATE 11/15/2010 - 04:27:08

--------------------------------------------------------------------------------
RESTITUTION FICHE 015848 DU 2010-10-29 07:25:56
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    contact mxc3xa9thode continue et routine MMEXCL
FONCTIONNALITE
   Anomalie
   ========
   
   La fiche 15685 ("validation élémentaire Valgrind") a permis de déceler une anomalie dans
   la routine MMEXCL lors du passage du cas-test ssnp121h.
   En effet, si on fait un print à la ligne 167 de NDFOND(IPTM), on s'aperçoit que IPTM prend
   des valeurs entre 1 et 10, or le tableau NDFOND est dimensionné en dur à 9.
   Question :  faut-il redimensionner NDFOND (9 -> 10), ou faut-il intervenir en amont sur la
   détermination de IPTM (IPTM=10 accepatble ou non) ?
   
   Remarque: Les routines dépendantes comme mmexcr et mmapre contiennent aussi des tableaux
   dimensionnés à 9
   
   Correction
   ==========
   
   On protège les appels à MMEXN1 et MMEXN2 dans MMEXCL : on ne fait appel à ces routines que
   pour les 9 premiers points d'intégration.
   Cela permet de ne pas impacter les tests tout en évitant les dépassements mémoires. Le
   fait de ne parcourir que les 9 premiers points d'intégration fonctionne car dans la
   routine qui déclare les points d'intégration (MMGAUS) on déclare toujours les vrais noeuds
   de la maille en premier.
   
   Remarque : cela n'explique pas pourquoi les schémas d'intégration différents de 'NOEUD'
   fonctionnent avec les fonctionnalités RACCORD_LINE_QUAD et FOND_FISSURE. À terme on
   envisagera la suppression de ces fonctionnalités ou au moins leur ré-écriture.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    astout continu
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 015864 DU 2010-11-04 10:53:22
TYPE aide utilisation concernant Code_Aster (VERSION 9.1)
TITRE
    Contact avec frottement (rxc3xa9f : AOM 15357)
FONCTIONNALITE
   AOM
   ===
   
   '''
   Bonjour,
   
   Je fais la référence de l'étude de contact avec frottement (AOM 15357 - l’interpénétration
   dans contact) qui traite l’interpénétration du noeud au bord de la surface esclave sur la
   surface maître. Je vous remercie d'avoir résoudre ce problème en proposant une solution
   assez fiable.
   
   Par ailleurs, j'ai continué la même étude en faisant translater la tige verticalement de
   façon cyclique (la même condition de contact avec frottement). Par conséquence, le calcul
   ne converge pas. J'ai fait un découpage de pas en temps de calcul du problème dans le
   fichier "include_tige_old.comm" mais le calcul converge dans le cas où le coefficient de
   frottement très faible (environ 0,01). 
   
   En outre, l'objectif de la simulation est de faire une étude paramétrique du coefficient
   de frottement (entre 0,05 et 0,4) aux interfaces tige/garniture, boîte/garniture et
   garniture/garniture. Ensuite, on étudie la distribution des contraintes le long du
   presse-garniture à la sortie de la simulation. Ci-joint les fichiers .comm et le maillage.
   '''
   
   Analyse
   =======
   
   Le calcul fourni par l'utilisateur fait suite à une AOM déjà réalisée et utilise la
   formulation continue. Il y a de nombreuses zones de contact, la plupart avec frottement
   (coefficient de Coulomb 0.1).
   Le calcul en STA10 ne converge plus à l'instant 1.0 avec un résidu relatif qui stagne
   (10^-5). Si on diminue le coefficient de Coulomb (0.01) alors il converge.
   
   En 10.2.9 on a corrigé plusieurs anomalies dans le traitement du frottement. Le calcul
   tourne ainsi parfaitement en NEW10 (ENDED OK).
   
   Je joins à la fiche la très légère modification à faire dans DEFI_LIST_INST pour faire
   passer de STA10 à NEW10 le fichier de commandes.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    xc3xa9tude jointe
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR elgharib     EL-GHARIB Joumana      DATE 11/16/2010 - 01:57:52

--------------------------------------------------------------------------------
RESTITUTION FICHE 015897 DU 2010-11-12 12:18:12
TYPE express concernant Code_Aster (VERSION 10.3)
TITRE
    Outil métier : Ajout de cas tests de charge limite tube et coude avec sous épaisseur
FONCTIONNALITE
   Ces cas tests sont crées pour qu'ils soient représentatifs des fichiers de commandes de
   charge limite dans l'outil métier à partir de Janvier 2010.
   
   Ajout du cas test ssep001 pour tube avec sous épaisseur
   modélisation a : charge limite inf
   modelisation b : charge limite sup
   Ajout du cas test ssep002 pour coude avec sous épaisseur
   modélisation a : charge limite inf
   modelisation b : charge limite sup
   
   charge limite inf : On calcule avec une approche par l'intérieur un minorant de la charge
   limite. On utilise la loi élastoplastique VMIS_ISOT_LINE avec pilotage de la pression
   interne par longueur d'arc. La pente de la courbe d'écrouissage est nulle.
   
   charge limite sup : On utilise la loi Norton_Hoff
   
   Les maillages correspondent à un tube et un coude avec sous épaisseur réelle (générés par
   l'outil métier). 
   
   Les maillages des cas tests sont faits exprès très grossiers pour que les temps
   d'execution des cas tests soient inférieurs à 300s. 
   
   Les nouveautés par rapport à la NEW9:
   on utilise la gestion automatique de la liste d'instants,
   on n'utilise pas la modélisation 3D_SI,
   pas de recherche linéaire avec Norton_Hoff.
   
   Dans ces fichiers, comme dans l'outil métier, on fait LINE_QUAD dans code_Aster. La
   génération des maillages quadratiques dans l'outil métier peut être longue si le maillage
   est très fin. 
   
   A voir en janvier 2010 :
   
   Créer les mailles points sans les scripts python pour éviter le message noeuds orphelins à
   la lecture des .med
   
   S'il faut rendre l'instant final comme donnée utilisateur. En effet, pour le 
   calcul de charge limite, il serait intéressant que le calcul s'arrête quand eta arrête
   d'évoluer.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : v1.02.101, v1.02.102
VALIDATION
    ssep001, ssep002
NB_JOURS_TRAV  : 3.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR greffet      GREFFET Nicolas        DATE 11/15/2010 - 05:41:42

--------------------------------------------------------------------------------
RESTITUTION FICHE 015154 DU 2010-06-04 06:08:58
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    creation d'un tran_gene avec REST_SPEC_TEMP
FONCTIONNALITE
   Depuis son implantation REST_SPEC_TEMP était censé pouvoir travailler sur des 
   structures de données résultats sur base physique ou modale :
   En effet sa syntaxe comporte en entrée, l'un des deux mot-clé suivant :
   RESU_GENE       =SIMP(statut='f',typ=(harm_gene,tran_gene,) ),
   RESULTAT        =SIMP(statut='f',typ=(dyna_harmo,dyna_trans,) ),
   En pratique cet opérateur n'avait été utilisé et testé que sur base physique 
   (cf. cas-test sdls119a).
   Irmela, en voulant l'utiliser sur base modale, a obtenu une erreur.
   
   Analyse du problème :
   la programmation sur base modale est incorrecte dès qu'on manipule une sd de 
   type tran_gene (que ce soit en lecture ou création). En effet c'est la seule sd 
   qui soit très différente des autres sd utilisables avec REST_SPEC_TEMP.
   Par exemple, tran_gene ne peut être créee par RSCRSD et ainsi de suite...
   Son mode de construction et de manipulation doit donc être programmé à part, en 
   reprenant ce qui est fait dans DYNA_TRAN_MODAL.
   
   Correction :
   on rajoute les traitements spécifique à tran_gene (impact sur ECRESU et PREFFT).
   On en profite aussi pour modifier SPDFFT afin de coller à la FFT de 
   CALC_FONCTION (point milieu du spectre : cf. t_fonction.py).
   
   On corrige aussi un petit bug dans la FFT de CALC_FONCTION (dans t_fonction.py).
   Le calcul de FFT avec CALC_FONCTION et option PROL_ZERO ne marche pas 
   correctement si le nombre d'échantillons du signal d'entrée est une puissance de 
   deux. En effet, dans ce cas on va prolonger jusqu'à la prochaine puissance de 
   deux supérieure.
   Nombre échantillon = 2^n, alors on prolonge avec des 0 jusqu'à 2^(n+1).
   C'est pas totalement faux, mais c'est pas ce qu'on attend...
   
   Dans t_fonction.py, le test fautif c'est celui là :
          if len(self.vale_y) < 2**(n+1):
   Le n est le plus grand entier tel que Nb échantillon (=len(self.vale_y)) soit 
   supérieur ou égal à 2^n. Donc en cas d'égalité : 
   len(self.vale_y) = 2**n et donc on a aussi len(self.vale_y) < 2**(n+1) ce qui 
   fait qu'on va prolonger le signal indûment.
   Je propose de corriger cela en remplaçant par le test suivant :
          if len(self.vale_y) > 2**n:
   La fiche 15038 devait corriger cela, mais il y a eu un petit raté...
   
   
   Impact sur les sources :
   prefft.f
   spdfft.f
   ecresu.f
   t_fonction.py
   
   Pas d'impact sur la doc : on met en fait le code en conformité avec sa doc...
   
   Validation :
   j'ai testé avec une version modifiée de sdls119a (qui est le seul cas-test 
   utilisant RESP_SPEC_TEMP mais sur base physique) et j'ai repassé tous les cas-
   tests faisant de la FFT (demo002a, miss07b, sdls119a, zzzz100b, zzzz241a)  pour 
   vérifier que les tests restaient OK.
   Je ne livre pas de cas-test sur base modale (sdls119a est déjà suffisamment 
   compliqué et long) car Irmela va livrer un vrai cas-test complet utilisant cette 
   fonctionnalité.
   
   Report en NEW9 :
   on reporte la correction de la FFT dans t_fonction.py : c'est très simple, il 
   faut juste reporter les corrections indiquées ci-dessus aux lignes 412 et 467.
   Pour REST_SPEC_TEMP lui-même on décide de ne pas reporter la correction. En 
   effet, les routines PREFFT et SPDFFT sont assez différentes. De plus aucune 
   utilisation sur base modale n'a eu lieu en NEW9.
   Afin de blinder le code, on va juste modifier le catalogue rest_spec_temp.capy 
   pour interdire la manipulation de sd sur base modale.
   Pour cela il suffit de retirer les quatre lignes suivantes :
     if AsType(RESU_GENE) == harm_gene    : return tran_gene
     if AsType(RESU_GENE) == tran_gene    : return harm_gene
     regles=UN_PARMI('RESU_GENE','RESULTAT'),
     RESU_GENE       =SIMP(statut='f',typ=(harm_gene,tran_gene,) ),
   et rendre le mot-clé RESULTAT obligatoire :
     RESULTAT        =SIMP(statut='o',typ=(dyna_harmo,dyna_trans,) ),
   
   Dans le fortran, si on veut être totalement rigoureux, il faudrait aussi retirer 
   les lectures du mot-clé RESU_GENE. Donc, dans OP0181, il faudrait retirer les 
   lignes suivantes :
         IF ( NVAL.EQ.0 ) THEN
            CALL GETVID(' ','RESU_GENE',1,1,1,RESIN,NVAL)
         ENDIF
   Et retirer la partie suivante du IF ligne 66  :
   .OR.(TYPRES(1:9).EQ.'HARM_GENE')
   Ensuite il faut retirer toutes les allusions à HARM_GENE et TRAN_GENE dans 
   ECRESU, et c'est tout.
   Je modifie la doc U4.63.34 en version 9 pour retirer les allusions au mot-clé 
   RESU_GENE (en v10 la doc reste OK telle qu'elle était).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    cas-test perso (basé sur sdls119a)
NB_JOURS_TRAV  : 5.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 014960 DU 2010-04-16 14:28:43
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Discrets + Amortissement
FONCTIONNALITE
   Résumé :
   cette fiche concerne la prise en compte de l'amortissement dû aux éléments 
   discrets dans un calcul avec DYNA_NON_LINE (DNL).
   
   Proposition de réponse à cette fiche :
   il n'y a pas d'anomalie à strictement parler, c'est plutôt un problème 
   d'utilisation pas totalement simple.
   
   Contexte :
   dans DNL, la prise compte des éléments discrets passe nécessairement par la 
   définition d'un matériau "bidon" affecté à ces mêmes discrets (ce matériau est 
   dit "bidon" car pour les discrets toutes les caractéristiques sont données en 
   fait par AFFE_CARA_ELEM). Ce matériau sert juste à passer certaines 
   vérifications dans le fortran.
   Dans DNL, la décision de construire la matrice d'amortissement globale est basée 
   sur la détection de la présence des mot-clés AMOR_ALPHA / AMOR_BETA qui sont les 
   paramètres de l'amortissement de Rayleigh (dans le DEFI_MATERIAU). Si le modèle 
   contient de l'amortissement défini par exemple par le biais de dashpots 
   (discrets), si l'utilisateur ne met pas AMOR_ALPHA / AMOR_BETA pour au moins un 
   élément de son modèle, alors la matrice d'amortissement ne sera pas du tout 
   assemblée. Ce fonctionnement avait déjà été abordé dans la fiche 11788.
   Pour conclure, si le système étudié contient des discrets qui seuls portent de 
   l'amortissement, alors il faudra quand même, d'une part leur associer un 
   matériau bidon (comme pour tout discret même sans amortissement), mais aussi 
   mettre AMOR_ALPHA = 0 et AMOR_BETA = 0.
   
   Documentation :
   La doc U2.06.13, page 12 explique tout cela. On ne dit rien là-dessus dans la 
   doc U4 de DNL car ce sont des infos qui ne peuvent apparaître dans la syntaxe 
   même de DNL.
   
   Conclusion :
   Cette fiche, en tant qu'anomalie peut être classée sans suite.
   
   Perspectives :
   Afin d'améliorer l'ergonomie, certaines des idées exposées ci-dessous (en 
   particulier par Jean-Luc) méritent d'être reprises dans un fiche d'évolution sur 
   ce sujet. On peut synthétiser tout cela en deux points :
   - améliorer la technique de détection de l'amortissement dans le modèle qui 
   arrive à DNL : recherche de toutes les possiblités d'amortissement : Rayleigh, 
   dashpots, frontières absorbantes...
   - pour les discrets, définition obligatoire d'un matériau spécifique DISCRET (en 
   lieu et place du matériau "bidon" actuel) pouvant porter des infos spécifiques 
   comme : AMOR=['OUI'|'NON']...
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    Sans objet
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR flejou       FLEJOU Jean Luc        DATE 11/15/2010 - 02:57:48

--------------------------------------------------------------------------------
RESTITUTION FICHE 015577 DU 2010-09-21 16:03:05
TYPE anomalie concernant Code_Aster (VERSION 10.2)
TMA : DeltaCad
TITRE
    Poutre MULTI_FIBRE ELAS+THERMIQUE
FONCTIONNALITE
   Objectifs
   ---------
   - Routine pmfcom: correction de l'anomalie concernant le calcul de la déformation
   thermique pour le comportement ELAS. 
   - Transfert dans les routines chapeaux (pmfcom,...) du calcul de la dilatation thermique
   qui est actuellement effectué dans les routines loi de comportement (nm1dis,...)
   
   Modifications
   -------------
   -> Routine pmfcom: le calcul de la déformation thermique pour le comportement ELAS.
   L'erreur est du au fait que l'on calculait la déformation thermique et non l'accroissement
   la déformation thermique. Il faut mettre à la ligne 115 de pmfcom, lors de l'appel à la
   routine VERIFM dans les arguments 'T' et non '+' 
   -> Transfert dans les routines chapeaux du calcul de la déformation thermique
   - Routine chapeaux concernées: pmfcom, nmco1d, nmpine, nmiclb, comcq1
   - Routines lois de comportement concernées
     'LABORD_1D'..........-> routine nmcb1d
     'PINTO_MENEGOTTO'....-> routine n1dpm
     'VMIS_CINE_LINE' ....-> routine nm1dci
     'VMIS_ISOT_LINE' ....-> routine nm1dis
     'GRAN_IRRA_LOG'  ....-> routine nm1vil
     'VISC_IRRA_LOG'  ....-> routine   "
   
   Validation
   ----------
   => Non-regression
   Passage des cas-tests utilisant les lois de comportements : 'LABORD_1D',
   'PINTO_MENEGOTTO', 'VMIS_CINE_LINE', 'VMIS_ISOT_LINE', 'GRAN_IRRA_LOG', 'VISC_IRRA_LOG' 
   => nouveau cas-test
   Création d'un nouveau cas-test hsll100a "Poutre multi-fibre bi-encastrée soumise à un
   champ de température",basé sur l'étude fournie. Dans ce cas-test on test :
   - Le comportement ELAS (Premier STAT_NON_LINE): résultat comparer a la solution analytique.
   - Le comportement VMIS_ISOT_LINE (Deuxième STAT_NON_LINE): 
   résultat comparer a la solution analytique. Pour ce calcul le comportement de la poutre
   est toujours élastique.
   
   Documentation
   -------------
   Création de la doc V7.16.100 correspondant au nouveau cas-test hsll100a
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 9.1.15
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 10.0.0
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V7.16.100
VALIDATION
    hsll100a
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR pellet       PELLET Jacques         DATE 11/15/2010 - 02:40:48

--------------------------------------------------------------------------------
RESTITUTION FICHE 015883 DU 2010-11-10 12:32:17
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    4 tests se plantent en 10.02.24 en // mpi : mumps04a, ssnl101a, ssnl125a et ssnv173i
FONCTIONNALITE
   Problème :
   -----------
   Les 4 tests ci-dessous se plantent en version 10.02.24 (version // mpi).
                                                                                            
                           
   mumps04a
   ssnl101a
   ssnl125a
   ssnv173i
                                                                                            
                           
   Le message d'erreur est :
     ! <F> <ALGORITH16_97>
     ! Il y a moins de GREL (1) dans le modèle que de processeurs participant au calcul (2).
   On ne peut pas distribuer les calculs élémentaires.
                                                                                            
                           
                                                                                            
                           
   Corrections :
   ------------
   1)  Je modifie ces tests pour qu'ils utilisent une autre forme de parallélisme.
   2)  Je modifie le texte de la macro MACR_LIGN_COUP pour forcer PARALLELISME='CENTRALISE'.
                                                                                            
                           
   Remarque :
   ----------
   Th De Soza est d'accord avec moi pour dire que les messages d'erreur <F>  ALGORITH16_93/97
    sont sans doute un peu abusifs. Si ces messages occasionnent d'autres problèmes et/ou
   fiches d'AL, on pourrait les basculer en <A>larme.
                                                                                            
                           
   93 : _("""
    Il y a moins de mailles (%(i1)d) dans le modèle que de processeurs participant au calcul
   (%(i2)d).
    
    Conseils :
      - vérifiez qu'un calcul parallèle est approprié pour votre modèle
      - diminuez le nombre de processeurs du calcul
   """),
    
   97 : _("""
    Il y a moins de GREL (%(i1)d) dans le modèle que de processeurs participant au calcul
   (%(i2)d). On ne peut pas distribuer les calculs élémentaires.
    
    Conseils :
      - diminuez le nombre de processeurs du calcul
      - changez le mode de distribution des mailles avec le mot-clé PARTITION/PARALLELISME de
   l'opérateur AFFE_MODELE (ou MODI_MODELE)
   """),
    
    
   Liste des fichiers impactés par la correction de la fiche:  15883
     macr_lign_coupe_ops.py
     mumps04a.comm  ssnl101a.comm  ssnl125a.comm  ssnv173i.comm
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    tests cassxc3xa9s
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 015887 DU 2010-11-10 16:34:08
TYPE express concernant Code_Aster (VERSION 9.1)
TITRE
    le fichier ssnv505a.mess fait plus de 1,3 Go
FONCTIONNALITE
   Problème:
   ---------
   ssnv505a.mess occupe 1,3 Go !
                                                                                            
                                                 
   Thomas et Mickael ont remarqué que j'avais laissé une "petite trace de debug" dans la
   routine resyme.f (impression des matr_elem non symétriques).
                                                                                            
                                                 
   ceci explique cela.
                                                                                            
                                                 
   Correction :
   ------------
   Je retire le "CALL UTIMSD" coupable.
    
    
   Liste des fichiers impactés par la correction de la fiche:  15887
     resyme.f
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    rien de particulier
NB_JOURS_TRAV  : 0.05
--------------------------------------------------------------------------------
RESTITUTION FICHE 015889 DU 2010-11-12 07:20:05
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.2.24, le cas-test zzzz256a est NOOK sur Bull, Rocks, Calibre 5 et Aster4
FONCTIONNALITE
   Problème :
   ----------
   Le test zzzz256a est NOOK en version 10.02.24 sur toutes les plateformes
                                                                                            
                           
   Correction :
   ------------
   Il s'agit d'une conséquence de la correction de l'AL 15846 (éléments discrets
   non-symétriques).
   Le te0141 a été modifié pour respecter la convention sur les matrices non-symétriques des
   éléments discrets (décrite dans la doc U d'AFFE_CARA_ELEM) : on donne les matrices par
   "colonnes".
                                                                                            
                           
   Un certain nombre de fichiers test.comm ont été modifiés pour tenir compte de cette
   correction.
   Le test zzzz256a a été oublié : il faut modifier son fichier .com
                                                                                            
                           
   Impact documentaire (doc D) :
   -----------------------------
   Il faut noter que la convention pour "donner" une matrice non symétrique dans
   AFFE_CARA_ELEM (par colonnes) est différente de celle de stockage des matrices
   élémentaires (par lignes).
   Cette dernière convention n'est écrite nulle part !
   Je propose de l'écrire dans D5.02.01 "Introduire une nouvelle grandeur"
                                                                                            
                           
   NEW9 :
   La correction de 15846 a été reportée en NEW9 mais il n'y a pas lieu de reporter cette
   correction en NEW9, car le test zzzz256a n'existe qu'en NEW10.
    
    
   Liste des fichiers impactés par la correction de la fiche:  15889
     zzzz256a.comm
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : D5.02.01
VALIDATION
    zzzz256a
NB_JOURS_TRAV  : 0.3
--------------------------------------------------------------------------------
RESTITUTION FICHE 015890 DU 2010-11-12 07:27:06
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.2.24, les cas-tests zzzz272a et zzzz272b s'arretent en <F>_ERROR sur Bull, Rocks, Calibre 5 et Aster 4
FONCTIONNALITE
   Problème :
   ----------
   En 10.02.24, les test zzzz272a/b s'arretent en erreur <F> sur toutes les plateformes
   (message CALCULEL2_5)
                                                                                            
                           
   Correction :
   ------------
   Il s'agit d'une légère erreur dans correction de la fiche 15718 :
   On a voulu interdire d'utiliser CREA_RESU / AFFE + champ de fonctions lorsque la grandeur
   XXXX_F est différente de DEPL_F, TEMP_F et PRES_F.
   Il y a une 4ème grandeur qu'il faut autoriser : FORC_F.
                                                                                            
                           
   Validation :
   ------------
   les tests cassés sont réparés.
                                                                                            
                           
   NEW9 :
   ------
   Comme la correction de 15718 a été reportée en NEW9, il faut faire de meme pour celle-ci :
   crtype.f :
   444c444
   < C              AUJOURD'HUI, SEULES TEMP_F, DEPL_F ET PRES_F SONT AINSI.
   ---
   > C              AUJOURD'HUI, SEULES 4 GRANDEURS SONT AINSI.
   446c446,447
   <      &      NOGDSI.NE.'PRES_F') CALL U2MESK('F','CALCULEL2_5',1,NOGDSI)
   ---
   >      &          NOGDSI.NE.'PRES_F'.AND.NOGDSI.NE.'FORC_F')
   >      &          CALL U2MESK('F','CALCULEL2_5',1,NOGDSI)
    
    
   Liste des fichiers impactés par la correction de la fiche:  15890
     crtype.f
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    tests cassxc3xa9s
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR sellenet     SELLENET Nicolas       DATE 11/15/2010 - 02:44:27

--------------------------------------------------------------------------------
RESTITUTION FICHE 015893 DU 2010-11-12 08:09:19
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW10.2.24, le cas-test ssll106f s'arrete en <F>_ERROR sur Bull MPI.
FONCTIONNALITE
   Problème :
   ----------
   Plantage de ssll106f en parallèle avec le message ALGORITH16_93 :
   """
   Il y a moins de mailles (1) dans le modèle que de processeurs participant au calcul (2). !
   """
   
   
   Solution :
   ----------
   On change le mode de distribution des mailles en le passant à CENTRALISE.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssll106f
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR moulin       MOULIN Stéphane       DATE 11/15/2010 - 04:18:57

--------------------------------------------------------------------------------
RESTITUTION FICHE 015176 DU 2010-06-09 13:41:38
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    poutre multifibres : arrêt en erreur en multi-matériau
FONCTIONNALITE
   Problème :
   ----------
   Il s'agit d'un problème relevé sur le forum.
   Si l'on utilise une poutre multi-fibre avec plusieurs matériaux dont au moins un qui
   utilise ALGO_1D='DEBORST', on rencontre une erreur dans la construction du matériau.
   
   Analyse :
   ---------
   Il s'agit d'un problème dans les poutres multi-fibres avec ALGO_1D='DEBORST' où l'on ne
   récupère que le 1er matériau. Il y a un commentaire dans le source qui décrit cette
   limitation.
   
   Solution :
   ----------
   Dans DEFI_COMPOR, Si on essaie de définir une poutre multi-fibre avec plusieurs matériaux
   dont au moins un qui utilise ALGO_1D='DEBORST', on émet une erreur fatale avec le message : 
   ...!-----------------------------------------------------------------------!
   ...!.<EXCEPTION>.<COMPOR1_15>..............................................!
   ...!.......................................................................!
   ...!.L'utilisation.de.lois.de.comportement.via.ALGO_1D='DEBORST'.nécessite.!
   ...!..d'avoir.un.seul.matériau.par.fibre!..................................!
   ...!-----------------------------------------------------------------------!
   De plus, on l'écrit dans la doc d'utilisation des poutres multi-fibres.
   
   La fiche issue15882 a été émise pour faire le développement des poutres multi-fibres
   multi-matériaux avec ALGO_1D='DEBORST'.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U3.11.07
VALIDATION
    sans objet
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST AJOUT hsll100a                    lebouvier F.LEBOUVIER        282    282      0
 CASTEST AJOUT sdll23c                      audebert S.AUDEBERT         524    524      0
 CASTEST AJOUT sdls112b                        bodel C.BODEL            254    254      0
 CASTEST AJOUT ssep001a                     elgharib J.EL-GHARIB        178    178      0
 CASTEST AJOUT ssep001b                     elgharib J.EL-GHARIB        176    176      0
 CASTEST AJOUT ssep002a                     elgharib J.EL-GHARIB        182    182      0
 CASTEST AJOUT ssep002b                     elgharib J.EL-GHARIB        176    176      0
 CASTEST MODIF mumps04a                       pellet J.PELLET           425      4      2
 CASTEST MODIF sdld25a                      audebert S.AUDEBERT         228     24      3
 CASTEST MODIF sdld301a                     audebert S.AUDEBERT         531      1      1
 CASTEST MODIF sdld30a                      audebert S.AUDEBERT        1660      9      9
 CASTEST MODIF sdll131a                     audebert S.AUDEBERT        1501      7      7
 CASTEST MODIF sdll23a                      audebert S.AUDEBERT         646     88     18
 CASTEST MODIF sdll23b                      audebert S.AUDEBERT         530    458     53
 CASTEST MODIF sdls112a                        bodel C.BODEL            427     21     14
 CASTEST MODIF ssll106f                     sellenet N.SELLENET         581      8      8
 CASTEST MODIF ssnl101a                       pellet J.PELLET           113      3      2
 CASTEST MODIF ssnl125a                       pellet J.PELLET           252      3      2
 CASTEST MODIF ssnv173i                       pellet J.PELLET           247      6      4
 CASTEST MODIF zzzz256a                       pellet J.PELLET           119      3      6
 FORTRAN MODIF algeline/op0032               boiteau O.BOITEAU          254      2      3
 FORTRAN MODIF algeline/op0044               boiteau O.BOITEAU          772      2      3
 FORTRAN MODIF algeline/op0045               boiteau O.BOITEAU         1225     10      9
 FORTRAN MODIF algeline/op0168                 bodel C.BODEL            472      4      3
 FORTRAN MODIF algeline/vpqzla               boiteau O.BOITEAU         1170     10      5
 FORTRAN MODIF algeline/vprecu                 bodel C.BODEL            281      2      2
 FORTRAN MODIF algeline/vpstor                 bodel C.BODEL            373     23      7
 FORTRAN MODIF algorith/arch93                 bodel C.BODEL            485     13      2
 FORTRAN MODIF algorith/asacce              audebert S.AUDEBERT         124      6      6
 FORTRAN MODIF algorith/ascalc              audebert S.AUDEBERT         332      3      3
 FORTRAN MODIF algorith/astron              audebert S.AUDEBERT         161      9      6
 FORTRAN MODIF algorith/crsvl2               boiteau O.BOITEAU          133     45      9
 FORTRAN MODIF algorith/crsvmu               boiteau O.BOITEAU          239      6      1
 FORTRAN MODIF algorith/crtype                pellet J.PELLET           519      4      3
 FORTRAN MODIF algorith/mmexcl                desoza T.DESOZA           194     11      1
 FORTRAN MODIF algorith/nm1dci             lebouvier F.LEBOUVIER        111      5      5
 FORTRAN MODIF algorith/nm1dis             lebouvier F.LEBOUVIER        161      5      5
 FORTRAN MODIF algorith/nm1dpm             lebouvier F.LEBOUVIER        406      5      7
 FORTRAN MODIF algorith/nm1vil             lebouvier F.LEBOUVIER        239      4      6
 FORTRAN MODIF algorith/nmco1d             lebouvier F.LEBOUVIER        155     11      5
 FORTRAN MODIF algorith/nmiclb             lebouvier F.LEBOUVIER        152      9      4
 FORTRAN MODIF algorith/nmpime             lebouvier F.LEBOUVIER        125      7      5
 FORTRAN MODIF algorith/op0109              audebert S.AUDEBERT         438      1      3
 FORTRAN MODIF assembla/resyme                pellet J.PELLET           148      3      3
 FORTRAN MODIF elements/comcq1             lebouvier F.LEBOUVIER        115      8      4
 FORTRAN MODIF elements/nmcb1d             lebouvier F.LEBOUVIER        126      6      5
 FORTRAN MODIF elements/pmfcom             lebouvier F.LEBOUVIER        318     31     15
 FORTRAN MODIF modelisa/op0059               tardieu N.TARDIEU          390     12      2
 FORTRAN MODIF utilitai/ecresu               greffet N.GREFFET          274    119     13
 FORTRAN MODIF utilitai/prefft               greffet N.GREFFET          288     48      4
 FORTRAN MODIF utilitai/spdfft               greffet N.GREFFET          167      8      1
  PYTHON MODIF Cata_Utils/t_fonction         greffet N.GREFFET          748      3      3
  PYTHON MODIF Macro/macr_lign_coupe_ops      pellet J.PELLET           982      4      2
  PYTHON MODIF Macro/macr_recal_ops           assire A.ASSIRE           685     52     31
  PYTHON MODIF Macro/reca_calcul_aster        assire A.ASSIRE           540     27     21
  PYTHON MODIF Macro/recal                    assire A.ASSIRE          1491     35     22
  PYTHON MODIF Meidee/meidee_cata              bodel C.BODEL           1309    131     82
  PYTHON MODIF Meidee/meidee_parametres        bodel C.BODEL            851    105     30
  PYTHON MODIF Messages/algeline5            boiteau O.BOITEAU          440     22      4
  PYTHON MODIF Messages/algorith16            pellet J.PELLET           494      7      3
  PYTHON MODIF Messages/compor1              tardieu N.TARDIEU          361      6      1
  PYTHON MODIF Messages/meidee0                bodel C.BODEL             54      1      5
  PYTHON MODIF Messages/recal0                assire A.ASSIRE           419     39     27


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :    7        1772      1772             +1772
 MODIF :   56       25981      1499     510      +989
 SUPPR :    0           0                 0        +0
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :   63       27753      3271     510     +2761 
