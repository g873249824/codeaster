

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 01/12/2008 - 14:03:10

--------------------------------------------------------------------------------
RESTITUTION FICHE 012866 DU 2008-11-20 10:50:41
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW 9.3.22, le cas-test comp002c s?arrete en ARRET_<A> sur Rocks.
FONCTIONNALITE
   idem 12867
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   non regression
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 012867 DU 2008-11-20 10:52:53
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW 9.3.22, le cas-test comp001f s?arrete en ARRET_<A> sur Rocks.
FONCTIONNALITE
   En fortran, on gère un tableau (&&SYS.KRESU) des concepts créés par les commandes dans
   lequel on stocke l'état du concept/de la commande. Exemple : &&ENCOURS, &&DETRUIT ou
   &&EXECUTE.
   Les macros ne sont donc pas comptées dans ce tableau.
   
   Dans FIN, on veut marquer les concepts temporaires (commençant par '.') comme &&DETRUIT.
   Or dans FIN, on utilise GETCMC qui va cherche l'attribut icmd de l'étape pour savoir
   combien d'étapes on a exécutées.
   Cet attribut est présent dans les étapes et les macro-étapes, il est donc incrémenté plus
   souvent que l'indice du tableau &&SYS.KRESU.
   Donc si on déborde du tableau et qu'on trouve le caractère '.' (d'où le caractère
   aléatoire du bug !), on écrit &&DETRUIT n'importe où...
   
   Le tableau &&SYS.KRESU est dimensionné à 500, puis agrandi par pas de 500. Pour que le bug
   puisse apparaitre, il faut que :
   nb_macro > nb_commandes modulo 500
   
   Je n'ai pas réussi à reproduire le plantage dû à l'écrasement sur ma machine, mais
   l'écrasement peut se détecter avec valgrind.
   
   Cette correction permet de passer le test ssnv166b (on constate qu'il ne plante plus avec
   la surcharge).
   Dans ce test, on a 574 étapes, 433 commandes donc 74 chances de cartonner une zone qui ne
   nous appartient pas !
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   comp001f
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 012868 DU 2008-11-20 10:56:44
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW 9.3.22, le cas-test ssnv166b s?arrete en ARRET_<A> sur Bull et Rocks.
FONCTIONNALITE
   La fiche 12867 corrige également ce test.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ssnv166b
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 012810 DU 2008-11-13 15:06:06
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW 9.3.21, le cas-test sslv130a s?arrete en ARRET_<A> sur Bull, Calibre 5 et Rocks.
FONCTIONNALITE
   Le test sslv130a plantait de manière un peu aléatoire et à des endroits différents selon
   le mode de lancement (PAR_LOT, SDVERI...).
   En général, l'erreur se produisait dans FIN en faisant échouer le garbage collector de python.
   
   L'erreur a pu être reproduite de manière plus fiable et surtout en mode debug en insérant
   un gc.collect entre chaque commande. Il n'y a pas de raison particulière mais en mode
   debug, valgrind a permis de détecter un 'Invalid write of size 4' dans cnsimp.
   Ce qui confirme pourquoi le test fonctionnait dès qu'on mettait INFO=1 dans AFFE_CHAR_CINE !
   
   Dans cnsimp (même bug corrigé dans cesimp), on utilise un tableau temporaire de K16. Or
   pour remplir ces chaines, on accède aux valeurs réelles via un tableau d'indirection.
   Mais il ne faut pas utiliser cette indirection pour remplir le tableau de K16 sinon on
   déborde !
   
   On corrige également des accès non initialisés :
   - op0166 et op0177, l'appel à psnoco/psrese (sensibilité) utilise un entier censé être une
   occurence de mot-clé facteur qui n'est pas initialisé (mais utilisé au moins pour en faire
   un PyInt)
   - lxscan : le booléen EXPNEG n'est pas toujours initialisé, on l'initialise à True :
   toutes les lectures de .mail !!
   
   onerrf : En mode debug jeveux, on imprime un message dans DEBUT avant d'avoir initialiser
   le comportement en cas d'erreur fatale. De ce fait, on était toujours en mode ABORT meme
   si on avait ERREUR_F=EXCEPTION dans le jdc.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sslv130a
NB_JOURS_TRAV  : 5.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 012904 DU 2008-11-28 09:47:10
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW 9.3.23, le cas-test sdnv105a est NOOK sur Calibre 4.
FONCTIONNALITE
   On augmente la tolérance à 3%.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sdnv105a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 012905 DU 2008-11-28 13:21:30
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Variables non initialis?
FONCTIONNALITE
   En examinant le test sdls112a :
   
   - harm75 qui lit NOM_CHAM et TOUT_CHAM, on utilise le code retour de GETVTX pour savoir
   combien on a lu de valeurs dans NOM_CHAM. On ignore les champs autres que DEPL, VITE, ACCE.
   
   - inistd : lecture maillage ideas. NOMAIL(22 à 28) n'était pas initialisés. On les met à ' '.
   - iradhs : on fait INDIC(ISU) avec ISU qui peut valoir 0. On ajoute un test supplémentaire
   "si ISU=0" (on fait comme quand INDIC(ISU)=0).
   
   - lridea : iocc de GETVID n'était pas initialisé à 1.
   - idem op0037
   
   - op0141 : exploiter le code retour de GETVID avant de tester la valeur (non) retournée.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sdls112a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR assire       ASSIRE Aimery          DATE 01/12/2008 - 14:03:12

--------------------------------------------------------------------------------
RESTITUTION FICHE 012892 DU 2008-11-26 14:17:39
TYPE evolution concernant Code_Aster (VERSION 7.0)
TITRE
   Ouverture de Stanley
FONCTIONNALITE
   Stanley repère si pylotage est installé pour choisir la configuration salomé ou gmsh.
   Si on a une configuration enregistrée, Stanley l'utilise en priorité.
   Cas particulier : si Stanley est lancé depuis Salome-meca, on force le mode Salome de Stanley.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   stanley
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR boyere       BOYERE Emmanuel        DATE 01/12/2008 - 14:03:12

--------------------------------------------------------------------------------
RESTITUTION FICHE 012902 DU 2008-11-27 18:01:46
TYPE express concernant Code_Aster (VERSION 9.3)
TITRE
   Commentaire malheureux dans GRAPPE_FLUIDE
FONCTIONNALITE
   Un mécanisme a été ajouté dans GRAPPE_FLUIDE pour arrêter le calcul des forces fluides
   lorsque la vitesse de la grappe s'arrête ou s'inverse car, alors, le calcul des forces
   fluides perd sa validité. Un message est alors émis et le calcul se poursuit sans les
   forces fluides tant que la chute n'a pas repris (vitesse de la grappe positive).
   Malheureusement un commentaire mal placé laissait le calcul GRAPPE_FLUIDE se poursuivre et
   menait plus loin à une erreur DVP2 plutôt que de laisser le calcul se terminer normalement
   laissant à l'utilisateur toutes les données pour analyser le cas.
   J'ôte le commentaire mal placé.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   xc3xa9tude
NB_JOURS_TRAV  : 3.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 012903 DU 2008-11-27 18:11:16
TYPE express concernant Code_Aster (VERSION 9.3)
TITRE
   test SHLL102 : validation de la gyroscopie en harmonique
FONCTIONNALITE
   On a récemment trouvé pourquoi DYNA_LINE_HARM donnait des résultats différents de ceux la
   référence dans le test SHLL102a.
   Il s'agit d'un calcul de ligne d'arbre avec gyroscopie.
   Le solveur par défaut de DYNA_LINE_HARM (MULT_FRONT) ne donne pas les bons résultats. En
   revanche les solveurs MUMPS et LDLT donnent des résultats cohérents avec ceux calculés par
   python. Ils collent maintenant à mieux que 0,2% par rapport à la référence (Rotor
   Dynamics, Lalanne & Ferraris) à l'exception d'une valeur (2%).
   
   
   J'en profite pour corriger une erreur dans le post-traitement des résultats issus de
   python. Cela menait à des imprécisions sur quelques valeurs.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   shll102a
NB_JOURS_TRAV  : 3.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desoza       DE SOZA Thomas         DATE 01/12/2008 - 14:03:12

--------------------------------------------------------------------------------
RESTITUTION FICHE 012894 DU 2008-11-26 17:47:47
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   Bug dans USURE (mxc3xa9thode CONTINUE)
FONCTIONNALITE
   Anomalie
   ========
   
   En debug_jeveux, les cas-tests d'usure ssnv128s, ssnv128t et ssnv128u sont NOOK (assez
   franchement sur certains tests).
   
   Analyse
   =======
   
   Dans la routine majusu, on met à jour des vecteurs JEVEUX destinés à être passés aux TE
   via la carte de contact. Or tous les JEVEUO sont fait en 'L' !
   
   Conclusion
   ==========
   
   Dans majusu.f, on passe une poignée de JEVEUO de 'L' vers 'E'. Cela corrige les tests.
   
   Résultats faux selon l'état de la mémoire. Pas de report en 8, usure introduite en 9.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 9.1.12
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ssnv128stu
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 012895 DU 2008-11-26 17:49:55
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   Bug avec mxc3xa9thode PENALISATION
FONCTIONNALITE
   Anomalie
   ========
   
   En utilisant la méthode de contact 'PENALISATION', on rencontre un message d'erreur JEVEUX
   (objet inexistant) qui semble se produire lorsque l'on décharge une structure.
   
   Analyse
   =======
   
   Il s'agit d'un bug dans l'algorithme de la méthode 'PENALISATION' avec contact et sans
   frottement. En effet quand il n'y a plus de liaisons actives (en décharge cela peut
   arriver), on ne construit pas la matrice qui vient enrichir la rigidité globale. On sort
   donc immédiatement de la routine mais on oublie de renseigner l'objet qui donne le nombre
   de liaisons actives.
   
   Or on se sert de cet objet plus loin pour savoir s'il faut faire la combinaisons linéaire
   de la matrice de rigidité globale et de la matrice de pénalisation ! 
   
   Conclusion
   ==========
   
   On corrige la routine algocp.f : au lieu de sortir immédiatement quand le nombre de
   liaisons actives est nul, on remplit l'objet ".COCO". avant.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   cas-test joint
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR greffet      GREFFET Nicolas        DATE 01/12/2008 - 14:03:13

--------------------------------------------------------------------------------
RESTITUTION FICHE 012899 DU 2008-11-27 14:07:28
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   Bug dans la routine UALFVA : passage matrice ligne de ciel vers morse (sparse)
FONCTIONNALITE
   Dans la routine UALFVA, on fait une boucle sur les lignes de la matrice :
            LDIAG=.TRUE.
            LPLEIN=.TRUE.
            DO 5,IEQ=1,NEQ
               IF (ZI(JSCHC-1+IEQ).NE.1) LDIAG=.FALSE.
               IF (ZI(JSCHC-1+IEQ).NE.IEQ) LPLEIN=.FALSE.
               IF (LDIAG) THEN
                  CALL CRSMOS(STOMOR,'DIAG',NEQ)
               ELSE
                  IF (LPLEIN) THEN
                     CALL CRSMOS(STOMOR,'PLEIN',NEQ)
                  ELSE
                     CALL ASSERT(.FALSE.)
                  ENDIF
               ENDIF
   
    5       CONTINUE
   Donc l'appel à CRSMOS a lieu à chaque ligne, ce qui ne sert à rien (cette 
   programmation n'a pas bougé depuis l'introduction de la routine en version 
   8.2.10) !
   On va même planter car on va refaire des CALL WKVECT sur des objets déjà 
   crées au premier tour de boucle (IEQ = 1). Les cas-tests passent car je 
   pense qu'on se limite au cas NEQ = 1...
   Il n'y a pas de résultat faux car on plante.
   
   En fait on doit appeler CRSMOS une seule fois, à la fin de l'analyse de la 
   matrice d'origine quand on sait si elle est pleine ou diagonale.
   On doit donc faire :
            LDIAG=.TRUE.
            LPLEIN=.TRUE.
            DO 5,IEQ=1,NEQ
               IF (ZI(JSCHC-1+IEQ).NE.1) LDIAG=.FALSE.
               IF (ZI(JSCHC-1+IEQ).NE.IEQ) LPLEIN=.FALSE.
    5       CONTINUE
            IF (LDIAG) THEN
               CALL CRSMOS(STOMOR,'DIAG',NEQ)
            ELSE
               IF (LPLEIN) THEN
                  CALL CRSMOS(STOMOR,'PLEIN',NEQ)
               ELSE
                  CALL ASSERT(.FALSE.)
               ENDIF
            ENDIF
   Il suffit de déplacer le CONTINUE... et de remercier Jacques pour son aide.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   Etude perso inspirxc3xa9e de sdnv106a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR proix        PROIX Jean-Michel      DATE 01/12/2008 - 14:03:13

--------------------------------------------------------------------------------
RESTITUTION FICHE 011797 DU 2008-02-22 09:35:14
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW9.2.11, le cas-test hsna104a est NOOK sur Rocks.
FONCTIONNALITE
   HSNA104A NOOK sur CLPASTER.
   
   Après invesgations de JP, MA, MC, JMP : il s'avère que c'est un problème de programmation
   dans la métallurgie, pour META_TRACTION, quand on reconstitue la courbe R(P,T) par
   interpolation ou extrapolation.
   
   Ce problème sera traité par la fiche 12915 (en 9.4.x)
   
   En attendant, pour la STA9.4, il suffit de mettre PROL_DROITE=PROL_GAUCHE=CONSTANT dans
   DEFI_NAPPE (au lieu de LINEAIRE) pour que ce soit OK.
   
   Cela semble faux depuis la 5.3.19 du 02/03/2000.
   
   Seule l'interpolation entre le point (0,0) et le premier point de la courbe R(p) de
   l'utilisateur est fausse, et seulement dans le cas où on interpole la courbe par rapport à
   la température (DEFI_NAPPE pour META_TRACTION).
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 5.3.19
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 5.3.19
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   hsna104a
NB_JOURS_TRAV  : 3.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 012900 DU 2008-11-27 14:45:45
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   ELAS dans GRAD_VARI
FONCTIONNALITE
   L'utilisation de la relation ELAS en modélisation GRAD_VARI induit une erreur 
   par "matrice non factorisable" sur les degrés de liberté de Lagrange.
   
   La relation ELAS n'a pas l'air d'être branchée sur ce type de modélisation bien 
   qu'aucun message d'alarme ou d'erreur ne soit renvoyé à l'utilisateur après 
   lecture du fichier de commande.
   
   Comme le dit Vincent, cette régularisation n'a pas de sens en élasticité (que
   régulariserait-on ? Il n'y a ni endommagement, ni déformation plastique...)
   
    Il faut donc l'empêcher. Il n'y a aucun impact sur les tests.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   pas de test
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR lefebvre     LEFEBVRE Jean-Pierre   DATE 01/12/2008 - 14:03:13

--------------------------------------------------------------------------------
RESTITUTION FICHE 012909 DU 2008-11-29 17:33:01
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   base hdf : portabilit?ass??
FONCTIONNALITE
   Le problème peut être contourné facilement en effectuant la poursuite en mode JEVEUX
   statique. Il s'agit d'une anomalie dans la routine JJHRSV lors de la relecture de la base
   HDF. Lors de l'appel à la routine JJLIDY (ligne 73) les arguments ont été intervertis.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test elementaire
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR pellet       PELLET Jacques         DATE 01/12/2008 - 14:03:14

--------------------------------------------------------------------------------
RESTITUTION FICHE 012913 DU 2008-12-01 08:04:02
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   problxc3xa8mes de codage en NEW9
FONCTIONNALITE
   Pour le cas de mdtr74, les concepts pulsatio et pulsat2, normalement communs à toutes les
   schémas d'intégration numérique, sont détruits par la méthode ITMI et recréés dans la
   routine mditmi.
   La méthode ITMI a une programmation qui manque de cohérence par rapport à l'architecture
   générale de DYNA_TRAN_MODAL. Toutefois, sa programmation est indépendante et ne semble pas
   mener à des destructions dangereuses d'objet.
   En revanche, on peut lui reprocher un manque certain de clarté.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   astout
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST MODIF hsna104a                     courtois M.COURTOIS        1171      3      3
 CASTEST MODIF mumps05a                     courtois M.COURTOIS         290      2      2
 CASTEST MODIF sdnv105a                     courtois M.COURTOIS        1336      2      2
 CASTEST MODIF shll102a                     courtois M.COURTOIS         417     18     34
 CASTEST MODIF ssnv128s                     courtois M.COURTOIS         200      1      1
 CASTEST MODIF ssnv128t                     courtois M.COURTOIS         202      1      1
 CASTEST MODIF ssnv128u                     courtois M.COURTOIS         225      1      1
       C MODIF supervis/astermodule         courtois M.COURTOIS        4161      8      4
       C MODIF utilitai/asterm              courtois M.COURTOIS         432      2      2
       C MODIF utilitai/iniast              courtois M.COURTOIS          60      2      2
 FORTRAN MODIF algeline/amogen              courtois M.COURTOIS         175      2      2
 FORTRAN MODIF algeline/op0037              courtois M.COURTOIS         656      2      1
 FORTRAN MODIF algeline/op0045              courtois M.COURTOIS        1167     25     20
 FORTRAN MODIF algeline/op0141              courtois M.COURTOIS         390      3      1
 FORTRAN MODIF algorith/algocp              courtois M.COURTOIS         370      2      3
 FORTRAN MODIF algorith/exfonc              courtois M.COURTOIS         255      2      2
 FORTRAN MODIF algorith/harm75              courtois M.COURTOIS         231     12      8
 FORTRAN MODIF algorith/lcmaza              courtois M.COURTOIS         610      2      2
 FORTRAN MODIF algorith/lcmzge              courtois M.COURTOIS         557      4      4
 FORTRAN MODIF algorith/lcvmgv              courtois M.COURTOIS         556      2      3
 FORTRAN MODIF algorith/majdva              courtois M.COURTOIS         151      2      2
 FORTRAN MODIF algorith/majusu              courtois M.COURTOIS         411      8     11
 FORTRAN MODIF algorith/nmgrfl              courtois M.COURTOIS         791      2      2
 FORTRAN MODIF algorith/nmvcmx              courtois M.COURTOIS         165      9     10
 FORTRAN MODIF algorith/op0166              courtois M.COURTOIS         259      2      1
 FORTRAN MODIF algorith/xconel              courtois M.COURTOIS         241      3      3
 FORTRAN MODIF assembla/ualfva              courtois M.COURTOIS         175      2      3
 FORTRAN MODIF calculel/cesimp              courtois M.COURTOIS         212      7      7
 FORTRAN MODIF calculel/cnsimp              courtois M.COURTOIS         188     12     12
 FORTRAN MODIF calculel/gverlc              courtois M.COURTOIS         146      2      2
 FORTRAN MODIF calculel/op0175              courtois M.COURTOIS         559      2      2
 FORTRAN MODIF calculel/op0177              courtois M.COURTOIS         221      2      1
 FORTRAN MODIF from_c/mumam                 courtois M.COURTOIS         300      1      3
 FORTRAN MODIF jeveux/jjhrsv                courtois M.COURTOIS          92      2      2
 FORTRAN MODIF modelisa/acearp              courtois M.COURTOIS         492      1     11
 FORTRAN MODIF prepost/iradhs               courtois M.COURTOIS         199     12      6
 FORTRAN MODIF prepost/lridea               courtois M.COURTOIS         570      2      1
 FORTRAN MODIF prepost/op0106               courtois M.COURTOIS         910      1      2
 FORTRAN MODIF stbtrias/inistb              courtois M.COURTOIS         348      9      1
 FORTRAN MODIF supervis/lxscan              courtois M.COURTOIS         309      2      1
 FORTRAN MODIF supervis/onerrf              courtois M.COURTOIS         101      2      2
 FORTRAN MODIF supervis/op9999              courtois M.COURTOIS         160      2      2
 FORTRAN MODIF utilitai/copisd              courtois M.COURTOIS         407      2      2
 FORTRAN MODIF utilitai/ecresu              courtois M.COURTOIS         161      1      2
  PYTHON MODIF Cata/ops                     courtois M.COURTOIS         481      1      1
  PYTHON MODIF Stanley/stanley              courtois M.COURTOIS        3178     13     14


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :    0           0         0                +0
 MODIF :   46       24688       200     204        -4
 SUPPR :    0           0                 0        +0
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :   46       24688       200     204        -4 
