========================================================================
Version 11.3.12 du : 06/03/2013
========================================================================


-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR alarcon      ALARCON Albert         DATE 03/04/2013 - 01:59:48

--------------------------------------------------------------------------------
RESTITUTION FICHE 020427 DU 2013-02-21 06:58:31
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    Titre de test erronxc3xa9 : sdld106a
FONCTIONNALITE
   Le titre du cas test n'a rien √† voir avec son contenu.
   
   Je change de:
   
   # TITRE VALIDATION INFORMATIQUE DE MACR_ADAP_MAIL
   
   √† 
   
   # TITRE SYSTEME MASSE-RESSORT-AMORTISSEMENT SOUS SOLLICITATION HARMONIQUE
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sdld106a
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------
RESTITUTION FICHE 020467 DU 2013-02-27 09:37:09
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    Erreur dans la programmation du calcul du pas de temps optimal des algorithmes de Runge-Kutta.
FONCTIONNALITE
   Probl√®me
   ----------------
   
   A l'√©criture de la doc R5.06.04 sur les sch√©mas en temps de Runge-Kutta dans DTM je me
   suis aper√ßu qu'il y avait une erreur dans la programmation de la formule qui calcule le
   pas de temps optimal qui doit √™tre th√©oriquement:
   
   dt_{opt}=0.9*dt*(1/err)^(1/(p+1))
   
   alors que dans la routine mdruku.f on avait cod√©:
   
   dt_{opt}=0.9*dt*(1/err)^(1/p)
   
   Modifications
   ----------------
   
   On modifie donc la routine mdruku.f en cons√©quence et les cas-tests suivants qui se sont
   vus impact√©s par cette modification (changements l√©gers des valeurs de TEST_RESU):sdld22b,
   sdld102a, sdld103a, sdld321b, sdld325a, sdld325b, sdnd104a.
   
   
   Impact doc
   ----------------
   
   Impacts associ√©s aux changements des valeurs de TEST_RESU: v5.06.04,
   v2.01.102,v2.01.321,v5.01.104
   
   Je profite √©galement de cette fiche pour clarifier une formulation de la doc r5.06.04
   (algos en temps de l'op√©rateur DTM).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : v5.06.04, v2.01.102,v2.01.321,v5.01.104,r5.06.04
VALIDATION
    sdld22b, sdld102a, sdld103a, sdld321b, sdld325a, sdld325b, sdnd104a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR assire       ASSIRE Aimery          DATE 03/04/2013 - 01:22:21

--------------------------------------------------------------------------------
RESTITUTION FICHE 020185 DU 2013-01-11 14:35:43
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    [FORUM] Erreur MACR_RECAL
FONCTIONNALITE
   Message du forum : http://www.code-aster.org/forum2/viewtopic.php?id=18475
   
   Un utilisateur avait un probl√®me avec MACR_RECAL (param√®tre dans une fonction).
   C'est une limitation indiqu√©e dans la doc et pour laquelle on pr√©conise de passer par le
   mode DISTRIBUTION. Apr√®s correction du .export, l'√©tude fonctionne bien.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    xc3xa9tude jointe
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR brie         BRIE Nicolas           DATE 03/05/2013 - 01:13:23

--------------------------------------------------------------------------------
RESTITUTION FICHE 020154 DU 2013-01-08 10:27:16
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Valider MACR_LIGN_COUPE sur mode_meca
FONCTIONNALITE
   -----------
   1. Objectif
   -----------
   Valider physiquement l'op√©rateur MACR_LIGN_COUPE sur un r√©sultat de type mode_meca,
   notamment avec le filtre d'acc√®s NUME_MODE.
   
   
   --------------
   2. R√©alisation
   --------------
   Le cas-test SDLS106 pr√©sente une configuration bien adapt√©e pour valider des d√©form√©es
   modales avec MACR_LIGN_COUPE. En effet, c'est une plaque rectangulaire simplement appuy√©e
   sur tous ses bords, et dans ce cas les modes propres peuvent se calculer analytiquement √†
   la fois en fr√©quences et en d√©form√©es (Blevins, Formulas for natural frequency and mode
   shape).
   On ajoute donc une mod√©lisation (h) au cas-test SDLS106. Dans toutes les autres
   mod√©lisations, le calcul des modes se faisait par sous-structuration. Dans cette nouvelle
   mod√©lisation, on fait le calcul de mani√®re directe. Il faut donc changer le titre du
   cas-test qui mentionnait explicitement la sous-structuration. Le nouveau nom du cas-test est :
   "Calcul modal d'une plaque rectangulaire simplement appuy√©e sur tous ses bords".
   
   On teste la d√©form√©e des modes 3 et 4 suivant trois lignes de coupe : la diagonale et les
   deux axes m√©dians de la plaque rectangulaire. Pour tester la distinction entre NUME_ORDRE
   et NUME_MODE, on d√©coupe le calcul des modes en deux MODE_ITER_SIMULT sur deux bandes
   adjacentes : l'un qui contient les deux premiers modes (concept dans lequel on a donc
   NUME_ORDRE = NUME_MODE) et l'autre qui contient les modes suivants (concept dans lequel on
   a donc NUME_ORDRE != NUME_MODE).
   
   -----------
   3. Impacts sur les sources
   -----------
   cr√©ation de sdls106h.comm et d'un maillage sdls106h.mmed associ√© (diff√©rent de ceux des autres
   mod√©lisations existantes).
   
   -----------
   4. Impacts documentaires
   -----------
   documentation V2.03.106 : modification du titre, du r√©sum√© et ajout d'une mod√©lisation.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V2.03.106
VALIDATION
    sdls106h
NB_JOURS_TRAV  : 2.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 020389 DU 2013-02-13 18:10:37
TYPE evolution concernant Code_Aster (VERSION )
TMA : Phimeca
TITRE
    NORM_MODE : pouvoir utiliser un GROUP_NO au lieu d'un NOEUD
FONCTIONNALITE
   1. Objectif:
   -----------
   Dans NORM_MODE, on peut donner des contraintes √† v√©rifier en un NOEUD donn√© : soit on
   force une composante donn√©e √† 1 quand le mot-cl√© NOEUD est un mot-cl√© principal, soit on
   force une composante donn√©e √† √™tre d'un SIGNE donn√© quand le mot-cl√© NOEUD est situ√© sous
   le mot-cl√© facteur MODE_SIGNE.
   
   Pour une meilleure ergonomie, il faut pouvoir fournir un GROUP_NO au lieu d'un NOEUD. Bien
   s√ªr, il faut que ce GROUP_NO contienne un seul noeud.
   
   
   2. R√©alisation:
   --------------
   
      - catalogue de commande de NORM_MODE :
   Ajout de GROUP_NO dans UN_PARMI('NORME','NOEUD','AVEC_CMP','SANS_CMP')
   Ajout GROUP_NO avec UN_PARMI(NOEUD,GROUP_NO) sous le mot-cl√© facteur MODE_SIGNE.
   
      - fortran de NORM_MODE (op0037) :
   Si pas de NOEUD renseign√©, appel √† la routine UTNONO pour r√©cup√©rer le noeud contenu dans
   le GROUP_NO. S'il y a plus d'un noeud dans le groupe, le message d'alarme SOUSTRUC_87 est
   √©mis.
   On en profite pour :
   - d√©clarer la variable NOEUD comme CH8 et non comme CH16
   - rendre plus clair le message SOUSTRUC_87 (et on modifie les quelques routines qui
   l'appellent)
   
   
   3. Validation:
   -------------
   - sdld02b : ajout de la cr√©ation de 2 groupes de noeuds et remplacement de NOEUD par GROUP_NO.
   - sdls106h : nouvelle mod√©lisation introduite aussi pour la fiche issue20154.
   
   
   4. Impacts sur les sources:
   ---------------------------
    * catalogue de commandes : norm_mode.capy
    * fortran : immeca.f    mdchge.f    op0037.f    orilgm.f    rfnoch.f
                rfrcha.f    rfresu.f    topoca.f    utreno.f
    * messages : soustruc.py (n¬∞87)
   
   5. Impacts documentaires:
   -------------------------
   Documentation Utilisateur de NORM_MODE : u4.52.11
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : u4.52.11
VALIDATION
    sdld02b, sdls106h
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR flejou       FLEJOU Jean Luc        DATE 05/03/2013 - 13:46:15

--------------------------------------------------------------------------------
RESTITUTION FICHE 019235 DU 2012-07-24 12:31:31
TYPE evolution concernant Code_Aster (VERSION )
TMA : Necs
TITRE
    GROT_GDEP sur tous les ÈlÈments de poutre POU_D_E, POU_D_T et POU_D_TG.
FONCTIONNALITE
   But :
   ===
   Ajouter la DEFORMATION = GROT_GDEP aux ÈlÈments de poutre POU_D_E, POU_D_T et POU_D_TG.
   
   Travail effectuÈ : 
   ================
   
   DÈveloppements :
   --------------
   
   1/ Remplacement de PETIT_REAC par GROT_GDEP
   2/ Ajout de la rÈactualisation de l'orientation dans les options FORC_NODA quand cela
   n'existait pas (appel ‡ la nouvelle routine porea2.f)
   3/ Correction de la rÈactualisation de l'angle de vrille GAMMA comme cela a ÈtÈ fait pour
   les POU_D_TGM (appel ‡ porea1.f pour les options FULL_MECA RAPH_MECA et RIGI_MECA_TANG,
   appel ‡ porea2.f pour FORC_NODA)
   4/ Calcul de la matrice de rigiditÈ gÈomÈtrique pour les options FULL_MECA et
   RIGI_MECA_TANG en recopiant dans les te en question ce qui est fait dans l'option
   RIGI_MECA_GE (te0143).
   
   
   DÈtails des modifs et ajouts :
   
   dismmo.f : ajout de exi_str2 (dans le cas ou on veut calculer l'option STRX_ELGA)
   dismlg.f : EXI_STR2 correspond uniquement au POU_D_EM
   op0046.f : remplacement de exi_strx par exi_str2
   op0048.f : remplacement de exi_strx par exi_str2
   ccfnrn.f : remplacement de exi_strx par exi_str2
   te0023.f : option INI_STRX, ajout des autres poutres et initialisation en copiant PCAORIE.
   te0346.f : FULL_MECA pour les POU_D_TG -> matrice de rigiditÈ geometrique + appel ‡ POREA1
   te0347.f : FORC_NODA pour POU_D_E POU_D_T POU_D_TG -> appel ‡ POREA2
   te0247.f : FULL_MECA pour POU_D_E POU_D_T -> matrice de rigiditÈ geometrique + appel ‡ POREA1
   te0517.f : FORC_NODA pour PMF, gros mÈnage, suppression des VARI_ELNO qui n'a rien ‡ faire
   la + appel ‡ POREA2
   te0156.f : FULL_MECA pour POU_D_TGM, appel ‡ porea1.f
   
   porea1.f : actualisation de la gÈometrie pour FULL_MECA
   porea2.f : actualisation de la gÈometrie pour FORC_NODA
   
   element3.py : ajout de message 40
                 suppression de message 78
                 suppression de message 58
   
   element4.py : suppression de message 15, en doublon avec elements3_40
                 suppression de message 16 (VARI_ELNO)
   
   
   EXI_STR et EXI_STR2 :
   ===================
   EXI_STR  : pour tous les ÈlÈments utilisant le champs STRX_ELGA
   EXi_STR2 : pour les ÈlÈments calculant l'option STRX_ELGA
   
   
   
   Cas tests :
   
   sdnl102a : utilisait PETIT_REAC on remplace par GROT_GDEP -> OK
   
   
   Validation :
   ----------
   On crÈe de nouvelles modÈlisations au test ssnl133 :
   c -> POU_D_TG
   d -> POU_D_T
   e -> POU_D_E
   
   Ce test valide GROT_GDEP pour les POU_D_TGM par comparaison ‡ la modÈlisation POU_D_T_GD.
   Les TEST_RESU sont tous OK pour chacun des 3 tests.
   
   Impact doc :
   ==========
   Doc V : V6.02.133
   
   Doc R :  R3.08.09 - Poutres multi-fibres en grands dÈplacements
   Cette doc est renommÈe et reprise pour Ítre commune ‡ tous les ÈlÈments de poutres sauf
   les POU_D_T_GD.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V6.02.133 , R3.08.09
VALIDATION
    ssnl133c,d,e
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR assire       ASSIRE Aimery          DATE 05/03/2013 - 13:46:16

--------------------------------------------------------------------------------
RESTITUTION FICHE 018798 DU 2012-04-28 16:55:44
TYPE evolution concernant Code_Aster (VERSION )
TMA : Necs
TITRE
    CALC_EUROPLEXUS : utiliser l'API Python de MED
FONCTIONNALITE
   Contexte :
   ========
   
   Pour relire les champs de contraintes et de variables internes contenus dans le fichier
   MED issu d'EPX, la macro-commande CALC_EUROPLEXUS utilise un mÈcanisme de try/except avec
   des appels ‡ LIRE_CHAMP dans le fichier MED.
   Les choses sont faites ainsi car on ne connait pas d'avance ni le nombre de champs de
   contraintes et de variables internes ni les noms des composantes de ces champs.
   
   Sur demande d'Aimery, Nicolas Sellenet a crÈÈ le module med_aster_module.c qui pour un
   fichier med donnÈ renvoie la liste des noms des champs contenu dans le fichier. Ce module
   est dÈj‡ prÈsent dans le code.
   
   Demande :
   =======
   Utiliser le module med_aster_module.c de Aster afin de supprimer le mÈcanisme de
   try/except pour la rÈcupÈration des champs de contraintes et de variables internes.
   
   
   Travail effectuÈ :
   ================
   
   Pour faire cela il faut disposer des noms des champs mais aussi des noms des composantes
   des champs.
   Mais dans EPX les composantes des contraintes sont notÈes : SIG1, SIG2, SIG3 .....
   et les composantes des variables internes : VAR1, VAR2 ....
   Ainsi il suffit de disposer du nombre de composantes pour connaÓtre leurs noms.
   
   Pour cela, on a modifiÈ le module med_aster_module.c pour qu'il retourne un dictionnaire
   {nom de champs : tuple avec les noms de composantes} au lieu de la liste des noms de champs.
   
   Avec ces informations, on peut supprimer les try/except dans calc_europlexus_ops.py.
   
   ConsÈquences :
   
   - le code est plus clair
   - on peut supprimer les MasquerAlarme MED_83, MED_98, MED_54, MED_77 et MED_37.
   - pas de gain de temps de calcul (contrairement ‡ ce qu'on a pu espÈrer lors de l'Èmission
   de cette fiche)
   
   Sources impactÈes : med_aster_module.c, calc_europlexus_ops.py
   
   Validation : passage de tous les tests plexu*
   
   Impact doc : Aucun
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    plexu*
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR cuvillie     CUVILLIEZ Sam          DATE 03/04/2013 - 02:47:24

--------------------------------------------------------------------------------
RESTITUTION FICHE 020473 DU 2013-02-27 14:32:37
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    DEFI_FISS_XFEM_floating point
FONCTIONNALITE
   Probl√®me :
   -----------
   
   Erreur d'utilisation.
   
   Dans CALC_G , depuis la version 11.2.7, la syntaxe √† adopter sous le mot cl√© facteur THETA
   n'est pas la m√™me selon que le r√©sultat renseign√© sous le mot cl√© RESULTAT provienne d'un
   calcul FEM ou d'un calcul X-FEM. Plus pr√©cis√©ment :
   
    . 1. dans le cas d'une fissure maill√©e
    . ----------------------------------
   
    . - appel √† STAT_NON_LINE ou MECA_STATIQUE, 
    . - appel √† DEFI_FOND_FISS pour d√©finir les caract√©ristiques de la fissure qui seront
   utilis√©es par CALC_G
    . - appel √† CALC_G, en renseignant le mot cl√© FOND_FISS du mot cl√© facteur THETA
   
    . 2. dans le cas d'un r√©sultat X-FEM :
    . ---------------------------------------
   
    . - appel √† DEFI_FISS_XFEM + MODI_MODELE_XFEM
    . - appel √† STAT_NON_LINE ou MECA_STATIQUE, 
    . - appel √† CALC_G, en renseignant le mot cl√© FISSURE du mot cl√© facteur THETA
   
   L'utilisateur se trouve en STA11 dans la configuration 1., il ne faut donc pas appeler
   DEFI_FISS_XFEM. Il se trouve qu'une anomalie (issue20380) non encore corrig√©e dans
   DEFI_FISS_XFEM √† fait planter le code avant l'appel √† CALC_G. Sans cette anomalie, le code
   se serait arr√™t√© proprement en erreur fatale dans CALC_G avec le message utilisateur suivant :
   
   ¬´ Lorsque le mod√®le n'est pas de type X-FEM il n'est pas possible d'utiliser
   le mot-cl√© FISSURE de la commande CALC_G.
   -> Risque et Conseil :
   Veuillez utiliser les mots-cl√©s FOND_FISS ou THETA ou revoir votre mod√®le. ¬ª
   
   Impact :
   ---------
   
   Aucun, les docs U4.82.03 (op√©rateur CALC_G) et U2.05.01 (Notice d'utilisation des
   op√©rateurs de m√©canique de la rupture pour l'approche classique) sont claires sur ce point
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    aucun
NB_JOURS_TRAV  : 0.25
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desoza       DE SOZA Thomas         DATE 05/03/2013 - 13:12:54

--------------------------------------------------------------------------------
RESTITUTION FICHE 020449 DU 2013-02-22 16:29:30
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    Fuite m√©moire dans te0347
FONCTIONNALITE
   '''
   Si on ajoute √† la ligne 152 de te0347.f la ligne suivante :
   CALL JEVECH ( 'PCOMPOR', 'L', ICOMPO )
   ou 
   CALL TECACH('ONN','PCOMPOR','L',1,ICOMPO,IRET)
   
   Le test zzzz234a plante en floating point exception.
   
   En regardant de plus pr√®s on voit que la valeur de XL est modifi√©e lors de l'appel √† RCVALB.
   '''
   
   Le code retour IRET donn√© √† RCVALB est de taille 1 alors que 2 valeurs sont √©crites (pour
   E et NU) d'o√π un √©crasement.
   
   La correction de ce bug est prise en compte dans issue19235.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    perso
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 020415 DU 2013-02-19 12:59:59
TYPE aide utilisation concernant Code_Aster (VERSION 10.5)
TITRE
    Am√©lioration du calcul des r√©sultantes FORC_NODA
FONCTIONNALITE
   Contexte
   ========
   
   '''
   Dans le cadre des mod√©lisations que nous menons au Centre d'Ing√©nierie Hydraulique, nous
   avons souvent 
   besoin de connaitre de mani√®re exacte les transmissions d'efforts entre les diff√©rentes
   parties des 
   structures (notamment r√©sultantes des efforts transmis du barrage vers sa fondation
   rocheuse). Pour cela, 
   nous utilisons FORC_NODA, cependant les r√©sultats sont inexacts et il n'est pas rare de
   d√©tecter des erreurs 
   allant jusqu'√† 5%.
   
   Je vous joins un fichier avec le cas d'un ouvrage r√©el. Le barrage a un volume de
   3,53203E4 m3, une masse 
   volumique de 2400 kg/m3 et une constante de pesanteur de 9,81 sont prises en compte, la
   r√©sultante devrait 
   donc √™tre de 8,31581E8 N. le calcul FORC_NODA donne une r√©sultante de 8,22676E8 N, soit
   une erreur de 1,1%.
   '''
   
   Explication
   ===========
   
   Les √©carts constat√©s en calculant la r√©sultante suivant Z du champ de forces nodales sont
   normaux et li√©s aux charges r√©parties dont la pesanteur est un cas particulier.
   
   En √©l√©ments finis, les charges r√©parties se traduisent par l'application d'une force en
   **chacun** des noeuds de la zone charg√©e. Cette force d√©pend de la taille des √©l√©ments qui
   concourent en ce noeud.
   
   Le champ FORC_NODA dans Code_Aster est un champ de vecteurs qui englobe les forces nodales
   en chaque noeud du mod√®le. √Ä convergence, ce champ ne contient plus que les forces issues
   du chargement ext√©rieur et des r√©actions d'appui :
   
   1. Pour un FORC_NODA calcul√© sur le mod√®le complet, les r√©actions d'appui correspondent
   aux efforts au niveau des conditions aux limites.
   2. Pour un FORC_NODA calcul√© sur une partie isol√©e du mod√®le (avec CALC_CHAMP/GROUP_MA),
   les r√©actions d'appui correspondent √† l'effort exerc√© par le reste de la structure sur la
   partie isol√©e.
   
   Ainsi en pr√©sence d'un chargement de pesanteur, lorsque l'on se place √† l'interface entre
   la partie isol√©e et le reste de la structure (groupe 'CONTACT' dans le cas transmis), les
   forces nodales sont constitu√©es √† la fois de la r√©action du reste de la structure et d'une
   contribution au chargement de pesanteur (d'autant plus petite que les mailles limitrophes
   de l'interface sont petites). Lorsque l'on calcule la r√©sultante on ne trouve donc pas
   exactement le poids de la structure.
   
   ==> J'ai illustr√© cette particularit√© sur un exemple tr√®s simple d'une poutre √† 4 √©l√©ments
   charg√©e sur une seule moiti√©, cf. PDF joint. On voit que sur le noeud 3, F3 qui est la
   r√©sultante sur l'interface n'est pas √©gale au poids de la structure charg√©e (25% d'erreur
   pour un maillage d√©coup√© en 4).
   
   Solution
   ========
   
   Pour pallier cela, il suffit de retirer les forces nodales issues du chargement de
   pesanteur, c'est exactement ce √† quoi sert l'option REAC_NODA.
   En calculant la r√©sultante des REAC_NODA, on retrouve le r√©sultat attendu.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : U4.81.04
VALIDATION
    √©tude jointe
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 020412 DU 2013-02-19 10:18:07
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    faute de frappe dans dxtbm.f
FONCTIONNALITE
   On corrige une coquille (sans cons√©quence) dans la routine de calcul de la matrice de
   membrane des √©l√©ments de plaque triangulaires (dxtbm.f).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    n√©ant
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 016860 DU 2011-05-02 11:28:32
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    CTC5 - Recherche lineaire dans l'algorithme de projection du contact
FONCTIONNALITE
   Contexte
   ========
   
   La fiche issue16830 a montr√© des d√©fauts dans l'algorithme de projection actuel pour le
   contact. En particulier dans certaines situations (notamment projection sur un quadrangle
   distordu) on constate que l'algorithme trouve une solution de tr√®s mauvaise qualit√© bien
   que celle-ci v√©rifie parfaitement le crit√®re de convergence.
   
   L'analyse du probl√®me a conduit √† pointer les d√©fauts suivants :
   - le point de d√©part de l'algorithme a une influence importante sur la solution obtenue
   (on est dans un cas o√π l'unicit√© n'est plus garantie)
   - d√®s la 2√®me it√©ration de Newton, l'it√©r√© produit est tr√®s mauvais et tr√®s en dehors de
   l'√©l√©ment de r√©f√©rence
   
   Concernant le premier point, il est difficile de faire mieux que ce qu'il y a actuellement
   : prendre le point de coordonn√©es param√©triques (0,0).
   S'agissant du second point, on propose dans cette fiche une am√©lioration de l'algorithme.
   
   D√©tails
   =======
   
   On a ajout√© √† l'algorithme de Newton r√©alisant la projection la capacit√© de faire de la
   recherche lin√©aire.
   Le type de recherche lin√©aire choisi est dit "√† rebroussement" et est calqu√© sur celui
   implant√© dans l'algorithme de Newton d'int√©gration du comportement (PLASTI, d√©crit dans
   R5.03.14). Avec cette recherche lin√©aire, on ne cherche un param√®tre d'avancement que dans
   la gamme [0,1], ce qui est coh√©rent avec l'id√©e d'emp√™cher l'algorithme de trop s'√©loigner
   de la maille de r√©f√©rence.
   
   Le param√®tre d'avancement choisi est construit par approximation quadratique ou cubique de
   la fonctionnelle √† annuler. On commence toujours par tester un param√®tre d'avancement √©gal
   √† 1. Le crit√®re de choix s'appuie sur la r√®gle d'Armijo.
   
   Utilisation
   ===========
   
   La recherche lin√©aire est activ√©e automatiquement sans action de la part de l'utilisateur.
   Par ailleurs cet apport de robustesse a conduit √† r√©activer l'erreur fatale en cas d'√©chec
   de la projection (auparavant on s√©lectionnait l'it√©r√© minimisant la distance au cours des
   it√©rations).
   
   Validation
   ==========
   
   L'int√©gralit√© des tests faisant appel √† l'appariement ont √©t√© pass√©s avec succ√®s (353 tests).
   
   Performances
   ============
   
   Cet ajout √† l'algorithme d√©grade tr√®s l√©g√®rement les performances. Sur le test SSNP157A
   qui r√©alise plus de 200 appariements on passe d'environ 21s √† 23s pour l'appariement mais
   cette variation est du m√™me ordre que celle li√©e √† la reproductibilit√© des temps.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : R5.03.50
VALIDATION
    astout contact
NB_JOURS_TRAV  : 2.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR geniaut      GENIAUT Samuel         DATE 03/05/2013 - 01:23:34

--------------------------------------------------------------------------------
RESTITUTION FICHE 020454 DU 2013-02-25 12:53:05
TYPE anomalie concernant Code_Aster (VERSION 11.4)
TITRE
    MAC3COEUR : perte de temps dans les sous-decoupage des pas de temps
FONCTIONNALITE
   Dans MAC3COEUR, on utilise en dur : ITER_GLOB_MAXI = 30 lors des appels √† STAT_NON_LINE.
   Cette valeur est pass√©e de 10 √† 20 (en 11.1.22) puis de 20 √† 30 (en 11.1.23) mais la
   raison n'a pas √©t√© indiqu√©e.
   
   Cela occasionne une perte de temps non n√©gligeable lors de la sous-d√©coupe du pas de
   temps, car d√®s les 6-7 premi√®res it√©rations de Newton, on voit que l'on ne convergera pas.
   
   De plus, de mani√®re g√©n√©rale, la convergence (quand elle a lieu) se fait en maximum 7
   it√©rations. Il n'y a donc aucune raison de choisir ITER_GLOB_MAXI = 30.
   
   
   -> on remet la valeur par d√©faut (ITER_GLOB_MAXI = 10).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    tests mac3*
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR perony       PERONY Raphael         DATE 03/05/2013 - 01:23:35

--------------------------------------------------------------------------------
RESTITUTION FICHE 020476 DU 2013-02-27 16:56:01
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    MAC3COEUR : retrait du contact qu'au dernier STAT_NON_LINE
FONCTIONNALITE
   Suite aux fiches issue19170 et issue19812, la simulation d'un cycle d'irradiation se
   d√©compose en 3 STAT_NON_LINE :
     --> Le 1er STAT_NON_LINE simule : fermeture de cuve + mont√©e en temp√©rature + 100%PN +
   descente en temp√©rature
     --> Le 2√®me STAT_NON_LINE simule une 1√®re partie de l'ouverture de cuve : on rel√¢che les
   contacts entre assemblages et on relache progressivement la fl√®che des ressorts de
   maintien de 2 tiers.
     --> Le 3√®me STAT_NON_LINE simule une 2√®me partie de l'ouverture de cuve : on retire le
   chargement de maintien (d√©charge "brusque")
   
   
   Le SEPTEN a observ√© des probl√®mes de convergence lors du 2√®me STAT_NON_LINE.
   Pour r√©soudre le probl√®me, nous proposons de ne rel√¢cher les contacts entre assemblages
   qu'au dernier STAT_NON_LINE, ce qui est d'ailleur plus r√©aliste.
   
   Impact sur le fichier calc_mac3coeur_ops.py : dans le 2√®me STAT_NON_LINE, on remplace
   "CHAM_MATER=_AF_MSC" par "CHAM_MATER=_AF_MAC".
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    tous les cas test mac3coeur
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 020468 DU 2013-02-27 09:58:51
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    MAC3COEUR : mise √† jour des fl√®ches des ressorts de maintien
FONCTIONNALITE
   Suite aux fiches issue19170 et issue19812, l'objet de cette fiche est de mettre 
   √† jour la valeur des fl√®ches des ressorts de maintien, √† la fermeture de la 
   cuve, pour les palier CPY et 1300 MWe.
   
   Fichiers impact√©s :
   Coeur_900.datg, Coeur_1300.datg
   
   La note associ√©e pour le descriptif des ph√©nom√®nes physiques est la suivante :
   H-T64-2012-01646-FR.
   Cette note sert de validation pour les simulations sur les paliers CPY et 1300MWe.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    tous les cas test mac3coeur
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 020458 DU 2013-02-26 15:25:48
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Extension au cas mono-assemblage de PERM_MAC3COEUR
FONCTIONNALITE
   Suite √† l'extension de CALC_MAC3COEUR au cas mono-assemblage (cf. issue20143) et afin de
   simuler plusieurs cycle de fonctionnement, il est √©galement n√©cessaire d'√©tendre
   PERM_MAC3COEUR au cas mono-assemblage.
   
   Concr√®tement, ce (mono-)assemblage est permut√© avec lui m√™me, mais il s'agit surtout de
   cr√©er un √©tat initial lisible par le mot cl√© RESU_INIT de CALC_MAC3COEUR.
   
   Impact sur le fichier perm_mac3coeur.capy : On ajoute simplement "MONO" comme valeur
   possible de TYPE_COEUR.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : U4.90.13
VALIDATION
    mac3c03a
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR martin       MARTIN Alexandre       DATE 03/04/2013 - 02:27:21

--------------------------------------------------------------------------------
RESTITUTION FICHE 020380 DU 2013-02-12 14:40:09
TYPE anomalie concernant Code_Aster (VERSION 11.3)
TITRE
    X-FEM : am√©lioration du "Fit-To-Vertex" en quadratique
FONCTIONNALITE
   Probl√®me :
   ----------
   
   Dans le calcul propos√©, le code s'arr√™te dans DEFI_FISS_XFEM sur une "Floatting Point
   Exception".
   
   Analyse :
   ---------
   
   Une premi√®re analyse men√©e par Samuel a permis d'identifier que le probl√®me se situ√©e dans
   la routine xajuls, lors de l'√©tape de "fit to vertex" pour les noeuds milieux des √©l√©ments
   quadratiques. L'algorithme utilis√© dans cette √©tape est le suivant. On a calcul√© les
   maxima lsnmax et lstmax des valeurs absolues des level-sets normales et tangentes,
   respectivement. On compare lsn(M)/lsnmax et lst(M)/lstmax au seuil fix√© pour savoir si on
   doit ramener lsn(M) ou lst(M) √† z√©ro.
   
   La fissure d√©finie par l'utilisateur est telle que la level-set tangente est nulle sur
   toute une partie du bord de la pi√®ce. Pour les mailles situ√©es dans cette partie du bord,
   on a lstmax = 0 et l'√©valuation de lst(M)/lstmax provoque donc une division par 0.
   
   Correction :
   ------------
   
   Apr√®s avoir essay√© plusieurs d√©marches, j'ai choisi d'appliquer une strat√©gie propos√©e par
   Samuel. On peut avoir lsnmax = 0 ou lstmax = 0 seulement dans le cas des mailles de bord.
   Or, il n'est pas n√©cessaire de parcourir les mailles de bord lors de l'√©tape de "fit to
   vertex". En effet, le parcours des mailles principales va r√©aliser le "fit to vertex" pour
   les noeuds du bord. J'ai donc ajout√© deux appels √† DISMOI pour conna√Ætre la dimension du
   maillage NDIME et la dimension topologique de la maille courante NDIM. Si NDIM < NDIME, la
   maille courante est un point ou une maille de bord et n'est donc pas trait√©e.
   
   Corrections suppl√©mentaires :
   -----------------------------
   
   Afin de pousser l'analyse jusqu'au bout, j'ai travaill√© sur un cas o√π lsnmax devient nul
   sur une partie des mailles du bord. J'ai ainsi pu constater quelques bugs suppl√©mentaires.
   
   Dans les routines xdecqu et xdecqv qui r√©alise le d√©coupage en sous-√©l√©ments des √©l√©ments
   quadratiques, l'algorithme pour d√©terminer si l'√©l√©ment doit √™tre d√©coup√© est :
     1- chercher l'indice i du premier noeud de l'√©l√©ment qui a une lsn non nulle,
     2- chercher s'il existe un noeud k tel que lsn(i)*lsn(k) < 0. Si tel est le cas, alors
   l'√©l√©ment doit √™tre coup√©.
   Le probl√®me est que dans la programmation actuelle, la boucle qui r√©alise l'√©tape 1- ne
   s'arr√™te pas si toutes les lsn sont nulles. Je l'ai r√©√©crite sous la forme d'une boucle
   "tant que i < nombre de noeuds de l'√©l√©ment".
   
   Dans la programmation actuelle, le code plante ensuite dans la routine te0514, car il
   d√©tecte trois points d'intersection --- ce qui est normal puisqu'on consid√®re un segment √†
   trois noeuds co√Øncidant avec la fissure --- car seuls deux points d'intersection sont
   attendus. Ce bug vient d'un sous-dimensionnement du champ PPINTO dans les catalogues
   d'√©l√©ments X-FEM 1D d√©finissant des √©l√©ments quadratiques (i.e. gener_medpl1_xh,
   gener_medpl1_xht et gener_medpl1_xt). J'ai donc pass√© la taille du champ PPINTO √† 6, soit
   la taille n√©cessaire pour stocker les coordonn√©es 2D de trois points d'intersection.
   
   Enfin, une analyse du code de la routine xdecqv m'a permis d'identifier que le crit√®re
   indiquant si la valeur de la fonction d'Heaviside pour un sous-√©l√©ment de bord doit √™tre
   recalcul√© plus tard dans xoripe est faux pour les √©l√©ments quadratiques. En effet, le
   crit√®re stipule que le nombre de points d'intersection de l'√©l√©ment de bord NINTER et le
   nombre de points d'intersection co√Øncidant avec un noeud sommet NPTS doit √™tre √©gal √† la
   dimension NDIM. Pour les √©l√©ments lin√©aires, on a :
      - en 2D : NINTER = NPTS = 2, pour les segments √† deux noeuds,
      - en 3D : NINTER = NPTS = 3, pour les triangles √† trois noeuds.
   Cependant, pour les √©l√©ments quadratiques, on a :
      - en 2D : NINTER = 3 et NPTS = 2, pour les segments √† trois noeuds,
      - en 3D : NINTER = 6 et NPTS = 3, pour les triangles √† six noeuds.
   J'ai donc remplac√© le crit√®re pour les √©l√©ments quadratiques par : NPTS = NDIM.
   
   Impact :
   --------
   
   - sources fortran : xajuls.f, xdecqu.f et xdecqv.f,
   - catalogues : gener_medpl1_xh.cata, gener_medpl1_xht.cata et gener_medpl1_xt.cata.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 11.2.7
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    passage du calcul probl√©matique + passage de l'ensemble des cas-tests X-FEM
NB_JOURS_TRAV  : 4.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR sellenet     SELLENET Nicolas       DATE 03/04/2013 - 02:00:07

--------------------------------------------------------------------------------
RESTITUTION FICHE 020432 DU 2013-02-21 13:04:23
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    En NEW11.03.09, le cas-test feti007a est NOOK sur Rocks.
FONCTIONNALITE
   Probl√®me :
   ----------
   En NEW11.03.09, le cas-test feti007a est NOOK sur Rocks.
   
   
   Solution :
   ----------
   J'ai modifi√© le maillage de feti007a, il faut que je modifie aussi les valeurs de
   r√©f√©rence pour que le test passe sur Rocks (clpaster).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    feti007a sur aster4 et clpaster
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 020428 DU 2013-02-21 09:28:02
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    zzzz112c: fichier identique sur les unitxc3xa9s 22 et 23
FONCTIONNALITE
   Ce sont des fichiers r√©sultats produits par PRE_IDEAS : √† supprimer.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    aucune
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------
RESTITUTION FICHE 020435 DU 2013-02-21 13:52:12
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    En NEW11.03.09, le cas-test wtnv135d est NOOK sur Rocks (clpaster)
FONCTIONNALITE
   Probl√®me :
   ----------
   En NEW11.03.09, le cas-test wtnv135d est NOOK sur Rocks (clpaster).
   
   
   Solution :
   ----------
   Il est √† nouveau ok cette semaine. Cela ne va sans doute pas durer mais en attendant, je
   classe la fiche.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    wtnv135d sur Rocks (clpaster)
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 020463 DU 2013-02-26 17:26:06
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    [FORUM] Assert dans LIAISON_MAIL/COQUE_MASSIF
FONCTIONNALITE
   Probl√®me :
   ----------
   Dans le calcul joint, on plante dans un ASSERT lors de la d√©finition d'une liaison
   massif-coque avec AFFE_CHAR_MECA/LIAISON_MAIL.
   
   Le maillage laisse √† penser que l'on essaye de faire une liaison non conforme (pas dans le
   plan de la coque).
   
   
   Solution :
   ----------
   Le plantage vient du fait que le champ donn√© dans le mot-cl√© simple CHAM_NORMALE de
   LIAISON_MAIL n'est pas d√©fini sur tous les noeuds donn√©s dans GROUP_NO_ESCL.
   
   Il faut donc pr√©ciser le message :
   """
    Le champ norcoext n'est pas d√©fini sur la totalit√© des noeuds pr√©cis√©s
    dans le mot-cl√© GROUP_MA_ESCL, GROUP_NO_ESCL, MAILLE_ESCL ou
    NOEUD_ESCL.
   
    Il vous faut compl√©ter le champ norcoext.
   """
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    etude jointe
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR tardieu      TARDIEU Nicolas        DATE 03/04/2013 - 02:16:00

--------------------------------------------------------------------------------
RESTITUTION FICHE 015988 DU 2010-11-29 17:16:18
TYPE evolution concernant Code_Aster (VERSION )
TMA : DeltaCad
TITRE
    Permettre la definition d'un discret 1D type "charniere"
FONCTIONNALITE
   R√©sum√© :
   ----------
   Le sujet de cette fiche est la production d'un √©l√©ment fini ou d'un ensemble de discrets pour permettre la 
   mod√©lisation d'une charni√®re.
   Il s'agit d'une id√©e qui est apparue lors d'une r√©union Omarisi ce qui explique l'attribution initiale √† 
   ce projet.
   Depuis 2 ans maintenant, les discussions se sont succ√©d√©es mais sans converger et sans que le besoin ne se 
   fasse particuli√®rement sentir.
   Je classe donc la fiche sans suite.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sans objet
--------------------------------------------------------------------------------
RESTITUTION FICHE 020483 DU 2013-02-28 09:01:07
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    Mettre zzzz337a.comm en internet
FONCTIONNALITE
   Probl√®me :
   ----------
   zzzz337a.comm est en intranet. Faut-il le garder ainsi?
   
   Solution :
   ----------
   zzzz337a.comm est en intranet par h√©ritage du fdlv112b.comm, qui l'est lui-m√™me pour son usage de miss3D.
   Dans la mesure o√π miss3D n'est pas utilis√© dans ce test, rien ne s'oppose √† sa mise en internet.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sans objet
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR taheri       TAHERI Said            DATE 03/04/2013 - 02:16:01

--------------------------------------------------------------------------------
RESTITUTION FICHE 019955 DU 2012-11-19 08:45:46
TYPE evolution concernant Code_Aster (VERSION )
TMA : Necs
TITRE
    Macro de mise en forme de champs de variables internes et de contraintes Aster-EPX
FONCTIONNALITE
   Le but est de construire une macro Aster permettant de mettre les champs de variables
   internes issue de la loi Johnson Cook d'Aster au format de cette m√™me loi Johnson Cook
   d'EPX, et inversement.
   
   2 macros ont √©t√© livr√©es.
   
   Macro 1 : cr√©e, √† partir d'un r√©sultat utilisant la loi VMIS_JOHN_COOK et d'un instant
   donn√©, un r√©sultat contenant les d√©placements et les contraintes du r√©sultats en entr√©e √†
   l'instant donn√©s et le champ de variables internes de JOHNSON COOK mis en forme pour EPX.
   
   Macro 2 : lit les champs de d√©placement, contraintes et variables internes contenus dans
   un fichier MED issus d'EPX (calcul avec la loi VMJC) pour un instant donn√©.
   On transforme ensuite les variables internes EPX en variables internes aster et construit
   un r√©sultat avec les champ DEPL SIEF_ELGA et VARI_ELGA.
   On calcule le champ EPSP_ELGA. Puis √† l'aide de CREA_CHAMP on fabrique un champ de
   contraintes √† partir de EPSP_ELGA.
   Enfin on construit le r√©sultat final √† partir de ce champ de contrainte,le champ DEPL lu
   dans le fichier med et le champ VARI_ELGA transform√© pour Aster.
   
   
   Par contre, aucun source ne sera livr√© dans le code, le p√©rim√®tre fonctionnel du d√©veloppement √©tant 
   r√©duit √† l'application vis√©e dans la th√®se sur le grenaillage.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    test perso
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR tardieu      TARDIEU Nicolas        DATE 03/04/2013 - 02:16:02

--------------------------------------------------------------------------------
RESTITUTION FICHE 020490 DU 2013-02-28 13:46:31
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    En NEW11.03.11, le cas-test sdlx400c sxe2x80x99arrxc3xaate en erreur fatale sur Aster4, Rocks et Calibre7.
FONCTIONNALITE
   Probl√®me :
   ----------
   En NEW11.03.11, le cas-test sdlx400c s‚Äôarr√™te en erreur fatale sur Aster4, Rocks et Calibre7. 
   
   Solution :
   ----------
   Il s'agit d'un oubli de modification des noms de groupes de mailles et de noeuds pr√©fix√©s dans le maillage 
   par GROUP_MA* et GROUP_NO* dans le cadre de la fiche issue20368.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    Passage cas test
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

       C MODIF supervis/med_aster_module    cheignon E.CHEIGNON          93     11     13
 CASTEST AJOUT sdls106h                         brie N.BRIE             357    357      0
 CASTEST AJOUT ssnl133c                     cheignon E.CHEIGNON         356    356      0
 CASTEST AJOUT ssnl133d                     cheignon E.CHEIGNON         356    356      0
 CASTEST AJOUT ssnl133e                     cheignon E.CHEIGNON         356    356      0
 CASTEST MODIF feti007a                     sellenet N.SELLENET         283      3      2
 CASTEST MODIF sdld102a                      alarcon A.ALARCON         1134      9      9
 CASTEST MODIF sdld103a                      alarcon A.ALARCON         1708      3      3
 CASTEST MODIF sdld106a                      alarcon A.ALARCON          231      2      2
 CASTEST MODIF sdld22b                       alarcon A.ALARCON          993     22     22
 CASTEST MODIF sdld321b                      alarcon A.ALARCON         1009     37     35
 CASTEST MODIF sdld325a                      alarcon A.ALARCON         1446     47     47
 CASTEST MODIF sdld325b                      alarcon A.ALARCON         1594     51     51
 CASTEST MODIF sdls106a                         brie N.BRIE             541      8     12
 CASTEST MODIF sdls106b                         brie N.BRIE             368      9     13
 CASTEST MODIF sdls106c                         brie N.BRIE             370      9     13
 CASTEST MODIF sdls106d                         brie N.BRIE             333      9     13
 CASTEST MODIF sdls106e                         brie N.BRIE             369      8     12
 CASTEST MODIF sdls106f                         brie N.BRIE             272      8     12
 CASTEST MODIF sdls106g                         brie N.BRIE             306     14     15
 CASTEST MODIF sdlx400c                      tardieu N.TARDIEU          357    238    271
 CASTEST MODIF sdnd104a                      alarcon A.ALARCON         1014      2      2
 CASTEST MODIF sdnl102a                     cheignon E.CHEIGNON         300      3      3
 CASTEST MODIF ssnl133b                     cheignon E.CHEIGNON         372      2      2
 CASTEST MODIF zzzz337a                      tardieu N.TARDIEU          511      2      2
CATALOGU MODIF typelem/gener_medpl1_xh        martin A.MARTIN            88      8      7
CATALOGU MODIF typelem/gener_medpl1_xht       martin A.MARTIN            89      8      7
CATALOGU MODIF typelem/gener_medpl1_xt        martin A.MARTIN            90     13     12
CATALOGU MODIF typelem/gener_mepde1         cheignon E.CHEIGNON         290     10      6
CATALOGU MODIF typelem/gener_mepdg1         cheignon E.CHEIGNON         279     10      7
CATALOGU MODIF typelem/gener_mepdt1         cheignon E.CHEIGNON         290     10      6
CATALOPY MODIF commande/norm_mode               brie N.BRIE              56     10      7
CATALOPY MODIF commande/perm_mac3coeur       geniaut S.GENIAUT           30      3      3
    DATG MODIF Coeur_1300.datg             S.GENIAUT 109                  2      2      0
    DATG MODIF Coeur_900.datg              S.GENIAUT 111                  2      2      0
 FORTRAN AJOUT algorith/mmreli                desoza T.DESOZA           144    144      0
 FORTRAN AJOUT algorith/mmresi                desoza T.DESOZA           110    110      0
 FORTRAN AJOUT elements/porea1              cheignon E.CHEIGNON         109    109      0
 FORTRAN AJOUT elements/porea2              cheignon E.CHEIGNON          86     86      0
 FORTRAN MODIF algeline/op0037                  brie N.BRIE             620     31      7
 FORTRAN MODIF algorith/mdchge                  brie N.BRIE             230      9      7
 FORTRAN MODIF algorith/mdruku               alarcon A.ALARCON          480      3      3
 FORTRAN MODIF algorith/mm2onf                desoza T.DESOZA           100      4      4
 FORTRAN MODIF algorith/mmnewt                desoza T.DESOZA           254     14     24
 FORTRAN MODIF algorith/op0046              cheignon E.CHEIGNON         252      3      3
 FORTRAN MODIF algorith/op0048              cheignon E.CHEIGNON         297      2      2
 FORTRAN MODIF algorith/xajuls                martin A.MARTIN           206     27     19
 FORTRAN MODIF algorith/xdecqu                martin A.MARTIN           362     16      8
 FORTRAN MODIF algorith/xdecqv                martin A.MARTIN           362     38     22
 FORTRAN MODIF calculel/ccfnrn              cheignon E.CHEIGNON         478      9      5
 FORTRAN MODIF elements/dxtbm                 desoza T.DESOZA            51      3      3
 FORTRAN MODIF elements/te0023              cheignon E.CHEIGNON          74     14      2
 FORTRAN MODIF elements/te0247              cheignon E.CHEIGNON         417     74     41
 FORTRAN MODIF elements/te0346              cheignon E.CHEIGNON         188     58     38
 FORTRAN MODIF elements/te0347              cheignon E.CHEIGNON         238     25      6
 FORTRAN MODIF elements/te0516              cheignon E.CHEIGNON         559     22     55
 FORTRAN MODIF elements/te0517              cheignon E.CHEIGNON         197     60    130
 FORTRAN MODIF modelisa/calir3              sellenet N.SELLENET         108      5      2
 FORTRAN MODIF modelisa/immeca                  brie N.BRIE             521      9      7
 FORTRAN MODIF modelisa/orilgm                  brie N.BRIE             367     10     10
 FORTRAN MODIF modelisa/topoca                  brie N.BRIE             484      8      6
 FORTRAN MODIF soustruc/utreno                  brie N.BRIE              69      6      5
 FORTRAN MODIF utilitai/dismlg              cheignon E.CHEIGNON         471     13      5
 FORTRAN MODIF utilitai/dismmo              cheignon E.CHEIGNON         237      3      3
 FORTRAN MODIF utilitai/rfnoch                  brie N.BRIE              86      6      5
 FORTRAN MODIF utilitai/rfrcha                  brie N.BRIE             168      7      5
 FORTRAN MODIF utilitai/rfresu                  brie N.BRIE             123      5      4
  PYTHON MODIF Mac3coeur/calc_mac3coeur_ops    geniaut S.GENIAUT          403      2     13
  PYTHON MODIF Macro/calc_europlexus_ops    cheignon E.CHEIGNON        2632     80    191
  PYTHON MODIF Messages/champs              sellenet N.SELLENET          94      8      4
  PYTHON MODIF Messages/elements3           cheignon E.CHEIGNON         261      8     17
  PYTHON MODIF Messages/elements4           cheignon E.CHEIGNON         239      2     10
  PYTHON MODIF Messages/soustruc                brie N.BRIE             433      3      2


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :    8        1874      1874             +1874
 MODIF :   65       26881      1160    1277      -117
 SUPPR :    0           0                 0        +0
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :   73       28755      3034    1277     +1757 
