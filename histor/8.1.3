

-----------------------------------------------------------------------
--- AUTEUR acbhhcd G.DEVESA   DATE  le 16/06/2005 a 17:19:16

------------------------------------------------------------------------
REALISATION EL 2005-124
   NB_JOURS_TRAV  : 5
   INTERET_UTILISATEUR : NON
   TITRE  "relation de comportement ASSE_CORN"
   FONCTIONNALITE
     Enrichir la loi de comportement ASSE_CORN pour pouvoir repasser en
     mécanisme 1 quand on change le signe du chargement après une décharge
     à partir du mécanisme 2.
   DETAILS
     Cela implique de stocker 4 nouvelles variables représentatives de
     l'historique : niveaux maxi d'effort et moment atteints en mécanisme
     2 avant décharge et déplacement et rotation nouvelles origines du
     mécanisme 1. On a maintenant 7 variables actives d'où la modif du
     catalogue général COMP_INCR pour ASSE_CORN.
     En outre, on ajoutera dès qu'on pourra au matériau ASSE_CORN une
     nouvelle entrée R_P0 permettant de paramétrer la pente à l'origine ou
     de décharge, actuellement fixée dans le code à 1.E4 qui deviendra la
     valeur par défaut.

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : OUI
     DOC_V : V6.02.102
       EXPL_ : modification de la modélisation SSNL102A
     DOC_R : R5.03.32
       EXPL_ : modification de la documentation ASSE_CORN
   VALIDATION
     On enrichit le cas test SSNL102A déjà existant pour tester le retour
     en mécanisme 1.

------------------------------------------------------------------------
REALISATION EL 2005-130
   NB_JOURS_TRAV  : 1.5
   INTERET_UTILISATEUR : NON
   TITRE  "AOM calcul radier souple avec Aster-Miss"
   FONCTIONNALITE
     Pour la prise en compte de la souplesse de radier,on compare
     les résultats obtenus en prenant en compte une base complète de modes
     statiques d'interface associés chacun à tous les ddls de l'interface,
     à ceux obtenus en considérant une réduction des modes d'interface
     obtenus par des modes propres sur tapis de ressorts de sol. On
     observait des différences sur les résultats spectraux.

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   NON
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
     Sur cette étude adaptée du test MISS05A, on observe qu'on a considéré
     le radier pesant pour calculer la matrice masse dans l'étude avec
     base complète et le radier non pesant dans l'étude avec base réduite.
     Ce qui ne se voit pas dans le calcul des modes propres mais a des
     conséquences sur le couplage des modes statiques avec la masse. En
     remettant le radier pesant dans l'étude avec base réduite, on
     rapproche les résultats de manière satisfaisante.

------------------------------------------------------------------------
REALISATION EL 2005-131
   NB_JOURS_TRAV  : 1.5
   INTERET_UTILISATEUR : NON
   TITRE  "AOM calcul radier souple avec Aster-Miss (2)"
   FONCTIONNALITE
     Pour la prise en compte de la souplesse de radier,on compare
     les résultats obtenus en prenant en compte une base complète de modes
     statiques d'interface associés chacun à tous les ddls de l'interface,
     à ceux obtenus en considérant une réduction des modes d'interface
     obtenus par des modes propres sur tapis de ressorts de sol. On
     observait des différences sur les résultats spectraux.

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   NON
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
     Sur cette étude adaptée du test MISS05A, on observe qu'on a considéré
     le radier pesant pour calculer la matrice masse dans l'étude avec
     base complète et le radier non pesant dans l'étude avec base réduite.
     Ce qui ne se voit pas dans le calcul des modes propres mais a des
     conséquences sur le couplage des modes statiques avec la masse. En
     remettant le radier pesant dans l'étude avec base réduite, on
     rapproche les résultats de manière satisfaisante.


-----------------------------------------------------------------------
--- AUTEUR boiteau O.BOITEAU   DATE  le 20/06/2005 a 17:43:44

------------------------------------------------------------------------------
REALISATION EL 2005-173
   NB_JOURS_TRAV  : 70
   INTERET_UTILISATEUR : OUI
   TITRE : Parallelisation du solveur lineaire FETI en MPI (part I)
   FONCTIONNALITE  SOLVEUR='FETI' dans MECA_STATIQUE
   --------------
   Parallelisation par envoie de message en MPI_1. La strategie retenue est
   la suivante:

     Avant MECA_STATIQUE
     -------------------
     Jusqu a MECA_STATIQUE tous les procs font tout et donc connaissent
     tous les objets JEVEUX, en particulier l'objet MAILLAGE et la SD_FETI
     C est sous-optimal mais c'est la seule solution envisageable compte
     tenu de l'architecture d un calcul actuellement.

     Strategie globale:
     ------------------
     Par contre, au cours de MECA_STATIQUE, pendant les phases de factorisa
     tions symbolique, numerique et d'assemblage, on va tarir le volume de
     donnees independantes proc par proc pour ainsi orienter la parallelisme
     sans avoir a polluer le code de if then du genre (option de parallelisme
     par defaut de MUMPS par ex.)
          si proc maitre renvoyer au proc i ... et au j ...
          si proc de rang i alors construire ...
          si proc de rang j alors...
	  .....
	
     Cela se fait beaucoup plus simplement via une boucle du style avec l objet
     JEVEUX &FETI.LISTE.SD.MPI: exemple pris dans CRESOL. Cela a des avantages
     en terme de lisibilite et maintenance.

     CALL JEVEUO('&FETI.LISTE.SD.MPI','L',ILIMPI)
C========================================
C BOUCLE SUR LES SOUS-DOMAINES + IF MPI:
C========================================
        DO 50 I=1,NBSD
          IF (ZI(ILIMPI+I).EQ.1) THEN
                    ......
          ENDIF
   50   CONTINUE
C========================================
C FIN BOUCLE SUR LES SOUS-DOMAINES + IF MPI:
C========================================

     Concernant les gros objets, chaque proc ne va donc construire et connaitre
     que les donnees dont il a besoin:
      SD_SOLVEURs global et ceux des sous-domaines qui lui sont rattaches
      idem pour NUME_DDL, MATR_ASSE, CHAM_NO, objets temporaires FETI

     Concernant les donnees de petit volume, comme souvent elles orientent
     le calcul (LOGICAL..), il faut les dupliquer pour que tous les procs
     passent par le meme cheminement !

     On a donc un arbre de dependance des donnees parallele du genre:
                        Proc 0                      Proc j
	--------------------------------------------------------------
     Avant
     MECA_STATIQUE    connait tout                connait tout

     CRESOL       SD_SOLVEUR maitre                   Idem
                  et son .FETS qui pointe
		  vers les SD_SOLVEUR
		  esclaves des sous-domaines
		  concernes par ce proc
		
     NUMERO       Idem avec NUME_DDL maitre,          Idem
                  esclaves et son .FETN
		
     ASSMAM       Idem avec MATR_ASSE maitre,         Idem
                  esclaves et son .FETM
		
     ASSVEC       Idem avec CHAM_NO maitre,           Idem
                  esclaves et son .FETC
		
     PRERES       Idem avec les MATR_ASSE.VALF,       Idem
                  .FETF, .FETP, .FETR esclaves
		
     ALFETI       connait tout                    Ne connait pas les gros
                                                objets lies a la reortho et
						 aux projections.
     En sortie          connait le CHAM_NO           connait le CHAM_NO sol
     de MECA_STATIQUE   solution global              local a chaque SD

     Le NUME_DDL de chaque sous-domaine n etant connu que de son processeur
     d acceuil, les envois de msgs se font avec des vecteurs de taille
     homogene, celle du nbre de ddl de l'interface (au cours de l'algo) ou
     du nbre de DDL total du pb (dans la phase finale de reconstruction)

     Repartition SD/Proc
     -------------------
     Pour restreindre le flot de donnees a chaque procs, il faut distribuer un
     ensemble de sous domaines contigues (en terme de numero de la SD_FETI)
     proc par proc (objets &FETI.LISTE.SD.MPI/MPIB). C est a ce niveau que
     l on peut commencer par faire de l equilibrage de charge (en memoire et/ou en
     temps). La strategie globale retenue est que le proc 0 (maître)
     centralise les gros objets de calcul lies aux etapes de projection
     et de reorthogonalisation.
     Philosophiquemnt c est lui qui a besoin de ces objets pour le calcul,
     donc il est le seul a devoir les stocker. Dans l heuristique de repartition
      SD/proc on a donc tendance a le decharger si le nombre de SD est superieur
      au nombre de proc.

      Ex: 4 SD 4 Proc
          SD     1        2       3       4
	  PROC   0        1       2       3
      Ex: 6 SD 4 Proc
          SD     1        2 3     4 5     6
	  PROC   0        1       2       3

      En parallele, la possibilite de ne pas stocker la matrice des modes
      rigides GI (STOCKAGE_GI='NON') est interdit (UTMESS_F) car tres
      sous-optimal en terme de communications inter-procs. Si on parallelise
      c est pour repartir un peu aussi la memoire, cette latitude n est
      donc plus de mise. En sequentiel, on laisse par contre bien sur les
      trois options: STOKAGE_GI= 'OUI', 'NON', 'CAL'

     Communication MPI
     -------------------
     Le processeur maitre gere les boucles du GCPPC et recoit/renvoi les
     informations requises. En gros,
        Proc j ---> Proc 0  (taille interface)    Zk = FI * Vk    MPI_REDUCE
	                                          Rk = M-1 * Rk   MPI_REDUCE
        Proc 0 ---> Proc j  (taille interface)    Pk reorthogona  MPI_BCAST
	                                          Gk = P * Rk     MPI_BCAST
     Donc un cout de communication du type:

       Init: 3*(MPI_REDUCE + MPI_CAST) + 6 NBI*NBSD/NBPROC MPI_GATHERV
       Chaque iter: 2 *(MPI_REDUCE + MPI_CAST)
       Reconstruction: 2*MPI_BCAST + MPI_REDUCE + MPI_REDUCE(taille du pb global)
       	  						
     Plutot que des boucles de communications points a points entre les procs
     esclaves et le proc maitre (MPI_SEND/RECV), on a retenu dans une premiere
     approche des communications collectives (MPI_REDUCE, BCAST, REDUCE, GATHER...)
     qui encapsule les SEND/RECV dans des boucles et synchronisent les envois de
     msgs.
     Avantages: synchronisation des processus et boucles sur les envois/receptions
     automatiques et transparentes, donc meilleur lisibilite, maintenabilite,
     portabilite.
     Inconvenients: cela ne permet pas des chevauchements calculs/communications,
     d'eviter le buffering et de limiter les temps de latence.

     Optimisation potentielle de l implementation MPI
     ------------------------------------------------
     Au vu de l'algo actuel, de la philosophie de parallelisme actuelle en "maitre
     esclaves" et des speed-ups constates dans les premiers tests, il
     semble que ces optimisations ne soient pas si prometteuses que cela. Elles
     sont aussi tres dependantes de la configuration machine, reseau, carte reseau,
     implementation machine et type de probleme.
     D'autres voies d'optmisations sont:
      - renverser la philosophie de parallelisation maitre/esclave en "tous les
      procs font et stocke presque tout"
      - essayer des types MPI derive plus lisible (colonne de matrice...)
      - tenir compte de la vrai longueur des interfaces des sous-domaines pour
      limiter les tailles des communications.
     Mais tous ces points auront un cout en terme de stockage, lisibilite et
     maintenance.

   Point 2: Suspension des tests de continuite aux interfaces (mot-cle
             TEST_CONTINU) qui est beaucoup plus difficile a organiser en
	     parallele et qui n etait pas complement satisfaisant en sequentiel
	
   Point 3:
   Maintenance preventive: amelioration de la lisibilite d ALFETI via
   FETCPU et FETTOR

   DETAILS
   --------
   routines modifiees <M>, nouvelles <N>
   <M> alfeti,assde1,assmam,assvec,creso1,cresol,exlim1,exlim2,facsmb,fetarp,
       fetccn,fetfac,fetfiv,fetggt,feting,fetinl,fetmon,fetprc,fetprj,fetreo,
       fetrex,fetrin,fetsca,mestat,numero,preml1,preres,resfet,resoud,vtcmbl,vtcreb,
       vtdefs,meca_statique.capy,E_ETAPE.py,astermodule.c,exstat,python.c
   <N> fetam,fetcpu,fetmpi.c,fetsm,fettor,affich,gtnpro.c.

   En comptant les jours de d auto-formations au parallelisme, de qualification des
   deux machines et des bibliotheques MPI retenues et d organisation d un calcul
   parallele Code_Aster en collaboration avec JPL: 45 OB + 25 JPL

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : OUI
   --------------------
     DOC_R : R6.01.03
       EXPL_ :  Doc de reference de FETI, comportant notamment un expurge
                 mis a jour de la note HI precedente.
     DOC_U : U4.50.01
       EXPL_ :  Utilisation du mot-cle SOLVEUR
     DOC D : D9.03.01
       EXPL_ :  Descriptif informatique du solveur FETI
     DOC D : D4.06.10
       EXPL_ :  SD MATR_ASSE
     DOC_D : D4.06.21
       EXPL_ : SD SD_FETI
       	
   VALIDATION
   -----------
     Diverses combinaisons en 2D/3D en variant configurations de blocage et nbre
     de sous-domaines + cas_test FETI de la base. Sur le cluster CLPASTER et la
     CLAYASTR.
     Sur le cube en elasticite lineaire sur la CLPASTER (nodebug avec MPI, seul
     sur la machine, a option DEBUT homogene). Les temps sont tres variables
     suivant le volume de memoire reservee et le parametrage numerique de FETI.
     Pour MULT_FRONT, les occupations memoires sont minimales (en deca cela plante)
     pas pour FETI, on peut encore baisser parfois (et acceptant de perdre en CPU).

     90 000 DDLS
     -----------
     MULT_FRONT           400 Mo       215 s

     FETI_10 SD  1 Proc    60 Mo       146 s
     FETI_10 SD  5 Proc    60 Mo        33 s
     FETI_10 SD 10 Proc    60 Mo        19 s

     FETI_40 SD  1 Proc    60 Mo       121 s
     FETI_40 SD  5 Proc    60 Mo        46 s
     FETI_40 SD 10 Proc    60 Mo        38 s

     612 000 DDLS
     -----------
     MULT_FRONT           4000 Mo     5570 s (CLAYASTR)

     FETI_10 SD  1 Proc    600 Mo     3339 s
     FETI_10 SD  5 Proc    600 Mo      610 s
     FETI_10 SD 10 Proc    600 Mo      310 s

     FETI_40 SD  1 Proc    600 Mo     1990 s
     FETI_40 SD  5 Proc    600 Mo      567 s


-----------------------------------------------------------------------
--- AUTEUR boyere E.BOYERE   DATE  le 20/06/2005 a 14:46:53

-------------------------------------------------------------------------
REALISATION EL 2005-160
   NB_JOURS_TRAV  : 0.5
   INTERET_UTILISATEUR : NON
   TITRE moins d'ambiguite pour MACRO_PROJ_BASE dans EFICAS
   FONCTIONNALITE
     La redaction d'un MACRO_PROJ_BASE etait un veritable piege pour le neophyte.
     J'ai donc ajoute des regles dans le catalogue et on a modifie EFICAS
     pour qu'il ne donne pas l'impression qu'on peut remployer un concept deja
     existant alors qu'il faut en creer un nouveau.
   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : OUI
     DOC_U : U1.04.11
       EXPL_ : redaction d'une doc pour EFICAS
   VALIDATION
   DETAILS
     trois nouvelles regles :
     globalement pour la commande :
         regles=(AU_MOINS_UN('MATR_ASSE_GENE','VECT_ASSE_GENE')),
     dans les mots clefs facteurs MATR_ASSE_GENE et VECT_ASSE_GENE respectivement
           regles=(UN_PARMI('MATR_ASSE','MATR_ASSE_GENE',),),
     et    regles=(UN_PARMI('VECT_ASSE','VECT_ASSE_GENE',),),

------------------------------------------------------------------------------
CLASSEMENT SANS SUITE AO 2005-145
   NB_JOURS_TRAV  : 0.0
   INTERET_UTILISATEUR : NON
   TITRE EFICAS et MACRO_MODE_MECA
   FONCTIONNALITE
     L'utilisateur a rencontre un cas ou EFICAS
     cree une commande MACRO_MODE_MECA invalide,
     avec
       mod_meca=MACRO_MODE_MECA(MATR_A=CO('rig_ass'),
                                MATR_B=CO('mas_ass'),
    au lieu de
       mod_meca=MACRO_MODE_MECA(MATR_A=rig_ass,
                                MATR_B=mas_ass,
    Je n'ai pas su reproduire le comportement errone avec la version 1.8 d'EFICAS.
    Je classe sans suite.
   IMPACT_DOCUMENTAIRE : NON

------------------------------------------------------------------------------
CORRECTION AO 2005-109
   NB_JOURS_TRAV  : 0.0
   INTERET_UTILISATEUR : NON
   TITRE EFICAS ne sait pas creer un CALC_ELEM sur un resultat lineaire
   FONCTIONNALITE
     Dans CALC_ELEM, (apres MECA_STATIQUE) on ne peut pas donner d'option : le bloc b_lineaire ne s'allume pas.
     En revanche on peut le faire a la reouverture du fichier.
     L'erreur etait averee. Elle a ete corrigee dans la version 1.8 d'EFICAS.
   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   NON
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION

--------------------------------------------------------------------------------------------------------------
CORRECTION AO 2005-102
   NB_JOURS_TRAV  : 0.0
   INTERET_UTILISATEUR : NON
   TITRE invalidation abusive d'un concept utilise en reuse
   FONCTIONNALITE
     Soit un cas de ce type :
       u=DYNA_NON_LINE()
       u=DYNA_NON_LINE(reuse=u)
       u=DYNA_NON_LINE(reuse=u)
       IMPR_RESU(u)
     si on commentarise la deuxieme commande uniquement, le concept "u" est declare
     invalide pour TOUT le jdc.
     Ainsi toutes les autres commandes, en aval comme en amont, utilisant "u" sont
     mises en rouge.
     Il faut, lors des commentarisations, trapper si "reuse" ou pas,
     et alors ne pas invalider le concept dans tout le jdc.
     Ce comportement excessif est corrige dans EFICAS v1.8.
   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   NON
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION

---------------------------------------------------------------------------------------------------------------
CLASSEMENT SANS SUITE AO 2005-073
   NB_JOURS_TRAV  : 0.0
   INTERET_UTILISATEUR : NON
   TITRE COMPLEXES et EFICAS
   FONCTIONNALITE
     Cette fiche est mal redigee.
     Je suis d'autant plus critique que j'en suis l'auteur.
     Elle melange plusieurs problemes dont deux sont corriges.
     - Les INCLUDE_MATERIAU fonctionnent avec EFICAS v1.8.
     C'est teste sur cabri02a.
     - Les complexes a la mode ASTER, en attendant ceux a la sauce python,
     sont compatibles avec EFICAS.
     En revanche sdld27b et e posent toujours probleme a EFICAS
     a cause des formules et des operations derriere un mot clef simple.
     On n'accepte dans EFICAS que des parametres ou des reels simples
     derriere les mots clefs simples, pas d'operation.
     L'equipe EFICAS travaille sur la question pour la prochaine version.
     A officialiser par une fiche EO claire.
   IMPACT_DOCUMENTAIRE : NON

--------------------------------------------
CORRECTION AO 2005-053
   NB_JOURS_TRAV  : 0.0
   INTERET_UTILISATEUR : NON
   TITRE temps excessif pour ouvrir les fichiers include et poursuite dans EFICAS
   FONCTIONNALITE
     On s'est apercu par hasard qu'EFICAS multipliait les operations a chaque
     ouverture d'un fichier include ou poursuite.
     Cela avait pour consequence que l'ouverture d'une chaine de fichiers imbriques
     pouvait prendre un temps demuserement long.
     Cela a ete depuis la v1.7b.
   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   NON
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION

--------------------------------------------
REALISATION EO 2005-014
   NB_JOURS_TRAV  : 0.0
   INTERET_UTILISATEUR : NON
   TITRE propositions d'amelioration de l'ergonomie d'EFICAS
   FONCTIONNALITE
     REALISE :
     o Valider une commande surlignee par un simple retour chariot
     o Pouvoir creer un fichier include
     o Personnaliser les couleurs de l'interface
     -> par l'intermediaire d'un fichier de config.
     NON REALISE
     o Inclure un bouton d'ajout d'une occurrence d'un mot clef qui peut etre
     repete
     o Ouvrir automatiquement dans un autre onglet le fichier poursuivi
     o Rendre utilisable la touche "entree" du pave numerique
     o Pouvoir changer la selection dans une fenêtre par les fleches du clavier

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   NON
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION

--------------------------------------------------------------------------
REALISATION EO 2005-013
   NB_JOURS_TRAV  : 0.
   INTERET_UTILISATEUR : NON
   TITRE integration du module PMW dans la livraison d'EFICAS
   FONCTIONNALITE
     C'est fait.
   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   NON
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION

-------------------------------------------------------------------------
REALISATION EO 2005-012
   NB_JOURS_TRAV  : 0.
   INTERET_UTILISATEUR : NON
   TITRE pouvoir entrer dans EFICAS indifferement un reel, une fonction ou une formule derriere un mot clef
   FONCTIONNALITE
     Le projet incertitude demandait la possibilite d'entrer dans EFICAS un reel,
     une formule ou une fonction derriere un mot clef simple.
     C'est fait.
   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   NON
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION

-------------------------------------------------------------------------
REALISATION EO 2004-133
   NB_JOURS_TRAV  : 0.
   INTERET_UTILISATEUR : NON
   TITRE EFICAS devrait conserver le formatage scientifique des reels
   FONCTIONNALITE
     Realise pour la v1.8 d'EFICAS.
     N.B. : On remarque toutefois qu'EFICAS peut perdre ce formatage dans les MACRO et les
   INCLUDE !!!
   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   NON
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION

-------------------------------------------------------------------------
REALISATION EO 2003-093
   NB_JOURS_TRAV  : 6.0
   INTERET_UTILISATEUR : NON
   TITRE entrer dans EFICAS une chaine de fichiers de commande et de poursuite
   en une seule ligne.
   FONCTIONNALITE
     Enfin realise pour la v1.8 d'EFICAS.
     Pour l'utilisation de cette fonctionnalite on se reportera a la toute nouvelle
     doc d'EFICAS : U1.04.11
   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   NON
   IMPACT_DOCUMENTAIRE : OUI
     DOC_U : U1.04.11
       EXPL_ : redaction d'une doc pour EFICAS
   VALIDATION


-----------------------------------------------------------------------
--- AUTEUR cibhhpd L.SALMONA   DATE  le 21/06/2005 a 10:30:20

-------------------------------------------------------------------------------
CORRECTION AL 2005-227
   NB_JOURS_TRAV  : 0.
   POUR_LE_COMPTE_DE   : A.ADOBES
   INTERET_UTILISATEUR : NON
   TITRE : DEFI_FLUI_STRU
   FONCTIONNALITE : Arret sur getr8
   DETAIL : Une variable non initialisée dans op0413 arretait les cas tests
     suivants en erreur fatale:
     sdll110a,sdll110b,sdll117a,sdll501a,sdll502a,sdll503a,sdll503b,sdll503c,
     sdll504a,sdll505a,sdll506a,sdll507a,sdll508a,sdll508b,sdll508c,sdnl112a,
     sdnl112b,sdnl112c

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION

-------------------------------------------------------------------------------
CORRECTION AL 2005-226
   NB_JOURS_TRAV  : 0.
   POUR_LE_COMPTE_DE   : A.ADOBES
   INTERET_UTILISATEUR : NON
   TITRE : CALC_FLUI_STRU
   FONCTIONNALITE : sdll134a NOOK
   DETAIL :
     Une tolérance trop serrée arretait le test en NOOK sous linux. On passe à 0.1%.

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION

-------------------------------------------------------------------------------
REALISATION EL 2005-056
   NB_JOURS_TRAV  : 0.5
   INTERET_UTILISATEUR : NON
   TITRE DEFI_FICHIER + LIBERER
   FONCTIONNALITE : l'utilisateur souhaitait changer l'émission d'un arret fatal
     en une alarme lorsqu'on libérait un fichier plusieurs fois ou en libérant une
     unité non attribué.
   DETAILS :
     Cette fiche a déjà été corrigé par le restitution de l'AL2005-190 en 8.0.22.

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   NON
   VALIDATION :
   IMPACT_DOCUMENTAIRE : NON


-----------------------------------------------------------------------
--- AUTEUR gevais V.GERVAIS   DATE  le 21/06/2005 a 10:55:58

---------------------------------------------------------------------------------
CORRECTION AL 2005-228
   NB_JOURS_TRAV  : 0.5
   POUR_LE_COMPTE_DE   : R.FERNANDES
   INTERET_UTILISATEUR : NON
   TITRE : Correction suite à erreur sur les cas tests ssnv184a et
     wtnv128a sous linux (Rocks et Calibre 3)
   FONCTIONNALITE
   DETAIL
      Correction de la routine hbrcvx.f : tableau mal dimensionné
      Correction du cas test ssna116a.comm : erreur de frappe dans une solution
      analytique
   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION


-----------------------------------------------------------------------
--- AUTEUR godard V.GODARD   DATE  le 20/06/2005 a 18:26:14

---------------------------------------------------------------------------------
REALISATION EL 2005-144
   NB_JOURS_TRAV  : 0.5
   INTERET_UTILISATEUR : NON
   TITRE : AOM DIS_CONTACT
   FONCTIONNALITE
     Lorsque je lance ce calcul, il s'interrompt dans les premiers pas de calcul
     et renvoie le message d'erreur suivant:
     " <DYNA_NON_LINE> <RCFON3> ON DEBORDE A DROITE REDEFINISSEZ
                                 VOS NAPPES ALPHA - MOMENT"
     Par contre, si je change juste le paramètre KM1 dans donnRFA1300.comm
     pour lui donner une valeur plus faible, (600 au lieu de 860 par exemple)
     le calcul se déroule normalement.
   DETAILS
     Je propose de clore cette fiche en l'état pour 2 raisons:
     - Le calcul modal, préalable à DYNA_NON_LINE, est effectué sans vérification des modes
       et des alarmes sont générées car les incertitudes sur les modes sont importantes voire très
       importantes. Le calcul s'arrete dès cette étape si on met  VERI_MODE=_F(STOP_ERREUR='OUI',),
       dans MACR_MODE_MECA. Pourquoi le calcul modal pose-t-il problème ?
       Ceci n'est probablement pas responsable de l'erreur obtenue dans DYNA_NON_LINE
       mais remet peut-etre en cause la pertinence des resultats de l'étude.
     - Il m'apparait difficile de résoudre les problèmes de DIS_CONTACT sur cette étude en dynamique,
       sachant qu'on observe déjà des problèmes en statique. Plusieurs modifications distinctes dans le fichier
       de commande permettent en effet indépendamment les unes des autres de faire passer le calcul:
       - diminuer KM1
       - mettre une petite rigidité dans la direction Z des discrets
       - caler la rigidité des discrets en rotation sur la courbe angle-moment
       - raffiner le pas de temps
     Il est donc difficile de conclure rapidement sur l'origine du problème.
     Le travail actuel sur la liaison grille-crayon dans le projet CACHEMIRE
     devrait contribuer à améliorer ce point.

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  NON
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION


-----------------------------------------------------------------------
--- AUTEUR lebouvie F.LEBOUVIER   DATE  le 20/06/2005 a 14:23:16

-----------------------------------------------------------------------------
REALISATION EL 2005-138
   NB_JOURS_TRAV  : 1.5
   POUR_LE_COMPTE_DE : C. DURAND
   INTERET_UTILISATEUR : OUI
   TITRE : Introduction sus forme de tests des démos du site
   FONCTIONNALITE
   DETAILS :
     L'objectif de cette fiche est de vérifier si les exemples présentés sur le site web code-aster.org
     dans les pages suivantes, sont présents dans la base de test, sinon les commenter et les restituer
     en tant que test de formation ou de demo .
     - Exemples simples commentés : http://www.code-aster.org/utilisation/exemples.php?page=1
     - Exemples d'utilisation de Python dans Aster : http://www.code-aster.org/utilisation/exemples.php?page=2
     Après analyse deux cas-tests sont resitués:
     - demo005 : exemple du réservoir
     - demo006 : optimisation du coude

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION : cas-tests restitués


-----------------------------------------------------------------------
--- AUTEUR mabbas M.ABBAS   DATE  le 20/06/2005 a 13:14:45

-----------------------------------------------------------------------
REALISATION EL 2005-120
   NB_JOURS_TRAV  : 3
   INTERET_UTILISATEUR : OUI
   TITRE :  AOM - CONTACT ET MODELISATIONS HETEROGENES
   FONCTIONNALITE
     Mon calcul se résume ainsi: Je crée en 2D une succession de bloc
     (béton) liés entre eux par des armatures (POU_D_E) afin de
     réprésenter un bloc de béton fissuré. Mon bloc de béton repose sur
     deux appuis de chaque côté, les poutres sont encastrées d'un côté
     et je tire de l'autre coté, le tout en appliquant un chargement
     sur une face en pression et température. Le calcul sans contact
     est correct. J'ai besoin pour la physique du phénomène de mettre
     des conditions de contact entre les 2 lèvres de mes fissures.
     Le message d'erreur est le suivant
     <CHVENO> IMPOSSIBILITE, SOIT LA MAILLE M3714 DOIT ETRE UNE MAILLE DE
      PEAU DE TYPE SEG CAR ON EST EN 2D ET ELLE EST DE TYPE SEG2 SOIT
      IL FAUT RENSEIGNER "VECT_Y" EN 3D.

     La maille en question est bien en SEG2, sur les lèvre de ma
     fissure et aucun de ses noeud n'est commun avec une maille POUTRE.
     J'ai ôter les POU du contact bien que les éléments sur lesquels
     j'impose des conditions de contact ne contiennent aucune POU
     (on ne sait jamais!). Le message d'erreur est le même.
     J'ai mis un VECT_Y dans le contact (2ème option du message d'erreur),
     cette fois l'erreur se produit au niveau du STAT_NON_LINE:
      MELANGE 2D 3D DANS LE CONTACT.
   DETAILS
     Le contact se fait entre les groupes FIS1_G et FIS1_D.
     FIS_1G est constitué exclusivement de mailles appartenant à la
     modélisation C_PLAN et donc est purement 2D.
     Par contre, FIS_1D est constitué de mailles appartenant à la fois
     à la modélisation C_PLAN et POU_D_E.
     Le problème se situe sur le noeud 223 appartenant à
          M3714/M3715          C_PLAN            SEG2          FIS1_D
          M188/M189              POU_D_E         SEG2          ACIER/AC_NAD
          M671/M675              C_PLAN           QUAD4        BETON
     Ce noeud appartient à la fois à une modélisation C_PLAN (et donc
     a deux degrés de liberté) et à la modélisation POU_D_E (et donc 3
     degrés de liberté).
     Au final, il est donc "3D". Il y a donc bien mélange de modélisation
      2D (FIS_1G) et 3D (FIS_1D).
     Le contact ne peut gérer des situations de mélange 2D/3D.
     C'est une évolution logicielle relativement lourde.
     Comme solution, je suggère d'arrêter la poutre avant le noeud 223,
      de manière à ce que ce noeud soit purement 2D.
     Ou alors, d'abandonner les contraintes planes et passer en full-3D.
     Autre solution proposee par l'EDA: etendre l'usage de l'option
     "SANS_NOEUD" du contact. En effet, actuellement, cette option ne fait
     qu'interdire l'appariement de certains noeuds. Les SD du contact
     ne sont pas influencees.
     Il est tout a fait possible de rendre SANS_NOEUD plus intelligent, ce
     qui evitera de devoir modifier le maillage pour passer ce genre d'etudes.
     Une EL est emise sur ce sujet.

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   NON
   IMPACT_DOCUMENTAIRE : OUI
     DOC_U : U4.44.01
       EXPL_ : Bien preciser que le melange 2D/3D est interdit pour
               le contact
   VALIDATION

-----------------------------------------------------------------------
REALISATION EL 2005-089
   NB_JOURS_TRAV  : 3
   INTERET_UTILISATEUR : OUI
   TITRE : AOM - STAT_NON_LINE/CONTACT
   FONCTIONNALITE
     Nous aurions besoins d'aide afin d'optimiser les surfaces de contact de notre structure.
     merci de prendre contact avec louis RATIER ou pascal CHRISTOL.
   DETAILS
     L'hypothese des petites deformations/petis deplacements n'etait pas respectee.
     Et le contact etait utilise avec recherche lineaire.
     Ce qui donne forcement un resultat FAUX.
     Sur ce probleme, l'utilisation de contact n'etait pas absolument
     necessaire, on pouvait s'en passer.
     L.Ratier a propose de nous donner un apercu des problemes rencontres
     pendant cette etude en ce qui concerne l'usage du contact, afin
     D'ameliorer la prise ne main de cette fonctionnalite delicate.

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   NON
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION


-----------------------------------------------------------------------
--- AUTEUR mcourtoi M.COURTOIS   DATE  le 21/06/2005 a 19:01:30

------------------------------------------------------------------------------
REALISATION EL 2005-119
   NB_JOURS_TRAV  : 0.5
   POUR_LE_COMPTE_DE : M. COURTOIS
   INTERET_UTILISATEUR : OUI
   TITRE : IMPR_FONCTION format TABLEAU
   FONCTIONNALITE : IMPR_FONCTION
     L'opérateur IMPR_FONCTION au format TABLEAU produit des lignes de texte non
     commentées, ce qui gène l'analyse syntaxique à la relecture et complique les
     importations dans les tableurs et autres outils de développement.
   DETAILS :
     La modification a consisté à utiliser le caractère commentaire spécifié par
     le mot clé COMMENTAIRE d'IMPR_FONCTION qui est '#' par défaut.
     Fichier modifié: Table.py

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION : cas-test ssns101b + modif zzzz140a

------------------------------------------------------------------------------
REALISATION EL 2005-163
   NB_JOURS_TRAV  : 5
   INTERET_UTILISATEUR : OUI
   TITRE :  CALC_TABLE : nouvelle commande pour manipuler les tables
   FONCTIONNALITE
      Suite aux demandes de plusieurs utilisateurs pour manipuler les données
      des tables, on crée une commande dédié à cela : CALC_TABLE.
      Fonctionnalités :
      =================
      1. Concaténation/combinaison de deux tables avec couture sur une liste
         de paramètres communs.

         tab=CALC_TABLE(
            TABLE=DEPLNO,
            COMB=_F(TABLE=EFF_GENc, NOM_PARA=('ABSC_CURV', 'NOEUD'),),
         )

         Quand ABSC_CURV et NOEUD sont identiques entre DEPLNO et EFF_GENc,
         on insère les valeurs de EFF_GENc sur la ligne de DEPLNO (pour les
         autres paramètres communs aux 2 tables, c'est donc la valeur de
         EFF_GENc qui écrase celle de DEPLNO).

         Sinon on ajoute la ligne de EFF_GENc à la fin de DEPLNO.

         Rem : NOM_PARA agit comme une clé primaire : si on a trouve plus d'une
         fois le couple (ABSC_CURV, NOEUD), on ajoute la ligne.


      2. Appliquer une formule dont les paramètres sont des labels de la table
         et insérer le résultat dans une nouvelle colonne.

         dnor=FORMULE(NOM_PARA=('DX', 'DY', 'DZ'),
                      VALE='sqrt(DX**2+DY**2+DZ**2)')
         tab=CALC_TABLE(
            TABLE=tab, reuse=tab,
            OPER=(_F(FORMULE=dnor, NOM_PARA='NORM_DEP',),
                  _F(...),),
            TITRE=('Combinaison des tables EFF_GEN et DEPLNO sur ABSC_CURV,NOEUD communs',
                   'Ajout de NORM_DEP'),
         )

      3. Renommer des paramètres d'une table.

         tab=CALC_TABLE(
            TABLE=tab, reuse=tab,
            RENOMME=(_F(NOM_PARA=('N','EFF_NORM'),), # (ancien nom,nouveau nom)
                     _F(...),),
         )

      4. Filtre des lignes selon certains critères (idem IMPR_TABLE).

         tab=CALC_TABLE(
            TABLE=tab, reuse=tab,
            FILTRE=(
               _F(NOM_PARA='ABS_corr', CRIT_COMP='GT', VALE=10000.),
               _F(NOM_PARA='ABS_corr', CRIT_COMP='LT', VALE=30000.),
            ),
         )

      5. Extraire certaines colonnes d'une table.

         tab=CALC_TABLE(
            TABLE=tab, reuse=tab,
            EXTR=_F(NOM_PARA=('ABS_corr', 'MTAST', 'EFF_NORM', 'NORM_DEP'),),
         )

      6. Ordonner les lignes selon les valeurs d'un paramètre.

         tab=CALC_TABLE(
            TABLE=tab, reuse=tab,
            TRI=_F(NOM_PARA='ABS_corr', ORDRE='CROISSANT',),
         )

      Généralités :
      =============
      OPER, FILTRE et RENOMME sont répétables, pas d'intérêt pour EXTR,
      COMB et TRI ne le sont pas car l'ordre des occurences du mots-clé facteur
      pourrait modifier le résultat final.

      UN_PARMI(actions) car elles ne sont pas commutatives.

      La commande est réentrante : On crée une nouvelle table de meme nom,
      on "n'enrichit" pas une table existante (au sens ajout de lignes
      ou de colonnes).

      Performances :
      ==============
      La seule opération couteuse est la combinaison (COMB).
      Le temps de la combinaison de deux tables (de 17 colonnes) entre la
      première écriture de la fonction merge et une deuxième où limite les
      opérations en N**2 au minimum est :
        Nb lignes       Temps merge v1      Temps merge v2
         5 000              18                  5
        10 000              70                 22
        20 000               -                 76
      Le temps augmente en peu moins de N**2.
      Le temps d'analyse des données par le superviseur n'est pas négligeable :
      en effet, on appelle CREA_TABLE avec des listes de 10 ou 20 000 réels
      derrière les mots-clés, et temps écoulé or de la commande elle-meme et
      donc imputable au "superviseur" est de l'ordre de 10 secondes pour
      la meme table de 10 000 lignes/17 colonnes.
      L'opération par formule (mot-clé OPER) n'est pas très couteuse :
      sur l'exemple cité plus haut : respectivement 3 et 7 secondes pour 10
      et 20 000 lignes, soit augmentation en N.

   DETAILS
    - Table.append : permet d'ajouter une colonne et non plus une ligne.
    - Table.dict_CREA_TABLE retourne le dictionnaire à fournir à CREA_TABLE
      pour créer la table_sdaster équivalente.
    - merge : fonction pour combiner deux tables.
    Nouveaux : calc_table.capy et calc_table_ops.py@Macro
    Une alarme supplémentaire car j'enchaîne un IMPR_TABLE et un IMPR_FONCTION
    au format XMGRACE dans le meme fichier pour vérifier que les courbes sont
    bien concaténées.

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : OUI
     DOC_U : U4.33.03
       EXPL_ : Nouvelle commande CALC_TABLE
   VALIDATION
      ssll501a.com2 :
         On refait la manip sur MT=f(ABSC_CURV) du .com1 en remplaçant
         RECU_FONCTION+CALC_FONCTION+IMPR_FONCTION/ABSCISSE
         par :

         decX = FORMULE(NOM_PARA='ABSC_CURV', VALE='57766.1-ABSC_CURV')
         norm = FORMULE(NOM_PARA='MT',        VALE='abs(MT*1.e-6)')
         EFF_GENc=CALC_TABLE(
            TABLE=EFF_GEN,
            OPER=(
               _F(FORMULE=decX, NOM_PARA='ABS_corr'),
               _F(FORMULE=norm, NOM_PARA='MTAST'),
            ),
         )
         + IMPR_TABLE
         + un test de chaque MCF

------------------------------------------------------------------------------
REALISATION EL 2005-125
   NB_JOURS_TRAV  : 0.5
   INTERET_UTILISATEUR : NON
   TITRE :   Performances d'extraction de données dans les tables
   FONCTIONNALITE
     CALC_TABLE, mcf COMB répond à ce que veut faire JLF.
     La combinaison de deux tables de 10000 lignes, 15 colonnes
     sur 2 paramètres communs prend 22 secondes sur mon PC.

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION


========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

       C AJOUT utilitai/fetmpi               boiteau O.BOITEAU           56     56      0
       C AJOUT utilitai/gtnpro               boiteau O.BOITEAU           45     45      0
       C MODIF supervis/astermodule          boiteau O.BOITEAU         3957     22      1
       C MODIF supervis/python               boiteau O.BOITEAU           80     29      2
 CASTEST AJOUT demo005a                     lebouvie F.LEBOUVIER        286    286      0
 CASTEST AJOUT demo006a                     lebouvie F.LEBOUVIER        229    229      0
 CASTEST MODIF sdll134a                      cibhhpd L.SALMONA          277      3      3
 CASTEST MODIF ssll501a                     mcourtoi M.COURTOIS         381      1      1
 CASTEST MODIF ssna116a                       gevais V.GERVAIS          447      2      2
 CASTEST MODIF ssnl102a                      acbhhcd G.DEVESA           138     25     28
 CASTEST MODIF zzzz140a                     mcourtoi M.COURTOIS         183      3      3
CATALOPY AJOUT commande/calc_table          mcourtoi M.COURTOIS          81     81      0
CATALOPY MODIF commande/macro_proj_base       boyere E.BOYERE            53      5      2
CATALOPY MODIF commande/meca_statique        boiteau O.BOITEAU           95      3      3
CATALOPY MODIF commun/c_comp_incr            acbhhcd G.DEVESA           319      2      2
 FORTRAN AJOUT algeline/fetcpu               boiteau O.BOITEAU           95     95      0
 FORTRAN AJOUT algeline/fetsm                boiteau O.BOITEAU          107    107      0
 FORTRAN AJOUT algeline/fettor               boiteau O.BOITEAU           87     87      0
 FORTRAN AJOUT supervis/affich               boiteau O.BOITEAU           29     29      0
 FORTRAN MODIF algeline/alfeti               boiteau O.BOITEAU          769    296    206
 FORTRAN MODIF algeline/facsmb               boiteau O.BOITEAU          275     21     14
 FORTRAN MODIF algeline/preml1               boiteau O.BOITEAU          365     25     15
 FORTRAN MODIF algeline/preres               boiteau O.BOITEAU          234     29     12
 FORTRAN MODIF algeline/resfet               boiteau O.BOITEAU          100      6      8
 FORTRAN MODIF algeline/resoud               boiteau O.BOITEAU          246     47      8
 FORTRAN MODIF algeline/vtcmbl               boiteau O.BOITEAU          391     32     17
 FORTRAN MODIF algeline/vtcreb               boiteau O.BOITEAU          138     19     13
 FORTRAN MODIF algeline/vtdefs               boiteau O.BOITEAU          170     29     10
 FORTRAN MODIF algorith/cresol               boiteau O.BOITEAU          349     51     16
 FORTRAN MODIF algorith/fetarp               boiteau O.BOITEAU          156     23     17
 FORTRAN MODIF algorith/fetccn               boiteau O.BOITEAU          195     30     21
 FORTRAN MODIF algorith/fetfac               boiteau O.BOITEAU          151      9     13
 FORTRAN MODIF algorith/fetfiv               boiteau O.BOITEAU          192     58     32
 FORTRAN MODIF algorith/fetggt               boiteau O.BOITEAU          341    128     51
 FORTRAN MODIF algorith/feting               boiteau O.BOITEAU          196     32     22
 FORTRAN MODIF algorith/fetinl               boiteau O.BOITEAU          284     80     40
 FORTRAN MODIF algorith/fetmon               boiteau O.BOITEAU          122      7     11
 FORTRAN MODIF algorith/fetprc               boiteau O.BOITEAU          149     44     18
 FORTRAN MODIF algorith/fetprj               boiteau O.BOITEAU          251     61     40
 FORTRAN MODIF algorith/fetreo               boiteau O.BOITEAU          221     39     16
 FORTRAN MODIF algorith/fetrex               boiteau O.BOITEAU          138      1     18
 FORTRAN MODIF algorith/fetrin               boiteau O.BOITEAU          550    159     90
 FORTRAN MODIF algorith/fetsca               boiteau O.BOITEAU          135      1      1
 FORTRAN MODIF algorith/hbrcvx                gevais V.GERVAIS           97      2      2
 FORTRAN MODIF algorith/mestat               boiteau O.BOITEAU          306      3      1
 FORTRAN MODIF assembla/assde1               boiteau O.BOITEAU          106     11      5
 FORTRAN MODIF assembla/assmam               boiteau O.BOITEAU          946     40     19
 FORTRAN MODIF assembla/assvec               boiteau O.BOITEAU          881     33     14
 FORTRAN MODIF assembla/numero               boiteau O.BOITEAU          340     35     21
 FORTRAN MODIF elements/creso1               boiteau O.BOITEAU          179     13     20
 FORTRAN MODIF elements/dicor4               acbhhcd G.DEVESA           125     13      4
 FORTRAN MODIF elements/dicor5               acbhhcd G.DEVESA           128     20     15
 FORTRAN MODIF elements/dicorn               acbhhcd G.DEVESA           606    319    150
 FORTRAN MODIF elements/dikini               acbhhcd G.DEVESA           102      4      4
 FORTRAN MODIF elements/te0047               acbhhcd G.DEVESA           638      7     10
 FORTRAN MODIF modelisa/exlim2               boiteau O.BOITEAU          348     44      9
 FORTRAN MODIF modelisa/op0143               cibhhpd L.SALMONA          552      2      1
 FORTRAN MODIF supervis/exstat               boiteau O.BOITEAU          118      6      7
  PYTHON AJOUT Macro/calc_table_ops         mcourtoi M.COURTOIS         172    172      0
  PYTHON MODIF Execution/E_ETAPE             boiteau O.BOITEAU          234     24     17
  PYTHON MODIF Utilitai/Graph               mcourtoi M.COURTOIS        1152      2      1
  PYTHON MODIF Utilitai/Table               mcourtoi M.COURTOIS         787    166    101


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :   10        1187      1187             +1187
 MODIF :   52       19693      2066    1157      +909
 SUPPR :    0           0                 0        +0
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :   62       20880      3253    1157     +2096 
