

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR acbhhcd      DEVESA G.              DATE 30/01/2006 - 18:03:51

--------------------------------------------------------------------------------
RESTITUTION FICHE 009143 DU 2005-10-25 00:00:00
TYPE anomalie concernant Code_Aster (VERSION 8.1)
TITRE
   DYNA_TRAN_MODAL
FONCTIONNALITE
   Comme suppose par Olivier, il faut bien intervenir dans la routine MDTR74 et
   tromper alors la valeur de la variable d'appel TYPBAS qui sera transmise en
   aval a la routine MDACCE pour l'inversion de la matrice de masse generalisee.
   On modifie TYPBAS pour se retrouver dans le cas d'une matrice pleine a
   inverser (type generique BASE_MODA) plutot que dans celui des matrices
   diagonales (type generique MODE_MECA ou MODE_GENE).
   On teste la modification sur une etude inspiree du test SDNL105D modifie.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE :
VALIDATION
   etude
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 009321 DU 2006-01-03 18:12:42
TYPE anomalie concernant Code_Aster (VERSION 8.2)
TITRE
   DYNA_NON_LINE et AMORTISSEMENT
FONCTIONNALITE
   Le probleme vient du fait que l'on prend en compte 2 fois l'amortissement
   mecanique. La premiere fois par une force de correction -C.V calculee quand on
   a des elements solides absorbants. La seconde fois en activant le calcul de la
   matrice d'amortissement via l'option AMOR_MECA s'il existe de l'amortissement
   AMOR_ALPHA dans un materiau.
   Pour avoir le bon resultat, il faut ne le prendre qu'une fois. Pour cela, on
   cree une option specifique AMOR_MECA_ABSO pour les elements solides absorbants
   3D_ABSO et DP_ABSO a la place de l'option AMOR_MECA.
   On la teste dans le cas test SDLV120A qui presentait un suramortissement quand
   on mettait AMOR_ALPHA = 0. On lance alors DYNA_LINE_TRAN par 2 chemins:
   Avec une force de correction sans matrice d'amortissement et avec une matrice
   d'amortissement calculee avec l'option AMOR_MECA_ABSO avec une force de
   correction nulle.
   Dans tous les cas, on se recale sur les resultats initiaux sans AMOR_ALPHA et
   sur ceux du calcul avec DYNA_NON_LINE.
   Parmi les modifications :
   - On cree donc la nouvelle option AMOR_MECA_ABSO
   - On l'affecte a la place d'AMOR_MECA dans les catalogues des elements ME3DA2
   et MEDPA1
   - On la renseigne dans le catalogue de CALC_MATR_ELEM
   - On modifie les sources de OP0009 et MEAMME
   - On modifie le test SDLV120A
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V2.04.120
VALIDATION
   cas test
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 009060 DU 2005-09-29 00:00:00
TYPE aide utilisation concernant Code_Aster (VERSION 7.5)
TITRE
   AOM  DYNA_NON_LINE
FONCTIONNALITE
   L'option utilisee pour prendre en compte le multi-appuis dans DYNA_NON_LINE
   utilisee ici n'est pas la meilleure methode ni non plus la plus usuelle.
   La methode a recommander, et qui merite variment le nom de multi-appuis, est
   la methode classique de correction du mouvement d'entrainement par modes
   statiques (comme DYNA_TRAN_MODAL) qui fait l'objet du test SDND102B avec mot
   clef MULTI_APPUI justement.
   Meme si elle distingue le mouvement absolu du mouvement relatif, elle est la
   seule qui garantisse de pouvoir imposer et controler simultanement un
   deplacement, une vitesse et une acceleration aux appuis.
   La methode des deplacements imposes aux appuis ne permet jamais de les
   controler simultanement. L'acceleration aux appuis peut varier avec le pas de
   temps et les parametres de l'algorithme sans qu'on puisse tirer de loi de
   variation reguliere. Et elle est par contre insensible a l'amortissement
   discret aux appuis et a l'amortissement par materiau dans la structure a
   cause de la condition de deplacement impose.
   Il y a cependant une variante aux deplacements imposes qui consiste a
   affecter aux appuis des rigidites tres grandes puis des forces nodales de
   meme valeur ce qui revient a imposer des deplacements unitaires aux appuis en
   ayant donc des modes de structure tres proches des modes sur base encastree.
   L'avantage de cette methode par rapport a la precedente est que
   l'acceleration est cette fois sensible a l'amortissement discret aux appuis
   et a l'amortissement par materiau dans la structure avec une non dependance
   par rapport au pas de temps cette fois-ci, mais on a toujours du mal a
   l'ajuster par les parametres de l'algorithme et on ne peut controler
   simultanement et exactement un deplacement, une vitesse et une acceleration
   aux appuis.
   Pour revenir au cas  de la methode classique de correction du mouvement
   d'entrainement par modes statiques que je preconise, on obtient alors des
   efforts calcules sur le mouvement relatif. Et il faut les completer par des
   efforts calcules sur le mouvement d'entrainement avec la meme modelisation
   que pour le calcul des modes statiques. Je propose une maquette
   d'utilisation  impliquant des boucles sur les instants de temps calcules
   comprenant :
   - extraction a chaque instant par CREA_CHAM option 'EXTR' des champs DEPL et
   DEPL_ABSOLU de l'evolution pour creer le champ DEPL correspondant au
   mouvement d'entrainement par difference et COMB_CHAM_NO ou CREA_CHAM
   option 'ASSE'.
   - constitution pour le meme instant par CREA_RESU du champ DEPL de
   l'evolution EVOL_ELAS du mouvement d'entrainement.
   A la fin de la boucle des instants, calcul de la contrainte par CALC_ELEM
   option SIEF_ELGA_DEPL sur l'evolution precedente.
   Puis dans une nouvelle boucle :
   - extraction a chaque instant par CREA_CHAM option 'EXTR'  des champs
   SIEF_ELGA et SIEF_ELGA_DEPL des evolutions des mouvements relatif et
   d'entrainement pour creer le champ SIEF_ELGA_DEPL correspondant au mouvement
   absolu par somme et COMB_CHAM_ELEM ou CREA_CHAM option 'ASSE'.
   - constitution pour le meme instant par CREA_RESU du champ SIEF_ELGA_DEPL de
   l'evolution EVOL_ELAS du mouvement absolu.

   On peut ensuite calculer ou combiner toute autre option analogue aux
   SIEF_ELGA de la meme facon
   Je joins un exemple de traitement issu de l'etude jointe avec une boucle de
   100 pas de temps.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE :
VALIDATION
   etude jointe
NB_JOURS_TRAV  : 12.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR adbhhvf      VOLDOIRE F.            DATE 31/01/2006 - 17:04:42

--------------------------------------------------------------------------------
RESTITUTION FICHE 009388 DU 2006-01-24 13:09:14
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   DYNA NON LINE / CONTACT : nouveau test
FONCTIONNALITE
   Je propose un nouveau cas-test :
   collision en dynamique non-lineaire.

   SDNV105
   doc V5.03.105
   Balancement d'un bloc sur une table.

   La version .a de ce test est en 2D, COPL, avec la methode Lagrange.
   Ca teste : les instants de collision, les energies cinetiques, les vitesses, les
   deplacements, les reactions (avec vale_cont), les percussions.
   Nota : ce test est assez sensible au choix des parametres numeriques. Les precisions
   des
   test_resu sont assez laches ; ceux-ci font reference a une solution analytique avec
   des
   hypotheses restrictives. Une solution de "reference" est aussi reconstituee
   mi-numerique
   mi-analytique.

   Les autres methodes suivront.

   Financement : projets VHTR et OMERSI.

   FV
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V5.03.105
VALIDATION
   c'en est une
NB_JOURS_TRAV  : 40.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR boyere       BOYERE E.              DATE 31/01/2006 - 13:43:29

--------------------------------------------------------------------------------
RESTITUTION FICHE 009315 DU 2006-01-03 12:50:18
TYPE anomalie concernant Code_Aster (VERSION 8.2)
TITRE
   test sdnl103a en version NEW8.2.1
FONCTIONNALITE
   Le cas test sdnl103a tourne sans probleme en 8.2.5 sur alpha et sur linux.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE :
VALIDATION
   sans objet
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 009242 DU 2005-11-25 00:00:00
TYPE anomalie concernant Code_Aster (VERSION 8.1)
TITRE
   CALC_NO et option REAC_NODA
FONCTIONNALITE
   Lionel Salmona (CS) a repere deux erreurs dans le calcul des reactions nodales en
   dynamique.
   1/ Dans DYNA_NON_LINE, une erreur de signe faisait
   que l'on retranchait l'inertie (masse*acceleration)
   plutot que de l'ajouter a aux forces nodales dans OP0106.
   Les reactions nodales etaient donc d'autant plus fausses
   que les effets inertiels etaient grands.
   2/ Dans la meme routine OP0106, on oubliait les resultats
   de type DYNA_TRANS (issus de DYNA_LINE_TRAN ou d'une restitution
   dans l'espace physique d'un calcul transitoire sur base modale
   par DYNA_TRAN_MODAL) parmi les concepts resultats
   avec une variation dans le temps.
   Resultat : on ne prenait pas en compte la fonction
   multiplicatrice des charges dans le calcul des reactions nodales.
   Les reactions nodales etaient donc fausses
   aux points d'application de contraintes ou forces.
   D'un autre cote, ce sont des points
   ou on est a priori peu interesse par les reactions nodales.

   Emmanuel

   PS :
   a/ Je preconise une RTA pour valider les reactions nodales en dynamique.
   b/ Il reste a programmer la prise en compte des effets de l'amortissement.

   PS : 1/ Je preconise une RTA pour faire le point sur la validation des reactions nodales
   en dynamique.
   2/
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 1.0.0
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 1.0.0
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE :
VALIDATION
   forma12 a et b
NB_JOURS_TRAV  : 3.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 009353 DU 2006-01-13 11:34:18
TYPE aide utilisation concernant Code_Aster (VERSION 8.2)
TITRE
   Visualisation des deformees modales
FONCTIONNALITE
   Il se cache certainement une idee derriere l'etude qui est soumise.
   En effet, il n'est habituellement pas utile de faire une boucle pour imprimer les modes.
   C'est d'ailleurs cette boucle qui ecrase les resultats lorsqu'ils sont ecrits dans un
   meme
   fichier.
   Pour faire cette operation proprement il faut passer par un CREA_RESU puis imprimer le
   concept RESULTAT global.

   Quant a la visu des modes sous gmsh, je trouve visuel de les animer grace au plugin
   "Harmonic to Time". Il suffit alors d'entrer le mode que l'on souhaite animer en Real Part
   et en Imaginary Part.
   Il est alors copie dans un autre champ que l'on peut animer.

   Emmmanuel

   PS : Si vous souhaitez une investigation plus poussee, le maillage de calcul serait
   utile.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE :
VALIDATION
   sans objet
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR mabbas       ABBAS M.               DATE 31/01/2006 - 14:15:34

--------------------------------------------------------------------------------
RESTITUTION FICHE 009031 DU 2005-09-22 00:00:00
TYPE evolution concernant Code_Aster (VERSION 7.5)
TMA : CS
TITRE
   contact et jeu deduit du cara_elem
FONCTIONNALITE
   Le but de cette evolution est d'introduire un jeu variable pour le contact d'elements de
   structure de type poutre.
   Ce jeu est lie a la poutre meme quand elle se deplace.
   On utilise simplement les informations liees a la poutre lors de l'AFFE_CARA_ELEM option
   POUTRE section='CERCLE'.
   Pour activer cette option, on introduit dans la commande AFFE_CHAR_MECA deux nouveaux mots
   cles:
   CONTACT = _F ( DIST_POUTRE = / 'NON'    par defaut
   / 'OUI'
   CARA_ELEM = cara
   ...
   si DIST_POUTRE est present, alors CARA_ELEM est obligatoire.

   Lors du traitement du contact, on ajoute simplement le jeu correspondant au rayon de la
   poutre pour le noeud ESCLAVE.

   Affichage lors de la lecture du mot cle CONTACT (INFO=2)
   Exemple d'impression
   <CONTACT> ************** DIST_POUTRE  ************
   NOEUD: N1       RAYON_POUTRE:  3.17500E+01
   NOEUD: N2       RAYON_POUTRE:  3.17500E+01
   NOEUD: N3       RAYON_POUTRE:  3.17500E+01
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.42.01 ; V6.04.505 ; D4.06.14
VALIDATION
   ssnv505g
NB_JOURS_TRAV  : 4.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR durand       DURAND C.              DATE 31/01/2006 - 14:15:39

--------------------------------------------------------------------------------
RESTITUTION FICHE 009387 DU 2006-01-24 09:25:22
TYPE anomalie concernant Code_Aster (VERSION 8.2)
TMA : CS
TITRE
   NEW8.2.4, le test cente01a s'arrete en ERREUR
FONCTIONNALITE
   Correction d'une faute de frappe dans la routine psvari :

   ELSE IF  (COMPOR.EQ.'ROUSS_VISC')  THEN
   IPOP2  = 1
   IPOP2  = NBVARI
   en
   ELSE IF  (COMPOR.EQ.'ROUSS_VISC')  THEN
   IPOP1  = 1
   IPOP2  = NBVARI

   passage du test cente01a sur clayastr et Rocks (ceci corrige la fiche  9370)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE :
VALIDATION
   cente01a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR mabbas       ABBAS M.               DATE 31/01/2006 - 14:15:43

--------------------------------------------------------------------------------
RESTITUTION FICHE 009393 DU 2006-01-25 12:10:13
TYPE express concernant Code_Aster (VERSION 8.2)
TITRE
   AFFE_CHAR_MECA - mots-clefs CONTACT
FONCTIONNALITE
   Il y a des mots-clefs dans le contact qui ne sont pas branches, qui
   ne servent a rien et qui sont buggues. Exemple (!):

   STOP_REAC_GEOM =SIMP(statut='f',typ='TXM',defaut="ALARME",
   into=("OUI","NON")),

   Mais aussi TOLE_REAC_GEOM et NB_REAC_MAXI et VERI_REAC_GEOM.

   On nettoie affe_char_meca et affe_char_meca_f
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE :
VALIDATION
   Neant
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 009272 DU 2005-12-16 16:20:28
TYPE anomalie concernant Code_Aster (VERSION 8.2)
TITRE
   OPTI_LIST_INST='INCR_MAXI'
FONCTIONNALITE
   Lorsque l'on active l'option OPTI_LIST_INST dans STAT_NON_LINE
   on obtient le message d'alarme suivant :
   <A> <STAT_NON_LINE> <OPTILI> LISTE D INSTANTS CHANGEE


   a tous les pas de temps, cad meme ceux ou aucun pas de temps n'a ete
   rajoute.

   La correction consiste a n'afficher l'information que lorsqu'on ajoute
   effectivement des pas de temps et a en donner le nombre:

   LISTE D'INSTANTS OPTIMISEE : 432 INSTANTS THERMIQUES AJOUTES

   Impacts:
   optili, nminit, nmimpr, nmimpm

   NB: ce n'est plus une alarme mais une simple information.

   On en profite pour rapatrier l'initialisation de l'affichage de op0070
   a nminit.

   Impacts:
   nmini0 et op0070
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE :
VALIDATION
   hsnv125e
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR durand       DURAND C.              DATE 30/01/2006 - 18:09:30

--------------------------------------------------------------------------------
RESTITUTION FICHE 009384 DU 2006-01-23 17:14:09
TYPE express concernant Code_Aster (VERSION 2.x)
TITRE
   destruction des objets temporaires des macros
FONCTIONNALITE
   Suite a un signalement par Georges Devesa, la destruction de ces objets temporaires
   (nommes avec un double underscore dans le corps des macros) n'etait effectif qu'en
   par_lot=NON. Je corrige donc E_MACRO_ETAPE.py.

   Au passage, ca permet de voir que dans macro_matr_asse_ops.py, le concept CALC_MATR_ELEM
   est sense etre conserve ... mais ne l'est pas : renommage en "simple" underscore.

   En plus de macro_matr_asse, correction d'objet __ en objet _ pour des charges dans
   macr_aspic_calc et macr_ascouf_calc
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE :
VALIDATION
   cas tests de la base
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 009370 DU 2006-01-19 07:59:08
TYPE anomalie concernant Code_Aster (VERSION 8.2)
TITRE
   test cente01a en version 8.2.4 linux Rocks
FONCTIONNALITE
   fiche corrigee avec 9387
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE :
VALIDATION
   cente01a
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------
RESTITUTION FICHE 009410 DU 2006-01-30 08:28:31
TYPE express concernant Code_Aster (VERSION 2.x)
TITRE
   detruire et numerotation des commandes
FONCTIONNALITE
   Desormais dans GCDETC.f, on balaye tous les concepts anterieurement crees et non plus
   seulement ceux de l'execution courante (en poursuite).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE :
VALIDATION
   etude perso
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR g8bhhxd      DESROCHES X.           DATE 30/01/2006 - 15:01:40

--------------------------------------------------------------------------------
RESTITUTION FICHE 009374 DU 2006-01-19 08:40:41
TYPE anomalie concernant Code_Aster (VERSION 8.2)
TITRE
   NEW8.2.4, le test hplp101b s'arrete en ERREUR
FONCTIONNALITE
   Suite au developpement du calcul des derivees des
   coefficients d'intensite de contraintes, les noms de
   certaines cmp dans les tables ont change.
   Ce cas-test n'avait pas ete mis a jour.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE :
VALIDATION
   hplp101b
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR gnicolas     Gerald NICOLAS         DATE 31/01/2006 - 14:29:38

--------------------------------------------------------------------------------
RESTITUTION FICHE 009251 DU 2005-12-02 00:00:00
TYPE anomalie concernant Code_Aster (VERSION 8.1)
TMA : DeltaCad
TITRE
   IMPR_RESU / LIRE_RESU au format MED
FONCTIONNALITE
   Il est apparu des problemes geometriques lors des passages Aster <--> MED.
   En effet, la description de certaines mailles est differente entre Aster et
   Med, notamment en ce qui concerne l'ordre des noeuds.
   Ces problemes peuvent survenir lorsque:
   - Code Aster genere un fichier de maillage au format MED
   (par un IMPR_RESU au format MED a partir d'un concept maillage issu de
   LIRE_MAILLAGE).
   - Code Aster lit en entree un fichier MED pour creer un concept maillage
   (par un LIRE_MAILLAGE au format MED)

   La consultation de la doc U3.01.01 (description du fichier de maillage du
   Code Aster) et de la doc de MED (disponible sur le site) a permis
   d'identifier les types de mailles dont la convention MED n'est pas respectee
   par Aster. Il s'agit des types de mailles TETRA4, TETRA10, PYRAM5, PYRAM13,
   PENTA6, PENTA15, HEXA8, HEXA20.

   L'une des convention MED a respecter est la normale sortante:
   Exemple: TETRA4
   Soit N1 N2 N3 N4 la representation des noeuds ordonnes d'une maille Aster TETRA4.
   La position du noeud N4 dans Aster est telle que la normale obtenue par le
   produit vectoriel de N1N2 et N1N3 soit entrante, alors que pour MED la normale est
   sortante.
   Ainsi, pour la maille Aster de type TETRA4, sa representation dans MED est:
   N1 N3 N2 N4.

   Une autre convention sur l'ordre de la numerotation des noeuds milieux n'a pas ete
   respectee pour
   les PENTA15 et les HEXA20:
   - dans Aster: l'ordre de numerotation est le suivant:
   1. numerotation des noeuds sommets des faces bas et haut
   2. numerotation des noeuds milieux de la face du bas.
   3. numerotation des noeuds milieux des aretes verticales
   4. numerotation des noeuds milieux de la face du haut.
   - dans Med, l'ordre de numerotation est different: 1 - 2 - 4 - 3

   Remarque: Pour verifier le contenu du fichier med (binaire), on utilise la commande
   xmdump.
   La version de xmdump utilisee doit etre la 2.2.3 et non celle prise par defaut
   (2.2.2).
   L'executable xmdump se trouve sur clayastr dans /home/med/med-2.2.3/bin.

   Sources modifiees:
   ircame.f irmhdf.f irmmma.f lrcame.f lrmhdf.f lrmmma.f lrmtyp.f op0150.f
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : STA7.1
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : NEW8.1
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE :
VALIDATION
   etude fournie (HEXA8) + extension de l'etude a d'autres types de mailles
NB_JOURS_TRAV  : 3.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 009346 DU 2006-01-11 15:32:15
TYPE anomalie concernant Code_Aster (VERSION 8.2)
TITRE
   Bug MED :  " <F> <IMPR_RESU> <IRMMFA> MED: ERREUR EFFAMC NUMERO -1 "
FONCTIONNALITE
   L'anomalie venait du fait que deux groupes portaient le meme nom, a un suffixe en '_'
   pres
   : 'Face_mX' et 'Face_mX_'. Or le programme de creation des noms de familles, mdnofa, se
   base sur les noms des groupes et complete avec des '_' a 32 caracteres. Ici, le
   programme
   cree donc deux fois la famille MED 'Face_mX__________________________'. Et comme deux
   familles ne peuvent pas porter le meme nom, il y a plantage.
   La correction consiste a reperer si des '_' sont presents en fin de nom de groupes.
   Dans
   ce cas, le mecanisme initial est ameliore en ajoutant un suffixe numerique et en
   controlant l'unicite des noms de famille (programme mdnofa).

   Par la meme occasion, j'apporte une evolution de securite. Si dans la description des
   familles enregistrees dans le fichier MED, un nom de groupe depasse les 8 caracteres,
   on
   fait un arret fatal. En effet, Aster ne sait traiter que des noms de groupe a 8
   caracteres
   (programme lrmmf3).

   Toutefois, comme la convention MED autorise des noms de groupe allant jusqu'a 80
   caracteres, ce probleme risque de se reproduire avec l'usage de Salome. Il faudra
   engager
   une evolution pour resoudre cette difficulte.

   En version 7, on ne restitue que l'arret fatal en cas de nom de groupe superieur a 80
   caracteres.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : NEW7.1
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : NEW8.1
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE :
VALIDATION
   cas-test MED
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 009358 DU 2006-01-13 13:59:00
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   IMPR_RESU au format MED - Localisation des points de Gauss
FONCTIONNALITE
   Quand on ecrit un champ aux points de Gauss dans un fichier au format MED, on ecrit
   egalement la description de la localisation de ces points dans l'element. La
   localisation
   est definie sur l'element de reference : coordonnees des noeuds, des points de
   Gauss,
   poids (programme uteref).

   Dans le fichier MED, cette localisation est identifiee par un nom, sur 32 caracteres
   (programme irmpg1), selon la convention suivante :
   NOLOPG( 1:16) = Nom de la famille des points de Gauss, au sens d'Aster
   On complete par des '_'
   Exemple : QU4_____FPG4 ___________________
   12345678901234567890123456789012

   Quand le champ est exprime avec des sous-points, on ajoute le nombre de sous-points dans
   le nom : NOLOPG(17:24)
   Exemple : QU4_____FPG4 __________3________
   12345678901234567890123456789012

   Enfin, il peut arriver que cela ne soit pas suffisant si les modelisations ne sont pas
   les
   memes : les sous-points ne sont pas forcement aux memes endroits. Dans ce cas-la, on
   ajoute un compteur en fin de chaine.
   Exemple : QU4_____FPG4 __________3_______1
   12345678901234567890123456789012

   Cette evolution permettra la visualisation correcte des champs avec leurs vraies valeur
   aux points de Gauss, par exemple dans Salome, et non plus via une projection sur les
   noeuds.

   Le cas des champs ELNO est un sous-ensemble des ELGA : il y a plusieurs valeurs par
   mailles mais les coordonnees de ces sous-points sont implicites puisqu'ils sont places
   aux
   noeuds. Dans ce cas, le nom de la localisation est defini par le nom de la maille, suivi
   de ELNO en position de 9 a 12.
   Exemple : TRIA6___ELNO____________________
   12345678901234567890123456789012
   Ce noeud est temporaire. Des que l'evolution MED numero 104 sera prise en compte, on
   utilisera le nom type reserve.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : NEW8.1
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U7.05.21
VALIDATION
   cas-test MED
NB_JOURS_TRAV  : 15.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR mcourtoi     COURTOIS Mathieu       DATE 30/01/2006 - 11:51:55

--------------------------------------------------------------------------------
RESTITUTION FICHE 009101 DU 2005-10-13 00:00:00
TYPE anomalie concernant Code_Aster (VERSION 8.1)
TMA : DeltaCad
TITRE
   menage appels UTMESS
FONCTIONNALITE
   Dans l'appel au routines UTMESS et UTDEBM, le deuxieme argument ne doit pas etre le nom
   de
   la commande courante (celui ci est automatiquement retrouve et affiche) mais le nom de la
   routine qui emet le message.

   Exemple thaclm.f :
   CALL UTMESS('A',NOMCMD,...) et la variable NOMCMD n'est de plus pas definie, ce qui
   produit des echos sales dans le fichier de message. Il faut faire :
   CALL UTMESS('A','THACLM',....)

   On remplace dans les appels a UTMESS et UTDEBM, le deuxieme argument d'appel a ces deux
   routines par le nom de la routine appelante. 139 routines fortran ont ainsi ete
   modifiees.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE :
VALIDATION
   liste restreinte
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR geniaut      GENIAUT S.             DATE 30/01/2006 - 17:02:39

--------------------------------------------------------------------------------
RESTITUTION FICHE 009372 DU 2006-01-19 08:36:48
TYPE anomalie concernant Code_Aster (VERSION 8.2)
TITRE
   NE8.2.4, le test ssnv173f s'arrete en ERREUR
FONCTIONNALITE
   bug du a une mauvaise orientation des normales des
   segments de contact.

   cela provoquait un calcul faux dans la verification du jeu
   au niveau de la boucle des contraintes actives.

   mais cela n'impactait pas le resultat en 8.2.1 car la
   tolerance sur la verification du jeu etait lache.

   en 8.2.3, la tolerance sur le jeu a ete resseree, ce qui a
   provoque le plantage.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 8.2.3
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE :
VALIDATION
   ssnv173.f
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR mcourtoi     COURTOIS Mathieu       DATE 31/01/2006 - 14:44:35

--------------------------------------------------------------------------------
RESTITUTION FICHE 009397 DU 2006-01-25 14:57:18
TYPE anomalie concernant Code_Aster (VERSION 7.6)
TITRE
   ssna110a plante sur 7.6 sur Calibre 4
FONCTIONNALITE
   Sous Calibre 4, le test ssna110a s'arrete brutalement avec le message :
   lda must be >= MAX(N,1): lda=0 N=0Parameter 7 to routine cblas_dgemv was incorrect

   Le message est emis par Numeric au moment ou on appelle :
   Numeric.dot(V1, V2) alors que V1 et V2 sont de longueur nulle.

   Je corrige en decomposant le second membre en deux parties :
   -
   xi=-LinearAlgebra.solve_linear_equations(take(take(Q,I),I,1),(take(d,I)+Numeric.dot(take(t
   ake(Q,I),Act,1),take(Dim.adim(dval),Act))))
   +          t_QI = take(Q, I)
   +          t_tQI_Act = take(t_QI, Act, 1)
   +          t_adim_Act = take(Dim.adim(dval), Act)
   +          if size(t_tQI_Act) > 0 and size(t_adim_Act) > 0:
   +             smemb = take(d, I) + Numeric.dot(t_tQI_Act, t_adim_Act)
   +          else:
   +             smemb = take(d, I)
   +          xi=-LinearAlgebra.solve_linear_equations(take(t_QI, I, 1), smemb)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : A0.02.30
VALIDATION
   ssna110a sous clapt602
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 009231 DU 2005-11-23 00:00:00
TYPE anomalie concernant Code_Aster (VERSION 8.1)
TITRE
   DEFI_FONCTION
FONCTIONNALITE
   Lorsqu'on definit une fonction avec DEFI_FONCTION - VALE_PARA/VALE_FONC et qu'on detruit
   ensuite une des listr8, on s'arrete assez salement lors, par exemple, d'un IMPR_FONCTION
   dans la methode Valeurs() !

   En effet, comme on est globalement en PAR_LOT='OUI', Valeurs() va chercher dans l'etape
   DEFI_FONCTION comment a ete creee la fonction et essaie donc d'appliquer Valeurs()
   sur la
   listr8 detruite.

   Je modifie les methodes Valeurs, Parametres pour que, en PAR_LOT='NON', on aille
   chercher
   les valeurs dans le concept (getvectjev), en PAR_LOT='OUI', on essaie d'aller chercher
   dans l'etape quand on sait le faire, sinon on s'arrete plus clairement.

   Dans l'exemple du DEFI_FONTION - VALE_PARA/VALE_FONC, Valeurs() dans IMPR_FONCTION ne pose
   plus de probleme car il est localement (dans la macro) en PAR_LOT='NON' et peut donc
   aller
   chercher les valeurs dans le concept.
   Si on ajoute dans le jeu de commandes :
   l_v = FSE.Valeurs()
   on s'arrete avec :

   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   ! Erreur dans listr8.Valeurs en PAR_LOT='OUI' !
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

   Pour cela, j'ajoute une methode dans la classe ASSD (N_ASSD.py) qui renvoie True si on
   est
   en par_lot, False sinon.

   Je modifie aussi toutes les methodes qui ont besoin d'etre en PAR_LOT='NON' pour
   emettre
   un message plus clair avant de planter quand on essaie le getvectjev...

   modele_gene.LIST_SOUS_STRUCT
   modele_gene.LIST_LIAIS_STRUCT
   macr_elem_dyna.NBRE_MODES
   macr_elem_dyna.EXTR_MATR_GENE
   macr_elem_dyna.RECU_MATR_GENE
   listr8.Valeurs
   maillage.LIST_GROUP_NO
   maillage.LIST_GROUP_MA
   cham_elem.EXTR_COMP
   cham_no.EXTR_COMP
   resultat.LIST_CHAMPS
   resultat.LIST_NOM_CMP
   resultat.LIST_VARI_ACCES
   resultat.LIST_PARA
   fonction.Parametres
   fonction.Trace
   fonction.Valeurs
   fonction_c.Valeurs
   fonction_c.Trace
   nappe.Valeurs
   nappe.Parametres
   nappe.Trace
   matr_asse_gene.EXTR_MATR_GENE
   matr_asse_gene.RECU_MATR_GENE
   matr_asse_gene_c.EXTR_MATR_GENE
   matr_asse_gene_c.RECU_MATR_GENE
   table.__getitem__
   table.EXTR_TABLE
   vect_asse_gene_r.EXTR_VECT_GENE
   vect_asse_gene_r.RECU_VECT_GENE
   vect_asse_gene_c.EXTR_VECT_GENE
   vect_asse_gene_c.RECU_VECT_GENE
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE :
VALIDATION
   liste complete
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 009407 DU 2006-01-27 10:31:40
TYPE anomalie concernant Code_Aster (VERSION 8.2)
TITRE
   LIRE_RESU et unite logique
FONCTIONNALITE
   Lors d'une etude, on enchaine un lire_resu puis un pre_ideas sur la meme unite logique du
   coup plantage.
   En regardant de plus pres l'op0150, on voit bien un ulopen pour ouvrir l'unite logique
   mais pas un ulopen pour la fermer.

   J'etais tente d'ajouter un ulopen pour fermer l'unite... mais dans un cas-test
   (sdll100a),
   on enchaine 2 LIRE_RESU sur la meme unite et si on ferme le fichier, il faudrait refaire
   le DEFI_FICHIER pour retrouver la correspondance unite/nom de fichier.

   Le probleme n'est pas vraiment dans LIRE_RESU mais plutot dans PRE_IDEAS qui fait soit
   l'open si le fichier n'est pas ouvert, rien sinon.
   Et donc dans ce dernier cas, comme les routines en dessous utilisent encore
   IUNIFI('IDEAS'), il faut redefinir le ddname 'IDEAS' avec ULDEFI.
   ==> dans stbast.f

   Il faudrait faire definitivement la peau a IUNIFI hors des unites "systeme" (message,
   resultat...).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE :
VALIDATION
   enchainement d'un lire_resu + pre_ideas
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR geniaut      GENIAUT S.             DATE 30/01/2006 - 11:43:41

--------------------------------------------------------------------------------
RESTITUTION FICHE 009357 DU 2006-01-13 13:22:48
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TMA : DeltaCad
TITRE
   POST_MAIL_XFEM
FONCTIONNALITE
   Une anomalie est apparue lorsque le maillage (initial) contenait plusieurs type de mailles
   volumiques.
   La correction a consiste a reinitialiser une variable dans l'op0187.f
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE :
VALIDATION
   passage de l'etude fournie
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST AJOUT sdnv105a                      adbhhvf F.VOLDOIRE        1313   1313      0
 CASTEST AJOUT ssnv505g                      cibhhlv L.VIVAN            248    248      0
 CASTEST MODIF hplp101b                      g8bhhxd X.DESROCHES        189      2      2
 CASTEST MODIF sdlv120a                      acbhhcd G.DEVESA           347    139     22
 CASTEST MODIF zzzz121b                     gnicolas G.NICOLAS          460    309    250
CATALOGU AJOUT options/amor_meca_abso        acbhhcd G.DEVESA            26     26      0
CATALOGU MODIF typelem/gener_me3da2          acbhhcd G.DEVESA            53      2      2
CATALOGU MODIF typelem/gener_medpa1          acbhhcd G.DEVESA            47      2      2
CATALOPY MODIF commande/affe_char_meca       cibhhlv L.VIVAN            943      6     21
CATALOPY MODIF commande/affe_char_meca_f     cibhhlv L.VIVAN            621      5     20
CATALOPY MODIF commande/calc_matr_elem       acbhhcd G.DEVESA           192     14      2
CATALOPY MODIF commande/defi_materiau         durand C.DURAND          2876      2      2
CATALOPY MODIF entete/accas                 mcourtoi M.COURTOIS        1148     95     35
 FORTRAN AJOUT modelisa/capoco               cibhhlv L.VIVAN            195    195      0
 FORTRAN AJOUT modelisa/lrmmf1              gnicolas G.NICOLAS          182    182      0
 FORTRAN AJOUT modelisa/lrmmf2              gnicolas G.NICOLAS          142    142      0
 FORTRAN AJOUT modelisa/lrmmf3              gnicolas G.NICOLAS          349    349      0
 FORTRAN AJOUT modelisa/lrmmf4              gnicolas G.NICOLAS          209    209      0
 FORTRAN AJOUT prepost/ircam1               gnicolas G.NICOLAS          325    325      0
 FORTRAN AJOUT prepost/irmmf1               gnicolas G.NICOLAS          216    216      0
 FORTRAN AJOUT prepost/irmmf2               gnicolas G.NICOLAS          392    392      0
 FORTRAN AJOUT prepost/irmpg1               gnicolas G.NICOLAS          457    457      0
 FORTRAN AJOUT prepost/irmpga               gnicolas G.NICOLAS          287    287      0
 FORTRAN AJOUT utilitai/uteref              gnicolas G.NICOLAS          317    317      0
 FORTRAN MODIF algeline/amogen              lebouvie F.LEBOUVIER        171      4      4
 FORTRAN MODIF algeline/cochgd              lebouvie F.LEBOUVIER        232      7      7
 FORTRAN MODIF algeline/mstget              lebouvie F.LEBOUVIER        245      2      2
 FORTRAN MODIF algeline/op0031              lebouvie F.LEBOUVIER        217      5      5
 FORTRAN MODIF algeline/op0032              lebouvie F.LEBOUVIER        226      3      3
 FORTRAN MODIF algeline/op0037              lebouvie F.LEBOUVIER        599     17     17
 FORTRAN MODIF algeline/op0044              lebouvie F.LEBOUVIER        784     19     19
 FORTRAN MODIF algeline/op0093              lebouvie F.LEBOUVIER        510      8      8
 FORTRAN MODIF algeline/op0167              lebouvie F.LEBOUVIER        878      4      4
 FORTRAN MODIF algeline/op0168              lebouvie F.LEBOUVIER        482     11      9
 FORTRAN MODIF algeline/recfou              lebouvie F.LEBOUVIER        170      7      7
 FORTRAN MODIF algeline/simono              lebouvie F.LEBOUVIER        116      2      2
 FORTRAN MODIF algeline/simul2              lebouvie F.LEBOUVIER        147      5      5
 FORTRAN MODIF algeline/simult              lebouvie F.LEBOUVIER        135      2      2
 FORTRAN MODIF algeline/vprecu              lebouvie F.LEBOUVIER        283      5      5
 FORTRAN MODIF algeline/vpstor              lebouvie F.LEBOUVIER        206      3      3
 FORTRAN MODIF algeline/vpstur              lebouvie F.LEBOUVIER         91      2      2
 FORTRAN MODIF algorith/asenap              lebouvie F.LEBOUVIER        258      4      4
 FORTRAN MODIF algorith/asmsup              lebouvie F.LEBOUVIER        223      4      4
 FORTRAN MODIF algorith/astron              lebouvie F.LEBOUVIER        152      2      2
 FORTRAN MODIF algorith/asveri              lebouvie F.LEBOUVIER        299     17     17
 FORTRAN MODIF algorith/cfdist               cibhhlv L.VIVAN            123     12     10
 FORTRAN MODIF algorith/dladap              lebouvie F.LEBOUVIER        597      7      7
 FORTRAN MODIF algorith/dlarch              lebouvie F.LEBOUVIER        115      3      3
 FORTRAN MODIF algorith/dldiff              lebouvie F.LEBOUVIER        472      7      7
 FORTRAN MODIF algorith/dlnewi              lebouvie F.LEBOUVIER        784      7      7
 FORTRAN MODIF algorith/dltini              lebouvie F.LEBOUVIER        212     11     11
 FORTRAN MODIF algorith/dltins              lebouvie F.LEBOUVIER        352     12     12
 FORTRAN MODIF algorith/dltp0               lebouvie F.LEBOUVIER        134      6      6
 FORTRAN MODIF algorith/dyarc1              lebouvie F.LEBOUVIER         89      4      4
 FORTRAN MODIF algorith/dylema              lebouvie F.LEBOUVIER        300      4      4
 FORTRAN MODIF algorith/gefact              lebouvie F.LEBOUVIER        470     12     12
 FORTRAN MODIF algorith/gematg              lebouvie F.LEBOUVIER        142      3      3
 FORTRAN MODIF algorith/harm75              lebouvie F.LEBOUVIER        248      3      3
 FORTRAN MODIF algorith/limsst              lebouvie F.LEBOUVIER        104      7      7
 FORTRAN MODIF algorith/mdchoc              lebouvie F.LEBOUVIER       1097     13     14
 FORTRAN MODIF algorith/mdfext              lebouvie F.LEBOUVIER        137      3      5
 FORTRAN MODIF algorith/mdgene              lebouvie F.LEBOUVIER        166     11     13
 FORTRAN MODIF algorith/mdinit              lebouvie F.LEBOUVIER        148      8     10
 FORTRAN MODIF algorith/mditmi              lebouvie F.LEBOUVIER        387     10     10
 FORTRAN MODIF algorith/mdptem              lebouvie F.LEBOUVIER        216      2      2
 FORTRAN MODIF algorith/mdtr74               acbhhcd G.DEVESA           703      9      8
 FORTRAN MODIF algorith/mdveri              lebouvie F.LEBOUVIER        132     10     10
 FORTRAN MODIF algorith/mpinv2              lebouvie F.LEBOUVIER        433      6      7
 FORTRAN MODIF algorith/mpinvc              lebouvie F.LEBOUVIER        383      6      7
 FORTRAN MODIF algorith/mpinvr              lebouvie F.LEBOUVIER        332      6      7
 FORTRAN MODIF algorith/nmimpm               cibhhlv L.VIVAN            532     17      1
 FORTRAN MODIF algorith/nmimpr               cibhhlv L.VIVAN            129      3      1
 FORTRAN MODIF algorith/nmini0               cibhhlv L.VIVAN            150     19      2
 FORTRAN MODIF algorith/nminit               cibhhlv L.VIVAN            571     92     71
 FORTRAN MODIF algorith/ntoptc              lebouvie F.LEBOUVIER        138      2      2
 FORTRAN MODIF algorith/op0022              lebouvie F.LEBOUVIER        184      5      5
 FORTRAN MODIF algorith/op0024              lebouvie F.LEBOUVIER        210      2      2
 FORTRAN MODIF algorith/op0027              lebouvie F.LEBOUVIER        259      3      3
 FORTRAN MODIF algorith/op0048              lebouvie F.LEBOUVIER        376      5      5
 FORTRAN MODIF algorith/op0060              lebouvie F.LEBOUVIER        629     12     12
 FORTRAN MODIF algorith/op0070               cibhhlv L.VIVAN            794      4     26
 FORTRAN MODIF algorith/op0075              lebouvie F.LEBOUVIER        289      9      9
 FORTRAN MODIF algorith/op0076              lebouvie F.LEBOUVIER         92      2      2
 FORTRAN MODIF algorith/op0109              lebouvie F.LEBOUVIER        472      7      7
 FORTRAN MODIF algorith/op0110              lebouvie F.LEBOUVIER        118      2      2
 FORTRAN MODIF algorith/op0115              lebouvie F.LEBOUVIER        263      4      4
 FORTRAN MODIF algorith/op0118              lebouvie F.LEBOUVIER        234      2      2
 FORTRAN MODIF algorith/op0120              lebouvie F.LEBOUVIER        219      2      2
 FORTRAN MODIF algorith/op0149              lebouvie F.LEBOUVIER        370      5      5
 FORTRAN MODIF algorith/op0166              lebouvie F.LEBOUVIER        245      2      2
 FORTRAN MODIF algorith/op0191              lebouvie F.LEBOUVIER        182      4      4
 FORTRAN MODIF algorith/optili               cibhhlv L.VIVAN            360      9      6
 FORTRAN MODIF algorith/projco               cibhhlv L.VIVAN            189     13      9
 FORTRAN MODIF algorith/rbph01              lebouvie F.LEBOUVIER        228     18     19
 FORTRAN MODIF algorith/rbph02              lebouvie F.LEBOUVIER        154      3      5
 FORTRAN MODIF algorith/rechco               cibhhlv L.VIVAN            406     10      6
 FORTRAN MODIF algorith/ssdt74              lebouvie F.LEBOUVIER        343      2      2
 FORTRAN MODIF algorith/tran75              lebouvie F.LEBOUVIER        510      6      6
 FORTRAN MODIF algorith/vriale              lebouvie F.LEBOUVIER        155     12     12
 FORTRAN MODIF algorith/xcface                massin P.MASSIN           342      6      3
 FORTRAN MODIF calculel/crperm              lebouvie F.LEBOUVIER        240      7      7
 FORTRAN MODIF calculel/meamme               acbhhcd G.DEVESA           206      8      3
 FORTRAN MODIF calculel/mecalm              lebouvie F.LEBOUVIER       2572     47     47
 FORTRAN MODIF calculel/medom1              lebouvie F.LEBOUVIER        216      4      4
 FORTRAN MODIF calculel/medome              lebouvie F.LEBOUVIER        215      3      3
 FORTRAN MODIF calculel/op0009               acbhhcd G.DEVESA           197      2      2
 FORTRAN MODIF calculel/op0058              lebouvie F.LEBOUVIER        120      3      3
 FORTRAN MODIF calculel/op0173              lebouvie F.LEBOUVIER         80      6      6
 FORTRAN MODIF calculel/resloc              lebouvie F.LEBOUVIER        298      7      7
 FORTRAN MODIF calculel/thaclm              lebouvie F.LEBOUVIER        891     22     22
 FORTRAN MODIF calculel/utcmp2              lebouvie F.LEBOUVIER        180      8      8
 FORTRAN MODIF calculel/vesecn              lebouvie F.LEBOUVIER        105      6      6
 FORTRAN MODIF elements/fonfis              lebouvie F.LEBOUVIER        489      2      2
 FORTRAN MODIF elements/psvari               cibhhlv L.VIVAN             88     11     11
 FORTRAN MODIF modelisa/calico               cibhhlv L.VIVAN            425      7      1
 FORTRAN MODIF modelisa/cazoco               cibhhlv L.VIVAN            577      6      6
 FORTRAN MODIF modelisa/chprec              lebouvie F.LEBOUVIER        278     10     10
 FORTRAN MODIF modelisa/lrmgrp              gnicolas G.NICOLAS          259     12     16
 FORTRAN MODIF modelisa/lrmhdf              gnicolas G.NICOLAS          306     14     15
 FORTRAN MODIF modelisa/lrmmfa              gnicolas G.NICOLAS          288    124    321
 FORTRAN MODIF modelisa/lrmmma              gnicolas G.NICOLAS          319     33      9
 FORTRAN MODIF modelisa/lrmmno              gnicolas G.NICOLAS          214      9      2
 FORTRAN MODIF modelisa/lrmtyp              gnicolas G.NICOLAS          386    260     16
 FORTRAN MODIF modelisa/op0056              lebouvie F.LEBOUVIER        813      4      4
 FORTRAN MODIF modelisa/surfco               cibhhlv L.VIVAN            408     25      8
 FORTRAN MODIF postrele/op0051              lebouvie F.LEBOUVIER        391      3      3
 FORTRAN MODIF postrele/rvvsup              lebouvie F.LEBOUVIER        143      5      5
 FORTRAN MODIF prepost/desgfa               gnicolas G.NICOLAS          153      2      1
 FORTRAN MODIF prepost/ircame               gnicolas G.NICOLAS          321     81    178
 FORTRAN MODIF prepost/irceme               gnicolas G.NICOLAS          129      6      8
 FORTRAN MODIF prepost/irchme               gnicolas G.NICOLAS          265     66     16
 FORTRAN MODIF prepost/ircmcc               gnicolas G.NICOLAS          133     27     15
 FORTRAN MODIF prepost/ircmec               gnicolas G.NICOLAS          209     44     70
 FORTRAN MODIF prepost/ircmpe               gnicolas G.NICOLAS          461    309    138
 FORTRAN MODIF prepost/ircmpf               gnicolas G.NICOLAS          301     16     21
 FORTRAN MODIF prepost/ircmpn               gnicolas G.NICOLAS          236     92     54
 FORTRAN MODIF prepost/ircmpr               gnicolas G.NICOLAS          224    125     52
 FORTRAN MODIF prepost/ircmva               gnicolas G.NICOLAS          237    111     51
 FORTRAN MODIF prepost/ircnme               gnicolas G.NICOLAS          128      6      8
 FORTRAN MODIF prepost/irmad0               lebouvie F.LEBOUVIER        142      3      3
 FORTRAN MODIF prepost/irmhdf               gnicolas G.NICOLAS          296     12      5
 FORTRAN MODIF prepost/irmmfa               gnicolas G.NICOLAS          229     59    423
 FORTRAN MODIF prepost/irmmma               gnicolas G.NICOLAS          280     27      9
 FORTRAN MODIF prepost/irmmno               gnicolas G.NICOLAS          209      6      7
 FORTRAN MODIF prepost/irparb               lebouvie F.LEBOUVIER         84      2      2
 FORTRAN MODIF prepost/lrcame               gnicolas G.NICOLAS          628     14      8
 FORTRAN MODIF prepost/lrceme               gnicolas G.NICOLAS          210      2      1
 FORTRAN MODIF prepost/lrcmva               gnicolas G.NICOLAS          281     23      5
 FORTRAN MODIF prepost/lrcmve               gnicolas G.NICOLAS          278     25      6
 FORTRAN MODIF prepost/lridea               lebouvie F.LEBOUVIER        570      5      5
 FORTRAN MODIF prepost/mdnofa               gnicolas G.NICOLAS          150     71      4
 FORTRAN MODIF prepost/mousto               lebouvie F.LEBOUVIER        324      2      2
 FORTRAN MODIF prepost/op0039               lebouvie F.LEBOUVIER        885     11     11
 FORTRAN MODIF prepost/op0106                 boyere E.BOYERE           814      3      2
 FORTRAN MODIF prepost/op0114               lebouvie F.LEBOUVIER        352      3      3
 FORTRAN MODIF prepost/op0132               lebouvie F.LEBOUVIER        688      5      5
 FORTRAN MODIF prepost/op0153               lebouvie F.LEBOUVIER        449      6      6
 FORTRAN MODIF prepost/op0163               lebouvie F.LEBOUVIER        236      3      3
 FORTRAN MODIF prepost/op0172               lebouvie F.LEBOUVIER        461      2      2
 FORTRAN MODIF prepost/op0176               lebouvie F.LEBOUVIER        208      2      2
 FORTRAN MODIF prepost/op0187                rezette C.REZETTE          789      8      1
 FORTRAN MODIF prepost/op0188               lebouvie F.LEBOUVIER        358      2      2
 FORTRAN MODIF prepost/pkdepl               lebouvie F.LEBOUVIER        280      9      9
 FORTRAN MODIF prepost/pkfond               lebouvie F.LEBOUVIER        840     18     18
 FORTRAN MODIF prepost/pkmate               lebouvie F.LEBOUVIER        155      5      5
 FORTRAN MODIF prepost/pkrec2               lebouvie F.LEBOUVIER        114      3      5
 FORTRAN MODIF prepost/pkrecu               lebouvie F.LEBOUVIER        185      7      9
 FORTRAN MODIF prepost/pktemp               lebouvie F.LEBOUVIER        160      2      2
 FORTRAN MODIF prepost/pofape               lebouvie F.LEBOUVIER        209      7      5
 FORTRAN MODIF prepost/pofaqu               lebouvie F.LEBOUVIER        182     10      8
 FORTRAN MODIF prepost/pofaun               lebouvie F.LEBOUVIER        289      9      9
 FORTRAN MODIF prepost/stbast               mcourtoi M.COURTOIS          50      4      1
 FORTRAN MODIF prepost/stock                lebouvie F.LEBOUVIER        163      2      2
 FORTRAN MODIF soustruc/op0104              lebouvie F.LEBOUVIER        167      2      2
 FORTRAN MODIF supervis/gcdetc                durand C.DURAND            87      6      6
 FORTRAN MODIF supervis/ibbase              lebouvie F.LEBOUVIER        211      7      7
 FORTRAN MODIF supervis/ibcode              lebouvie F.LEBOUVIER        130      2      2
 FORTRAN MODIF supervis/ibdbgs              lebouvie F.LEBOUVIER        143     11     14
 FORTRAN MODIF supervis/ibimpr              lebouvie F.LEBOUVIER        110      4      4
 FORTRAN MODIF supervis/ibtcpu              lebouvie F.LEBOUVIER         75      2      2
 FORTRAN MODIF supervis/ops007                durand C.DURAND           109      2      2
 FORTRAN MODIF supervis/ops014                durand C.DURAND           140      1      4
 FORTRAN MODIF utilitai/focrch              lebouvie F.LEBOUVIER        318      9      9
 FORTRAN MODIF utilitai/focrr0              lebouvie F.LEBOUVIER        201      7      7
 FORTRAN MODIF utilitai/focrr2              lebouvie F.LEBOUVIER        414     20     20
 FORTRAN MODIF utilitai/focrr3              lebouvie F.LEBOUVIER        126      5      5
 FORTRAN MODIF utilitai/foimpr              lebouvie F.LEBOUVIER        225      4      4
 FORTRAN MODIF utilitai/folie5              lebouvie F.LEBOUVIER        160      3      3
 FORTRAN MODIF utilitai/foverf              lebouvie F.LEBOUVIER        111      2      2
 FORTRAN MODIF utilitai/iredmi              lebouvie F.LEBOUVIER        212      2      2
 FORTRAN MODIF utilitai/liimpr              lebouvie F.LEBOUVIER        146      2      2
 FORTRAN MODIF utilitai/op0003              lebouvie F.LEBOUVIER        260     11     11
 FORTRAN MODIF utilitai/op0004              lebouvie F.LEBOUVIER        226      9      9
 FORTRAN MODIF utilitai/op0134              lebouvie F.LEBOUVIER        153      2      2
 FORTRAN MODIF utilitai/op0150              gnicolas G.NICOLAS          903     13      9
 FORTRAN MODIF utilitai/op0181              lebouvie F.LEBOUVIER        198      6      6
 FORTRAN MODIF utilitai/op0184              lebouvie F.LEBOUVIER        421     12     12
 FORTRAN MODIF utilitai/ordonn              lebouvie F.LEBOUVIER        178      6      6
 FORTRAN MODIF utilitai/rfbefl              lebouvie F.LEBOUVIER        194      3      3
 FORTRAN MODIF utilitai/rfhge1              lebouvie F.LEBOUVIER        134      5      5
 FORTRAN MODIF utilitai/rfhge2              lebouvie F.LEBOUVIER        192      5      5
 FORTRAN MODIF utilitai/rfmge1              lebouvie F.LEBOUVIER        148      5      5
 FORTRAN MODIF utilitai/rfmge2              lebouvie F.LEBOUVIER         86      3      3
 FORTRAN MODIF utilitai/rfrcha              lebouvie F.LEBOUVIER        186      6      6
 FORTRAN MODIF utilitai/rfrgen              lebouvie F.LEBOUVIER        301      8      8
 FORTRAN MODIF utilitai/rsexc1              lebouvie F.LEBOUVIER         63      3      3
 FORTRAN MODIF utilitai/rsexc2              lebouvie F.LEBOUVIER         99      5      5
 FORTRAN MODIF utilitai/rsharm              lebouvie F.LEBOUVIER        164      4      4
 FORTRAN MODIF utilitai/rstran              lebouvie F.LEBOUVIER        194      5      5
 FORTRAN MODIF utilitai/rsutnu              lebouvie F.LEBOUVIER        447     10     10
 FORTRAN MODIF utilitai/titrea              lebouvie F.LEBOUVIER        110      2      2
 FORTRAN MODIF utilitai/uttrif              lebouvie F.LEBOUVIER        119      2      2
 FORTRAN SUPPR modelisa/lrmimp              gnicolas G.NICOLAS          194      0    194
  PYTHON MODIF Execution/E_MACRO_ETAPE        durand C.DURAND           246     17      1
  PYTHON MODIF Macro/macr_ascouf_calc_ops     durand C.DURAND           687     10     10
  PYTHON MODIF Macro/macr_aspic_calc_ops      durand C.DURAND           804     14     14
  PYTHON MODIF Macro/macro_matr_asse_ops      durand C.DURAND           149      6      6
  PYTHON MODIF Macro/reca_algo              mcourtoi M.COURTOIS         267     10      3
  PYTHON MODIF Noyau/N_ASSD                 mcourtoi M.COURTOIS         134     12      1


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :   14        4658      4658             +4658
 MODIF :  204       65916      3363    2917      +446
 SUPPR :    1         194               194      -194
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :  219       70768      8021    3111     +4910 
