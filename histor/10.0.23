

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR abbas        ABBAS Mickael          DATE 26/10/2009 - 13:04:15

--------------------------------------------------------------------------------
RESTITUTION FICHE 013883 DU 2009-09-16 07:05:47
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   PILOTAGE en DDL_IMPO s'arrxc3xaate anormalement
FONCTIONNALITE
   Anomalie
   ========
   
   Dans cette version modifiée du test SSNL133A (on pilote en déplacement au lieu de piloter
   en effort), le test s'arrête et termine proprement alors qu'il n'a pas convergé.
   
   Détails
   =======
   
   Je pilote la structure (une équerre) en déplacement (PILOTAGE/DDL_IMPO) suivant le noeud
   'PC' et la composante 'DX'. Je demande un coefficient multiplicateur obtenu par le
   pilotage ETA_PILO_MAX de 5.0
   Ma liste d'instants va de 0.0 à 10.0. Je suis à l'instant 0.208, ma matrice devient non
   inversible (mais j'ai sélectionné STOP_SINGULIER='DECOUPE') je devrais donc m'attendre à
   subdiviser.
   Or comme avant matrice singulière le ETA_PILOTAGE calculé valait 5.0, il m'affiche :
   SUBDIVISION DU PAS DE TEMPS EN    4 SOUS PAS
   puis termine le STAT_NON_LINE !
   
   Solution
   ========
   
   Effectivement, quand le pilotage atteint ses bornes, un flag est mis à .TRUE. (FINPAS). Ce
   flag sert ensuite à sortir de la boucle en temps. Le problème, c'est que ce flag est levé
   dans NMCONV AVANT la vérification des erreurs survenues pendant l'itération de Newton
   (dans ce cas, une matrice non factorisable).
   Du coup, le code croit avoir atteint les bornes, ce qui se traduit par deux problèmes:
   - il archive le pas de temps croyant qu'il est correct (alors que c'est faux, puisqu'on a
   eu une erreur).
   - il sort de STAT_NON_LINE comme s'il avait convergé.
   
   Il y a risque de résultats faux quand:
   - Le pilotage est arrivé au bout (lettre B dans le tableau de convergence)
   - Il y a eu une erreur quelconque pendant les itérations du dernier pas de temps
   STAT_NON_LINE finit en OK_ALARM alors que le résultat est faux.
   
   En passant, je corrige un petit bug d'affichage (sans conséquence sur la justesse du
   calcul). STAT_NON_LINE affiche deux fois la dernière itération de Newton quand il y a une
   erreur. 
   
   Impact: NMCONV
   A faire en v9
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 9.0
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 10.0
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   liste restreinte
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 014007 DU 2009-10-09 09:35:36
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Suite Fiche 13965 : Charge de type 'DIDI' incompatible avec prediction extrapol
FONCTIONNALITE
   Problème:
   =========
   
   Quand on utilise des charges de type DIDI avec une prdiction en "EXTRAPOL" ou en
   "DEPL_CALCULE", les résultats sont FAUX.
   
   Diagnostic:
   ===========
   
   Il vient du fait que dans STAT_NON_LINE, on ne teste jamais explicitement qu'on respecte
   les conditions limites car elles sont toujours linéaires (il suffit de les imposer une
   fois au début pour qu'elles soient OK)
   Dans les méthodes EXTRAPOL (ou DEPL_CALCULE), on procède à une reprojection explicite des
   CL de Dirichlet pour justement les respecter. Il manquait le second membre correspondant à
   DIDI.
   
   Traitement:
   ===========
   
   Il suffit d'ajouter le second membre "CNDIDI" lors du calcul en prédiction.
   
   Impact: NMASSD
   
   Résultats faux: DIDI + PREDICTION ='TANGENTE' ou PREDICTION ='DEPL_CALCULE'
   
   
   A faire en v9
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 9.0
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 10.0
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   hsnv121a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 014075 DU 2009-10-21 08:57:05
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   Alarme MECANONLINE5_5
FONCTIONNALITE
   L'alarme MECANONLINE5_5 se déclenche intempestivement dans trois cas-tests (sdnd102c/d,
   sdnv100f).
   Cette alarme est là pour prevenir que l'usage de la pénalisaiton pour le contact discret
   ou les éléments de type DIS_CHOC implique de réactualiser la matrice à chaque itération.
   Pour supprimer l'alarme:
   - sdnd102c/d: il suffit de mettre REAC_ITER=1
   - sdnv100f: c'est un cas explicite pour lequel le message n'a pas de sens. Il faut
   modifier NMCHRM
   
   Impact: NMCHRM+cas-tests
   A faire en v9 (pour nmchrm au moins)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sdnd102c/d, sdnv100f
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR delmas       DELMAS Josselin        DATE 26/10/2009 - 17:13:37

--------------------------------------------------------------------------------
RESTITUTION FICHE 014068 DU 2009-10-20 13:38:31
TYPE anomalie concernant Documentation (VERSION *)
TITRE
   Doc U4.81.22 : courbes fausses (suite passage open office ?)
FONCTIONNALITE
   Problème :
   ========
   Sur la doc U4.81.22, on représente les significations des mots clés TRAV_EXT élastique et
   total.
   Les aires (orange et bleue) sont erronées : elle ne sont pas des rectangles mais se
   limitent aux aires sous la courbe pour l'orange et à un triangle rectangle pour la bleue.
   Pour avoir la bonne version, il faut par exemple consulter la doc équivalente de la version 8.
   
   Correction :
   ==========
   On corrige la figure en conséquence.
   
   Impact :
   ======
   version 10
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.81.22
VALIDATION
   *
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 014051 DU 2009-10-16 07:53:40
TYPE anomalie concernant Documentation (VERSION *)
TITRE
   Doc R4.05.01: erreur dans les references de renvoie a la DOC U
FONCTIONNALITE
   Problème :
   ========
   Dans la doc R4.05.01, les renvois aux doc U sont faux (mauvaise clé doc).
   
   Correction :
   ==========
   Cette doc est sûrement ancienne et ces clés n'ont pas été mise à jour.
   On corrige.
   
   Au passage on corrige REST_BASE_PHYS en REST_GENE_PHYS.
   
   Impacts :
   =======
   Corrections faites en 9 et 10.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   *
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 014049 DU 2009-10-15 15:44:04
TYPE anomalie concernant Documentation (VERSION *)
TITRE
   Pb affichage figure doc V6.03.015
FONCTIONNALITE
   Problème :
   ========
   Dans la doc V6.03.015 les figures et les équations sont illisibles.
   
   Correction :
   ==========
   On reprend les figures et les équations. On en profite pour mettre à jour les morceaux de
   fichier de commande (syntaxe V5).
   
   Impact :
   ======
   La correction est faite pour la doc v9 et v10
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   *
NB_JOURS_TRAV  : 1.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 013997 DU 2009-10-08 14:13:56
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
   En NEW10.0.20 et NEW9.5.7, les cas-tests sslp316a et sslp316b sont NOOK sur Rocks et sur Calibre 4.
FONCTIONNALITE
   Problème :
   ========
   En NEW10.0.20 et NEW9.5.7, les cas-tests sslp316a et sslp316b sont NOOK sur Rocks et sur
   Calibre 4.
   
   Analyse :
   =======
   Ce TEST_RESU avait été supprimé par erreur en 10.0.19 par Gérald (issue13789), puis
   rétabli en 10.0.20 (issue13976) avec une valeur différente...
   
   Par ailleurs, on observe une variation de la valeur calculée par rapport aux plateformes.
   
   Le problème vient du te0382, d'une erreur dans les arguments de la routine CALNOR. Cette
   routine est appelée deux fois : dans une boucle sur les éléments puis dans une boucle sur
   les éléments sous-découpés. L'argument erroné est le nombre max d'éléments (dans un cas
   éléments parents dans l'autre éléments sous-découpé) qui dans les deux cas était celui
   pour les éléments parents.
   
   Correction :
   ==========
   385c385
   <     &                      IAUX, NBS, NBNASE, ORIEN,
   >     &                      IAUX, NNO, NBNASE, ORIEN,
   
   On en profite pour rétablir la bonne valeur du TEST_RESU.
   
   Impacts :
   =======
   te0382.f
   sslp316a
   sslp316b
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 9.5.7
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 10.0.19
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   passage des tests
NB_JOURS_TRAV  : 2.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desroches    DESROCHES Xavier       DATE 27/10/2009 - 10:56:11

--------------------------------------------------------------------------------
RESTITUTION FICHE 014017 DU 2009-10-09 15:29:39
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   DKT relation ELAS_COQUE contraintes fausses
FONCTIONNALITE
   Correction d'une erreur sur les éléments de plaque dans 
   SIEF_ELGA_DEPL relation ELAS_COQUE : les contraintes 
   étaient mal calculées sur les différents niveaux des 
   couches.
   
   Pour l'option SIGM_ELNO_DEPL, il y avait la même erreur 
   que pour EPSI_ELNO_DEPL (fiche 13979) dans le cas où la 
   coque a plusieurs couches sans passer par DEFI_COQU_MULT 
   : les contraintes  étaient calculées sur une seule couche
   
   On en profite pour faire du ménage dans les routines.
   Création de 2 routines supplémentaires dktsie et dkqsie.
   Ménage dans xxxcol avec xxx=dkt,dkq,dst,dsq,q4g
   
   Validation dans les tests SSLS502A et B.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 3.1.1
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   SSLS502A SSLS502B
NB_JOURS_TRAV  : 5.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR devesa       DEVESA Georges         DATE 26/10/2009 - 13:47:27

--------------------------------------------------------------------------------
RESTITUTION FICHE 013393 DU 2009-05-07 15:27:14
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   RIGI_PARASOL : impression dans le fichier resultat
FONCTIONNALITE
   Les valeurs de raideurs ou d'amortissement au noeud calculées par 
   RIGI_PARASOL n'étaient plus écrites dans le fichier RESULTAT au 
   format des commandes de Code_Aster, et ceci malgré l'utilisation 
   de INFO=2, comme spécifié dans le paragraphe 17.4 de la doc 
   U4.42.01-I.
   Et en effet, ce problème apparaissait lorsqu'on affectait ces 
   caractéristiques aux noeuds ou mailles tardives, c'est-à-dire 
   sans la présence du mot clé GROUP_MA_POI1. Dans ce dernier cas, 
   cela marche.
   On corrige donc la routine ACEARP pour que cela fonctionne 
   également dans le cas des mailles tardives. Et pour satisfaire un 
   souhait de Mathieu, on imprime dorénavant ces informations dans 
   le fichier MESSAGE plutôt que dans le fichier RESULTAT si INFO=2 
   (d'où l'impact dans la doc).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.42.01
VALIDATION
   cas test ZZZZ200A
NB_JOURS_TRAV  : 1.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 013820 DU 2009-09-04 07:59:31
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Certains tests Miss emettent trop d'alarmes
FONCTIONNALITE
   On effectue des actions correctrices sur les fichiers de 
   commandes ou maillage de certains cas tests MISS pour diminuer le 
   nombre d'alarmes:
   Cas tests MISS01A et MISS05A: 
             -------    -------
   - on élimine les alarmes MODELISA5_8 :
    la maille :  %(k1)s  est en double dans le group_ma:  %(k2)s . 
   on elimine les doublons
   Pour cela , on supprime dans les fichiers .mail des groupes de 
   mailles inutiles.
   
   - pour le cas test MISS05A, on élimine aussi les alarmes 
   MODELISA_39 :
    la maille  %(k1)s  n'a pas ete afféctée par une matrice 
   (DISCRET).
   Pour cela, on affecte des masses ponctuelles nulles au groupe de 
   mailles RADIER dans miss05a.13
   
   Cas tests MISS04A et MISS04B: 
             -------    -------
   - on élimine les alarmes ELEMENTS_40 :
     -> L'axe de référence pour le calcul du repère local est normal 
   à au moins un élément de plaque.
   Pour cela, on suit le conseil en modifiant l'axe de référence 
   (axe X par défaut) par ANGL_REP dans AFFE_CARA_ELEM en donnant 
   une direction oblique.
   
   Toutefois pour les fichiers de commandes de MISS05a et MISS01A, 
   on n'a pu éliminer les alarmes ELEMENTS4_80 :
     L'élément de plaque QUAD4 défini sur la maille : %(k1)s
     n'est pas plan et peut conduire a des résultats faux
     Distance au plan :  %(r1)f
   Le maillage commun à ces 2 tests d'EPR a été transmis par le 7N 
   avec un maillage manuel par GIBI des éléments du dôme à la 
   planéité imparfaite.
   On n'a pu non plus éliminer les messages ALGELINE5_23 sur le 
   calcul modal par bandes où la vérification a posteriori sur un 
   intervalle légèrement élargi peut générer un message sur un 
   nombre de modes estimé différent de celui calculé.
   
   Il y avait aussi un certain nombre de messages MODELISA4_8 ou 
   MODELISA4_9 sur la présence de mailles doubles ou aplaties dans 
   les tests MISS051A, MISS05A, MISS03A, MISS08A.
   Pour le test MISS03A, on a pu les éliminer en supprimant des 
   mailles inutiles et les groupes qui les contiennent.
   Mais pour les autres tests, ces messages étaient soit inévitables 
   (MISS08A avec des mailles SEG2 de taille nulle) soit trop 
   compliqués à éliminer (MISS01A et MISS05A). Dans ce cas, on a 
   rajouté un VERI_MAIL=_F(VERIF='NON')qui s'il ajoute lui-même une 
   alarme permet de diminuer de beaucoup la taille des messages 
   d'alarmes précédents.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   tests MISS
NB_JOURS_TRAV  : 1.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR fernandes    FERNANDES Roméo        DATE 27/10/2009 - 06:57:23

--------------------------------------------------------------------------------
RESTITUTION FICHE 013738 DU 2009-08-21 09:14:00
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
   bug ssnv158d (LAIGLE)
FONCTIONNALITE
   Le plantage est du a une division par zero qui peut effectivement se produire lors du
   calcul de la derivee du critère par rapport au deviateur des contraintes.
   
   On trappe cette division par zero et on active le découpage (global) du pas de temps
   si celui-ci a ete demande par l'utilisateur, sinon on plante.
   
   Attention, l'operation qui contient cette division par zero est commune aux lois de Laigle
   et CJS. Dans le cas CJS, l'erreur est stoppee, mais la remontee d'erreur pour un eventuel
   decoupage des pas de temps n'a pas ete faite (necessaire? car probablement beaucoup de
   routines a impacte. TMA?).
   
   Pas de restitution de cas test, celui proposé par Samuel dans le cadre de cette fiche
   d'anomalie passe.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test ssnv158d modifie
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 014079 DU 2009-10-21 14:47:15
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
   BUG LAIGLE
FONCTIONNALITE
   Une erreur s'est glissée dans une routine (de projection au sommet de la surface de
   charge) de la loi de comportement LAIGLE. Deux
   variables sont inversées entre la routine appelante et la routine appelée! Fort
   heureusement cet appel se produit dans des cas extrêmes et très occasionnellement.
   
   Cette erreur peut être la cause de résultats FAUX depuis la version 7.0.10 mais pas
   d'impact sur les tests de la base aster.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 7.0.10
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 7.0.10
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   tests LAIGLE + CJS
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR geniaut      GENIAUT Samuel         DATE 27/10/2009 - 17:39:28

--------------------------------------------------------------------------------
RESTITUTION FICHE 012982 DU 2008-12-12 14:18:15
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
   VISCOCHAB : erreur de signe dans la jacobienne du systeme NL local
FONCTIONNALITE
   VISCOCHAB : Correction de certains termes de la matrice tangente
   
   DXI/DS
   DXI/DX1
   DXI/DX2
   DXI/DP
   DXI/DXI
   
   impact : cvmjac.f
   
   + une erreur de frappe dans la doc R5.03.12 sur la dernière éq de DXI/DXI
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test viscochab
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 013004 DU 2008-12-19 16:58:51
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
   VISCOCHAB : non-convergence quand poursuite
FONCTIONNALITE
   Problème :
   ----------
   
   Jean a remarque certains problèmes de convergence à la suite d'une poursuite d'un calcul
   de soudage.
   
   VISOCHAB ne converge pas (comme d'autres lois) alors que des lois plus simple convergent
   (VMIS_CINE_LINE notamment)
   
   
   
   Solution :
   ----------
   
   Cela ne traduit pas forcément un bug, c'est p-e qu'on part trop loin de la solution pour
   arriver à converger.
   
   Pas de besoin utilisateur particulier 
   fiche à classer sans suite
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   neant
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 013736 DU 2009-08-20 14:27:16
TYPE evolution concernant Code_Aster (VERSION )
TITRE
   MN08 gestion auto du pas de temps : bug sur la precision
FONCTIONNALITE
   Problème :
   ----------
   
   Avec la gestion auto du pas de temps, pour savoir si l'instant t+1 calculé a dépassé ou
   non le prochain instant de passage obligé, on fait un test, sans prendre en compte la
   PRECISION :
   
   on peut donc se retrouver à calculer un instant 1,999999999 alors que le prochain instant
   de passage obligé est 2.
   Du coup, on risque de se retrouver avec un instant tout petit à calculer ensuite, qui peut
   être plus petit que PAS_MINI. C'est effectivement le cas sur une étude de Jean-Michel :
   
   PAS DE TEMPS POUR CHAQUE METHODE D ADAPTATION :
   FIXE   - DT =   1.999999999998892E-003
   ON DEPASSE LE PROCHAIN INSTANT DE PASSAGE  3.20199999999998  >=  3.19999999999998     
   PAS DE TEMPS RETENU : DT =    8.881784197001252E-016
   
      !--------------------------------------------------------------------------------!
      ! <EXCEPTION> <DISCRETISATION_11>                                                !
                                                                             !
      !  La valeur du pas de temps retenu (8.881784197e-16) est inférieure à PAS_MINI. !
   
   
   On pourrait :
   
   - soit on utilise PRECISION pour la recherche du pas de temps obligé suivant
   - soit on ne vérifie pas que dt < PAS_MINI si on va à un instant de passage obligé
   
   
   Solution :
   ----------
   
   Ne pas vérifier que dt > PAS_MINI ne semble pas une bonne idée.
   Il faut donc faire en sorte que le dt nouvellement calculé respecte la condition dt >
   PAS_MINI.
   Pour cela, on ne peut pas utiliser PRECISION (car si PRECISION est inférieure à PAS_MINI,
   on aura tjs la même erreur). 
   
   Dans nmadat.f, au lieu de faire des tests a > b directement sur les réels, on utilise une
   routine utilitaire (compr8) qui permet de comparer 2 réels entre eux, avec une précision
   donnée (en absolu ou en relatif).
   On utilise alors comme précision : 2*PAS_MINI, en absolu, pour savoir si on a dépassé le
   prochain instant de passage obligé.
   De cette manière, on est sûr que les pas de temps engendrés sont plus grands que PAS_MINI.
   
   détails sur compr8.f (A,COMP,B,EPS,CRIT) : fonction qui renvoie true si la condition est
   vérifiée :
   C     A = B EN ABSOLU   <=> |A-B| <= EPS
   C     A = B EN RELATIF  <=> |A-B| <= EPS.MAX(|A|,|B|)
   
   C     A <= B EN ABSOLU  <=> A <= B + EPS
   C     A <= B EN RELATIF <=> A <= B + EPS.MAX(|A|,|B|)
   C
   C     A < B EN ABSOLU   <=> A <= B - EPS
   C     A < B EN RELATIF  <=> A <= B - EPS.MAX(|A|,|B|)
   C
   C     A >= B EN ABSOLU  <=> A >= B - EPS
   C     A >= B EN RELATIF <=> A >= A - EPS.MAX(|A|,|B|)
   C
   C     A > B EN ABSOLU   <=> A >= B + EPS
   C     A > B EN RELATIF  <=> A >= A + EPS.MAX(|A|,|B|)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : D6.00.01
VALIDATION
   tests perso
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 013815 DU 2009-09-03 16:15:19
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
   xenrch.f : impressions parasites
FONCTIONNALITE
   Problème :
   ----------
   
   
   La routine xenrch.f fait des impressions parasites :
   
    XENRCH-1) RESTRICTION DE LA ZONE D ENRICHISSEMENT
    NOMBRE DE MAILLES DE LA ZONE FISSURE :                     4
    XENRCH-2) ATTRIBUTION DU STATUT DES NOEUDS DE GROUPENRI
    XENRCH-3) ATTRIBUTION DU STATUT DES MAILLES
    NOMBRE DE MAILLES DE MAFON  :                     0
    NOMBRE DE MAILLES DE MAENR1 :                    12
    NOMBRE DE MAILLES DE MAENR2 :                     0
    NOMBRE DE MAILLES DE MAENR3 :                     0
    XENRCH-4) RECHERCHE DES POINTS DE FONFIS
    LA LONGUEUR DE LA PLUS PETITE ARETE DU MAILLAGE EST  0.10000E+01.
    NOMBRE DE POINTS DE FOND DE FISSURE :                     0
      
    XENRCH-7) FIN DE XENRCH
   
   Si ce n'est pas le cas il faut le faire en info = 2 ou utiliser U2MESX(<I>,...)
   
   
   
   Solution :
   ----------
   
   J'imprime les infos indispensables : nb de points du fond de fissure + nb de fonds +
   coordonnées des points du fond avec CALL U2MESX dans tous les cas (quelque soit la valeur
   de INFO)
   
   J'imprime les infos utiles si INFO > 1 avec CALL U2MESX....
   
   J'imprime les infos de débuggage si INFO > 2 avec write....
   
   Cette solution est étendue à tout DEFI_FISS_XFEM (et non pas seulement à xenrch.f comme il
   était mentionné dans la demande initiale).
   
   
   impact :
   xinils.f, xenrch.f et xstami.f
   xfem.py
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.82.08
VALIDATION
   test X-FEM
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 013816 DU 2009-09-03 16:26:00
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
   Message XFEM2_14 dans les tests XFEM
FONCTIONNALITE
   Problème :
   ----------
   
   Dans les tests suivants, l'alarme XFEM2_14 est émise un trop grand nombre de fois.
   
   sslv315a ! (*) XFEM2_14   emise   19425 fois 
   sslv315b ! (*) XFEM2_14   emise   22590 fois 
   sslv315c ! (*) XFEM2_14   emise   78135 fois 
   sslv315d ! (*) XFEM2_14   emise   123582 fois
   sslv316a ! (*) XFEM2_14   emise   71391 fois 
   sslv316b ! (*) XFEM2_14   emise   81918 fois 
   sslv316c ! (*) XFEM2_14   emise   88635 fois 
   sslv316d ! (*) XFEM2_14   emise   82227 fois
   
     -> La discrétisation du fond de fissure est grossière par rapport à la 
        courbure du fond de fissure.
     -> Risque & Conseil:
        - possibilité de résultats faux
        - il faudrait raffiner le maillage autour du fond de fissure.
   
   Dans tous les tests l'alarme est ignorée. Toutefois, ne doit-on pas émettre le message
   qu'une seule fois par pas de temps par exemple.
   
   
   
   Solution :
   ----------
   
   L'émission de ce message est basée sur la valeur du déterminant de la matrice de la base
   locale en fond de fissure (issue des gradients des level sets). Normalement, la base est
   orthonormée, donc le déterminant vaut 1.
   Cette alarme était émise si |det-1| > 1e-3
   On supprime tout simplement ce test qui ne sert à rien en pratique.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   testx x-fem
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 013817 DU 2009-09-03 16:30:22
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
   Message XFEM_58 dans les tests XFEM
FONCTIONNALITE
   Problème :
   ----------
   
   Quand j'ai fait le changement de syntaxe (introduction de TYPE_DISCONTINUITE), les tests
   suivants étaient cassés :
   ssnp503b 
   ssnp503d 
   ssnp503f  
   ssnp503j 
   ssnp504b 
   ssnp504d   
   ssnp504f 
   
   Je n'ai donc pas pu modifier leur syntaxe.
   
   Quand ces tests ont été corrigés , ils ont gardé la vieille syntaxe, qui conduit à une
   alarme (XFEM_58) :
    -> Aucun point du fond de fissure n'a été trouvé !
        Cela signifie que le fond de fissure se trouve en dehors de la structure.
   
     -> Risque & Conseil :
        - Si vous souhaitiez définir une interface, il faut choisir TYPE_DISCONTINUITE =
   'INTERFACE'
           pour ne plus avoir ce message.
        -  Si vous souhaitiez définir une fissure, il doit y avoir une erreur lors de la
   définition 
           de la level set tangente Vérifier la définition des level sets.
   
   Pour ne plus avoir cette alarme, il suffit de renseigner dans DEFI_FISS_XFEM :
   TYPE_DISCONTINUITE =
   'INTERFACE'.
   
   
   
   Solution : 
   ----------
   
   Je rajoute à ces tests  TYPE_DISCONTINUITE='INTERFACE' dans DEFI_FISS_XFEM.
   
   impact : 
   ssnp503b.comm  ssnp503f.comm  ssnp504b.comm  ssnp504f.comm
   ssnp503d.comm  ssnp503j.comm  ssnp504d.comm
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test x-fem
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 013998 DU 2009-10-08 14:18:12
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
   En NEW10.0.20, le cas-test sslv110f est NOOK sur Bull, Rocks,Calibre 4 et 5.
FONCTIONNALITE
   Problème :
   ----------
   
   En NEW10.0.20, les cas-tests sslv110f sont NOOK sur Bull, Rocks,Calibre 4 et 5.
   
   A titre d'exemple, le test NOOK obtenu sur Bull est le suivant:
   "--------------------------------------------------------------------------------
    ---- TABLE: SIFTH    NOM_PARA: K1_LOCAL                
                                          
   REFERENCE: NON_REGRESSION  
   NOOK SIFTH        RELA     0.363 % VALE: 3.7537450367314D+00
   K1_LOCAL          TOLE     0.100 % REFE: 3.7401520000000D+00
   "
   
   
   
   
   Solution :
   ----------
   
   lors de la restit sur les PYRA, j'ai faits qq modifs dans xptfon qui améliore la recherche
   des points du fond de fissure.
   
   du coup, j'ai très légèrement améliorer un TEST_RESU dans sslv110f : la valeur de KI sur
   le point n°21 :
   
   référence analytique : 4.068
   avant : 3.740
   apres : 3.754
   
   or j'ai oublié de mettre ce test dans le répertoire de tests restitués.
   
   NB : il n'y a pas d'impact doc car la valeur écrite dans la doc correspond à la nouvelle
   valeur
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ssnv110f
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------
RESTITUTION FICHE 013999 DU 2009-10-08 14:20:41
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
   En NEW10.0.20, les cas-tests sslv315a et sslv315d sont NOOK sur Bull, Rocks,Calibre 4 et 5.
FONCTIONNALITE
   Problème :
   ----------
   
   En NEW10.0.20, les cas-tests sslv315a et sslv315d sont NOOK sur Bull, Rocks,Calibre 
   4 et 5.
   A titre d'exemple, le test NOOK obtenu sur Bull et concernant le cas-test sslv315a 
   est le suivant:
   "
   --------------------------------------------------------------------------------
    ---- TABLE: SIF_1    NOM_PARA: K2_LOCAL                
                                          
   REFERENCE: NON_REGRESSION  
   NOOK              RELA    -8.399 % VALE: 3.6877807859483D+05
    MAX              TOLE     5.000 % REFE: 4.0259145440442D+05
   "
   
   
   Solution :
   ----------
   
   Tests de propagation de fissure avec la méthode SIMPLEXE.
   Ces tests sont instables. Julien Messier propose de les revoir complètement (fiche 14065)
   Cette fiche est donc sans suite
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   neant
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 014006 DU 2009-10-09 09:13:35
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
   DEFI_FOND_FISS : groupe_maille contenant le fond
FONCTIONNALITE
   la doc de DEFI_FOND_FISS (§3.2.1) dit que sous FOND_FISS_F(GROUP_MA=...), on attend une
   liste de mailles de type SEG2 ou SEG3.
   
   Il n'y a donc pas d'anomalie.
   
   Pour définir un fond de fissure sur un maillage 2D : il faut faire  
   
    FISS=DEFI_FOND_FISS(MAILLAGE=MAIB,
                         LEVRE_SUP=_F(GROUP_MA='LSUP'),
                         FOND_FISS=_F(GROUP_NO='FONDFISS'),
                         LEVRE_INF=_F(GROUP_MA='LINF'),);
   
   avec FONDFISS le groupe de noeuds du fond de fissure (un seul noeud)
   
   ou bien 
   
    FISS=DEFI_FOND_FISS(MAILLAGE=MAIB,
                         LEVRE_SUP=_F(GROUP_MA='LSUP'),
                         FOND_FISS=_F(NOEUD='FONDFISS'),
                         LEVRE_INF=_F(GROUP_MA='LINF'),);
   
   avec FONDFISS = nom du noeud en fond de fissure
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   aucun
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 014009 DU 2009-10-09 13:18:20
TYPE anomalie concernant Code_Aster (VERSION 10.2)
TITRE
   POST_K1_K2_K3 : coherence de VECT_K1
FONCTIONNALITE
   problème :
   ----------
   
   Sur un exemple simple d'une plaque fissurée en 2D, lorsque VECT_K1 n'est pas correctement
   renseigné (VECT_K2 par exemple) le code plante salement avec un FPE.
   
   On devrait pouvoir planter proprement en faisant des vérifications.
   
   
   Solution :
   ----------
   
   Sur le sslp313a en mettant  VECT_K1 = ( 1., 0., 0., ) au lieu de VECT_K1  = ( 0., 1., 0., ) :
   
   calibre 5   debug : NOOK, mais sans plantage
   calibre 5 nodebug : NOOK, mais sans plantage
   bull debug        : NOOK, mais sans plantage
   bull nodebug      : NOOK, mais sans plantage
   
   Je n'arrive donc pas à reproduire le bug.
   
   A classer sans suite, sauf contre ordre
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sslp313a
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 014034 DU 2009-10-13 16:19:32
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
   DEFI_LIST_INST : wtnp117b
FONCTIONNALITE
   Problème :
   ----------
   
   Lors de la restitution de la gestion automatique du pas de temps (fiche 12196), j'ai
   restitué un cas-test (wtnp117b : Rééquilibrage capillaire d?un bi-matériaux décrit par des
   lois de Van-Genuchten Mualem) qui met en oeuvre la gestion automatique.
   
   La discrétisation temporelle du test initial est la suivante :
   
      ?    1000s en 20 pas de temps
      ?    5000 s en 20 pas de temps
      ?    10000 s en 10 pas de temps
      ?    50000 s en 20 pas de temps
      ?    100000 s en 20 pas de temps
   
   Avec la gestion automatique, on donne seulement 2 instants : 50 et 100000s et le calcul se
   débrouille tout seul.
   Au final, le calcul est réalisé en 19 instants.
   
   Le gain en temps CPU est évident.
   
   Cependant, aucun TEST_RESU_n'avait été fait sur ce calcul avec la gestion automatique.
   Or il se trouve que si on fait le même TEST_RESU (celui réalisé avec la liste d'instants
   classiques), le test finit en NOOK car on commet une erreur de 4% (PRE1 au noeud N111, à t
   final) alors que la tolérance est de 1% (c'est un test de non-régression)
   
   La gestion automatique du pas de temps garantit que le résultat a convergé (au sens
   équilibre Fint = Fext) mais ne permet pas de garantir la convergence des résultats
   vis-à-vis de la discrétisation temporelle (au même titre que rien ne garantit que la
   maillage du cas test soit suffisamment raffiné).
   
   
   Solution :
   ----------
   
   Finalement, après discussion avec Roméo, une précision de 4% est suffisante.
   On rajoute donc les 2 TEST_RESU (un à 5000s et un à 100000s).
   Pour le 1er, la précision reste la même (1%).
   pour le second, on la fixe à 4%.
   
   impact : wtnp117b.comm (on rajoute aussi l'instant t=5000s dans la liste des instants de
   passage, afin de pouvoir réaliser le TEST_RESU sur cet instant)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V7.32.117
VALIDATION
   wtnp117b
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 014067 DU 2009-10-20 11:41:42
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
   CALC_K_G
FONCTIONNALITE
   Problème :
   ----------
   
   Anomalie détectée par Michael GAUDIN (Septen) dans le cadre de l'AT:
   
   Il souhaite calculer les facteurs d'intensité des contraintes à partir de G. 
   Il utilise donc l'option CALC_K_G de l'opérateur CALC_G.
   
   Il a donc renseigné une fissure calculée à partir de DEFI_FISS_XFEM.
   Il obtient un message du style "erreur de programmation".
   
   
   
   Solution :
   ----------
   
   Plusieurs bugs ont été identifiés grâce à ce test.
   
   1) l'orientation des points du fond de fissure (DEFI_FISS_XFEM) était mauvaise car on
   avait mal identifié les
   points de bord. Ce pb était dû à un bug dans xptfon.f, que j'ai corrigé. Le VECT_ORIE
   initialement choisi (Z) est le bon.
   Plus précisément, dès que l'on trouvait un point du fond, on regardait si la face courante
   était une face de bord.
   Et si sur une autre face on trouvait ce même point, on passait directement à la face
   suivante sans vérifier si cette face était une face de bord ou pas. Le pb ici était que le
   premier point du fond n'était pas reconnu comme un point de bord car la face qui avait
   permis de l'identifier n'était pas une face de bord. 
   
   impact : xoriff.f et xptfon.f
   
   2) Dans CALC_G, option CALC_K_G en 3D, on boucle sur toutes les mailles (même les mailles
   de bord). Or les mailles FACE3 (triangles de bord) appellent la famille RIGI = COT3 :
   points de Gauss aux milieux des cotés. Donc une maille TRIA3 de bord, dont un coté est
   confondu avec le fond de fissure se retrouve avec un de ces 3 points de Gauss exactement
   sur le fond de fissure. Or les fonctions auxiliaires intervenant dans la formule de K1, K2
   et K3 (forme bilinéaire g(u,v)) ne sont pas définies pour r = 0 (où r est la distance au
   fond de fissure). Il faut choisir un schéma d'intégration tel que les points de Gauss
   soient à l'intérieur des mailles. 
   On modifie donc gener_me3d_2.cata en remplaçant RIGI=COT3 par RIGI=FPG1 pour les
   MECA_FACE3 et MECA_X_FACE6
   
   
   De plus, les couronnes d'intégration pour CALC_G ne sont pas correctes (mais ce n'est pas
   un bug) :
   le rayon du tore en fond de fissure est de l'ordre de r = 125e-3
   la taille des éléments en fond de fissure est de l'ordre de h = 25e-3
   or on demande une intégration pour CALC_G entre Rinf = 1e-3 et Rsup = 5e-3, ce qui est
   largement inférieur à la taille d'un élément.
   Je préconise Rinf = 50e-3 et Rsup = 125e-3
   
   
   Enfin, les performances de POST_K1_K2_K3 (avec TYPE_MAILLAGE='LIBRE') sur ce test laissent
   à désirer :
   avec mémoire totale = 900 Mo, dont 150 Mo pour Aster, le test s'arrête par manque de
   mémoire python dans POST_K1_K2_K3 !
   Je teste avec un gros paramètre mémoire (5000 Mo dont 200 Mo pour Aster) pour être sûr de
   passer. Voici les temps CPU :
   .*.MECA_STATIQUE............:.......8.63.:.......0.45.:.......9.08.:.......9.17.*
   .*.DEFI_FISS_XFEM...........:......41.01.:.......0.04.:......41.05.:......41.19.*
   .*.CALC_G...................:......10.86.:.......0.07.:......10.93.:......10.95.* (lissage
   LEGENDRE)
   .*.CALC_G...................:......13.37.:.......0.16.:......13.53.:......13.60.* (lissage
   LEGENDRE)
    * CALC_G                   :     100.99 :       1.39 :     102.38 :     102.61 * (lissage
   LAGRANGE)
    * POST_K1_K2_K3            :    1073.60 :       1.83 :    1075.43 :    1138.93 *
   
   Effectivement, en fin de calcul, on trouve :  
     #     - MEMOIRE DYNAMIQUE CONSOMMEE :         0.00 Mo (MAXIMUM ATTEINT :       197.83 Mo) 
   et  VmData :      2810.19 Mo - VmSize :      2982.12 Mo
   
   Aster (JEVEUX) a besoin de 200 Mo et python (POST_K1_K2_K3) a besoin de 2,5 Go
   et POST_K1_K2_K3 est 100 fois plus long que le MECA_STATIQUE.
   J'emets une fiche pour ce pb (fiche 14085)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test fourni + tests X-FEM
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR greffet      GREFFET Nicolas        DATE 26/10/2009 - 14:04:45

--------------------------------------------------------------------------------
RESTITUTION FICHE 014086 DU 2009-10-22 12:10:56
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   ARCH_ETAT_INIT : bug en poursuite
FONCTIONNALITE
   Dans la routine NMCRAR, dès qu'on détecte la présence de ARCH_ETAT_INIT = 'OUI', 
   alors on met le numéro d'archivage à zéro : NUMARC = 0.
   Avant la version 9.2.14, on vérifiait en plus si on était en poursuite (DERNIE ne 
   vaut alors pas 0) et dans ce cas, on s'arrêtait en erreur <F> avec le message :
   "impossible d'archiver l'état initial : le concept est réentrant (ARCHIVAGE)"
   
   En 9.2.14, le test par rapport à DERNIE fut retiré, ainsi donc que le message et 
   l'arrêt en erreur <F> associé. Donc on peut laisser ARCH_ETAT_INIT en poursuite et 
   cela remet à zéro le numéro d'archivage.
   
   En plus d'entraîner la perte de la solution calculée avant la poursuite, on peut 
   avoir des résultats faux si l'on tente d'extraire des valeurs suivant leur numéro 
   d'ordre si l'on croit que ce numéro d'ordre commence avec le premier appel à 
   l'opérateur de résolution non linéaire (STAT_NON_LINE, THER_NON_LINE ou 
   DYNA_NON_LINE). Si l'on accède par instant (recommandé !), pas de risque de 
   résultat faux : on n'aura aucune valeur en retour si l'instant est antérieur à la 
   poursuite.
   
   Pour éviter ce bug, deux solutions :
   - revenir au fonctionnement d'avant la 9.2.14 et s'arrêter en erreur si le mot-clé 
   ARCH_ETAT_INIT  est présent en poursuite,
   - être plus "user friendly" et en cas de poursuite, passer outre et ne pas tenir 
   compte d'ARCH_ETAT_INIT.
   
   Je préconise la deuxième voie. Pour cela je teste la valeur de DERNIE : si il est 
   bien nul (cas sans reprise) alors on met bien NUMARC à 0, sinon, on ne fait rien 
   et on emet juste une alarme (message ARCHIVAGE_99)
   "L'option d'archivage de l'état initial ne sert que lors du premier calcul,
   son appel dans les poursuites suivantes est ignoré (ARCHIVAGE, ARCH_ETAT_INIT)"
   
   On valide en modifiant légèrement le cas-test SDLD31A qui faisait déjà des 
   poursuites. On rajoute : ARCHIVAGE = _F(ARCH_ETAT_INIT = 'OUI'), lors des reprises 
   de REPHHTP.
   Je modifie aussi un instant de poursuite de manière à tester des valeurs à un 
   instant antérieur à la poursuite en question. Ainsi, sans la modification, ces 
   valeurs n'existent pas et le TEST_RESU est NOOK. Avec la modification c'est OK.
   
   Impact sources et fichiers :
   - nmcrar.f,
   - archivage.py (message 99),
   - sdld31a.comm.
   
   Le report en version 9 est facile car :
   - nmcrar.f et archivage.py sont inchangés,
   - sdld31a existe déjà.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 9.2.14
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 9.2.14
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.51.03, V02.01.031
VALIDATION
   sdld31a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR messier      MESSIER Julien         DATE 27/10/2009 - 10:57:14

--------------------------------------------------------------------------------
RESTITUTION FICHE 013848 DU 2009-09-10 14:04:14
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
   XFEM - sslp322a et sslp321b non OK sur ROCKS et Calibre4
FONCTIONNALITE
   Le test sslp321b est NOOK en 10.0.16 et 10.0.20
   En effet, la non correction de la tolérance du sslp321b est à l'origine de l'ouverture de la fiche 14030.
   On ajuste donc la tolérance comme prévu à 5% sur le K1 et on ferme les deux fiches.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V3.02.321
VALIDATION
   le cas-test
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 014000 DU 2009-10-08 14:24:00
TYPE anomalie concernant Code_Aster (VERSION 10.2)
TITRE
   En NEW10.0.20, le cas-test sslv316c s'arrete en erreur_<F> sur Bull, Rocks,Calibre 4 et 5.
FONCTIONNALITE
   Le cas-test sslv316c est un test de propagation d'une fissure XFEM en mode mixte dans une maillage 3D 
   avec la méthode simplexe.
   Il est cassé en NEW10.0.20 sur un pb manifeste de reinitialisation des level-sets aux noeuds.
   
   Diagnostic : La face concernée par l'erreur (3 arêtes comportant une annulation de la level-set sur un 
   élément quadrangulaire) appartient à une maille de bord. On se souvient alors de 2 fiches (13080 et 
   12925) où l'on avait déjà soulevé cette "sensibilité" de la méthode simplexe à la réinitialisation sur 
   ce type de maille. On propose donc de restituer la solution évoquée dans la fiche 12925.
   
   Solution : On modifie la boucle 800 des routines xprrei et xprreo (réinitialisation et 
   réorthogonalisation des level-sets pour les mailles de bord). On en profite pour améliorer la routine 
   intfac pour ajouter un test plus propre pour la recherche des faces où s'annule conjointement les level-
   sets. On en profite aussi pour améliorer le test (on prend RS = DA au lieu de RS > DA) 
   
   Résultat : Le test est parfaitement OK.
   
   Restitution : xprrei, xpreo, intfac, sslv316c (en PJ)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   le cas-test
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 014030 DU 2009-10-13 08:18:01
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
   En NEW10.0.20, le cas-test sslp321b s'arrete en erreur_<F> sur Calibre 4 et est NOOK sur Bull.
FONCTIONNALITE
   Le cas-test sslp321b est NOOK sur BULL.
   Une correction aurait dû être portée suite à la fiche 13848.
   Elle consiste à porter la tolérance sur le K1 de 2.5 à 5%.
   
   Ce même cas-test (propagation XFEM par la méthode simplexe) s'arrête en erreur_<F> en NEW 10.0.20 sur 
   Calibre 4.
   On souligne que cette méthode numérique fait souvent apparaître des fluctuations en fonction des 
   machines.
   On corrige, dans la fiche 14030, 3 routines dont deux concernent la méthode simplexe : xprrei et xprreo 
   (respectivement pour la réinitialisation et la réorthogonalisation des level-sets).
   Après ces corrections, ce cast-test est OK sur toutes les plates-formes.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V3.02.321
VALIDATION
   ce cas-test
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 014065 DU 2009-10-20 10:53:39
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
   XFEM : Harmonisation des mod?sations du test sslv315
FONCTIONNALITE
   Le test sslv315 consiste à solliciter une structure fissurée 3D et propager une fissure, initialement 
   oblique, en mode mixte avec différentes méthodes de propagation.
   La modélisation a utilise la méthode SIMPLEXE.
   Les modélisations b et c utilisent la méthode MAILLAGE (resp. avec CALC_G et POST_K1_K2_K3).
   La modélisation d utilise la méthode UPWIND
   
   Or, chacune de ces modélisations sont de non régression en utilisant des hypothèses différentes.
   On propose, dans cette fiche, d'harmoniser les hypothèses de calcul afin de faire dorénavant porter la 
   non régression sur une référence commune aux 4 modélisations.
   
   A l'instar du sslp315, on vérifiera, dans les modélisations a et d, qu'un point extrême du fond de 
   fissure (là où les level-sets doivent s'annuler conjointement) est localisé sur la même face élémentaire 
   (ou "pas très loin") que la position identifiée dans les modélisations b et c.
   
   Pour que le test soit suffisamment rapide, on se contente de 3 pas de propagation (de 0.4).
   On souligne néanmoins, (du point de vue développement) qu'il sera important d'imposer des propagations 
   plus grandes pour garantir (et améliorer) la robustesse des différentes méthodes de PROPA_FISS en 3D. 
   
   On vérifie que ces 4 cas-tests sont OK sur toutes les plates-formes avec les surcharges fortran de la 
   fiche 14000.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V3.04.315
VALIDATION
   sslv315a,sslv315b,sslv315c,sslv315d
NB_JOURS_TRAV  : 0.4
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR geniaut      GENIAUT Samuel         DATE 27/10/2009 - 10:57:15

--------------------------------------------------------------------------------
RESTITUTION FICHE 013999 DU 2009-10-08 14:20:41
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
   En NEW10.0.20, les cas-tests sslv315a et sslv315d sont NOOK sur Bull, Rocks,Calibre 4 et 5.
FONCTIONNALITE
   Problème :
   ----------
   
   En NEW10.0.20, les cas-tests sslv315a et sslv315d sont NOOK sur Bull, Rocks,Calibre 
   4 et 5.
   A titre d'exemple, le test NOOK obtenu sur Bull et concernant le cas-test sslv315a 
   est le suivant:
   "
   --------------------------------------------------------------------------------
    ---- TABLE: SIF_1    NOM_PARA: K2_LOCAL                
                                          
   REFERENCE: NON_REGRESSION  
   NOOK              RELA    -8.399 % VALE: 3.6877807859483D+05
    MAX              TOLE     5.000 % REFE: 4.0259145440442D+05
   "
   
   
   Solution :
   ----------
   
   Tests de propagation de fissure avec la méthode SIMPLEXE.
   Ces tests sont instables. Julien Messier propose de les revoir complètement (fiche 14065)
   Cette fiche est donc sans suite
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   neant
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR boiteau      BOITEAU Olivier        DATE 26/10/2009 - 13:08:07

--------------------------------------------------------------------------------
RESTITUTION FICHE 014035 DU 2009-10-14 07:18:46
TYPE anomalie concernant Code_Aster (VERSION 10.2)
TITRE
   En NEW10.0.21, certains cas test s'arretent sur Bull dans MUMPS
FONCTIONNALITE
   Fiche restituée pour OB par JP (Merci !).
   
   Problème
   =========
     Depuis l'activation automatique de la détection singularité lors de l'usage 
     du solveur linéaire MUMPS (en 10.0.21), 15 des 106 cas-tests concernés sont
     cassés sur toutes les plate-formes.
   
   Eléments de réponse/solutions paliatives
   ========================================
     Pour établir un diagnostic, j'ai appliqué la démarche suivante:
   
      * Tous ces cas-tests utilisent ils un opérateur non linéaire ?
          ---> la réponse est heureusement "oui". On a au moins la garantie du
               processus de Newton si on débranche le critère de qualité du
               solveur linéaire (c'est fait par défaut avec RESI_RELA=-1.D0 en
               non linéaire) et si on débranche le détection de singularité (à
               faire explicitement via NPREC<0).
   
       * Plantent ils avec un autre solveur direct (LDLT ou MF) ?
         ---> "Oui", soit pour des raisons de pivotage, soit pour une détection
               de singularité (pas désactivable avec ces solveurs).
      
       * Plantent ils en mettant le critère de qualité de MUMPS à une valeur
         raisonnable ? Par exemple celle employée en linéaire: RESI_RELA=1.E-6.
         ---> "Oui". On trouve des erreurs allant de 10.E-5 à 10.E+7 !!!!!
               Cela veut dire que potentiellement aucun digit de la solution
               n'est bon ! Attention, si ces chiffres sont intéressants, ils
              calculent cependant une erreur relative:
                  - qui est une borne max (le scénario le pire, on peut avoir de
                        la chance !),
                  - qui est en norme infinie (certains DDLs "auxillaires" peuvent
                    être très mal estimés voire carrément spectateurs, alors que
                    les DDLs physiques sont eux bien calculés). C'est ce que j'ai
                    vérifié en faisant des calculs de résidu annexes avec des
                    surcharges privées de amumpp.F.
   
       - En jouant sur les potards de MUMPS (ELMIM_LAGR2 et PRETRAITEMENTS par ex),
         la situation est elle similaire (en terme d'estimation de qualité et de
         singularité) ?
         ---> "Oui". On ne peut donc pas véritablement suspecter un bug ds MUMPS
            car il arrive à des résultats "proches" par des voies différentes ou
           avec des données différentes.
   
      Bref, je propose :
         - De restituer ces cas-tests en désactivant explicitement  la détection de
           singularité (NPREC=-1). La raison de cette désactivation étant tracé 
           ds le .comm.
         - De réfléchir à des actions plus constructives (réfléchir aux modélisa
           tions concernées, à la pertinence des cas-tests, aux solutions logiciel
           les potentielles telle la recherche de noyau...) ds le cadre du 
           Projet MN (j'émet l'EL ad hoc ds le Rex).
        - Pour info les modélisations concernées sont: D_PLAN_SI, CZM_OUV/FAT_MIX,
           3D_INCO_GD, X-FEM.
   
   Validation
   ===========
      Tests numériques sur tous les cas-tests sur la Bull en séq nodebug.
   
   Cas-tests modifiés
   =================
   ssnp122a
   ssnp139a
   ssnp139b
   ssnv112a
   ssnv112b
   ssnv112c
   ssnv112d
   ssnv199e
   ssnv199f
   ssnv209b
   ssnv209c
   ssnv209d
   ssnv209e
   ssnv209f
   ssnv209g
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 10.0.21
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   informatique,non-rxc3xa9gression
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR sellenet     SELLENET Nicolas       DATE 27/10/2009 - 08:01:58

--------------------------------------------------------------------------------
RESTITUTION FICHE 013152 DU 2009-02-20 07:30:48
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Probleme Bull-MPI
FONCTIONNALITE
   Problème :
   ----------
   Reboot automatique d'un noeud de calcul lorsqu'un calcul parallèle plante.
   
   
   Solution :
   ----------
   Suite à la coupure de la machine aster du 17/10/2009, l'exploitant a appliqué un patch
   correctif pour le problème dont parle cette fiche.
   
   Lundi 19/10/2009, j'ai relancé des tests en me placant dans les mêmes conditions qu'en
   février dernier (à savoir plantage dû à dépassement de tableau avec un deséquilibre de
   charge entre le proc 0 et les autres) et cette fois-ci le noeud sur lequel le calcul était
   lancé n'a pas rebooté.
   
   Je pense donc que le problème est résolu.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   nxc3xa9ant
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------
RESTITUTION FICHE 013963 DU 2009-10-01 12:35:20
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW10.0.19, le cas-test perf004c s'arrete par manque de temps CPU sur Bull.
FONCTIONNALITE
   Problème :
   ----------
   """
   En NEW10.0.19, le cas-test perf004c s'arrete par manque de temps CPU sur Bull.
   """
   
   
   Solution :
   ----------
   Du fait de la charge importante de la Bull en ce moment, je propose d'agrandir le temps
   disponible dans le .para.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   aucune
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------
RESTITUTION FICHE 014005 DU 2009-10-08 15:42:29
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   LIRE_RESU / MED : probleme lors de la verification du modxc3xa8le
FONCTIONNALITE
   Problème :
   ----------
   """
   Dans le profil joint, on essaie de faire un LIRE_RESU après un IMPR_RESU. Depuis une
   évolution récentes faite par DELTACAD, on vérifie la cohérence du modèle fourni par
   l'utilisateur.
   
   Dans le cas présent, l'unité logique pour la lecture du fichier MED est fausse. On ne lit
   donc aucun fichier. Or on cherche quand même à vérifier la cohérence du modèle.
   
   Il faudrait vérifier qu'on a bien lu un fichier avant de vérifier le modèle.
   
   Par ailleurs, il se peut que le problème soit identique avec LIRE_CHAMP.
   """
   
   
   Solution :
   ----------
   On rajoute une vérification dans LRVEMO qui permet de constater que l'ouverture de fichier
   MED correspondant s'est bien passée. Si ce n'est pas le cas, on plante en erreur F avec le
   message suivant :
   """
   Problème à l'ouverture du fichier MED fort.81 !
   """
   
   Comme LRVEMO est utilisé aussi par LIRE_CHAMP, ce correctif s'applique aussi au cas
   LIRE_CHAMP.
   
   
   Validation :
   ------------
   Cas test fourni par Josselin + cas test de la base utilisant LIRE_RESU et LIRE_CHAMP.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test unitaire + tests LIRE_CHAMP et LIRE_RESU
NB_JOURS_TRAV  : 0.25
--------------------------------------------------------------------------------
RESTITUTION FICHE 014076 DU 2009-10-21 11:38:42
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Routine d'observation LOBS
FONCTIONNALITE
   Problème :
   ----------
   Plantage de ttnl02a dans la routine LOBS à la ligne 89 en debug JEVEUX.
   
   
   Analyse :
   ---------
   Dans NMCRLI des vecteurs sont alloués pour la gestion de l'observation (par exemple
   "&&OP0070.SDDISC    .DITR"). Ces allocations sont faites entre une paire JEMARQ - JEDEMA
   et sont donc potentiellement libérables. Or ces tableaux sont utilisés ailleurs dans le code.
   
   Pour réutiliser ces tableaux, on doit passer par la routine UTDIDT qui effectue le JEVEUO
   correspondant au tableau demandé et renvoie l'adresse JEVEUX correspondante. Or dans
   UTDIDT ce JEVEUO se situe aussi entre une paire de JEMARQ - JEDEMA donc en debug JEVEUX,
   le tableau est rechargé en mémoire et libéré juste après.
   
   
   Solution :
   ----------
   Enlever les JEMARQ - JEDEMA dans la routine UTDIDT pour éviter la libération après le JEVEUO.
   
   
   Validation :
   ------------
   Liste de 47 cas tests + validation debug JEVEUX.
   
   
   Impact :
   --------
   UTDIDT
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   Liste de 47 cas tests + debug JEVEUX
NB_JOURS_TRAV  : 0.6
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR sfayolle     FAYOLLE Sebastien      DATE 26/10/2009 - 17:22:29

--------------------------------------------------------------------------------
RESTITUTION FICHE 014070 DU 2009-10-20 14:09:11
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Prediction de GLRC
FONCTIONNALITE
   Problème :
   ~~~~~~~~~~~
   
   Dans l'étape de prédiction élastique lors de l'intégration de la loi de comportement de
   GLRC_DM, il est nécessaire de résoudre deux polynômes d'ordre 4. Pour trouver les racines
   de ces polynômes, la routine zeropn.f est utilisée. La méthode utilisée est celle de la
   recherche des valeurs propres de la matrice compagnon. Dans le cas du calcul SMART réalisé
   par Irméla, la routine zeropn s'arrête sur un CALL ASSERT
   
   CALL VPHQRP(ZR(JMAT),DEGRE,DEGRE,ICODE,RACINE,BIDON,1,VBID,30,IER,IBID)
   CALL ASSERT(IER.EQ.0)
   
   Ce CALL ASSERT s'active quand la méthode itérative de recherche des valeurs propres ne
   converge pas.
   
   Solutions :
   ~~~~~~~~~~~~
   
   La solution adoptée a été de modifier la fonction zeropn
   
   <<SUBROUTINE ZEROPN( DEGRE, AI, RACINE )
   
   >>SUBROUTINE ZEROPN( KSTOP, DEGRE, AI, RACINE, IER )
   
   Le paramètre KSTOP permet de spécifier si on doit s'arrêter ou non si la résolution ne
   converge pas.
   De plus, on remonte le code erreur.
   
   
   >>IF (KSTOP.EQ.' ') GOTO 40
   >>
   >>IF (IER .NE. 0) THEN
   >>  CALL U2MESI(KSTOP,'ALGORITH17_6',1,IER)
   >>ENDIF
   >>
   >>40   CONTINUE
   
   La fonction zeropn est utilisé une seule autre fois dans le code par la fonction cribif.
   
   Dans l'intégration de la loi de comportement de GLRC_DM (gldloc.f), on teste le code
   retour de zeropn. Si celui-ci ne vaut pas 0, on utilise une autre méthode de prédiction
   qui est plus robuste mais moins précise.
   
   Fichiers modifiés : gldloc.f, zeropn.f, cribif.f
   Cas-tests : sdns106e,ssnp125a,ssnp125b,ssns106x,ssnv208a,SMART
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   cas test
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR tardieu      TARDIEU Nicolas        DATE 27/10/2009 - 16:50:28

--------------------------------------------------------------------------------
RESTITUTION FICHE 014081 DU 2009-10-22 07:57:19
TYPE express concernant Code_Aster (VERSION 10.1)
TITRE
   Des erreurs au sein du solveur de contact GCP
FONCTIONNALITE
   Analyse :
   --------
   1- Depuis le 1er jour, l'algorithme du GCP pour le contact comporte une erreur algorithmique
   au niveau du préconditionnement. Il y avait une confusion entre la direction de recherche
   et le gradient. On préconditionnait la première au lieu de la seconde. Cette erreur avait
   des conséquences même en l'absence de préconditionneur car elle impactait la formule de
   conjugaison. 
   
   Néanmoins ceci ne déclenchait pas de résultats faux ; seule la convergence était altérée.
   
   2- Il y avait une petite erreur qui empêchait l'usager d'augmenter le nombre
   d'itérations max (on prenait un min au lieu d'un max).
   
   3- Dans le GCP, pour voir si un noeud était exclu du contact pour cause de projection
   hors-zone (TOLE_PROJ_EXT), on testait si son jeu était à R8VIDE. Ceci était réalisé dans
   CHMANO.F. Or depuis la 8.3.13, le jeu n'est plus mis à R8VIDE dans un tel cas ; on
   interroge plutôt une fonction, CFEXCL. Or ceci n'était pas fait dans le GCP. Il y a donc
   un risque de résultats faux depuis la 8.3.13. 
   
   
   
   Corrections :
   ------------
   1- J'ai remis l'algorithme au propre. Les gains de performance devraient être notables.
   Comme la conjugaison fonctionne bien, j'ai augmenté le nombre par défaut d'itérations de
   GCP sans réinitialiser la direction de recherche  : de 3 on passe à 20.
   
   AU passage, j'augmente le nombre d'itérations max par défaut : de 2*NBLIAI on passe à
   10*NBLIAI.
   
   2- J'ai corrigé l'erreur qui empêchait l'usager d'augmenter le nombre d'itérations max.
   
   3- On appelle CFEXCL pour tester si un noeud est à exclure du contact.
   
   Enfin, je modifie l'initialisation de l'algorithme. Avant, on partait toujours d'un état nul ;
   je propose de partir de l'état précédent, ce qui permet un gain de performance substantiel
   quand l'état de contact évolue de manière régulière.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 8.2.9
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 8.2.9
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : R5.03.50
VALIDATION
   as_tout
NB_JOURS_TRAV  : 1.5
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST MODIF hsnv121a                        abbas M.ABBAS            218      2      1
 CASTEST MODIF miss01a                        devesa G.DEVESA           487      2      2
 CASTEST MODIF miss03a                        devesa G.DEVESA          1006      1      1
 CASTEST MODIF miss04a                        devesa G.DEVESA           321      2      1
 CASTEST MODIF miss04b                        devesa G.DEVESA           472      2      1
 CASTEST MODIF miss05a                        devesa G.DEVESA           444      3      2
 CASTEST MODIF miss08a                        devesa G.DEVESA           372      2      2
 CASTEST MODIF perf004c                     sellenet N.SELLENET          89      2      2
 CASTEST MODIF sdld31a                       greffet N.GREFFET          947      4      2
 CASTEST MODIF sdnd102c                        abbas M.ABBAS            248      2      1
 CASTEST MODIF sdnd102d                        abbas M.ABBAS            243      3      1
 CASTEST MODIF sdns106e                     sfayolle S.FAYOLLE          416      1      1
 CASTEST MODIF sdnv100f                        abbas M.ABBAS            397      1      1
 CASTEST MODIF sslp316a                       delmas J.DELMAS           220      4      4
 CASTEST MODIF sslp316b                       delmas J.DELMAS           188      4      4
 CASTEST MODIF sslp321b                      messier J.MESSIER          225      2      2
 CASTEST MODIF ssls502a                    desroches X.DESROCHES        283     57     30
 CASTEST MODIF ssls502b                    desroches X.DESROCHES        278     23      2
 CASTEST MODIF sslv110f                      geniaut S.GENIAUT          212      2      2
 CASTEST MODIF sslv315a                      messier J.MESSIER          283     95     18
 CASTEST MODIF sslv315b                      messier J.MESSIER          261     41      8
 CASTEST MODIF sslv315c                      messier J.MESSIER          232     10      9
 CASTEST MODIF sslv315d                      messier J.MESSIER          293     94     17
 CASTEST MODIF sslv316c                      messier J.MESSIER          318     10      5
 CASTEST MODIF ssna102e                      tardieu N.TARDIEU          249      5      5
 CASTEST MODIF ssnp122a                       pellet J.PELLET           303      6      2
 CASTEST MODIF ssnp125a                     sfayolle S.FAYOLLE          495      2      1
 CASTEST MODIF ssnp125b                     sfayolle S.FAYOLLE          424      1      1
 CASTEST MODIF ssnp139a                       pellet J.PELLET           294      6      3
 CASTEST MODIF ssnp139b                       pellet J.PELLET           330      5      3
 CASTEST MODIF ssnp503d                      geniaut S.GENIAUT          235      7      9
 CASTEST MODIF ssnp503f                      geniaut S.GENIAUT          233      7     10
 CASTEST MODIF ssnp503j                      geniaut S.GENIAUT          275      7     16
 CASTEST MODIF ssnp504b                      geniaut S.GENIAUT          254      7     10
 CASTEST MODIF ssnp504d                      geniaut S.GENIAUT          250      7      9
 CASTEST MODIF ssnp504f                      geniaut S.GENIAUT          277      7      7
 CASTEST MODIF ssns106a                     sfayolle S.FAYOLLE          953      1      1
 CASTEST MODIF ssns106b                     sfayolle S.FAYOLLE         1412      1      1
 CASTEST MODIF ssns106c                     sfayolle S.FAYOLLE         1526     45     45
 CASTEST MODIF ssns106d                     sfayolle S.FAYOLLE          416      1      1
 CASTEST MODIF ssns106e                     sfayolle S.FAYOLLE          530     21     21
 CASTEST MODIF ssns106f                     sfayolle S.FAYOLLE          741      1      1
 CASTEST MODIF ssns106g                     sfayolle S.FAYOLLE          493      1      1
 CASTEST MODIF ssnv112a                       pellet J.PELLET           318      6      4
 CASTEST MODIF ssnv112b                       pellet J.PELLET           358      5      2
 CASTEST MODIF ssnv112c                       pellet J.PELLET           303      5      2
 CASTEST MODIF ssnv112d                       pellet J.PELLET           310      5      2
 CASTEST MODIF ssnv199e                       pellet J.PELLET           365     10      5
 CASTEST MODIF ssnv199f                       pellet J.PELLET           388      6      4
 CASTEST MODIF ssnv208a                     sfayolle S.FAYOLLE          594      1      1
 CASTEST MODIF ssnv209b                       pellet J.PELLET           589      7      4
 CASTEST MODIF ssnv209c                       pellet J.PELLET           494      7      3
 CASTEST MODIF ssnv209d                       pellet J.PELLET           507      5      2
 CASTEST MODIF ssnv209e                       pellet J.PELLET           508      5      2
 CASTEST MODIF ssnv209f                       pellet J.PELLET           263      5      2
 CASTEST MODIF ssnv209g                       pellet J.PELLET           492      6      2
 CASTEST MODIF wtnp117b                      geniaut S.GENIAUT          461     23      1
 CASTEST MODIF yyyy100a                       delmas J.DELMAS           115      2      2
CATALOGU MODIF typelem/gener_me3d_2          geniaut S.GENIAUT          213      3      3
CATALOPY MODIF commun/c_contact              tardieu N.TARDIEU          322      2      2
 FORTRAN AJOUT elements/dkqsie             desroches X.DESROCHES        172    172      0
 FORTRAN AJOUT elements/dktsie             desroches X.DESROCHES        168    168      0
 FORTRAN AJOUT utilitai/compr8               geniaut S.GENIAUT          113    113      0
 FORTRAN MODIF algeline/calcpj             fernandes R.FERNANDES        137      2      2
 FORTRAN MODIF algeline/calcq              fernandes R.FERNANDES         84     10      3
 FORTRAN MODIF algeline/lcpllg             fernandes R.FERNANDES        296     17     14
 FORTRAN MODIF algeline/lglini             fernandes R.FERNANDES        147      7      5
 FORTRAN MODIF algeline/lglite             fernandes R.FERNANDES        127      6      4
 FORTRAN MODIF algeline/lgljpl             fernandes R.FERNANDES        150      6      4
 FORTRAN MODIF algeline/solrei             fernandes R.FERNANDES         83      6      4
 FORTRAN MODIF algeline/solren             fernandes R.FERNANDES         55      4      4
 FORTRAN MODIF algorith/algocg               tardieu N.TARDIEU          666    111     73
 FORTRAN MODIF algorith/cjside             fernandes R.FERNANDES        348      4      4
 FORTRAN MODIF algorith/cjsiid             fernandes R.FERNANDES        424      4      4
 FORTRAN MODIF algorith/cjsjde             fernandes R.FERNANDES        771      3      3
 FORTRAN MODIF algorith/cjsjid             fernandes R.FERNANDES        850      3      3
 FORTRAN MODIF algorith/cjstde             fernandes R.FERNANDES        264      3      3
 FORTRAN MODIF algorith/cjstid             fernandes R.FERNANDES        314      3      3
 FORTRAN MODIF algorith/cribif              sfayolle S.FAYOLLE          123      3      3
 FORTRAN MODIF algorith/cvmjac               geniaut S.GENIAUT          807      2      2
 FORTRAN MODIF algorith/intfac               messier J.MESSIER          192     49     17
 FORTRAN MODIF algorith/lcjpla             fernandes R.FERNANDES         68      4      4
 FORTRAN MODIF algorith/nmadat               geniaut S.GENIAUT          254      9      6
 FORTRAN MODIF algorith/nmassd                 abbas M.ABBAS            176     18      2
 FORTRAN MODIF algorith/nmchrm                 abbas M.ABBAS            248      2      2
 FORTRAN MODIF algorith/nmconv                 abbas M.ABBAS            519     13     11
 FORTRAN MODIF algorith/nmcrar               greffet N.GREFFET          269      4      2
 FORTRAN MODIF algorith/nueqch                 abbas M.ABBAS            110     30     14
 FORTRAN MODIF algorith/op0041               geniaut S.GENIAUT          340      2      2
 FORTRAN MODIF algorith/plasti             fernandes R.FERNANDES        446      6      4
 FORTRAN MODIF algorith/pregcp               tardieu N.TARDIEU          266      5      8
 FORTRAN MODIF algorith/utdidt              sellenet N.SELLENET         308      1      4
 FORTRAN MODIF algorith/xcalfe               geniaut S.GENIAUT          151      2      9
 FORTRAN MODIF algorith/xenrch               geniaut S.GENIAUT          425     18     19
 FORTRAN MODIF algorith/xgrals               geniaut S.GENIAUT          111      1      3
 FORTRAN MODIF algorith/xinils               geniaut S.GENIAUT          586      6     11
 FORTRAN MODIF algorith/xoriff               geniaut S.GENIAUT          206      4      2
 FORTRAN MODIF algorith/xprrei               messier J.MESSIER          559     36     49
 FORTRAN MODIF algorith/xprreo               messier J.MESSIER          564     45     39
 FORTRAN MODIF algorith/xptfon               geniaut S.GENIAUT          232     33     13
 FORTRAN MODIF algorith/xstami               geniaut S.GENIAUT          110      9      9
 FORTRAN MODIF algorith/zeropn              sfayolle S.FAYOLLE          109     22      3
 FORTRAN MODIF elements/dkqcol             desroches X.DESROCHES        181     19    170
 FORTRAN MODIF elements/dktcol             desroches X.DESROCHES        186     19    138
 FORTRAN MODIF elements/dsqcol             desroches X.DESROCHES        432     38    232
 FORTRAN MODIF elements/dstcol             desroches X.DESROCHES        330     31    147
 FORTRAN MODIF elements/gldloc              sfayolle S.FAYOLLE          228     83     29
 FORTRAN MODIF elements/gverif               geniaut S.GENIAUT          885      1      1
 FORTRAN MODIF elements/q4gcol             desroches X.DESROCHES        346     27    100
 FORTRAN MODIF elements/te0033             desroches X.DESROCHES        319      5      7
 FORTRAN MODIF elements/te0382                delmas J.DELMAS           530    122     63
 FORTRAN MODIF modelisa/acearp                devesa G.DEVESA           462     50     11
 FORTRAN MODIF prepost/lrvemo               sellenet N.SELLENET         236      7      3
  PYTHON MODIF Messages/algorith13             abbas M.ABBAS            267      2      4
  PYTHON MODIF Messages/algorith17          sfayolle S.FAYOLLE           45      4      1
  PYTHON MODIF Messages/algorith9              abbas M.ABBAS            296      1      5
  PYTHON MODIF Messages/archivage            greffet N.GREFFET           38      6      1
  PYTHON MODIF Messages/mecanonline5           abbas M.ABBAS            220      9      1
  PYTHON MODIF Messages/mecanonline            abbas M.ABBAS            153      1      4
  PYTHON MODIF Messages/med                 sellenet N.SELLENET         558      6      1
  PYTHON MODIF Messages/rupture0             geniaut S.GENIAUT          563      2      1
  PYTHON MODIF Messages/xfem2                geniaut S.GENIAUT          478      1     10
  PYTHON MODIF Messages/xfem                 geniaut S.GENIAUT          289     45      1


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :    3         453       453              +453
 MODIF :  120       43680      1602    1610        -8
 SUPPR :    0           0                 0        +0
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :  123       44133      2055    1610      +445 
