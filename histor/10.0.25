

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR audebert     AUDEBERT Sylvie        DATE 09/11/2009 - 15:29:39

--------------------------------------------------------------------------------
RESTITUTION FICHE 013770 DU 2009-08-25 14:04:21
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   comb_sism_modal et concept fonction dans SPEC_OSCI
FONCTIONNALITE
   bug signalÃ© sur le forum :
   le mot clÃ© spec_osci admet des nappes comme des fonctions simples. Or dans (au 
   moins) asexc1.f,
   on manipule l'objet .VALE de cet objet comme s'il s'agissait d'une collection 
   (JEXNUM) et non d'un
   vecteur simple.
   
   Autrement dit, on suppose qu'on a toujours affaire Ã  une nappe, et non une fonction 
   simple.
   
   On modifie le catalogue de telle sorte que les fonctions soient interdites pour le 
   mot-clé SPEC_OSCI de COMB_SISM_MODAL (en cohérence avec CALC_FONCTION, qui produit 
   bien des nappes). En effet, une nappe est absolument nécessaire (même d'une seule 
   fonction) pour le calcul.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   astout de COMB_SISM_MODAL
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR corus        CORUS Mathieu          DATE 10/11/2009 - 15:21:05

--------------------------------------------------------------------------------
RESTITUTION FICHE 013211 DU 2009-03-16 12:27:38
TYPE anomalie concernant Code_Aster (VERSION 10.2)
TITRE
   Pb ecriture format I-DEAS de resultats issus de la commande REST_SOUS_STRUC
FONCTIONNALITE
   -- PROBLEME ORIGINAL --
   
   L'ecriture de resultats provenant de la commande REST_SOUS_STRUC au format unv d'I-DEAS
   (commande
   IMPR_RESU) est erronnee.
   
   On souhaite en effet ecrire des resultats obtenus sur un modele generalise Ã  partir de la
   commande REST_SOUS_STRUC. Un maillage des sous-structures est defini Ã  partir de
   DEFI_SQUELETTE
   (Concept SQUEL), les resultats sont projetes sur le maillage squelette (concept MODIDTT) et
   sauvegardes dans un fichier unv d'I-DEAS pour le post-traitement.
   L'analyse du fichier unv d'IDEAS montre qu'il y a des incoherences. En particulier, les
   resultats
   sont ecrits successivement sur les mailles des sous-structures mais pas sur le maillage
   squelette
   complet !
   
   N.B. L'ecriture des memes resultats au format MED ne pose pas de probleme de
   post-traitement dans
   Salome...
   
   -- RESOLUTION --
   
   Apres analyse, il ressort que le probleme rencontre n'est pas un bug, mais resulte d'une
   difference de comportement d'IMPR_RESU entre les formats MED et Ideas. L'utilisateur
   demande a imprimer un maillage qui est different de celui portant le resultat. On a donc
   modifie l'operateur IMPR_RESU pour afficher un message d'alarme indiquant la confusion.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   cas test personnel
NB_JOURS_TRAV  : 0.125
--------------------------------------------------------------------------------
RESTITUTION FICHE 013553 DU 2009-06-23 09:59:53
TYPE anomalie concernant Code_Aster (VERSION 10.2)
TITRE
   Mauvaise prise en compte de l'amortissement hysteretique heterogene
FONCTIONNALITE
   -- PROBLEME ORIGINAL --
   
   Je signale ici une petite anomalie sur la prise en compte de l'amortissement hystérétique.
   Dans le cas d'un modèle presentant simultanement des materiaux dissipatifs et non
   dissipatifs, pour obtenir un resultat correct, il faut pour l'instant preciser
   AMOR_HYST=0. dans les DEFI_MATERIAU associes aux materiaux non dissipatifs, faute de quoi
   un amortissement leur est assigne. Par exemple, dans le cas d'une plaque sandwich acier /
   visco / acier, si on ne precise pas AMOR_HYST=0.0 pour l'acier, voici les resultats que
   l'on obtient (calcul modal) :
   
       NUMERO    FREQUENCE (HZ)    AMORTISSEMENT    NORME D'ERREUR
            1      6.13318E+01       4.98790E-01       3.04393E-09
            2      1.35097E+02       4.98923E-01       6.36164E-10
            3      3.44878E+02       4.99163E-01       1.21238E-10
            4      4.36279E+02       4.99547E-01       9.22955E-11
            5      4.64861E+02       4.98940E-01       6.80782E-11
   
   Dans le cas test (joins), j'ai fixé eta=1, ce qui conduit, dans le cas eta=1 pour tout le
   modele, a un amortissement modal de eta/2, soit le 0,5 retrouve par calcul.
   
   Et voici ce qu'il faut obtenir (obtenu en precisant AMOR_HYST = 0.0 pour le materiau
   associe a l'acier)
   
       NUMERO    FREQUENCE (HZ)    AMORTISSEMENT    NORME D'ERREUR
            1      6.18367E+01       1.40127E-02       4.30809E-09
            2      1.38709E+02       3.77744E-02       8.61579E-10
            3      3.57371E+02       4.94749E-02       1.64133E-10
            4      4.49336E+02       4.30415E-02       1.20468E-10
            5      4.85451E+02       6.54859E-02       8.89606E-11
   
   
   Je propose donc que, par defaut, on assigne la valeur 0.0 à AMOR_HYST, ce qui me semble
   etre la facon la plus simple de contourner le probleme.
   
   -- RESOLUTION --
   
   La valeur assignee a AMOR_HYST n'est pas initialisee dans te0050.f. Par analogie avec les
   autres modelisations d'amortissement, on initialise a 0 cette valeur dans te0050f. Le fait
   de ne pas renseigner explicitement le mot clef dans DEFI_MATERIAU revient donc a ne pas
   considerer d'amortissement hysteretique.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 7.0
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 7.0
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   cas test personnel
NB_JOURS_TRAV  : 0.125
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 10/11/2009 - 09:49:12

--------------------------------------------------------------------------------
RESTITUTION FICHE 014088 DU 2009-10-23 10:38:13
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Erreur lors de la recuperation des erreurs fatales dans STAT_NON_LINE
FONCTIONNALITE
   Problème
   ========
   
   resu=STAT_NON_LINE(...)
   => exception aster.error levée et récupérée par le superviseur qui écrit <S> (via impers)
      dans le fichier ERREUR (fort.9)
   => diagnostic <S>_ERROR : la base est fermée et recopiée.
   
   try:
      resu=STAT_NON_LINE(...)
   except aster.error:
      xxx
   => exception aster.error levée mais récupérée par le jdc et non le superviseur, donc
      pas de <S>.
   => diagnostic <F>_ERROR : la base a été fermée correctement (par FIN) mais n'est pas
   recopiée en raison du diagnostic.
   
   
   Solution
   ========
   
   Rappel sur le mécanisme d'erreurs/exceptions :
   ----------------------------------------------
   Dans les études (mot-clé CODE absent de DEBUT/POURSUITE), en cas d'erreur fatale :
    - on imprime le message avec le code <EXCEPTION> (au lieu de <F>),
    - on invalide le concept courant,
    - on ferme la base correctement en passant par FIN,
    - on lève une exception,
    - le diagnostic est <S>_ERROR, la base est recopiée.
   
   Si CODE (ou ERREUR_F='ABORT') est présent dans DEBUT/POURSUITE, en cas d'erreur fatale :
    - on imprime le message avec le code <F>,
    - on ne passe pas par FIN,
    - on appelle abort,
    - le diagnostic est <F>_ERROR, la base n'est pas recopiée.
   
   
   Dans STAT_NON_LINE, on souhaite récupérer les instants déjà calculé.
   Pour cela, on active le comportement en cas d'erreur fatale appelé EXCEPTION+VALID (via
   onerrf).
   
   Mais dans ce cas, l'impression du message ne remplaçait pas <F> (ou <E>) par <EXCEPTION>
   car le test était "== 'EXCEPTION'" et donc non vérifié avec EXCEPTION+VALID.
   
   Après correction, si on récupère l'exception dans le jdc, le diagnostic est <A>_ALARM (à
   cause du PAR_LOT='NON').
   
   
   On ajoute le test erreu05a pour vérifier ce comportement :
    - On fait un calcul thermo-mécanique.
    - La température varie de 0 à 10°C entre 0 et 10s.
    - Les propriétés matériaux ne sont définies qu'entre 0 et 5°C.
    - On demande le calcul aux instants 3 et 6s.
    - On récupère l'exception.
   En poursuite :
    - On vérifie que le concept evol_noli ne contient qu'un pas de temps calculé.
    - On calcule un instant supplémentaire (t=4s) pour vérifier l'intégrité du concept
   sauvegardé dans la base.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : u1.03.01
VALIDATION
   erreu05a
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 014146 DU 2009-11-06 09:48:56
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   tabulations dans 2 sources fortran90
FONCTIONNALITE
   amumph et amumpi contiennent des tabulations.
   Cela perturbait la vérification des messages, le source étant nettoyé des commentaires,
   des caractères de suite...
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ras
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 014148 DU 2009-11-06 09:51:39
TYPE express concernant Code_Aster (VERSION 7.0)
TITRE
   Preparation au passage a python2.6
FONCTIONNALITE
   En passant à python2.6, on tombe sur un certain nombre d'anomalies.
   
   La plupart sont (selon moi) un bug lié à python2.6 avec Numeric (en 64 bits et déjà vu
   parfois avec python2.5). Le passage de Numeric à numpy devrait être réalisé pour la 10.2.
   En attendant, on peut contourner ce problème avec le slice (tab[1:] qui retourne un
   tableau vide) en utilisant tab[1:len(tab)].
   
   On supprime aussi les DeprecationWarning des modules devenus obsolètes : sets (set
   introduit en 2.4), md5 (hashlib introduit en 2.5, on gère donc les 2).
   
   Tous les concepts doivent avoir une partie SD associée (et donc hériter de AsBase) : reel
   et entier dans accas.capy.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   astout liste complxc3xa8te
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 014128 DU 2009-11-02 17:45:05
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Degradation de l'evaluation des formules
FONCTIONNALITE
   Problème
   ========
   
   Le temps consommé par DYNA_TRAN_MODAL dans sdll126b est passé d'environ 8 s à 30 s suite à
   la modification de l'évaluation des formules pour les macros (cf. issue14018).
   
   
   Solution
   ========
   
   Pour pouvoir évaluer des formules définies dans les macros et qui utilisent des
   constantes, on a ajouté un context pour cela. Comme ce contexte est similaire à
   const_context du JDC, on a repris le même nom.
   Or quand on évalue la formule, on ne sait pas immédiatement si on est sous une macro ou
   sous le JDC, on testait la présence du const_context.  Si présent, on l'utilise pour
   l'évaluation de la formule.
   
   Sauf que l'attribut const_context est présent aussi si la formule a été définie dans le
   JDC ! Et donc dans tous les cas, on ajoutait jdc.const_context au context courant.
   C'est cette tâche qui prend du temps.
   Tout est relatif, les 20 secondes perdues correspondent à 300.000 évaluations de la formule !
   
   Peut-être serait-il plus efficace de tabuler la formule avec CALC_FONC_INTERP avant de la
   passer à DYNA_TRAN_MODAL ?
   
   
   Après correction, on retrouve le temps initial.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sdll126b
NB_JOURS_TRAV  : 2.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 014141 DU 2009-11-05 14:19:07
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   En NEW10.0.24, le cas-test sdll126b s'arrete en CPU_LIMIT sur Bull.
FONCTIONNALITE
   Le problème d'augmentation du temps de ce test (dans la commande DYNA_TRAN_MODAL) est
   regardé dans la fiche issue14128.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sdll126b
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR durand       DURAND Christophe      DATE 09/11/2009 - 16:31:24

--------------------------------------------------------------------------------
RESTITUTION FICHE 012752 DU 2008-10-30 15:18:12
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   ASSE_MAILLAGE : permettre les noeuds confondus dans les zones ?oller
FONCTIONNALITE
   Quand on a des noeuds géométriquement confondus dans un des groupes à coller pour
   ASSE_MAILLAGE, il y a confusion. En effet, l'appariement entre les groupes en vis à vis se
   fait par identité géométrique (distance nulle de noeud à noeud). Si dans l'une et l'autre
   des zones à apparier, on a déjà des noeuds topologiquement disjoints, mais géométriquement
   confondus, l'algorithme se plante fatalement.
   
   Je corrige donc en blindant : émission d'une erreur fatale quand on a des noeuds confondus
   dans la zone group_ma_1 du premier maillage. Comme par la suite on vérifie que la zone
   group_ma_2 lui est géométriquement superposée, pas besoin de faire la mm vérification sur
   le deuxième maillage.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test fourni par Samuel dans la fiche
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR elgharib     EL-GHARIB Joumana      DATE 09/11/2009 - 15:37:04

--------------------------------------------------------------------------------
RESTITUTION FICHE 013740 DU 2009-08-21 12:23:51
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   bug wtnv135a (LETK)
FONCTIONNALITE
   Pour garder une trace et pour que les personnes ayant à 
   communiquer pourquoi cette loi peut poser dans certains cas 
   un problème numériquement, ceci est une explication avec en 
   appui deux figures que j'attache à la fiche:
   
   Le résultat numérique obtenu avec Code_Aster du cas test 
   wtnv135a sur le déviateur des contraintes 
   et 
   Une page de la thèse d'A. Kleine où elle montre des résultats 
   de déviateurs sur des triaxiaux. 
   
   Un point commun ::: un plateau de contraintes. (sur le 
   plateau , on peut s'attendre à des problèmes d'où l'émission 
   de cette fiche)
   
   Les explications de ce plateau sont détaillées dans la note H-
   T64-2007-01800-FR et sont liées à la valeur du paramètre n (n 
   étant l'exposant de la loi de fluage)
   
   Grosso modo, la loi LETK dans sa version simplifiée de 
   code_aster est une loi à plusieurs mécansimes : plastique et 
   viscoplastique, et à plusieurs seuils :
   seuil élastique ou viscoplastique initial,
   seuil élastoplastique de pic ,
   seuil viscoplastique maximal.
   
   Le fluage et la plasticité commencent par se développer 
   conjointement, si le seuil viscoplastique max est atteint et 
   ne s'écrouit plus, la vitesse de fluage croit rapidement, le 
   seuil plastique s'écrouit plus vite et le point de charge 
   passe à l'intérieur du domaine élastique. Nous avons montré 
   numériquement qu'une stabilité des contraintes peut avoir 
   lieu pour de fortes valeurs de la puissance n  .
   
   Je propose de ne pas toucher à la liste d'instants originale.
   
   le message est  clair : on conseille le redécoupage mais on 
   ne garantit pas que le redécoupage va remédier au problème.
   
   Cette loi doit être manipulée avec prudence car elle est 
   compliquée (ne garantit pas une solution au problème local 
   dans tous les cas) .
   
   Elle sera utilisée par la R&D pour faire seulement des 
   triaxiaux avec des listes d'instants qu'on adapte 
   manuellement pour caler les paramètres d'une autre loi plus 
   simple 'VISC_DRUC_PRAG'.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   wtnv135a ssnv206
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR greffet      GREFFET Nicolas        DATE 09/11/2009 - 18:42:18

--------------------------------------------------------------------------------
RESTITUTION FICHE 013773 DU 2009-08-26 12:12:16
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Doc ZZZZ102 et cas test associ?
FONCTIONNALITE
   Contexte
   Le cas-test zzzz102a présentait trois tests sur des valeurs de spectres 
   d'oscillateurs avec des tolérances importantes : de 5 à 10 %. Les solutions 
   de références sont analytiques.
   
   Analyse et solution
   En pratique, si l'on analyse le contenu fréquentiel des signaux utilisés 
   (unités logiques 18 et 19), on remarque que la fréquence de coupure se 
   situe vers 50 - 60 Hz, pas moins.
   
   On cherche à tester des valeurs asymptotiques (type accélération 
   d'entraînement), qui sont donc à ne pas mesurer fortement en dessous de la 
   fréquence de coupure du signal d'entrée.
   
   Le cas-test d'origine testait à 35,5 Hz (c'est la fréquence de coupure par 
   défaut pour SPEC_OSCI) et comme on le voit sur les figures ci-jointes le 
   spectre est encore assez "chahuté" à cette fréquence et il faudrait se 
   placer plus loin : a minima vers 50 Hz pour bien approcher la valeur 
   asymptotique.
   La valeur par défaut de LIST_FREQ pour le calcul SPEC_OSCI reste pertinente 
   pour des accéléros "classiques", dont la fréquence de coupure est 
   inférieure à 30 - 40 Hz (cas des spectres réglementaires français 
   habituels).
   
   Je propose donc de modifier le cas-test afin de bien tenir compte de tout 
   le contenu fréquentiel des signaux employés. Je définis donc une liste de 
   fréquence plus large : jusqu'à FMAX = 100 Hz (qui sera aussi la fréquence 
   pour mesurer les valeurs asymptotiques).
   
   En faisant cela, les écarts aux solutions de références deviennent 
   inférieures à 0.03%. On redéfinit donc la tolérance à 0.1 % (au lieu de 5 
   et 10 %).
   
   Le temps de calcul passe d'environ 10 s à 14 s (sur Calibre 5).
   
   Impact documentaire
   Au niveau de la doc U2, on donnera le conseil de toujours commencer par 
   vérifier le contenu fréquentiel du signal d'entrée, afin de pouvoir définir 
   la liste de fréquence pour le calcul de spectre d'oscillateur en 
   conséquence, surtout si on cherche l'accélération d'entrainement.
   Pour la doc U4, on pourra clarifier la définition de la liste de fréquence 
   par défaut.
   
   Qualité des résultats
   En termes d'imprécision des résultats avec la liste de fréquence par 
   défaut, il faut modérer les conclusions : en effet, l'information 
   pertinente est souvent la valeur maximale du spectre, qui est 
   habituellement obtenue pour des fréquences bien plus basses que 30 Hz.
   
   Version 9
   le report en version 9 sera simple : seul zzzz102a.comm est (légèrement) 
   impacté par cette restitution.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V1.01.102, U4.32.04, U2.06.10
VALIDATION
   zzzz102a
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 014139 DU 2009-11-05 12:07:47
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   Depassement de tableau sdls119 a
FONCTIONNALITE
   Effectivement, le vecteur de réels 'FON_PROV' qui contient le champ 
   d'entrée pour la FFT
   (ou la FFT inverse) est de dimension 2*NBORDR pour la FFT et 3*NBORDR en 
   FFT inverse.
   Les données sont rangées ainsi :
   - de 1 à NBORDR ce sont les instants ou les fréquences suivant le sens de 
   FFT,
   - ensuite de sont les valeurs (réelles pour la FFT) ou complexes pour la 
   FFT-1.
   Pour stocker les nombres complexes on stocke séparement partie réelle et 
   imaginaire voilà
   pourquoi le vecteur et 1/3 plus long pour la FFT-1.
   Ce vecteur est construit dans PREFFT qui fait ensuite appel à SPDFFT.
   Dans SPDFFT, on va lire ces valeurs et pour le sens FFT-1, la boucle va 
   trop loin : 
   l'indice va en fait jusqu'au plus petit entier puissance de 2 supérieur à 
   NBORDR.
   
   En fait il faut récupérer les valeurs jusqu'à NBORDR puis éventuellement 
   compléter de 0.
   
   Si on fait cette modification, cela ne change pas les valeurs du test 
   sdls119a (qui est le
   seul à passer par ces routines : via op0181 : REST_SPEC_TEMP). Tous les 
   autres calculs de
   FFT se font avec CALC_FONCTION et se basent maintenant sur la FFT python.
   
   Routine impactée : SPDFFT
   
   Validation : on complète le test sdls119a en comparant les solutions avec 
   celles obtenues
   avec la FFT python (on passe alors par un CALC_FONCTION).
   
   Report en version 9 : facile car SPDFFT est alors quasiment identique.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V2.03.119
VALIDATION
   sdls119a
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR wadier       WADIER Yves            DATE 10/11/2009 - 09:52:14

--------------------------------------------------------------------------------
RESTITUTION FICHE 013772 DU 2009-08-26 08:36:23
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TMA : CS
TITRE
   POST_GP : incoherence python / catalogue
FONCTIONNALITE
   Objectif :
   ----------
   
   1/ maintenir EXCIT facultatif,
   2/ tester s'il est bien la, et s'il est la on prend les charges fournies,
   3/ s'il n'est pas là on va recuperer les charges dans resu.
   
   Modifications:
   -------------
   Les modifications ont impactes seulement la Macro post_gp_ops.py.
   
   Le mot-cle EXCIT reste facultatif dans le catalogue de commande de post_gp.
   Dans la macro post_gp_ops.py, l'information relative à l'excitation est transmise
   seulement à CALC_G et POST_ELEM. Or dans ces commandes, cette meme information est
   facultative et par defaut prise dans resu. Il suffit alors d'ajouter un argument
   facultatif lors de l'utilisation de ces commandes.
   
   91a92,95
   >    # Excitation
   >    args={}
   >    if self['EXCIT']:args={'EXCIT'   : self['EXCIT'].List_F()}
   >
   116d119
   <                            EXCIT=self['EXCIT'].List_F(),
   120c123,124
   <                            COMP_ELAS=self['COMP_ELAS'].List_F(),)
   ---
   >                            COMP_ELAS=self['COMP_ELAS'].List_F(),
   >                            **args)
   149d152
   <                            EXCIT=self['EXCIT'].List_F(),
   154,155c157,158
   <                            LISSAGE=self['LISSAGE'].List_F()
   <                            )
   ---
   >                            LISSAGE=self['LISSAGE'].List_F(),
   >                            **args)
   205a209,211
   >    # Charges
   >    args={}
   >    if self['EXCIT']:args={'CHARGE': [charg['CHARGE'] for charg in self['EXCIT']]}
   208d213
   <       l_charg = [charg['CHARGE'] for charg in self['EXCIT']]
   246d250
   <                                  CHARGE=l_charg,
   249c253,254
   <                                  TITRE='Energie ?lastique',)
   ---
   >                                  TITRE='Energie ?lastique',
   >                                  **args)
   363d367
   <                                  CHARGE=l_charg,
   366c370,371
   <                                  TITRE='Energie ?lastique',)
   ---
   >                                  TITRE='Energie ?lastique',
   >                                  **args)
   
   Validation:
   ----------
   hsna103a, ssnp131a et b dans lesquels, la presence/absence du mot-cle EXCIT est testee.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   hsna103a, ssnp131a, ssnp131b
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desroches    DESROCHES Xavier       DATE 10/11/2009 - 09:52:14

--------------------------------------------------------------------------------
RESTITUTION FICHE 013851 DU 2009-09-10 15:55:59
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TMA : CS
TITRE
   Erreur JEVEUX avec MODI_REPERE
FONCTIONNALITE
   Anomalie:
   --------
   Lors de l'execution d'une etude ne contenant pas de groupe de 
   noeud, une erreur JEVEUX apparait lors de l'appel a la commande 
   MODI_REPERE. Quand on rajoute un GROUP_NO quelconque dans le 
   fichier de maillage, cette erreur n'apparait plus.
   
   Modification:
   ------------
   La routine chrpel est modifiée afin de tester la presence de 
   groupes
   
   Validation:
   ----------
   sdls01b modifie pour reproduire l'anomalie mais non restitue
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   sans
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR pellet       PELLET Jacques         DATE 10/11/2009 - 09:52:15

--------------------------------------------------------------------------------
RESTITUTION FICHE 013940 DU 2009-09-24 16:06:10
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TMA : CS
TITRE
   Message incomplet et peu clair LIAISON_MAIL
FONCTIONNALITE
   Anomalie
   ========
   
   Dans cette étude vue sur le forum (réf
   http://www.code-aster.org/forum2/viewtopic.php?pid=18506#p18506), 
   on rencontre un message
   incomplet (car tronqué) et peu clair.
   
   Ce qui se passe c'est qu'en LIAISON_MAIL/DNOR, on fait une 
   vérification que la surface
   esclave est bien constituée de mailles de peau, or ici parce que 
   des groupes ont vu leur
   nom tronqué (supérieur à 8 caractères), on se retrouve avec un 
   GROUP_MA_ESCL qui contient
   à la fois des faces et des volumes. D'où le message d'erreur.
   
   Il faut corriger le message. Par ailleurs dans CALIRC, on trouve 
   le nom des mailles
   admissibles et certaines n'existent pas dans Aster : 
   
         IF (NDIM.EQ.2) THEN
           NBTYP = 3
           LISTYP(1) = 'SEG2'
           LISTYP(2) = 'SEG3'
           LISTYP(3) = 'SEG4'
         ELSE IF (NDIM.EQ.3) THEN
           NBTYP = 10
           LISTYP(1) = 'TRIA3'
           LISTYP(2) = 'TRIA6'
           LISTYP(3) = 'TRIA9'
           LISTYP(4) = 'QUAD4'
           LISTYP(5) = 'QUAD8'
           LISTYP(6) = 'QUAD9'
           LISTYP(7) = 'QUAD12'
           LISTYP(8) = 'SEG2'
           LISTYP(9) = 'SEG3'
           LISTYP(10) = 'SEG4'
         END IF
   
   Modification:
   ============
   
   * Modifier le message lors de la detection de mailles non conformes dans 
   la construction de GROUP_MA_ESCL. 
   "Certaines mailles constituant le groupe de mailles %(k1)s ne sont pas 
   des mailles surfaciques.
   Risques & Conseils :
   Verifiez la constitution des groupes de mailles renseignees sous le 
   mot-cle GROUP_MA_ESCL."
   
   
   * Supprimer dans la routine calirc.f le nom des mailles
   inexistantes conformement a ce qui est present dans 
   type_maille__.cata soit les mailles de type  : 'TRIA9' et 'QUAD12'
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ?de jointe
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR messier      MESSIER Julien         DATE 09/11/2009 - 15:09:24

--------------------------------------------------------------------------------
RESTITUTION FICHE 014144 DU 2009-11-06 08:00:41
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
   Simplification du cas-test sslp317 + Doc V3.02.317
FONCTIONNALITE
   Le cas-test sslp317 valide la commande RAFF_XFEM dont le principe est d'associer un champ d'erreur et la 
   macro-commande MACR_ADAP_MAIL dans le but de raffiner le maillage en fonction de la distance au fond de 
   fissure.
   On propose d'une part, de simplifier et corriger les équations du §3.1 de la doc V3.02.317 afin de les 
   rendre cohérentes au §1.1, et d'autre part, de corriger la définition des level-sets dans le cas-test 
   lui-même pour le mettre également en cohérence avec la doc.
   
   Après correction, les level-sets s'écrivent simplement :
   
   LN1 = x²+y²-R1²
   LT1 = y 
   
   LN2 = x²+y²-R2²
   LT2 = -y
   
   LN3 = y-0.25
   LT3 = x-0.4 si x>0.3
   LT3 = -x+0.2 sinon
   
   LN4 = y-0.25
   LT4 = -x-0.3 si x<-0.2
   LT4 = x+0.1 sinon
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V3.02.317
VALIDATION
   cast-test lui-meme
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 014136 DU 2009-11-04 17:28:48
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
   En NEW10.0.24, le cas-test sslp322a est NOOK sur Calibre4.
FONCTIONNALITE
   Le cas-test sslp322a est NOOK sur ROCKS et Calibre.
   On restitue dans cette fiche la modification de la tolérance proposée dans les fiches 13807 et 13848 et 
   qui n'avait pas encore été repercutée.
   On passe la tolérance sur K1 de 0.1 à 1.5%.
   Le cas-test est OK.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   cast-test lui-meme
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR meunier      MEUNIER Sébastien      DATE 09/11/2009 - 16:00:38

--------------------------------------------------------------------------------
RESTITUTION FICHE 013966 DU 2009-10-01 15:56:32
TYPE anomalie concernant Code_Aster (VERSION 10.2)
TITRE
   Post-traitement et Arlequin
FONCTIONNALITE
   Objet :
   -------
   Post-traitement pour la méthode Arlequin.
   
   Suite à la réunion du 13/10/09 (cf CR-AMA-09.234), je propose de favoriser les solutions
   minimisant le nombre de développement vu qu'on peut faire des calculs corrects sans
   développements supplémentaires. En résumé, pour toutes les commandes de post-traitement,
   il suffit juste de faire les calculs sur le patch et sur le maillage grossier indépendamment.
   
   J'ai donc fait le travail suivant :
   
   1 => CALC_G et POST_K1_K2_K3 :
   ------------------------------
   On restreint les calculs aux groupes de mailles du patch autour de la fissure pour ne pas
   compter la matière plusieurs fois.
   
   Sinon, il y a des résultats faux lorsque la couronne d'intégration autour de la fissure
   contient des noeuds du maillage grossier, ce qui peut tout à fait arriver.
   
   J'ai repris les tests de la base où j'ai pris la précaution de restreindre le calcul de la
   couronne THETA et de G au maillage du patch. Il n'y avait pas de résultats faux avant car
   on était justement dans le cas particulier où la couronne ne contient pas de noeuds du
   maillage grossier mais je fais cela pour montrer l'exemple. J'ai donc modifié sslp108b,
   sslp108c, (cas de fissure droite), sslp313c et sslp313f (cas de fissure inclinée).
   
   Cela se fait typiquement par l'enchaînement de commandes suivant :
   
   IMPR_RESU(FORMAT='MED',
             UNITE=81,
             RESTREINT=_F(GROUP_MA=('COUR','FISS',),
                          TOUT_GROUP_NO='OUI',),
             RESU=_F(RESULTAT=RESU,
                     NOM_CHAM='DEPL',),);
   ...
   
   RESU_RES=LIRE_RESU(TYPE_RESU='EVOL_ELAS',
                      FORMAT='MED',
                      MODELE=MO_RES,
                      CHAM_MATER=MAT_RES,
                      UNITE=81,
                      FORMAT_MED=_F(NOM_CHAM='DEPL',
                                    NOM_CHAM_MED='&RESUR1_DEPL____________________',),
                      TOUT_ORDRE='OUI',);
   
   Il y a juste un petit développement à faire si on a de la plasticité (VMIS_ISOT_LINE) dans
   le modèle. En effet, on est bloqué car LIRE_RESU ne sait pas lire les champs EPSP_ELNO. Il
   suffit de rajouter le bloc suivant :
   ELSE IF (NOCH.EQ.'EPSP_ELNO') THEN
     NOMGD  = 'EPSI_R'
     TYPCHA = 'ELNO'
     OPTION = 'EPSP_ELNO'
     PARAM  = 'PDEFOPL'
   autour de la ligne 746 de op0150.f pour que LIRE_RESU sache lire les champs EPSP_ELNO.
   
   2 => PROJ_CHAMP :
   -----------------
   Pas de développement. Il suffit d'utiliser le mot-clef VIS_A_VIS pour projeter les champs
   du maillage grossier d'une part et les champs du maillage fin d'autre part.
   
   3 =>MACR_LIGN_COUPE et POST_RELEVE_T :
   --------------------------------------
   Rien à faire, vu que PROJ_CHAMP fonctionne.
   
   4 => CALC_ELEM :
   ----------------
   On interdit l'usage des indicateurs d'erreur dans cette commande, sinon tout le reste est OK.
   
   5 => POST_ELEM :
   ----------------
   On n'interdit rien, mais il faut post-traiter par groupe de mailles, comme pour CALC_G.
   
   Les consignes d'utilisation devraient être documentées quelque part, dans une doc U2 (voir
   fiche 9399)
   
   Remarque :
   ----------
   Samuel pourra restituer une variante de ssnp138 : "fissure xfem sur patch Arlequin",
   détaillée dans le CR-AMA-09-210 quand il le veut !
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   tous les tests Arlequin
NB_JOURS_TRAV  : 5.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 014140 DU 2009-11-05 13:54:34
TYPE express concernant Code_Aster (VERSION 10.1)
TITRE
   Modes locaux inutiles
FONCTIONNALITE
   1. Catalogues :
   ---------------
   Le mode local cterefe est inutile dans les catalogues d'éléments suivants :
   
   gener_2d2g.cata
   gener_me3a62.cata
   gener_me3a64.cata
   gener_meaa62.cata
   gener_meaa64.cata
   gener_meda62.cata
   gener_meda64.cata
   gener_medpl2.cata
   
   Je les supprime donc.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   aucune
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 009403 DU 2006-01-25 17:09:36
TYPE anomalie concernant Code_Aster (VERSION 10.2)
TITRE
   ARLEQUIN - Bug CALC_K_G
FONCTIONNALITE
   Cette fiche est résolue grâce à la fiche 13966.
   
   Objet :
   -------
   Post-traitement pour la méthode Arlequin.
   
   Suite à la réunion du 13/10/09 (cf CR-AMA-09.234), je propose de favoriser les solutions
   minimisant le nombre de développement vu qu'on peut faire des calculs corrects sans
   développements supplémentaires. En résumé, pour toutes les commandes de post-traitement,
   il suffit juste de faire les calculs sur le patch et sur le maillage grossier indépendamment.
   
   J'ai donc fait le travail suivant :
   
   1 => CALC_G et POST_K1_K2_K3 :
   ------------------------------
   On restreint les calculs aux groupes de mailles du patch autour de la fissure pour ne pas
   compter la matière plusieurs fois.
   
   Sinon, il y a des résultats faux lorsque la couronne d'intégration autour de la fissure
   contient des noeuds du maillage grossier, ce qui peut tout à fait arriver.
   
   J'ai repris les tests de la base où j'ai pris la précaution de restreindre le calcul de la
   couronne THETA et de G au maillage du patch. Il n'y avait pas de résultats faux avant car
   on était justement dans le cas particulier où la couronne ne contient pas de noeuds du
   maillage grossier mais je fais cela pour montrer l'exemple. J'ai donc modifié sslp108b,
   sslp108c, (cas de fissure droite), sslp313c et sslp313f (cas de fissure inclinée).
   
   Cela se fait typiquement par l'enchaînement de commandes suivant :
   
   IMPR_RESU(FORMAT='MED',
             UNITE=81,
             RESTREINT=_F(GROUP_MA=('COUR','FISS',),
                          TOUT_GROUP_NO='OUI',),
             RESU=_F(RESULTAT=RESU,
                     NOM_CHAM='DEPL',),);
   
   MA_RES=LIRE_MAILLAGE(UNITE=81,
                        FORMAT='MED',
                        VERI_MAIL=_F(VERIF='OUI',),);
   
   MA_RES=MODI_MAILLAGE(reuse =MA_RES,
                        MAILLAGE=MA_RES,
                        MODI_MAILLE=_F(OPTION='NOEUD_QUART',
                                       GROUP_NO_FOND='P0',),);
   
   MO_RES=AFFE_MODELE(MAILLAGE=MA_RES,
                      AFFE=_F(TOUT='OUI',
                              PHENOMENE='MECANIQUE',
                              MODELISATION='C_PLAN',),);
   
   MAT_RES=AFFE_MATERIAU(MAILLAGE=MA_RES,
                         AFFE=_F(TOUT='OUI',
                                 MATER=MATERI,),);
   
   RESU_RES=LIRE_RESU(TYPE_RESU='EVOL_ELAS',
                      FORMAT='MED',
                      MODELE=MO_RES,
                      CHAM_MATER=MAT_RES,
                      UNITE=81,
                      FORMAT_MED=_F(NOM_CHAM='DEPL',
                                    NOM_CHAM_MED='&RESUR1_DEPL____________________',),
                      TOUT_ORDRE='OUI',);
   
   Il y a juste un petit développement à faire si on a de la plasticité (VMIS_ISOT_LINE) dans
   le modèle. En effet, on est bloqué car LIRE_RESU ne sait pas lire les champs EPSP_ELNO. Il
   suffit de rajouter le bloc suivant :
   ELSE IF (NOCH.EQ.'EPSP_ELNO') THEN
     NOMGD  = 'EPSI_R'
     TYPCHA = 'ELNO'
     OPTION = 'EPSP_ELNO'
     PARAM  = 'PDEFOPL'
   autour de la ligne 746 de op0150.f pour que LIRE_RESU sache lire les champs EPSP_ELNO.
   
   2 => PROJ_CHAMP :
   -----------------
   Pas de développement. Il suffit d'utiliser le mot-clef VIS_A_VIS pour projeter les champs
   du maillage grossier d'une part et les champs du maillage fin d'autre part.
   
   3 =>MACR_LIGN_COUPE et POST_RELEVE_T :
   --------------------------------------
   Rien à faire, vu que PROJ_CHAMP fonctionne.
   
   4 => CALC_ELEM :
   ----------------
   On interdit l'usage des indicateurs d'erreur dans cette commande, sinon tout le reste est OK.
   
   5 => POST_ELEM :
   ----------------
   On n'interdit rien, mais il faut post-traiter par groupe de mailles, comme pour CALC_G.
   
   Les consignes d'utilisation devraient être documentées quelque part, dans une doc U2 (voir
   fiche 9399). Pour l'instant, je propose de mettre quelques phrases dans la documentation
   de AFFE_CHAR_MECA (U4.44.01)
   
   Remarque :
   ----------
   Samuel pourra restituer une variante de ssnp138 : "fissure xfem sur patch Arlequin",
   détaillée dans le CR-AMA-09-210 quand il le veut !
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.44.01
VALIDATION
   Tests Arlequin
NB_JOURS_TRAV  : 5.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR sellenet     SELLENET Nicolas       DATE 09/11/2009 - 16:50:04

--------------------------------------------------------------------------------
RESTITUTION FICHE 014101 DU 2009-10-26 13:03:55
TYPE anomalie concernant Code_Aster (VERSION 7.0)
TITRE
   ssla200 a et b NOOK_TEST_RESU
FONCTIONNALITE
   Problème :
   ----------
   """
   ssla200a et ssla200b NOOK_TEST_RESU en debug JEVEUX.
   """
   
   
   Analyse :
   ---------
   Un test réalisé sur un résultat issu d'un MECA_STATIQUE devient NOOK lorsqu'on passe en
   debug JEVEUX. En imprimant le second membre calculé au début du MECA_STATIQUE, je me suis
   rendu compte qu'il n'était pas similaire en debug JEVEUX et en mode normal.
   
   Après analyse, j'ai constaté que la partie du second membre qui était fausse est due à un
   LIAISON_GROUP d'un AFFE_CHAR_MECA_F.
   
   Dans AFFE_CHAR_MECA_F pour construire la sd_char_meca correspondante au fichier de
   données, on commence par construire une liste des noeuds impliqués dans le LIAISON_GROUP.
   Cette liste et toutes les listes dépendantes sont triées dans la routine ORDLRL.
   Malheureusement, ces listes sont appelées avec un JEVEUO en lecture, de ce fait, en debug
   JEVEUX, le tri n'est pas sauvegardé. On se retrouve donc avec des inversions de valeurs
   dans la charge calculée.
   
   Cela peut engendrer des résultats faux depuis la 3.3.24 puisque ces tableaux n'ont jamais
   été sollicité en écriture dans cette routine.
   
   
   Solution :
   ----------
   Dans ORDLRL, on fait le JEVEUO en écriture sur les tableaux à trier.
   
   
   Validation :
   ------------
   ssla200a en debug JEVEUX.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 3.3.24
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 3.3.24
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ssla200a en debug JEVEUX
NB_JOURS_TRAV  : 2.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR tardieu      TARDIEU Nicolas        DATE 09/11/2009 - 16:34:21

--------------------------------------------------------------------------------
RESTITUTION FICHE 014135 DU 2009-11-04 17:25:44
TYPE anomalie concernant Code_Aster (VERSION 10.2)
TITRE
   En NEW10.0.24, le cas-test ssna102e est NOOK sur Calibre5.
FONCTIONNALITE
   J'ai regardé le problème : il s'agit d'une variation qui apparait au fur et à mesure que
   le calcul avance. On accumule des petites erreurs liées au calcul en virgule flottante et
   au final, on obtient une petite différence sur le résultat.
   Je mets donc les tolérances pour que ça marche.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   Passage du test
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 014130 DU 2009-11-03 16:18:26
TYPE express concernant Code_Aster (VERSION 10.2)
TITRE
   Encore un probl? dans le GCP
FONCTIONNALITE
   Comme dans la fiche 14081, il s'agit d'une erreur au sein de l'algorithme de Gradient
   Conjugué Projeté. Il y avait une autre confusion entre la direction de recherche et le
   gradient de la fonctionnelle. Précédemment, il s'agissait de la conjugaison, là il s'agit
   de la phase de projection.
   Heureusement, ceci ne pouvait produire de résultats faux.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   astout tests avec GCP
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 014066 DU 2009-10-20 11:35:53
TYPE anomalie concernant Code_Aster (VERSION 10.2)
TITRE
   Autre prxc3xa9conditionneur que LDLT_INC inutilisable
FONCTIONNALITE
   Dans la routine crsvpe.f, après lecture des arguments du mot-clé facteur SOLVEUR, on
   faisait un ASSERT pour bien vérifier la lecture de certaines informations. Or, il y en
   avait qui ne sont pas toujours présentes : des informations de niveau de remplissage liées
   à l'utilisation de factorisation incomplète (LDLT_INC) qui ne sont jamais renseignées si
   on utilise SOR comme préconditionneur.
   Je limite donc la présence des ces ASSERT aux seuls paramètres toujours présents dans le
   mot-clé facteur SOLVEUR.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test perso
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST AJOUT erreu05a                     courtois M.COURTOIS         104    104      0
 CASTEST MODIF perf001a                     sellenet N.SELLENET          67      1      1
 CASTEST MODIF sdls119a                      greffet N.GREFFET          497     81      7
 CASTEST MODIF sslp108b                      meunier S.MEUNIER          327     79     53
 CASTEST MODIF sslp108c                      meunier S.MEUNIER          365     84     70
 CASTEST MODIF sslp313c                      meunier S.MEUNIER          302     71     25
 CASTEST MODIF sslp313f                      meunier S.MEUNIER          343     82     28
 CASTEST MODIF sslp317a                      messier J.MESSIER          248     25     25
 CASTEST MODIF sslp322a                      messier J.MESSIER          241      2      2
 CASTEST MODIF ssna102e                      tardieu N.TARDIEU          247      7      9
 CASTEST MODIF zzzz102a                      greffet N.GREFFET         1518     37     14
CATALOGU MODIF typelem/gener_2d2g            meunier S.MEUNIER          168      1      2
CATALOGU MODIF typelem/gener_me3a62          meunier S.MEUNIER          177      1      2
CATALOGU MODIF typelem/gener_me3a64          meunier S.MEUNIER          180      1      2
CATALOGU MODIF typelem/gener_meaa62          meunier S.MEUNIER          163      1      2
CATALOGU MODIF typelem/gener_meaa64          meunier S.MEUNIER          166      1      2
CATALOGU MODIF typelem/gener_meda62          meunier S.MEUNIER          163      1      2
CATALOGU MODIF typelem/gener_meda64          meunier S.MEUNIER          166      1      2
CATALOGU MODIF typelem/gener_medpl2          meunier S.MEUNIER          619      1      2
CATALOPY MODIF commande/comb_sism_modal     audebert S.AUDEBERT         128      4      4
CATALOPY MODIF entete/accas                 courtois M.COURTOIS         223      3      3
FORTRAN90 MODIF mumps/amumph                 courtois M.COURTOIS         391      1      1
FORTRAN90 MODIF mumps/amumpi                 courtois M.COURTOIS         435      1      1
 FORTRAN MODIF algeline/crsvpe               tardieu N.TARDIEU          117      5      5
 FORTRAN MODIF algorith/algocg               tardieu N.TARDIEU          666     56     56
 FORTRAN MODIF algorith/chrpel               macocco K.MACOCCO          722      9      3
 FORTRAN MODIF calculel/meca01               meunier S.MEUNIER          741     19      4
 FORTRAN MODIF calculel/mecalm               meunier S.MEUNIER         2557      3      2
 FORTRAN MODIF calculel/op0100               meunier S.MEUNIER         1084     56     32
 FORTRAN MODIF elements/te0050                 corus M.CORUS            187      2     10
 FORTRAN MODIF modelisa/asmaco                durand C.DURAND           643     23      2
 FORTRAN MODIF modelisa/calirc               macocco K.MACOCCO          534      9     11
 FORTRAN MODIF modelisa/nbnlma               macocco K.MACOCCO          158      4      7
 FORTRAN MODIF modelisa/ordlrl              sellenet N.SELLENET         375      7      7
 FORTRAN MODIF prepost/op0039                  corus M.CORUS            988     22      4
 FORTRAN MODIF utilitai/op0150               meunier S.MEUNIER         1138      6      1
 FORTRAN MODIF utilitai/spdfft               greffet N.GREFFET          166      6      4
  PYTHON MODIF Accas/__init__               courtois M.COURTOIS          80      2      1
  PYTHON MODIF Build/B_ETAPE                courtois M.COURTOIS         804      3      4
  PYTHON MODIF Build/B_SENSIBILITE_MEMO_NOM_SENSI   courtois M.COURTOIS         375      6      8
  PYTHON MODIF Execution/checksd            courtois M.COURTOIS         102      5      7
  PYTHON MODIF Macro/calc_europlexus_ops    courtois M.COURTOIS        2545      5      6
  PYTHON MODIF Macro/dyna_iss_vari_ops      courtois M.COURTOIS         360      3      2
  PYTHON MODIF Macro/impr_table_ops         courtois M.COURTOIS         247      3      5
  PYTHON MODIF Macro/macr_lign_coupe_ops    courtois M.COURTOIS         954      6      7
  PYTHON MODIF Macro/post_dyna_alea_ops     courtois M.COURTOIS         431      4      5
  PYTHON MODIF Macro/post_gp_ops             macocco K.MACOCCO          938     18     15
  PYTHON MODIF Macro/test_fichier_ops       courtois M.COURTOIS         324     27     16
  PYTHON MODIF Meidee/modes                 courtois M.COURTOIS        1351      1      5
  PYTHON MODIF Messages/arlequin             meunier S.MEUNIER          199      9      2
  PYTHON MODIF Messages/modelisa2             durand C.DURAND           332     66     58
  PYTHON MODIF Messages/modelisa8            macocco K.MACOCCO          358      6      2
  PYTHON MODIF Messages/prepost3               corus M.CORUS            226      5      1
  PYTHON MODIF Noyau/N_ASSD                 courtois M.COURTOIS         143      3      1
  PYTHON MODIF Noyau/N_FONCTION             courtois M.COURTOIS         121      2      2
  PYTHON MODIF Noyau/N_MACRO_ETAPE          courtois M.COURTOIS         714      3      3
  PYTHON MODIF SD/sd_resultat               courtois M.COURTOIS         182      4      5
  PYTHON MODIF SD/sd_util                   courtois M.COURTOIS         185      2      3
  PYTHON MODIF Utilitai/optimize            courtois M.COURTOIS         593      7      7
  PYTHON MODIF Utilitai/Table               courtois M.COURTOIS        1039      3      4
  PYTHON MODIF Utilitai/t_fonction          courtois M.COURTOIS         732      6      7
  PYTHON MODIF Utilitai/utils               courtois M.COURTOIS          48      4      5
  PYTHON MODIF Utilitai/Utmess              courtois M.COURTOIS         678      3      4


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :    1         104       104              +104
 MODIF :   62       31271       919     592      +327
 SUPPR :    0           0                 0        +0
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :   63       31375      1023     592      +431 
