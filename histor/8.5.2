

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR geniaut      GENIAUT Samuel         DATE 31/07/2007 - 16:27:23

--------------------------------------------------------------------------------
RESTITUTION FICHE 010274 DU 2006-11-17 09:55:23
TYPE anomalie concernant Code_Aster (VERSION 8.4)
TITRE
   NEW8.3.22, le test ssnv182b s'arrete par manque de MEMOIRE (R)
FONCTIONNALITE
   problème :
   ----------
   
   MUMPS manque de mémoire pour pivoter dans le cas test ssnv182b sous rocks en NEW8
   
   
   
   réponse : 
   ---------
   
   Je rajoute le paramètre mem_aster 50 dans ssnv182b.para et ca passe.
   Du coup, je n'augmente pas la mémoire globale.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ssnv182b
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR greffet      GREFFET Nicolas        DATE 31/07/2007 - 16:27:23

--------------------------------------------------------------------------------
RESTITUTION FICHE 011051 DU 2007-07-05 16:19:30
TYPE express concernant Code_Aster (VERSION 2.x)
TITRE
   IMPR_MACR_ELEM format MISS3D : transmission xc3xa0 MISS3D de l'info sur le formattage long des reels : 1PE16.9
FONCTIONNALITE
   On modifie iredm1 pour spécifier dans le fichier de sortie ASCII pour MISS3D 
   quel est le format des réels :
   - court (ancien format et format par défaut) : 1PE12.5 :
             mot-clé dans le fichier : 'FORMAT_REAL_COURT'
   - long : 1PE16.9 : 
             mot-clé dans le fichier : 'FORMAT_REAL_LONG'
   
   A noter que ce choix de format n'est valide qu'avec PROMISS3D V1.4. Avec la 
   version V1.3, on n'a que le format court.
   
   Cette modification, pour être fonctionnelle, est accompagnée d'une modification 
   du script de lancement miss3d.csh :
   on teste la présence du mot-clé FORMAT_REAL_LONG et si il est là, on lance 
   gtaster_long.x, sinon on lance gtaster.x
   
   On corrige aussi la fiche 11040 en remplaçant dans ce script miss3d.csh la 
   ligne :
   unalias -a (syntaxe bash)
   par :
   unalias * (syntaxe csh correct puisque le script est en csh)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   cas-test personnel (basxc3xa9 sur zzzz108a)
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 31/07/2007 - 16:27:23

--------------------------------------------------------------------------------
RESTITUTION FICHE 009927 DU 2006-07-20 09:47:14
TYPE anomalie concernant Code_Aster (VERSION 8.3)
TITRE
   IMPR_TABLE: fichier d'impression tronquxc3xa9 si erreur
FONCTIONNALITE
   Le problème apparait quand on imprime sur l'unité 8 et qu'un UTMESS se produit au milieu
   de l'impression.
   
   Comme l'unité a été fermée par la macro (pour faire un flush...), l'UTMESS en se
   déclenchant commence un fichier vierge (write fortran sans open) : on perd tout.
   
   La solution est de vérifier l'état du fichier dans affich.f (appelé par aster.affiche) et
   si besoin d'ouvrir le fichier en mode APPEND et non NEW.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test xc3xa9lxc3xa9mentaire faisant IMPR sur fort.8 puis Alarme
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 010561 DU 2007-02-23 12:54:55
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TITRE
   Erreur fatale dans POST_K1_K2_K3 avec TYPE_MAILLAGE='LIBRE'
FONCTIONNALITE
   Contexte :
   boucle sur N maillages
   - MODL = AFFE_MODELE(...)
   - ...
   - TAB = POST_K1_K2_K3(...)
   - DETRUIRE(MODL, ...)
   
   Au 2ème passage, sds_dict utilisé dans POST_K1_K2_K3 ne contient pas MODL.
   
   En fait, pour mettre à jour le contexte au moment de l'étape courante, on appelle
   update_context de chaque étape qui execute l'op_init s'il est présent. Je n'ai pas vérifié
   mais j'ai l'impression qu'on exécute une 2ème fois l'op_init du DETRUIRE précédent et qui
   MODL est sorti du sds_dict.
   
   Je modifie l'ops.detruire (op_init de DETRUIRE) en ajoutant un test :
      if hasattr(self,"executed") and self.executed == 1:
         return
   
   L'attribut "executed" étant renseigné par l'exécution de l'étape.
   Je ne le fais pas dans les autres op_init (POURSUITE, INCLUDE...).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   liste restreinte
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 011015 DU 2007-06-25 15:30:34
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TITRE
   Comportement anormal de Stanley en PAR_LOT='OUI'
FONCTIONNALITE
   Dans un jeu de commandes qui calcule plusieurs concepts résultat :
   RESU1 = MECA_STATIQUE(...)
   RESU2 = MECA_STATIQUE(...)
   
   Si on insère PRE_STANLEY() entre les deux et qu'on est en PAR_LOT='OUI', Stanley nous
   propose de choisir parmi RESU1 et RESU2 alors que RESU2 n'a pas encore été calculé.
   
   Pour corriger cela, on utilise la valeur de l'attribut "executed" de l'étape qui produit
   le concept avant de l'ajouter dans la liste.
   On fait de même pour tous les concepts récupérés dans le jdc.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   xc3xa9tude jointe
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 011058 DU 2007-07-09 07:22:37
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TITRE
   NEW8.5.1, les cas tests utilisant MUMPS s'arrete en ERREUR_<F>
FONCTIONNALITE
   Plantage de tous les tests MUMPS en NEW8 sur Calibre : les sources fortran 90 n'avaient
   été mis à jour.
   Après mis à jour des 3 sources de bibf90/mumps, les 25 tests utilisant MUMPS et durant
   moins de 300 s sont OK.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   25 tests mumps (<300s)
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR pellet       PELLET Jacques         DATE 31/07/2007 - 16:27:25

--------------------------------------------------------------------------------
RESTITUTION FICHE 010333 DU 2006-11-30 18:04:48
TYPE aide utilisation concernant Code_Aster (VERSION 2.x)
TITRE
   TRANSLATE_EVOL : Faciliter les calculs thermo-mxc3xa9caniques avec chargement thermique complexe
FONCTIONNALITE
   Problème :
   ----------
   Cette fiche émise à l'origine par J.F. Rit a été complétée par J.L. Fléjou.
                                                                                            
                           
   Je reprends ici le besoin exprimée par Jean Luc :
                                                                                            
                           
   J'ai un chargement thermique composé de plusieurs cycles différents :
   Charge1 [0,dt1] à faire 1 fois (dt1)
   Charge2 [0,dt2] à faire n fois (dt2)
   Charge3 [0,dt3] à faire p fois (dt3)
   Charge4 [0,dt4] à faire 1 fois (dt4)
   Charge5 [0,dt5] à faire infini fois (dt5)
                                                                                            
                           
   Imaginons que les chargements thermiques Charge1, ..., Charge5 aient été calculés par 5
   appels à THER_LINEAIRE, on voudrait éviter de construire un "énorme" transitoire thermique
   servant de chargement thermique pour le calcul mécanique.
                                                                                            
                           
                                                                                            
                           
                                                                                            
                           
   Solution:
   ---------
   La solution proposée tient en 2 évolutions :
   1) Une évolution de CREA_RESU permettant de mettre bout à bout (en les translatant) les 5
   evol_ther Chargei
   2) Une évolution de AFFE_MATERIAU/AFFE_VARC pour éviter de répéter inutilement les cycles
   de chargement :
      On distingue 2 "temps" :
       - INST_EV   : le temps de l'evol_xxx affecté comme variable de commande
       - INST_CALC : le temps du calcul mécanique
       La correspondance entre ces 2 temps est assurée par une fonction fournie par
   l'utilisateur (FONC_INST=finst).
       INST_EV=finst(INST_CALC)
       Si la fonction n'est pas fournie, les 2 temps sont considérés identiques.
                                                                                            
                           
                                                                                            
                           
   Si l'on reprend le calcul imaginé par Jean Luc, on fera :
   --------------------------------------------------------
                                                                                            
                           
   Charge1= THER_LINEAIRE(...)
   ...
   Charge5= THER_LINEAIRE(...)
                                                                                            
                           
   # concaténation de Charge1, ..., Charge5 (on les met bout à bout):
   TEMPE=CREA_RESU(OPERATION='ASSE', TYPE_RESU='EVOL_THER',
         ASSE=(
           _F(RESULTAT=Charge1, TRANSLATION=0.),
           _F(RESULTAT=Charge2, TRANSLATION=dt1),
           _F(RESULTAT=Charge3, TRANSLATION=dt1+dt2),
           _F(RESULTAT=Charge4, TRANSLATION=dt1+dt2+dt3),
           _F(RESULTAT=Charge5, TRANSLATION=dt1+dt2+dt3+dt4),
         ))
                                                                                            
                           
   # fabrication de la fonction de correspondance des 2 temps (finst)
                                                                                            
                           
   dt1=... ; dt5= ...
   n= ... ; p= ...;
                                                                                            
                           
   def transitoire(inst_calc) :
       T0=0. ; T1=T0+1*dt1 ; T2=T1+n*dt2 ; T3=T2+p*dt3 ; T4=T3+1*dt4
       assert inst_calc > T0
                                                                                            
                           
       if T0 <= inst_calc and inst_calc <= T1 :
           inst_ev =  (inst_calc -T0) % dt1  + 0.
       if T1 <= inst_calc and inst_calc <= T2 :
           inst_ev =  (inst_calc -T1) % dt2  + dt1
       if T2 <= inst_calc and inst_calc <= T3 :
           inst_ev =  (inst_calc -T2) % dt3  + dt1+dt2
       if T3 <= inst_calc and inst_calc <= T4 :
           inst_ev =  (inst_calc -T3) % dt4  + dt1+dt2+dt3
       if T5 <= inst_calc   :
           inst_ev =  (inst_calc -T4) % dt5  + dt1+dt2+dt3+dt4
       return inst_ev
                                                                                            
                           
   finst = FORMULE(NOM_PARA='INST',VALE='transitoire(INST)')
                                                                                            
                           
   # calcul mécanique :
   CHMATM=AFFE_MATERIAU(  MAILLAGE=MAIL,  AFFE=_F(  TOUT = 'OUI', MATER = MATERI),
                          AFFE_VARC=_F(  TOUT = 'OUI', NOM_VARC='TEMP', EVOL=TEMPE,
   FONC_INST=finst, ),)
                                                                                            
                           
   U=MECA_STATIQUE( MODELE=MO,  CHAM_MATER=CHMATM, ...)
                                                                                            
                           
                                                                                            
                           
                                                                                            
                           
   Validation :
   -------------
   On ajoute un nouveau test (zzzz223a) qui utilise ces 2 évolutions.
                                                                                            
                           
   #  On fabrique 2 évolutions thermiques homogènes en espace :
   #    ch1 : 1 montée   en température de 10 degré à 17 degrés [0., 0.7 s]
   #    ch2 : 1 descente en température de 17 degré à 14 degrés [0., 0.3 s]
   #
   #  Le cycle [ch1+ch2] est décalé pour former l'intervalle [1.5, 2.5].
   #  Puis on répète périodiquement le cycle [ch1+ch2] et on fait le calcul mécanique sur
   l'intervalle [0.5, 4.5]
   #
   #  Le problème mécanique est très simple : il s'agit d'une dilatation libre (alpha=1) d'un
   petit carré (1x1).
   #  Le déplacement du coin du carré est alors identique à la température imposée.
   #  On peut alors vérifier que la courbe de déplacement est bien une suite de cycles de
   montée-descente
   #  entre les températures 10 et 17.
   #
   #  On teste :
   #    U(t=1.0) = U(t=2.0) = U(t=4.0) = 15.
   #    U(t=1.3) = U(t=2.3) = U(t=4.3) = 16.
   #
   # Ce test dure 2s sur clpaster.
   #----------------------------------------------------------------------------------------------------------------
                                                                                            
                           
                                                                                            
                           
                                                                                            
                           
                                                                                            
                           
    Impact_documentaire :
    ----------------------
    * U4.44.12  (CREA_RESU) :
       Ajout OPERATION='ASSE'
    * U4.43.03  (AFFE_MATERIAU) :
       Ajout du mot clé FONC_INST
    * D4.06.22  (sd_cham_mater) :
       On stocke dans CART2 une 7eme CMP : finst contenant le nom de la fonction de
   transformation du temps.
                                                                                            
                           
                                                                                            
                           
    A corriger en NEW8 :
    --------------------
    A l'occasion de cette évolution, j'ai remarqué quelques bugs concernant les variables de
   commande en NEW8.
    Ces bugs n'entrainent pas de résultats faux, mais je propose néanmoins de les corriger.
                                                                                            
                           
    op0006 : NOCART : NCMP : 4 -> 6 (pour PROLGA et PROLDR)
    nmvcd2 : exiref : JEEXIN carte.2 -> carte.1 (avis L. Salmona ?)
    vrcin2 : NBCHS  : N1/4 -> N1/7
             + déplacement hors de la boucle du calcul de NBCHS et JLISSD (pour améliorer
   perfs CPU).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.44.12 U4.43.03  D4.06.22
VALIDATION
   zzzz223a
NB_JOURS_TRAV  : 2.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 31/07/2007 - 16:27:25

--------------------------------------------------------------------------------
RESTITUTION FICHE 011081 DU 2007-07-13 07:43:12
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TITRE
   IMPR_TABLE d'un inter-spectre
FONCTIONNALITE
   Problème lors de l'impression d'un inter-spectre qui est une table
   contenant des noms de fonctions complexes.
   On utilise IMPR_FONCTION='OUI' pour imprimer la table + les fonctions dont
   les noms sont dans la table.
   
   Fiche émise en version 7 : La fonction est typée fonction au lieu de fonction_c.
   On mélange donc abscisses et partie réelle, partie imaginaire.
   La version 7 n'est plus maintenue, il n'y aura pas de correction.
   Solution de contournement :
   Faire un RECU_FONCTION avec TYPE_RESU='FONCTION_C'.
   
   
   Correction en version 8 et 9 :
   Il y avait une erreur dans la recherche des noms de fonctions dans la table
   à imprimer. La table réduite aux colonnes FONCTION et FONCTION_C était vide
   (car on imposait implicitement que les 2 existent en même temps).
   
   Différence IMPR_FONCTION / IMPR_TABLE :
   Quand on imprime une fonction complexe avec IMPR_FONCTION / FORMAT='TABLEAU,
   les noms de colonnes sont (par exemple) : FREQ, DSP_0_R, DSP_0_I
   (0 pour courbe n°0)
   
   Avec IMPR_TABLE, IMPR_FONCTION='OUI', on avait : FREQ, DSP, IMAG
   Je change en (je n'ai pas de numéro puisqu'il n'y en a qu'une) : DSP_R, DSP_I.
   
   
   DEFI_FONCTION, INFO=2 :
   Ajout d'info sur les valeurs qui posent problème lors de la vérification de
   la monotonie des abscisses.
   Par exemple :
   DECROISSANT   I=  5463   VALEUR(I-1) : 8.982298989E6   VALEUR(I)   : 8.000000000E6
   
   ce qui permet de mieux comprendre l'erreur <F> qui suit :
   Abscisses non strictement croissantes.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   xc3xa9tude jointe
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR angles       ANGLES Jean            DATE 31/07/2007 - 16:27:26

--------------------------------------------------------------------------------
RESTITUTION FICHE 010827 DU 2007-05-03 11:16:21
TYPE anomalie concernant Code_Aster (VERSION 8.5)
TITRE
   Robustesse CALC_FATIGUE
FONCTIONNALITE
   Suite à l'EDA, j'ai modifié l'histor précédent.
   -----------------------------------------------
   
   Le cas proposé sur le forum a mis en évidence plusieurs défauts de "blindage" de la
   commande CALC_FATIGUE.
   
   1/ Le calcul est un calcul 2D or les critères de fatigue ne sont utilisable qu'en 3D.
      Le calcul s'est arrêté (c'est plutôt bien), mais pas sur une erreur liée  à la
      dimension de la modélisation, (c'est moin bien).
   
   2/ Effectivement, comme l'a remarqué Mathieu il y avait également un problème
      concernant le nom du maillage et la l'absence de GROUP_MA ou GROUP_NOEUD ou MAILLE
      NOEUD.
   
   
   Pour corriger le premier problème, j'ai ajouté trois messages dans
   bibpyt/Messages/fatigue1.py :
   
   1: _("""
    Aucun élément du modèle ne sait calculer l'option
    de fatigue multiaxiale, ('PFACY_R').
    Il se peut que la modélisation affectée au groupe de mailles
    sur lequel vous faites un calcul de fatigue ne soit pas "3D".
   
    Le critère de fatigue que vous utilisez n'est utilisable qu'en 3D.
   
   """),
   
   2: _("""
    La modélisation affectée au groupe de mailles sur lequel vous
    faites un calcul de fatigue n'est problament pas "3D".
    La composante %(i1)d du tenseur des contraintes n'existe pas.
   
    Le critère de fatigue que vous utilisez n'est utilisable qu'en 3D.
   
   """),
   
   3: _("""
    La modélisation affectée au groupe de mailles sur lequel vous
    faites un calcul de fatigue n'est problament pas "3D".
    La composante %(i1)d du tenseur des déformations n'existe pas.
   
    Le critère de fatigue que vous utilisez n'est utilisable qu'en 3D.
   
   """),
   
   Les messages 1, 2 et 3 sont appelés dans les routines paqmai.f et paqnoe.f.
   
   Pour corriger le second problème j'ai modifié le catalogue python de la commande
   CALC_FATIGUE (calc_fatigue.py) de façon à rendre obligatoire :
     *  le mot clef MAILLAGE dans tous les cas ;
     *  UN_PARMI('GROUP_NO','NOEUD','GROUP_MA','MAILLE').
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 8.0.23
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 9.0.0
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.83.02
VALIDATION
   SSLV135a SSLV135b SSLV135c SSLV135d SSLV135e SSLV135f plus le cas de calcul donnxc3xa9 par l'xc3xa9metteur de la fiche.
NB_JOURS_TRAV  : 3.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR pellet       PELLET Jacques         DATE 31/07/2007 - 16:27:26

--------------------------------------------------------------------------------
RESTITUTION FICHE 010881 DU 2007-05-21 17:13:21
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TMA : CS
TITRE
   AFFE_MATERIAU/AFFE_VARC/SECH mailles pas toutes affectxc3xa9es
FONCTIONNALITE
   Problème :
   ----------
   Si dans un calcul mécanique nécessitant du séchage comme variable de commande, on
   n'affecte pas le séchage sur TOUTES les mailles du modèle (commande
   AFFE_MATERIAU/AFFE_VARC), on est arrêtés brutalement dans la routines vrcins.f "Condition
   non respectée".
   
   Les fichiers qui le mettent en évidence ont été transmis par l'assistance Aster à
   Christophe qui me les a transmis.
   
   Solution :
   ----------
   
   En NEW9 : 
   ---------
   Lors de la création des variables de commandes "nouvelles générations", le cas d'une
   affectation partielle n'avait pas été traité correctemen.
   On corrige le fortran pour permettre cette affectation partielle. A cette occasion, on
   corrige quelques bugs présents dans les routines :
   
   cescel : permettre vraiment une affectation partielle (et mise à
   NaN des mailles non affectés).
   
   rcvalb : suppression d'un bout de fortran inutile
   
   rcvarc : un bug se produisait lorsque la température ainsi qu'une autre variable de
   commande était présente. Ce bug n'apparaissait que dans le cas d'une affectation partielle
   de variables de commande.
   
   En NEW8 :
   --------
   on reporte les bugs découverts ci-dessus et on harmonise les différentes routines cescel,
   rcvalb et rcvarc qui n'ont pas de raison d'être différente de la 8 à la 9, (hormis qu'on
   interdit d'utiliser la température comme variable de commande)
   
   Validation :
   ------------
   Cas test personnel ou on affecte la moitié des mailles
   avec le sechage (ou l'hydratation) et on s'assure que le test ne s'arrete plus en erreur
   fatale (en v8 et en v9)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   test perso
--------------------------------------------------------------------------------
RESTITUTION FICHE 011007 DU 2007-06-21 15:34:55
TYPE anomalie concernant Code_Aster (VERSION 2.x)
TMA : CS
TITRE
   diffxc3xa9rences entre AFFE_CHAR_MECA et AFFE_CHAR_CINE
FONCTIONNALITE
   Il y avait effectivement un bug dans la routine ascavc.f qui s'occupe de construire le
   second membre dû aux charges cinématiques.
   
   Cette routine crée un CHAM_NO des ddls contraints avec en plus un objet .DLCI qui décrit
   les ddls réellement contraints. Il s'agit d'un vecteur d'entiers contenant des 1 pour les
   ddls contraints et 0 pour les autres. Cet objet (parfois mal calculé) est utilisé dans la
   (seule) routine nmcvci.f.
   
   
   Résultat faux:
   ==============
   
   Les résultats étaient faux lorsque les conditions suivantes étaient réunis :
   - utilisation de plusieurs charges cinématiques dans  STAT_NON_LINE (ou DYNA_NON_LINE)
   - valeurs imposées non nulles.
   - noeuds/ddls bloqués différents
   
   Exemple :
   
   CHCI1 = AFFE_CHAR_CINE( ... NOEUD='A', DX=3.)
   CHCI2 = AFFE_CHAR_CINE( ... NOEUD='B', DY=7.)
   U=STAT_NON_LINE(EXCIT=(_F(CHARGE=CHCI1),_F(CHARGE=CHCI2),)...
   
   => résultats faux : DY(B)=0. !
   
   A faire en v8.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 8.0.0
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 9.0.0
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   ssnv151a + xc3xa9tude fournie
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST MODIF sslv135a                      salmona L.SALMONA         1290      5      1
 CASTEST MODIF sslv135b                      salmona L.SALMONA         1270      5      1
 CASTEST MODIF sslv135c                      salmona L.SALMONA          788      5      1
 CASTEST MODIF sslv135d                      salmona L.SALMONA          774      5      1
 CASTEST MODIF sslv135e                      salmona L.SALMONA          841      3      1
 CASTEST MODIF sslv135f                      salmona L.SALMONA          545      5      1
 CASTEST MODIF ssnv182b                      salmona L.SALMONA          272      1      1
CATALOPY MODIF commande/calc_fatigue         salmona L.SALMONA           85      3      4
CATALOPY MODIF entete/accas                  salmona L.SALMONA         1158      3      2
 FORTRAN MODIF algorith/ascavc               salmona L.SALMONA          156     17     10
 FORTRAN MODIF algorith/nmvcd2               salmona L.SALMONA           76      2      2
 FORTRAN MODIF calculel/cescel               salmona L.SALMONA          539     57     39
 FORTRAN MODIF calculel/rcvarc               salmona L.SALMONA          271     79     14
 FORTRAN MODIF calculel/vrcin2               salmona L.SALMONA          181      7      5
 FORTRAN MODIF calculel/vrcins               salmona L.SALMONA          167     19      5
 FORTRAN MODIF calculel/vrcref               salmona L.SALMONA          182     24      8
 FORTRAN MODIF modelisa/op0006               salmona L.SALMONA          283      2      2
 FORTRAN MODIF modelisa/rcvalb               salmona L.SALMONA           81     22     18
 FORTRAN MODIF prepost/paqmai                salmona L.SALMONA          611     16      1
 FORTRAN MODIF prepost/paqnoe                salmona L.SALMONA          436      7      1
 FORTRAN MODIF supervis/affich               salmona L.SALMONA           37      8      2
 FORTRAN MODIF utilitai/iredm1               salmona L.SALMONA          456      7      1
  PYTHON AJOUT Messages/fatigue1             salmona L.SALMONA           55     55      0
  PYTHON MODIF Cata/ops                      salmona L.SALMONA          454      3      1
  PYTHON MODIF Macro/impr_table_ops          salmona L.SALMONA          238      2      1
  PYTHON MODIF Messages/calculel5            salmona L.SALMONA          248     10      1
  PYTHON MODIF Stanley/stanley               salmona L.SALMONA         3173     25     25


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :    1          55        55               +55
 MODIF :   26       14612       342     149      +193
 SUPPR :    0           0                 0        +0
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :   27       14667       397     149      +248 
