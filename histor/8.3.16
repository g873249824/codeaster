

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR alexei       MIKCHEVITCH A.         DATE 03/10/2006 - 16:11:03

--------------------------------------------------------------------------------
RESTITUTION FICHE 009917 DU 2006-07-13 07:08:16
TYPE anomalie concernant Code_Aster (VERSION 8.3)
TITRE
   Pb sur pre_ideas et creation des groupes de mailles et de noeud par couleur
FONCTIONNALITE
   Suite a un message sur le forum, il y avait un bug sur la
   creation de groupe de noeud et de maille par couleur qui
   sont restees sur l'ancien format NO et MA lie a IDEAS.
   
   La correction a ete faite dans slecol.f et snecol.f en
   modifiant le prefixe et la longeur de la chaine ainsi que
   dans la partie de declaration des variables de type
   CHARACTER.
   
   Corrections apportees:
   
   - dans la sub-routine SLECOL (slecol.f) :
   
   1. CHARACTER*1 PRFMAI au lieu de CHARACTER*2 PRFMAI
   2. PRFMAI = 'M' au lieu de PRFMAI = 'MA'
   3. CALL CODNOP(CHMAIL,PRFMAI,1,1) au lieu de
   CALL CODNOP(CHMAIL,PRFMAI,1,2)
   4. CALL CODENT(INUM,'G',CHMAIL(2:8)) au lieu de
   CALL CODENT(INUM,'G',CHMAIL(3:8))
   
   
   
   - dans la sub-routine SNECOL (snecol.f) :
   
   1. CHARACTER*1 PRFNOE au lieu de CHARACTER*2 PRFNOE
   2. PRFNOE='N' au lieu de PRFNOE='NO'
   3. CALL CODNOP(CHNODE,PRFNOE,1,1) au lieu de
   CALL CODNOP(CHNODE,PRFNOE,1,2)
   4. CALL CODENT(INUM,'G',CHNODE(2:8)) au lieu de
   CALL CODENT(INUM,'G',CHNODE(3:8))
   
   
   Les tests de lecture/criture daun maillage daIdeas
   Version 11 ont ete effectues pour valider les
   modifications: on verifie/compare les groupes de
   mailles/n≈ìuds crees directement dans Ideas (creation par
   couleur) avec ceux generes par Aster lors de la lecture
   du fichier de maillage par PRE_IDEAS.
   
   Les tests ont ete faits avec les versions STA8 et NEW8
   daAster.
   
   Alexei Mikchevitch
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 8.0
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U7.01.01
VALIDATION
   Tests Ideas V11 de lecture/ecriture
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR galenne      GALENNE E.             DATE 03/10/2006 - 12:36:18

--------------------------------------------------------------------------------
RESTITUTION FICHE 009730 DU 2006-05-03 11:55:11
TYPE evolution concernant Code_Aster (VERSION )
TMA : CS
TITRE
   POST_RCCM
FONCTIONNALITE
   cette demande correspond a des parametres nouveaux a calculer et/ou a stocker dans la
   table resultat,
   pour l'option FATIGUE de la methode UNITAIRE.
   Il faut stocker dans la table produite par POST_RCCM
   - les grandeurs calculees de chaque combinaison avec le seisme
   - les grandeurs calculees de chaque combinaison sans le seisme
   - les maximum des grandeurs calculees
   ce qui correspond a toutes les valeurs imprimees lors du calcul dans le fichier message.
   
   Toutes les grandeurs sont calculees et stockees dans une seule table.
   
   TABLES RESULTATS POUR L'OPTION FATIGUE :
   ========================================
   pour TYPE_RESU = 'VALE_MAX', les parametres de la table sont :
   LIEU   PM_MAX   PB_MAX   PMPB_MAX   SM   SN/3SM   SN_MAX   SN*_MAX   SP_MAX   KE_MAX
   SALT_MAX   FACT_USAGE_CUMU
   
   pour TYPE_RESU = 'DETAILS', les parametres de la table sont :
   pour les maxima
   LIEU   PM_MAX   PB_MAX   PMPB_MAX   SM   SN/3SM   SN_MAX   SN*_MAX   SP_MAX   KE_MAX
   SALT_MAX   FACT_USAGE_CUMU
   puis pour les grandeurs calculees pour chaque situation avec et sans SEISME
   NUME_GROUPE   LIEU   NUME_SITU   PM   PB   PMPB   SN   SN*   SP   KE_MECA   KE_THER
   SALT   FACT_USAGE
   puis pour les grandeurs calculees pour chaque combinaison avec et sans SEISME
   NUME_GROUPE   LIEU   NUME_SITU_I   NUME_SITU_J   SN   SP_ETAT_A_A   SALT_ETAT_A_A
   SP_ETAT_B_A   SALT_ETAT_B_A   SP_ETAT_A_B   SALT_ETAT_A_B   SP_ETAT_B_B   SALT_ETAT_B_B
   puis les resultats du calcul facteur d'usage :
   NUME_GROUPE   LIEU   NUME_SITU_K   NUME_SITU_L   FACT_USAGE   %_FACT_USAGE
   puis les resultats du calcul du rochet thermique :
   LIEU   SY   SP_THER   SIGM_M_PRES   VALE_MAXI_LINE   VALE_MAXI_PARAB
   avec
   SY              : limite conventionnelle d'elasticite
   SP_THER         : l'amplitude de variation de la contrainte d'origine thermique
   SIGM_M_PRES     : maximum de la contrainte de membrane generale due a la pression
   VALE_MAXI_LINE  : valeur maximale admissible de l'amplitude de variation de la contrainte
   d'origine thermique dans le cas ou la variation de temperature est
   lineaire a travers la paroi
   VALE_MAXI_PARAB : valeur maximale admissible de l'amplitude de variation de la contrainte
   d'origine thermique dans le cas ou la variation de temperature est
   parabolique a travers la paroi
   
   
   TABLES RESULTATS POUR LES OPTIONS PMPB, SN SN* :
   ================================================
   pour TYPE_RESU = 'VALE_MAX', les parametres de la table sont :
   LIEU   PM_MAX   PB_MAX   PMPB_MAX   SN_MAX   SN*_MAX
   
   pour TYPE_RESU = 'DETAILS', les parametres de la table sont :
   pour les maxima
   LIEU   PM_MAX   PB_MAX   PMPB_MAX   SN_MAX   SN*_MAX
   puis pour les grandeurs calculees pour chaque situation avec et sans SEISME
   NUME_GROUPE   LIEU   NUME_SITU   PM   PB   PMPB   SN   SN*
   
   Exemple d'utilisation de IMPR_TABLE avec les filtres :
   #Impression des maxima
   IMPR_TABLE(TABLE=TRCCM[k],
   TITRE = 'impression des maxima',
   NOM_PARA = ('LIEU', 'PM_MAX', 'PB_MAX', 'PMPB_MAX', 'SM' ,
   'SN/3SM' , 'SN_MAX' , 'SN*_MAX' , 'SP_MAX',
   'KE_MAX', 'SALT_MAX', 'FACT_USAGE_CUMU' ), );
   
   #Impression des grandeurs avec prise en compte du seisme
   IMPR_TABLE(TABLE=TRCCM[k],
   TITRE = 'impression des grandeurs avec prise en compte du seisme',
   FILTRE= _F( NOM_PARA = 'SEISME',
   VALE_K  = 'AVEC'),
   NOM_PARA = ('NUME_GROUPE','LIEU', 'NUME_SITU', 'PM' , 'PB' , 'PMPB',
   'SN', 'SN*', 'SP', 'KE_MECA', 'KE_THER', 'SALT', 'FACT_USAGE'),
   );
   
   #Impression des grandeurs sans prise en compte du seisme
   IMPR_TABLE(TABLE=TRCCM[k],
   TITRE = 'impression des grandeurs sans prise en compte du seisme',
   FILTRE= _F( NOM_PARA = 'SEISME',
   VALE_K  = 'SANS'),
   NOM_PARA = ('NUME_GROUPE','LIEU', 'NUME_SITU', 'PM' , 'PB' , 'PMPB',
   'SN', 'SN*', 'SP', 'KE_MECA', 'KE_THER', 'SALT', 'FACT_USAGE'),
   );
   
   #Impression des SN et SP pour chaque combinaison sans prise en compte du seisme
   IMPR_TABLE(TABLE=TRCCM[k],
   TITRE = 'impression des SN et SP pour chaque combinaison sans prise en
   compte du seisme',
   FILTRE= _F( NOM_PARA = 'SEISME',
   VALE_K  = 'SANS'),
   NOM_PARA = ('NUME_GROUPE', 'LIEU', 'NUME_SITU_I', 'NUME_SITU_J', 'SN' ,
   'SP_ETAT_A_A' , 'SALT_ETAT_A_A' , 'SP_ETAT_B_A' ,
   'SALT_ETAT_B_A' ,
   'SP_ETAT_A_B' , 'SALT_ETAT_A_B' , 'SP_ETAT_B_B' ,
   'SALT_ETAT_B_B'),  );
   
   #Impression des SN et SP pour chaque combinaison avec prise en compte du seisme
   IMPR_TABLE(TABLE=TRCCM[k],
   TITRE = 'impression des SN et SP pour chaque combinaison avec prise en
   compte du seisme',
   FILTRE= _F( NOM_PARA = 'SEISME',
   VALE_K  = 'AVEC'),
   NOM_PARA = ('NUME_GROUPE', 'LIEU', 'NUME_SITU_I', 'NUME_SITU_J', 'SN' ,
   'SP_ETAT_A_A' , 'SALT_ETAT_A_A' , 'SP_ETAT_B_A' ,
   'SALT_ETAT_B_A' ,
   'SP_ETAT_A_B' , 'SALT_ETAT_A_B' , 'SP_ETAT_B_B' ,
   'SALT_ETAT_B_B'),  );
   
   #Impression  du facteur d usage
   IMPR_TABLE(TABLE=TRCCM[k],
   TITRE = 'impression du facteur d usage',
   NOM_PARA = ( 'NUME_GROUPE', 'LIEU', 'NUME_SITU_K', 'NUME_SITU_L',
   'FACT_USAGE' , '%_FACT_USAGE' ),  );
   
   #Impression du rochet thermique
   IMPR_TABLE(TABLE=TRCCM[k],
   TITRE = 'impression du rochet thermique',
   NOM_PARA = ( 'LIEU', 'SY', 'SP_THER', 'SIGM_M_PRES',
   'VALE_MAXI_LINE', 'VALE_MAXI_PARAB' ), );
   
   
   Apres ce developpement, 1 seul cas test parmi les 18 validant POST_RCCM est NOOK.
   1 NOOK sur la grandeur SN_MAX pour le rccm07a.com1
   SN_MAX = 2.16529E+02 au lieu de 2.04761E+02
   La reference est de non regression, et apres verification le SN_MAX est bien de
   2.16529E+02.
   Ce max est obtenu lors de la combinaison des situations.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   liste de cas tests validant POST_RCCM
--------------------------------------------------------------------------------
RESTITUTION FICHE 009731 DU 2006-05-03 11:58:20
TYPE evolution concernant Code_Aster (VERSION )
TMA : CS
TITRE
   POST_RCCM : rochet thermique
FONCTIONNALITE
   Dans l'analyse codifiee de l'amplitude des chargements, le rochet thermique est un
   critere qui est a verifier si l'amplitude de SN depasse 3SM.
   La forme du critere du rochet thermique programmee dans Code_Aster est precise dans le
   chapitre B 3234.8 du RCC-M.
   Le calcul du rochet thermique a ete programme pour le TYPE_RESU_MECA 'UNITAIRE' et
   'EVOLUTION'.
   
   La limite conventionnelle d'elasticite pour la temperature maximale atteinte au cours
   du
   cycle est lue dans les donnees :
   - soit SY_02 dans le materiau RCCM
   - soit SY_MAX, nouveau mot cle simple dans la commande POST_RCCM
   
   ** pour l'option EVOLUTION, le critere du rochet thermique est calcule si :
   - presence du mot cle TABL_RESU_PRES et TABL_RESU_THER sous le mot cle facteur
   TRANSITOIRE
   - la table des releves des contraintes dues au chargement de pression est fournie
   derriere le nouveau mot cle TABL_RESU_PRES sous le mot cle facteur TRANSITOIRE,
   
   ** pour l'option UNITAIRE, le critere du rochet thermique est calcule si
   - presence du mot cle facteur RESU_THER
   - la table des releves des contraintes dues au chargement de pression est fournie
   derriere le mot cle TABL_PRES sous le mot cle facteur RESU_MECA_UNIT, et les pressions
   sont lues derriere les mots cles PRES_A et PRES_B du mot cle facteur SITUATION
   
   R1- pour l'option UNITAIRE, si le SY_02 n'est pas present dans le materiau et si
   l'utilisateur n'a pas renseigne le mot cle SY_MAX, le code emet un message d'Alarme
   que le
   calcul du rochet ne peut pas etre realise.
   => Ajout du parametre SY_02 dans certains cas tests actuels pour eviter un message
   d'Alarme
   supplementaire.
   
   R2-  X = SIGM / SYMAX avec
   - SIGM  : maximum de la contrainte de membrane generale due a la pression
   - SYMAX : valeur maximale admissible de l'amplitude de variation de la contrainte
   d'origine thermique
   on doit avoir 0.  < X < 1.  pour la variation lineaire
   et  0.3 < X < 1.  pour la variation parabolique
   En dehors de ces bornes, le code emet un message d'Information et la grandeur n'est pas
   calculee :
   <I> <POST_RCCM> <RCMCRT> CRITERE DU ROCHET THERMIQUE
   CALCUL IMPOSSIBLE POUR UNE VARIATION DE TEMPERATURE PARABOLIQUE
   X = SIGM / SYMAX =   3.1675E-02
   SIGM =   4.2317E+00
   SYMAX =   1.3360E+02
   ON DOIT AVOIR 0.3 < X < 1.
   
   Les resultats du calcul du rochet thermique sont stockes dans la table resultat. Les
   parametres de la table ROCHET_THER sont :
   
   LIEU   SY   SP_THER   SIGM_M_PRES   VALE_MAXI_LINE   VALE_MAXI_PARAB
   SY              : limite conventionnelle d'elasticite
   SP_THER         : l'amplitude e variation de la contrainte d'origine thermique
   SIGM_M_PRES     : maximum de la contrainte de membrane generale due a la pression
   VALE_MAXI_LINE  : valeur maximale admissible de l'amplitude de variation de la
   
   contrainte d'origine thermique dans le cas ou la variation de
   temperature est lineaire a travers la paroi
   VALE_MAXI_PARAB : valeur maximale admissible de l'amplitude de variation de la
   contrainte d'origine thermique dans le cas ou la variation de
   temperature est parabolique a travers la paroi
   
   Les parametres peuvent etre affiches de maniere independante en filtrant le tableau
   (FILTRE=_F( NOM_PARA = 'TYPE', VALE_K  = 'ROCHET'),), cf. rccm04a.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U2.09.03, U4.83.11, V1.01.107,
VALIDATION
   rccm01a et b
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR cibhhpd      SALMONA L.             DATE 03/10/2006 - 14:29:13

--------------------------------------------------------------------------------
RESTITUTION FICHE 009916 DU 2006-07-11 13:19:25
TYPE express concernant Code_Aster (VERSION 2.x)
TITRE
   Restitution du cas test de la fiche 9351
FONCTIONNALITE
   Lors de la restitution de la fiche 9351, un cas test devait valider les developpements.
   Malheureusement, un nom definitif n'etait pas disponible. Il s'agit du cas test sdll136a
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V2.02.136
VALIDATION
   sdll136a
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR jmbhh01      PROIX J.M.             DATE 03/10/2006 - 14:29:15

--------------------------------------------------------------------------------
RESTITUTION FICHE 009717 DU 2006-04-27 15:25:52
TYPE anomalie concernant Code_Aster (VERSION 7.6)
TMA : CS
TITRE
   loi ELAS_ORTH et thermique avec MECA_STATIQUE
FONCTIONNALITE
   La prise en compte du repere d orthotropie est bien gere par MECA_STATIQUE. Les
   deplacements sont donc corrects. Par contre pour les post traitements ( SIEF_ELGA_DEPL par
   exemple), la prise en compte de la deformation d origine thermique est mal calcule. La
   routine qui s en charge, EPSTMC, recupere les donnees materiaux theoriquement dans le
   repere d orthotropie mais les considere dans le repere global.
   On ajoute donc dans la routine EPSTMC un changement de repere pour bien avoir les
   deformations thermiques dans le repere global.
   Remarque : On modifie aussi nmorth ( equivalent pour STAT_NON_LINE ) qui avait prevu ce
   changement de repere mais mal.
   
   Pour la validation, on ajoute au cas test sslv131a deux calcul, un via MECA_STATIQUE et un
   via STAT_NON_LINE avec un chargement de temperature. La solution est analytique.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 7.0.0
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 8.0.0
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V3.04.131
VALIDATION
   sslv131a
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR durand       DURAND C.              DATE 03/10/2006 - 13:01:50

--------------------------------------------------------------------------------
RESTITUTION FICHE 010084 DU 2006-10-02 07:37:06
TYPE express concernant Code_Aster (VERSION 2.x)
TITRE
   post_dyna_alea et defi_inte_spec en python
FONCTIONNALITE
   Reecriture en python de DEFI_INTE_SPEC :
   Isofonctionnel. A cette occasion, je blinde un vilain bug dans DEFI_FONCTION :
   l'interpolation LOG sur les ordonnees d'une fonction complexe etait licite. Or,
   derriere,
   ce n'est pas le log-complexe qui est programme ; en particulier, il nous jetait si la
   partie imaginaire est nulle.
   
   Reecriture en python de POST_DYNA_ALEA :
   Isofonctionnel pour la partie de calcul de moments. Je resorbe par contre les calculs de
   fonctions statistiques propres au seisme : VANMARCKE, RAYLEIGH, GAUSS, DEPASSEMENT. En
   effet, ces fonctions etaient attachees a la table produite mais, par construction de la
   structure de donnees, IMPOSSIBLES A RECUPERER ! Ce n'etait donc fatalement d'aucun
   usage a
   quiconque : on supprime et si ca repond a un besoin pour les calculs en seisme a AMA
   ou au
   SEPTEN, le projet OMERSI pourvoiera a la reprogrammation propre et maitrisee.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.53.22
VALIDATION
   tests utilisant ces commandes
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR jmbhh01      PROIX J.M.             DATE 03/10/2006 - 08:18:11

--------------------------------------------------------------------------------
RESTITUTION FICHE 010082 DU 2006-10-02 06:37:41
TYPE express concernant Code_Aster (VERSION 8.3)
TITRE
   tests COQUE_3D non lineaires NOOK sur machine Bull
FONCTIONNALITE
   Les tests
   hsns101c.comm
   hsnv121d.comm
   ssnp15d.comm
   ssnp15e.comm
   ssnv115d.comm
   ssnv115e.comm
   etaient NOOK sur Bull en nodebug. Ils etaient OK en debug.
   Ceci etait du a l'instruction suivante, dans VDXNLR (COQUE_3D-HPP), qui etait mal
   comprise
   par l'optimiseur du compilateur ifort (isolee par Jean-Pierre) :
   LGPG = MAX(ITAB(6),1)*ITAB(7)
   
   dans ssnp15d, ITAB(6)=12 (nombre de sous-points*nombre de variables internes, ITAB(7)=7
   (nombre de points de Gauss surfaciques). En ndebug on trouvait bien 84, mai en nodebug, on
   trouvait 42 !
   
   on remplace par :
   >       IF (ITAB(6).LE.1) THEN
   >          LGPG=ITAB(7)
   >       ELSE
   >          LGPG = ITAB(6)*ITAB(7)
   >       ENDIF
   tout ces tests passent. Par mesure de precaution, on fait la meme modif dans
   VDPNLR.f (COQUE_3D-GREEN_GR) et TE0239 (COQUE_1D)
   
   2 jours passes  3 (JPL, JP, JMP) pour une erreur de multiplication entiere !
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   SSNP15D
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR alexei       MIKCHEVITCH A.         DATE 03/10/2006 - 12:45:12

--------------------------------------------------------------------------------
RESTITUTION FICHE 009631 DU 2006-03-31 09:17:50
TYPE anomalie concernant Code_Aster (VERSION 7.6)
TMA : DeltaCad
TITRE
   LIRE_RESU (dataset55) : mauvaise estimation des termes generalises
FONCTIONNALITE
   Cette fiche a pour objectif (commande LIRE_RESU) de corriger les erreurs dans le calcul de
   l'amortissement generalise 'AMOR_GENE' et de la rigidite generalisee 'RIGI_GENE' effectue
   a partir de la masse generalisee lue dans le fichier universel.
   
   Les modifications apportees (routine stock) sont les suivantes:
   
   1/ Amortissement generalise:
   ZR(IAD) = 2*AMRGE*MASGEN*DEPI*IOUF (2 * facteur daamortissement * masse
   generalieee *
   pulsation)
   au lieu de      ZR(IAD) = 2*AMRGE*(2*DEPI*IOUF)
   
   2/ Rigidite generalisee :
   ZR(IAD) = MASGEN*(DEPI*IOUF)**2   (masse generalisee * pulsation au carre)
   au lieu de       ZR(IAD) = MASGEN*(2*DEPI*IOUF)**2
   
   3/ Ajout du calcul de OMEGA2
   
   D'autre part on en profite pour corriger dans la routine ECRTES le format d'ecriture
   (format UNV) de la frequence, masse  generalisee,... On remplace le format 3000
   FORMAT(6E12.5) par FORMAT(6(1PE13.5E3)).
   
   Routine modifiees: stock.f, erctes.f
   
   Verifications:
   - Cas-tests modifie : on ajoute dans le cas-test sdls112a plusieurs TEST_RESU pour
   verifier les  parametres 'FREQ', 'OMEGA2', 'MASS_GENE', 'AMOR_REDUIT', 'AMOR_GENE',
   'RIGI_GENE',
   - IDEAS : relecture du du fichier universel suite a la modification du format d'ecriture
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 7.0
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U7.02.01
VALIDATION
   Cas-test sdls112a modifie et relecture UNV
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR mjbhhpe      FLEJOU J.L.            DATE 03/10/2006 - 13:24:29

--------------------------------------------------------------------------------
RESTITUTION FICHE 010070 DU 2006-09-27 13:25:13
TYPE express concernant Code_Aster (VERSION 8.3)
TITRE
   Stat_non_line et Arret=NON
FONCTIONNALITE
   Lors de ma restit j'ai casse 10 cas tests :
   comp001a zzzz130a zzzz131a ssnp115c ssnv505h
   zzzz159a zzzz159b zzzz159c zzzz159d ssna110a
   
   
   comp001a : dans le catalogue de la commande SIMU_POINT_MAT, une subdivision est demandee.
   Je mets donc a jour le .capy. Je remplace egalement dans le .py les boucles du type :
   |   dCompIncr=COMP_INCR[0].cree_dict_valeurs(COMP_INCR[0].mc_liste)
   |   for i in dCompIncr.keys():
   |      if dCompIncr[i]==None : del dCompIncr[i]
   |   motscles['COMP_INCR']   =dCompIncr
   par
   |   motscles['COMP_INCR'] = COMP_INCR.List_F()
   
   
   ssnv505h : une subdivision est demandee. Je modifie le cas test en indiquant la methode
   de
   subdivision 'UNIFORME'.
   
   zzzz159a zzzz159b zzzz159c zzzz159d ssna110a : ces cas tests utilisent MACR_RECAL. Les
   modifications sont a faire dans les fichiers esclaves.
   
   
   zzzz130a, zzzz131a, ssnp115c : Il y a changement de comportement de STAT_NON_LINE avec
   ARRET=NON et subdivision. Ces cas passent au travers des verifications faite dans op0070
   et fait que le code s'arrete en levant une exception. Or dans ces cas on devrait
   continuer
   sans lever d'exception. Je corrige l'op0070.
   
   
   Fichiers modifies :
   -------------------
   op0070.f simu_point_mat.capy simu_point_mat_ops.py
   comp001a.comm ssnv505h.comm  zzzz159a.3 zzzz159b.3 zzzz159c.3 zzzz159d.3 ssna110a.3
   
   verifications par passage des 10 cas tests
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
   passage des 10 cas tests comp001a zzzz130a zzzz131a ssnp115c ssnv505h zzzz159a zzzz159b
zzzz159c zzzz159d ssna110a
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST AJOUT sdll136a                      cibhhpd L.SALMONA          651    651      0
 CASTEST MODIF comp001a                      mjbhhpe J.L.FLEJOU         280     10      4
 CASTEST MODIF hsns101c                      jmbhh01 J.M.PROIX          460      1      1
 CASTEST MODIF hsnv121d                      jmbhh01 J.M.PROIX          231      1      1
 CASTEST MODIF rccm01a                       cibhhlv L.VIVAN            200      3      2
 CASTEST MODIF rccm01b                       cibhhlv L.VIVAN            489    102     28
 CASTEST MODIF rccm04a                       cibhhlv L.VIVAN            432     84     13
 CASTEST MODIF rccm05a                       cibhhlv L.VIVAN           2037      6    136
 CASTEST MODIF rccm07a                       cibhhlv L.VIVAN            366     37     20
 CASTEST MODIF rccm08a                       cibhhlv L.VIVAN            158      7      9
 CASTEST MODIF sdld101a                       durand C.DURAND           492      7     23
 CASTEST MODIF sdls112a                     lebouvie F.LEBOUVIER        434     27      1
 CASTEST MODIF sdlx302a                       durand C.DURAND           390      1    232
 CASTEST MODIF sslv131a                      cibhhpd L.SALMONA          362    163     29
 CASTEST MODIF sslv200a                      cibhhpd L.SALMONA         1296     88     88
 CASTEST MODIF sslv200b                      cibhhpd L.SALMONA         1265     88     88
 CASTEST MODIF ssna110a                      mjbhhpe J.L.FLEJOU        2118      1      1
 CASTEST MODIF ssnp15d                       jmbhh01 J.M.PROIX          481      3      1
 CASTEST MODIF ssnp15e                       jmbhh01 J.M.PROIX          229      3      1
 CASTEST MODIF ssnv115d                      jmbhh01 J.M.PROIX          203      1      1
 CASTEST MODIF ssnv115e                      jmbhh01 J.M.PROIX          202      1      1
 CASTEST MODIF ssnv505h                      mjbhhpe J.L.FLEJOU         445      5      2
 CASTEST MODIF zzzz159a                      mjbhhpe J.L.FLEJOU         112      1      1
 CASTEST MODIF zzzz159b                      mjbhhpe J.L.FLEJOU         114      1      1
 CASTEST MODIF zzzz159c                      mjbhhpe J.L.FLEJOU         118      1      1
 CASTEST MODIF zzzz159d                      mjbhhpe J.L.FLEJOU         126      1      1
CATALOGU MODIF options/epme_elga_depl        cibhhpd L.SALMONA           55      4      1
CATALOGU MODIF options/epme_elno_depl        cibhhpd L.SALMONA           55      4      1
CATALOGU MODIF options/epmg_elga_depl        cibhhpd L.SALMONA           55      4      1
CATALOGU MODIF options/epmg_elno_depl        cibhhpd L.SALMONA           55      4      1
CATALOGU MODIF options/epsi_elga_depl        cibhhpd L.SALMONA           67      4      1
CATALOGU MODIF options/epsi_elno_depl        cibhhpd L.SALMONA           59      4      1
CATALOGU MODIF typelem/gener_me3d_3          cibhhpd L.SALMONA          668      7      3
CATALOGU MODIF typelem/gener_meax_2          cibhhpd L.SALMONA          586      7      1
CATALOGU MODIF typelem/gener_mecpl2          cibhhpd L.SALMONA          600      7      5
CATALOGU MODIF typelem/gener_medpl2          cibhhpd L.SALMONA          619      7      3
CATALOGU MODIF typelem/mecpqs4               cibhhpd L.SALMONA          518      6      5
CATALOGU MODIF typelem/mecptr3               cibhhpd L.SALMONA          552      7      5
CATALOGU MODIF typelem/medpqs4               cibhhpd L.SALMONA          532      7      3
CATALOGU MODIF typelem/medpqs8               cibhhpd L.SALMONA          534      7      1
CATALOPY MODIF commande/defi_inte_spec        durand C.DURAND            62      4      2
CATALOPY MODIF commande/post_dyna_alea        durand C.DURAND            43      4     32
CATALOPY MODIF commande/post_rccm            cibhhlv L.VIVAN            252      7      1
CATALOPY MODIF commande/simu_point_mat       mjbhhpe J.L.FLEJOU         113     38      4
 FORTRAN AJOUT postrele/rc32r0               cibhhlv L.VIVAN            168    168      0
 FORTRAN AJOUT postrele/rc32r8               cibhhlv L.VIVAN             99     99      0
 FORTRAN AJOUT postrele/rc32rt               cibhhlv L.VIVAN             67     67      0
 FORTRAN AJOUT postrele/rcmcrt               cibhhlv L.VIVAN             97     97      0
 FORTRAN MODIF algorith/caldis                durand C.DURAND           195      2      2
 FORTRAN MODIF algorith/nmorth               cibhhpd L.SALMONA          242     15      4
 FORTRAN MODIF algorith/op0070               mjbhhpe J.L.FLEJOU         963     39      8
 FORTRAN MODIF elements/epstmc               cibhhpd L.SALMONA          302     96     11
 FORTRAN MODIF elements/epsvmc               cibhhpd L.SALMONA          214      3      3
 FORTRAN MODIF elements/epthmc               cibhhpd L.SALMONA          129     31     15
 FORTRAN MODIF elements/ethdst               cibhhpd L.SALMONA          137      4      4
 FORTRAN MODIF elements/ortrep               cibhhpd L.SALMONA          159      2      1
 FORTRAN MODIF elements/sigtmc               cibhhpd L.SALMONA          148     15      7
 FORTRAN MODIF elements/te0025               cibhhpd L.SALMONA          185      6      2
 FORTRAN MODIF elements/te0239               jmbhh01 J.M.PROIX          470      7      2
 FORTRAN MODIF elements/vdpnlr               jmbhh01 J.M.PROIX         1301      7      2
 FORTRAN MODIF elements/vdxnlr               jmbhh01 J.M.PROIX          466      7      2
 FORTRAN MODIF postrele/op0165               cibhhlv L.VIVAN            144     17     14
 FORTRAN MODIF postrele/rc3200               cibhhlv L.VIVAN             82      6      5
 FORTRAN MODIF postrele/rc3201               cibhhlv L.VIVAN            681    198     93
 FORTRAN MODIF postrele/rc3203               cibhhlv L.VIVAN            335     38     13
 FORTRAN MODIF postrele/rc32ac               cibhhlv L.VIVAN            515    152     59
 FORTRAN MODIF postrele/rc32r1               cibhhlv L.VIVAN            269    155     42
 FORTRAN MODIF postrele/rc32rs               cibhhlv L.VIVAN             56     11     29
 FORTRAN MODIF postrele/rc32sa               cibhhlv L.VIVAN             81      5      3
 FORTRAN MODIF postrele/rcev22               cibhhlv L.VIVAN            371     67     11
 FORTRAN MODIF postrele/rcevo1               cibhhlv L.VIVAN             93     16     13
 FORTRAN MODIF postrele/rcevo2               cibhhlv L.VIVAN            419     77     11
 FORTRAN MODIF postrele/rcevod               cibhhlv L.VIVAN            532     68     14
 FORTRAN MODIF postrele/rcevol               cibhhlv L.VIVAN            203     21     10
 FORTRAN MODIF postrele/rcevom               cibhhlv L.VIVAN            646     72     13
 FORTRAN MODIF prepost/ecrtes               lebouvie F.LEBOUVIER        265      2      2
 FORTRAN MODIF prepost/stock                lebouvie F.LEBOUVIER        170     10      3
 FORTRAN MODIF stbtrias/slecol                alexei A.MIKCHEVITCH      118      5      5
 FORTRAN MODIF stbtrias/snecol                alexei A.MIKCHEVITCH      121      5      5
 FORTRAN MODIF utilitai/op0003                durand C.DURAND           260      8      4
 FORTRAN MODIF utilitai/rftabl                durand C.DURAND           111      4      2
 FORTRAN SUPPR algorith/kanai                 durand C.DURAND            29      0     29
 FORTRAN SUPPR algorith/op0115                durand C.DURAND           260      0    260
 FORTRAN SUPPR postrele/rc32r2               cibhhlv L.VIVAN             99      0     99
 FORTRAN SUPPR postrele/rc32r3               cibhhlv L.VIVAN             92      0     92
 FORTRAN SUPPR postrele/rc32r4               cibhhlv L.VIVAN             92      0     92
 FORTRAN SUPPR postrele/rc32r5               cibhhlv L.VIVAN             92      0     92
 FORTRAN SUPPR postrele/rc32r6               cibhhlv L.VIVAN             96      0     96
 FORTRAN SUPPR postrele/rc32r7               cibhhlv L.VIVAN            100      0    100
 FORTRAN SUPPR prepost/op0132                 durand C.DURAND           688      0    688
  PYTHON AJOUT Macro/defi_inte_spec_ops       durand C.DURAND           152    152      0
  PYTHON AJOUT Macro/post_dyna_alea_ops       durand C.DURAND           255    255      0
  PYTHON MODIF Macro/calc_table_ops           durand C.DURAND           162      2      2
  PYTHON MODIF Macro/simu_point_mat_ops      mjbhhpe J.L.FLEJOU         328      6     26
  PYTHON MODIF Messages/modelisa7            cibhhpd L.SALMONA          407      4      1
  PYTHON MODIF Messages/postrele             cibhhlv L.VIVAN            307     37     14


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :    7        1489      1489             +1489
 MODIF :   80       30052      1995    1214      +781
 SUPPR :    9        1548              1548     -1548
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :   96       33089      3484    2762      +722 
