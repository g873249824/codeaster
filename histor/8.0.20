

-----------------------------------------------------------------------
--- AUTEUR durand C.DURAND   DATE  le 12/05/2005 a 13:08:47

--------------------------------------------------------------------------
REALISATION EL 2005-097
   NB_JOURS_TRAV  : 14.0
   INTERET_UTILISATEUR : OUI
   TITRE : fonctions et nappes en python, CALC_FONCTION est une macro
   FONCTIONNALITE fonctions, CALC_FONCTION, INFO_FONCTION
   DETAILS

Tout d'abord, on éclate l'actuelle commande CALC_FONCTION en 2 commandes :
CALC_FONCTION (qui produit une nappe ou une fonction)
INFO_FONCTION (qui produit une table)

Sont déplacés dans INFO_FONCTION, les mots clé facteurs :
RMS,NOCI_SEISME,MAX,NORME,ECART_TYPE

Un peu à la façon de ce qui a été fait pour les tables, on introduit un
module autoporteur définissant des objets fonctions ou nappes. Ce module
est importable et utilisable en dehors d'ASTER :
from Utilitai.t_fonction import t_fonction, t_nappe, t_fonction_c

Ces objets présentent, dans leur contenu intrinsèque (attributs de __init__)
et leur comportement (méthodes d'évaluation), exactement les mêmes
caractéristiques que les fonctions ASTER. A savoir :

t_fonction et t_fonction_c (hérite de t_fonction) :
============================
### attributs :
vale_x : numarray des valeurs d'abscisses
vale_y : numarray des valeurs d'ordonnées
para   : dictionnaire pour INTERPOLATION, PROLONGEMENTs, NOM_PARA et NOM_RESU
### méthodes :
__call__    : pour évaluer f(x)
__add__     : pour faire f+g ou f+3, produit une nouvelle t_fonction
__mul__     : pour faire f*g ou f*3, produit une nouvelle t_fonction
__repr__    : pour imprimer sur 2 colonnes x et y
__getitem__ : pour faire la composition fog par f[g]
cut         : renvoie la meme fonction "coupée" entre 2 valeurs données
cat         : concaténation de fonctions
tabul       : renvoie la liste (x1,y1,x2,y2 ... )
extreme     : renvoie un dict des occurences de valeurs extrèmes min et max
trapeze     : renvoie la primitive par la méthode des trapezes
simpson     : idem simpson
derive      : renvoie la fonction dérivée
inverse     : renvoie f-1
abs         : renvoie la valeur absolue de la fonction
sup         : renvoie l'enveloppe sup de 2 fonctions données
inf         : renvoie l'enveloppe inf de 2 fonctions données
suppr_tend  : pour les corrections d'accélérogrammes
normel2     : norme L2 de la fonction
fft         : renvoie la t_fonction_c transformée FFT
evalfonc    : renvoie la fonction interpolée suivant une liste donnée

t_nappe :
========
### attributs :
vale_para : numarray des valeurs du paramètre
l_fonc    : liste d'objets t_fonction représentant les fonctions de la nappe
para   : dictionnaire pour INTERPOLATION, PROLONGEMENTs, NOM_PARA et NOM_RESU
### méthodes :
__call__    : pour évaluer f(x)
__add__     : pour faire f+g ou f+3, produit une nouvelle t_nappe
__mul__     : pour faire f*g ou f*3, produit une nouvelle t_nappe
__repr__    : pour imprimer
homo_support: rend homogène le support de discrétisation de 2 nappes
extreme     : renvoie un dict des occurences de valeurs extrèmes min et max

On ajoute dans accas.capy (comme méthode associée aux classes ASTER des
fonctions et nappes), une méthode de conversion pour obtenir le type python :
aa=DEFI_FONCTION(...)
bb=aa.convert() # : instance de la classe t_fonction, fonction-python

Ainsi, à titre d'exemple, dans calc_fonction_ops.py, élever une fonction
à une puissance s'écrit en trois lignes :

  if (PUISSANCE   != None):
     __ff=PUISSANCE['FONCTION'].convert()
     __ex=__ff
     for i in range(PUISSANCE['EXPOSANT']-1) : __ex=__ex*__ff


ATTENTION : je n'ai pas reprogrammé le lissage enveloppe (LISS_ENVELOPPE).
Ca aurait en effet été assez pénible et il se trouve que le LISS_ENVELOPPE
actuel n'est pas utilisé par la communauté des sismologues (T62+7N) car
ne répondant pas aux besoins réels. En particulier, il ne traite que les
fonctions quand on voudrait qu'il traite les nappes. Donc, temporairement,
on supprime LISS_ENVELOPPE en version 8 et on engage le chantier de
programmation d'un lissage sur base python avec une spécif EL2004-099
qui réponde aux attentes du 7N.

Concernant SPEC_OSCI :
En programmant l'algorithmie (un peu tordue) de spec_osci (routines fortran
foc2so et foc3so), on a constaté des dégradations de performances d'un facteur
40 sur les calc_fonction de sdns01a. La solution a été de faire la tâche en C.
Mathieu Courtois a donc créé un module aster_fonctions importable en python.
Le calcul est fait par spec_osci.c sans perte de perfs par rapport au fortran.
Le plus délicat a été de gérer le passage des array numeriques python vers
les tableaux C.

Complètement isofonctionnel à part le prolongement des fonctions primitives
ou dérivées : ça pourrait poser problème aux utilisateurs jusqu'à présent
peu scrupuleux.

re-programmation de CALC_FONCTION en python
en fortran : environ 10000 lignes
en python  : 1176 lignes

Problème des prolongements de fonctions intégrales et dérivées :
jusqu'à présent, on a affecté les mm caractéristiques de prolongement
aux primitives et dérivées qu'aux fonctions de départ. Or il ne serait
pas idiot de penser que le prolongement 'LINEAIRE' d'une fonction donnée
se transforme en prolongement 'CONSTANT' chez sa dérivée (et réciproquement)
Prudence étant mère de sureté, je mets systématiquement les prolongements
à EXCLU pour intégrale et dérivée ... charge à l'utilisateur d'affecter
sciement les prolongements dans CALC_FONCTION.
Ca a en particulier posé problème dans FORMA12C, où on évalue en prolongement
une fonction intégrale (vitesse déduite de accélération) en "héritant" des
prolongements de la fonction accélération. Pour m'en sortir, je précise donc
PROL_DROITE='CONSTANT' dans le calc_fonction en question.

Désormais, CALC_FONCTION, en tant que macro, finit toujours par invoquer
DEFI_FONCTION : on fait désormais toutes les vérifs (coercitives) de
cohérence de la fonction.
Par exemple, dans sslv200a, on récupère une fonction à ordonnées négatives
mais on lui affecte sans vergogne un interpol=LOG .. on est maintenant
arrêté dans le CALC_FONCTION qui suit. Avant, ni RECU_FONCTION (mais ça
reste le cas), ni CALC_FONCTION ne faisaient ce genre de vérifs.
D'ailleurs, modif interpol=LIN pour sslv200a et sslv200b.

Concernant NOCI_SEISME, plusieurs bug dans l'ancienne programmation fortran :
tous dus à une mauvaise gestion des interpolations dans le cas où on donne
INST_INIT, INST_FIN ou FREQ_INIT, FREQ_FIN pour l'option de calcul INTE_SPEC.
Ainsi, je change les valeurs de référence de INLBNS18 / INTE_SPEC et
INH1 / INTE_SPEC dans zzzz100d.


Encore un bug dans les usages de CALC_FONCTION propres à la dynamique :
le mot clé facteur NORME. Ce n'est testé que dans sdns01a et sdns01b avec, à
chaque fois, une nappe ne contenant qu'une fonction unique. De fait, ça plante
pour une nappe contenant plusieurs fonctions (ligne 88 de focnor.f). Pour la
programmation python, je choisis de produire une table à une seule colonne
('NORME') et contenant, empilés dans l'ordre où on a trouvé les fonctions,
les normes L2 associées.

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : OUI
      DOC_U : U1.03.02 Méthodes Python d'accès aux objets Aster
       EXPL_ : documenter t_fonction
      DOC_U : U4.32.04 Opérateur CALC_FONCTION
       EXPL_ : revoir la doc + créer celle de INFO_FONCTION
      DOC_D : D4.02.02 Structures de Données fonction
       EXPL_ : peut etre dire un mot
   VALIDATION
      Tous cas tests activant déjà CALC_FONCTION


-----------------------------------------------------------------------
--- AUTEUR mcourtoi M.COURTOIS   DATE  le 11/05/2005 a 08:39:01

CORRECTION AL 2005-029
   INTERET_UTILISATEUR : NON
   TITRE
      Utilisation de DEFI_FICHIER dans les macros
   FONCTIONNALITE

Constat :
=========
    - il y a des risques de conflits entre les fichiers créés dans
      les macros ou dans le fortran,
    - les macros n'ont pas les moyens de récupérer le nom associé à une
      unité logique, ne peuvent donc pas tenir compte du nom passé à
      DEFI_FICHIER.

   On ajoute donc un état dans la gestion des unités logiques ('RESERVE')
   en modifiant DEFI_FICHIER et la possibilité de récupérer le nom associé
   à une unité logique via INFO_EXEC_ASTER/ETAT_UNITE.

   Sur l'idée de Jean-Luc, on écrit une classe pour manipuler plus facilement
   les unités dans les macros :

class UniteAster
 |  Classe pour manipuler les fichiers en Python en accord avec les unités
 |  logiques utilisées en Fortran.
 |  De manière analogue au Fortran, les états possibles d'une unité sont :
 |     'F' : fermé, 'O' : ouvert, 'R' : réservé.
 |
 |  Méthodes :
 |     Nom      : Retourne le nom du fichier associé à une unité,
 |     Etat     : Retourne l'état d'une unité,
 |     Libre    : Retourne un numéro d'unité libre,
 |     EtatInit : Remet une, plusieurs ou toutes les unités dans leur état initial.
 |
 |  Méthode privée :
 |     _setinfo : pour remplir le dictionnaire des 'infos'
 |  Attribut privé :
 |     infos[numéro unité] = { 'nom' : x, 'etat' : x , 'etat_init' : x }
 |
 |  Methods defined here:
 |
 |  Etat(self, ul, **kargs)
 |      Retourne l'état de l'unité si 'etat' n'est pas fourni
 |      et/ou change son état :
 |         kargs['etat']  : nouvel état,
 |         kargs['TYPE']  : type du fichier à ouvrir ASCII/BINARY/LIBRE,
 |         kargs['ACCES'] : type d'accès NEW/APPEND/OLD.
 |
 |  EtatInit(self, ul=None)
 |      Remet l'unité 'ul' dans son état initial.
 |      Si 'ul' est omis, toutes les unités sont remises dans leur état initial.
 |
 |  Libre(self, nom=None)
 |      Réserve et retourne une unité libre en y associant, s'il est fourni,
 |      le fichier 'nom'.
 |
 |  Nom(self, ul)
 |      Retourne le nom du fichier associé à l'unité 'ul'.
 |
 |  __init__(self)
 |      Initialise le dictionnaire des unités.


Utilisation dans les macros IMPR_FONCTION et IMPR_TABLE :
=========================================================

   from Utilitai.UniteAster import UniteAster
   UL=UniteAster()
   nomfich=UL.Nom(UNITE)
   if UNITE==8:
      UL.Etat(UNITE, etat='F')
   ... les classes Graph et Table font les open/close ...
   UL.EtatInit()


   RESU_FAUX_VERSION_EXPLOITATION   :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT  :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   OUI
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : OUI
      DOC_U : U4.12.03
      EXPL_ : - nouvelle ACTION='RESERVER' (on ne fait pas d'open),
              - dire que depuis que les commandes utilisent directement UNITE
                cela n'a d'intérêt qu'en précisant FICHIER='...',
              - donner un exemple avec REPE_OUT,
              - dire que seul cette commande devrait modifier l'état des unités
                logiques et donc que les IMPR_xxxx, LIRE_yyyy doivent les
                laisser dans l'état où elles les ont trouvées.
   VALIDATION
      tous les tests qui utilisent IMPR_FONCTION/IMPR_TABLE testent UniteAster
      + impression dans REPE_OUT dans zzzz140a
   DETAILS
   NB_JOURS_TRAV  : 1
------------------------------------------------------------------------------
CORRECTION AL 2005-039
   INTERET_UTILISATEUR : NON
   TITRE
      DEFI_FICHIER / FICHIER et IMPR_FONCTION
   FONCTIONNALITE
      idem AL 2005-029

   RESU_FAUX_VERSION_EXPLOITATION   :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT  :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   OUI
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
   DETAILS
   NB_JOURS_TRAV  : 0.5
------------------------------------------------------------------------------
CORRECTION AL 2005-086
   INTERET_UTILISATEUR : NON
   TITRE
      Fichier MED et DEFI_FICHIER
   FONCTIONNALITE
      Les routines d'impression au format MED postulaient que le nom de
      fichier était 'fort.'+ul.
      On utilise maintenant ULISOG (qui lit NAMEFI(ul) le common), car c'est
      bien le nom de fichier que l'on passe ensuite à EFOUVR, routine med qui
      ouvre le fichier.

      Pour les ouvertures de fichiers :
       - Si on fait un open fortran (non nommé en général), utiliser ULOPEN.
       - Si on fait un open nommé (par exemple en C par les routines med) :
            1. On essaie de récupérer le nom associé à l'ul (s'il y a eu un
               DEFI_FICHIER).
            2. Si le nom est vide et que le fichier est dans l'état [F]ermé,
               son nom sera 'fort.'+ul.

   RESU_FAUX_VERSION_EXPLOITATION   :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT  :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   OUI
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
      forma03a en POURSUITE :
         ul=DEFI_FICHIER(FICHIER='REPE_OUT/fichier.med', TYPE='LIBRE')
         IMPR_RESU(UNITE  = ul,
                   FORMAT = 'MED',
                   MODELE = MO,
                   RESU   = _F(MAILLAGE = M,
                               RESULTAT = SOLNL2,),)
   DETAILS
    + ircame.f (résultat), irmhdf.f (maillage) en écriture
    + op0150.f, lrcame.f (résultat), lrmhdf.f (maillage) en lecture
    + On tronque le nom à 200 caractères pour med alors que l'on va jusqu'à
      255 caractères dans DEFI_FICHIER (on est bien dans la zone détail !).
   NB_JOURS_TRAV  : 0.5
------------------------------------------------------------------------------
REALISATION EL 2005-092
   INTERET_UTILISATEUR : NON
   TITRE
      Ne pas s'arrêter sur un niveau de version de GIBI inconnu
   FONCTIONNALITE
      On émet une alarme si le niveau n'est pas dans ceux répertoriés,
      car si on réussit à lire le maillage, c'est bon.
   RESU_FAUX_VERSION_EXPLOITATION  :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   OUI
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
   DETAILS
      op0049
   NB_JOURS_TRAV  : 0.5
------------------------------------------------------------------------------
CORRECTION AL 2005-110
   INTERET_UTILISATEUR : NON
   TITRE
      IMPR_TABLE / Ordre de la PAGINATION
   FONCTIONNALITE
      On enchaîne ces deux commandes :

         tab=POST_RELEVE_T(..., NUME_ORDRE = (23, 45, 76, 80),)

         IMPR_TABLE(TABLE=tab,
                    TRI=_F(NOM_PARA = 'COOR_Y',
                           ORDRE = 'DECROISSANT',),
                    PAGINATION=('NUME_ORDRE'),)

      On trie d'abord les COOR_Y, les NUME_ORDRE sont alors mélangés, et il
      se trouve que la pagination est faite avec NUME_ORDRE=80, 76, 45 puis 23.

      Le tri est fait assez tôt dans impr_table_ops alors que la pagination
      est traitée par la méthode Impr des objets Table.

      J'ai deux solutions :
       - je remonte la pagination dans impr_table_ops et je crée les N tables
         avant d'appeler les méthodes d'impression, je dois ajouter une boucle
         systématique sur LA table à imprime ou LES tables si PAGINATION.
       - j'ajoute une ligne dans la méthode Impr pour trier systématiquement
         les valeurs des paramètres de PAGINATION.
      J'ai choisi la seconde !

      S'il y a un intérêt à mettre NUME_ORDRE=(76, 23, 80, 45) et à paginer
      dans cet ordre, la première solution devra être mise en oeuvre.

   RESU_FAUX_VERSION_EXPLOITATION   :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT  :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   OUI
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
   DETAILS
   NB_JOURS_TRAV  : 0.5
------------------------------------------------------------------------------
CORRECTION AL 2005-101
   INTERET_UTILISATEUR : NON
   TITRE
      LIRE_RESU / FORMAT='MED' de champs NOEU
   FONCTIONNALITE
      Aujourd'hui, LIRE_RESU ne sait lire que ces champs (grandeur/support) :
         TEMP >>> TEMP_R / NOEU
         DEPL >>> DEPL_R / NOEU
         SIEF_ELNO, EPSA_ELNO, VARI_ELNO >>> SIEF_R, EPSA_R, VARI_R / ELNO
         PRES >>> PRES_R / ELEM

      J'ajoute quelques possibilités :
         SIEF_NOEU >>> SIEF_R / NOEU
         EPSI_ELNO, EPSI_NOEU >>> EPSI_R / ELNO, NOEU
         EPSA_NOEU >>> EPSA_R / NOEU
         VARI_NOEU >>> VARI_R / NOEU
         EQUI_ELNO_SIGM, EQUI_NOEU_SIGM >>> SIEF_R / ELNO, NOEU

      Néanmoins, je pense qu'il faudrait remettre la commande à plat pour
      qu'elle soit plus générale.

   RESU_FAUX_VERSION_EXPLOITATION   :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT  :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   OUI
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
   DETAILS
   NB_JOURS_TRAV  : 0.5
------------------------------------------------------------------------------
REALISATION EL 2003-075
   INTERET_UTILISATEUR : NON
   TITRE
      Simplifier l'utilisation de LIRE_RESU au format MED
   FONCTIONNALITE
    - NOM_CMP_IDEM='OUI' par défaut :
      C'était effectivement assez curieux : NOM_CMP_IDEM ne peut valoir que OUI
      mais si aucun des mots-clés NOM_CMP/_IDEM/_MED n'est présent, on s'arrête
      sur "COMPOSANTES INCOMPATIBLES" (grâce à NBCMPV non initialisée !).
      C'est une AL.

    => je supprime NOM_CMP_IDEM (c'est le comportement par défaut), j'ajoute
      une règle ENSEMBLE('NOM_CMP', 'NOM_CMP_MED')

    - redondance du mot-clé NOM_CHAMP en dehors et sous le mcfact FORMAT_MED
      On a déjà supprimé NOM_CHAMP hors du mcfact avant la 7.4.

   RESU_FAUX_VERSION_EXPLOITATION  :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   OUI
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : OUI
      DOC_U : U7.02.01
      EXPL_ : Modifications de la gestion des noms de composantes
   VALIDATION
   DETAILS
      op0150, lire_resu
   NB_JOURS_TRAV  : 0.5
------------------------------------------------------------------------------
CORRECTION AL 2004-250
   INTERET_UTILISATEUR : NON
   TITRE
      UTEXCP : Levée d'exception
   FONCTIONNALITE
      Avec UTEXCP, le message associé à l'exception est tronqué à
      132 caractères, nom de la commande compris.

      Je n'avais été très malin quand j'avais mis en place ce mécanisme !!!
      Je remets tout à plat :
         UTEXCP( n° d'exception, sous-prog, message )
      remplace
         UTMESS( 'S', sous-prog, message )

      et
         UTDEXC( n° d'exception, sous-prog, message )
      remplace
         UTDEBM( 'S', sous-prog, message )

      En dessous, UTEXCP et UTDEXC appellent UTMESS et UTDEBM avec un type
      d'erreur 'Z' + le numéro de l'exception passé en COMMON. On peut
      ensuite utiliser les routines UTIMPI/K/R...
      Car on ne souhaite pas modifier toutes les routines utilisant UTMESS
      ou UTDEBM !

=== Message plus clair :
...
 <ASTER  8. 0.17 21/04/2005 > <EXCEPTION LEVEE>
 <STAT_NON_LINE> <OP0070>     ARRET : ABSENCE DE CONVERGENCE AVEC LE NOMBRE
     D'ITERATIONS REQUIS

  %  FIN COMMANDE: STAT_NON_LINE    DUREE TOTALE:       0.65 s (SYST:    0.01 s)

=== si l'exception est interceptée :

Non convergence, on augmente le nombre d'iterations...
...

=== sinon FIN() puis :

>> JDC.py : DEBUT RAPPORT
CR phase d'initialisation
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   ! <S> Exception utilisateur levee mais pas interceptee.                 !
   ! Les bases sont fermees.                                               !
   ! NonConvergenceError : <STAT_NON_LINE> <OP0070>     ARRET : ABSENCE DE !
   ! CONVERGENCE AVEC LE NOMBRE...                                         !
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
fin CR phase d'initialisation

>> JDC.py : FIN RAPPORT


      Exemple, dans la routine chbcvg (objet de la fiche) :
       CALL UTDEXC(23,'CHABOCHE','ERREUR D''INTEGRATION ')
       CALL UTIMPI('L','- ESSAI D''INTEGRATION  NUMERO ',1, INTG)
       CALL UTIMPI('L','- CONVERGENCE VERS  UNE SOLUTION NON CONFORME ',
     &      0, 0)
       CALL UTIMPR('L','- INCREMENT DE DEFORMATION CUMULEE NEGATIVE = '
     &      , 1, DP)
       CALL UTIMPI('L','- CHANGER LA TAILLE D''INCREMENT', 0, 0)
       CALL UTFINM

   RESU_FAUX_VERSION_EXPLOITATION   :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT  :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   OUI
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : OUI
      DOC_D : D6.00.01
      EXPL_ : lister les routines UTEXCP et UTDEXC
   VALIDATION
      zzzz107a
   DETAILS
      utfinm retrouve à peu près la tête qu'il avait avant, en traitant
      le cas IDF=8 (exception = erreur de type 'Z').
      utcomm est supprimé.

      Remplacement de UTEXCP par UTDEXC pour les messages longs dans :
         chbcvg.f cvmcvg.f lcpllg.f lcctrl.f lmacvg.f inscvg.f onocvg.f
   NB_JOURS_TRAV  : 0.5
------------------------------------------------------------------------------
CORRECTION AL 2005-135
   INTERET_UTILISATEUR : NON
   TITRE
      GETCON et UTMESS
   FONCTIONNALITE
      On ne peut pas mettre d'UTMESS dans GETCON car on est entre deux commandes
      (dans aster.getvectjev par exemple) et donc GETRES plante.
      ==> dans GETRES (astermodule.c) :

        /* (MC) le 1er test ne me semble pas suffisant car entre deux commandes,
           commande n'est pas remis à (PyObject*)0... */
        if(commande == (PyObject*)0 || PyObject_HasAttrString(commande, "getres")==0) {
          /* Aucune commande n'est active on retourne des chaines blanches */
          BLANK(nomres,lres);
          BLANK(concep,lconc);
          BLANK(nomcmd,lcmd);
          return ;
        }

      Ainsi CALL UTMESS('A', 'GETCON', 'TEST UTMESS') dans getcon.f produit :
          <A> <> <GETCON> TEST UTMESS

   RESU_FAUX_VERSION_EXPLOITATION   :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT  :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   OUI
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
   DETAILS
      Visiblement, le cas était prévu. Est-ce 'depile' qui est censé remettre
      'commande' à zéro ?
   NB_JOURS_TRAV  : 0.5
------------------------------------------------------------------------------
CORRECTION AL 2005-027
   INTERET_UTILISATEUR : NON
   TITRE
      IMPR_FONCTION / XMGRACE - AGRAF
   FONCTIONNALITE
      1. Le filtre JPEG ne marche pas : sur l'Alpha, c'est vrai (la doc
      d'IMPR_FONCTION précise les filtres disponibles, c'est lié à l'absence
      de certaines librairies sur la machine et nécessite de recompiler xmgrace
      pour en ajouter).

      2. Echelle LOG et valeurs négatives.
      Par défaut, si les bornes ne sont pas fournies via BORNE_X/BORNE_Y, on les
      fixe aux min/max des valeurs -/+ 5% de (max-min) (pour faire joli).
      Donc la valeur min de l'échelle peut donc être négative même si toutes
      les valeurs sont positives.
      => Si échelle LOG, on prend la plus petite valeur positive comme valeur
         min de l'échelle.

      3. Impression de 3 graphes de 5 courbes chacun (avec 3 appel successifs
      à IMPR_FONCTION), xmgrace affiche les 15 courbes superposées.
      => On ne gère qu'un graphe dans IMPR_FONCTION (on pourrait éventuellement
         le traiter, mais il faudrait s'en souvenir d'un appel à l'autre ce qui
         n'est très bon, ou bien avoir un mot-clé pour cela).
         Il faut plutôt faire chaque appel à IMPR_FONCTION dans un fichier
         différent, si on a bcp de fichiers, utiliser REPE_OUT
         (exemple dans U2.51.02).

      4. modification des courbes semble plus compliqué qu'avec agraf :
      => Dire ce qu'il manque dans U2.51.01 ?

      5. nappe de spectres
      Les fonctions d'une nappe ne sont plus imprimées en colonnes mais comme
      N fonctions indépendantes.
      => Au format AGRAF, on saute une ligne entre chaque fonction dans le .digr
         comme demandé.
         On précise la légende des différentes fonctions en reprenant la valeur
         du paramètre, format '%s %s=%g' :
            - légende (nom de la nappe par défaut),
            - nom du paramètre,
            - sa valeur.

      6. plantage au format TABLEAU
      => Je n'ai plus les données ; je suppose qu'une des fonctions de la nappe
         ne peut pas être interpolée ou prolongée...
         - Est-ce au superviseur de s'arrêter sur un message plus explicite :
         "plantage dans CALC_FONC_INTERP" au lieu de "impossible de construire
         la macro" ?
         - Faut-il être capable de récupérer les erreurs <F> dans les macros ?
         - Modifier ici l'erreur <F> en erreur <S> pour la récupérer ?

   RESU_FAUX_VERSION_EXPLOITATION   :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT  :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   OUI
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
      zzzz140a modifié
   DETAILS
      Graph.py (pour les bornes)
      impr_fonction_ops.py (pour la légende)
   NB_JOURS_TRAV  : 0.5
------------------------------------------------------------------------------
REALISATION EL 2004-143
   INTERET_UTILISATEUR : NON
   TITRE
      Remplacement des UTMESS/UTDEBM('S', 'ARRET CPU') par ArretCpuError
   FONCTIONNALITE
      On remplace l'erreur 'S' de type arrêt CPU par l'exception ArretCpuError,
      dont le code d'exception est 28 (cf. astermodule.c).
      On utilise UTEXCP ou UTDEXC.

   RESU_FAUX_VERSION_EXPLOITATION  :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : OUI
      DOC_U : U1.03.01
      EXPL_ : lister les exceptions particularisées dans la doc U du superviseur
   VALIDATION
   DETAILS
      dldiff.f  mddevo.f  mditm2.f  mestat.f  op0060.f  op0171.f
      mdadap.f  mdeul1.f  mdnewm.f  op0025.f  op0070.f  op0186.f
      dladap.f  dlnewi.f
   NB_JOURS_TRAV  : 0.5
------------------------------------------------------------------------------


Traitement des AO/EO :
======================

SANS SUITE :
============
AO 2004-007 : rex et filtre

ED 2004-009 : doc de run_aster
 - doc de as_run dans U1.04.00


REALISE :
=========
ED 2004-018 : doc d'xmgrace
 - dans U2.51.01

EO 2004-020 : run_aster et .export dans le répertoire de travail
 - fait par les scripts de l'agla pour le batch sur la machine de référence
   et par as_run en interactif et batch hors agla,
 - pour Mefisto.

EO 2004-088 : ssh/scp dans astk et run_aster
 - c'est un choix que l'on peut faire via le menu Configuration/Interface,
   il est global (pour toutes les machines).

EO 2004-112 : actualiser tous les jobs en une fois ou sélectionner un seul
              job à actualiser
 - on a réalisé la deuxième solution : clic droit sur un job ouvre un menu
   contextuel pour Actualiser, Editer le .o ou le .e, Supprimer...
 - le bouton Actualiser opèrent sur l'ensemble des jobs non terminés.

EO 2005-008 : type comm avec UL différente de 1
 - le type comm est particulier car il permet de gérer les fichiers de commande
   multiples en utilisant l'extension du nom de fichier pour déterminer l'ordre.
 - on ajoute un traitement particulier, si on a changé l'UL, on bascule le type
   à libr dans le fichier export.

EO 2005-037 : blinder astk
 - assurer la cohérencee entre les données et les résultats de surcharge à
   produire, par exemple : s'arrêter si on veut créer un exécutable et qu'il
   n'y a pas de source dans le profil.
 - c'était déjà fait mais le test qui permet de court-circuiter ces vérifs si
   besoin était mal écrit !

------------------------------------------------------------------------------


========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

       C AJOUT supervis/fonctions_module      durand C.DURAND           158    158      0
       C AJOUT supervis/spec_osci             durand C.DURAND           165    165      0
       C MODIF supervis/astermodule         mcourtoi M.COURTOIS        3936      4     17
       C MODIF supervis/python                durand C.DURAND            53      6      1
 CASTEST MODIF forma12c                       durand C.DURAND           773      5      5
 CASTEST MODIF sdll109a                       durand C.DURAND          2071      6      6
 CASTEST MODIF sdll109b                       durand C.DURAND          1813      6      6
 CASTEST MODIF sdll109c                       durand C.DURAND          1682      6      6
 CASTEST MODIF sdnd102b                       durand C.DURAND           461     13     11
 CASTEST MODIF sdnd120a                       durand C.DURAND           276     16     13
 CASTEST MODIF sdns01a                        durand C.DURAND           420      2      2
 CASTEST MODIF sdns01b                        durand C.DURAND           420      2      2
 CASTEST MODIF sdnx300a                       durand C.DURAND          3204     15     15
 CASTEST MODIF ssla200a                       durand C.DURAND          1315      2      3
 CASTEST MODIF ssla200b                       durand C.DURAND          1337      2      3
 CASTEST MODIF ssll107g                     mcourtoi M.COURTOIS         353     47     47
 CASTEST MODIF ssll501a                       durand C.DURAND           381     13     33
 CASTEST MODIF sslp200a                       durand C.DURAND          1253      2      3
 CASTEST MODIF sslp200b                       durand C.DURAND          1255      2      3
 CASTEST MODIF sslp201a                       durand C.DURAND          1184      2      3
 CASTEST MODIF sslp201b                       durand C.DURAND          1187      2      3
 CASTEST MODIF sslv200a                       durand C.DURAND          1297      2      3
 CASTEST MODIF sslv200b                       durand C.DURAND          1265      5      6
 CASTEST MODIF ssnp115b                     mcourtoi M.COURTOIS         174      1      3
 CASTEST MODIF ssns101a                       durand C.DURAND           382      5      3
 CASTEST MODIF ssns101b                       durand C.DURAND           268      5      3
 CASTEST MODIF ssns101c                       durand C.DURAND           274      6      3
 CASTEST MODIF yyyy106a                     mcourtoi M.COURTOIS         921      2      3
 CASTEST MODIF yyyy106b                     mcourtoi M.COURTOIS         747      2      3
 CASTEST MODIF zzzz100a                       durand C.DURAND          1824    131     96
 CASTEST MODIF zzzz100d                       durand C.DURAND           416     18     18
 CASTEST MODIF zzzz102a                       durand C.DURAND          1494     22     16
 CASTEST MODIF zzzz140a                     mcourtoi M.COURTOIS         183      8      6
 CASTEST MODIF zzzz161a                     mcourtoi M.COURTOIS         225      4      5
 CASTEST MODIF zzzz162a                     mcourtoi M.COURTOIS         392      3      8
 CASTEST MODIF zzzz162b                     mcourtoi M.COURTOIS         219      3      6
 CASTEST MODIF zzzz180a                       durand C.DURAND           888     21     21
CATALOPY AJOUT commande/info_fonction         durand C.DURAND            85     85      0
CATALOPY MODIF commande/calc_fonction         durand C.DURAND           171     40     76
CATALOPY MODIF commande/defi_fichier        mcourtoi M.COURTOIS          69     13      4
CATALOPY MODIF commande/lire_resu           mcourtoi M.COURTOIS         171      2      2
CATALOPY MODIF entete/accas                   durand C.DURAND          1110    118     31
 FORTRAN AJOUT utilifor/utdexc              mcourtoi M.COURTOIS          37     37      0
 FORTRAN AJOUT utilitai/ulisog              mcourtoi M.COURTOIS          63     63      0
 FORTRAN MODIF algeline/lcpllg              mcourtoi M.COURTOIS         304     19     19
 FORTRAN MODIF algorith/chbcvg              mcourtoi M.COURTOIS         305     37     34
 FORTRAN MODIF algorith/cvmcvg              mcourtoi M.COURTOIS         321     28     27
 FORTRAN MODIF algorith/dladap              mcourtoi M.COURTOIS         594      2      2
 FORTRAN MODIF algorith/dldiff              mcourtoi M.COURTOIS         469      2      2
 FORTRAN MODIF algorith/dlnewi              mcourtoi M.COURTOIS         781      2      2
 FORTRAN MODIF algorith/inscvg              mcourtoi M.COURTOIS         303     29     27
 FORTRAN MODIF algorith/lcctrl              mcourtoi M.COURTOIS         158     20     20
 FORTRAN MODIF algorith/lmacvg              mcourtoi M.COURTOIS         326     34     32
 FORTRAN MODIF algorith/mdadap              mcourtoi M.COURTOIS         618      2      2
 FORTRAN MODIF algorith/mddevo              mcourtoi M.COURTOIS         364      2      2
 FORTRAN MODIF algorith/mdeul1              mcourtoi M.COURTOIS         448      2      2
 FORTRAN MODIF algorith/mditm2              mcourtoi M.COURTOIS         513      2      2
 FORTRAN MODIF algorith/mdnewm              mcourtoi M.COURTOIS         338      2      2
 FORTRAN MODIF algorith/mestat              mcourtoi M.COURTOIS         304      2      2
 FORTRAN MODIF algorith/onocvg              mcourtoi M.COURTOIS         306     29     27
 FORTRAN MODIF algorith/op0025              mcourtoi M.COURTOIS         338      2      2
 FORTRAN MODIF algorith/op0060              mcourtoi M.COURTOIS         590      2      2
 FORTRAN MODIF algorith/op0070              mcourtoi M.COURTOIS         799      3      3
 FORTRAN MODIF algorith/op0186              mcourtoi M.COURTOIS         640      3      3
 FORTRAN MODIF calculel/op0171              mcourtoi M.COURTOIS         398      2      2
 FORTRAN MODIF modelisa/lrmhdf              mcourtoi M.COURTOIS         307      9      3
 FORTRAN MODIF prepost/ircame               mcourtoi M.COURTOIS         418     10      5
 FORTRAN MODIF prepost/irmhdf               mcourtoi M.COURTOIS         289     10      5
 FORTRAN MODIF prepost/lrcame               mcourtoi M.COURTOIS         622      9      6
 FORTRAN MODIF prepost/op0049               mcourtoi M.COURTOIS         109      3      3
 FORTRAN MODIF utilifor/utdebm              mcourtoi M.COURTOIS         157     17      6
 FORTRAN MODIF utilifor/utexcp              mcourtoi M.COURTOIS          36      8     12
 FORTRAN MODIF utilifor/utfinm              mcourtoi M.COURTOIS         118     99      6
 FORTRAN MODIF utilifor/utinit              mcourtoi M.COURTOIS         115      8      3
 FORTRAN MODIF utilifor/utmess              mcourtoi M.COURTOIS          27      2      2
 FORTRAN MODIF utilifor/utvtam              mcourtoi M.COURTOIS          49      2      2
 FORTRAN MODIF utilitai/op0035              mcourtoi M.COURTOIS         127     24     10
 FORTRAN MODIF utilitai/op0150              mcourtoi M.COURTOIS         899     39     20
 FORTRAN MODIF utilitai/ops026              mcourtoi M.COURTOIS         102      7      2
 FORTRAN MODIF utilitai/ulclos              mcourtoi M.COURTOIS          53      3      1
 FORTRAN MODIF utilitai/ulimpr              mcourtoi M.COURTOIS          72      3      1
 FORTRAN MODIF utilitai/ulopen              mcourtoi M.COURTOIS         236     45      8
 FORTRAN SUPPR algorith/focabs                durand C.DURAND           101      0    101
 FORTRAN SUPPR algorith/foccar                durand C.DURAND           122      0    122
 FORTRAN SUPPR algorith/focinv                durand C.DURAND           138      0    138
 FORTRAN SUPPR algorith/nor091                durand C.DURAND            46      0     46
 FORTRAN SUPPR utilifor/utcomm              mcourtoi M.COURTOIS         147      0    147
 FORTRAN SUPPR utilitai/foc1en                durand C.DURAND           151      0    151
 FORTRAN SUPPR utilitai/foc2de                durand C.DURAND            55      0     55
 FORTRAN SUPPR utilitai/foc2df                durand C.DURAND           120      0    120
 FORTRAN SUPPR utilitai/foc2en                durand C.DURAND           131      0    131
 FORTRAN SUPPR utilitai/foc2ma                durand C.DURAND           103      0    103
 FORTRAN SUPPR utilitai/foc2so                durand C.DURAND            84      0     84
 FORTRAN SUPPR utilitai/foc2su                durand C.DURAND           136      0    136
 FORTRAN SUPPR utilitai/foc3en                durand C.DURAND           150      0    150
 FORTRAN SUPPR utilitai/foc3so                durand C.DURAND            84      0     84
 FORTRAN SUPPR utilitai/foc3su                durand C.DURAND           140      0    140
 FORTRAN SUPPR utilitai/focaas                durand C.DURAND           229      0    229
 FORTRAN SUPPR utilitai/focaca                durand C.DURAND           168      0    168
 FORTRAN SUPPR utilitai/focaco                durand C.DURAND           141      0    141
 FORTRAN SUPPR utilitai/focade                durand C.DURAND           108      0    108
 FORTRAN SUPPR utilitai/focaen                durand C.DURAND           144      0    144
 FORTRAN SUPPR utilitai/focaex                durand C.DURAND           106      0    106
 FORTRAN SUPPR utilitai/focama                durand C.DURAND            93      0     93
 FORTRAN SUPPR utilitai/focaso                durand C.DURAND           177      0    177
 FORTRAN SUPPR utilitai/focasu                durand C.DURAND           150      0    150
 FORTRAN SUPPR utilitai/foccav                durand C.DURAND           160      0    160
 FORTRAN SUPPR utilitai/focmax                durand C.DURAND           137      0    137
 FORTRAN SUPPR utilitai/focnor                durand C.DURAND           108      0    108
 FORTRAN SUPPR utilitai/focphf                durand C.DURAND           167      0    167
 FORTRAN SUPPR utilitai/focrms                durand C.DURAND           176      0    176
 FORTRAN SUPPR utilitai/foins3                durand C.DURAND           179      0    179
 FORTRAN SUPPR utilitai/foinsp                durand C.DURAND           168      0    168
 FORTRAN SUPPR utilitai/folie0                durand C.DURAND           129      0    129
 FORTRAN SUPPR utilitai/folie1                durand C.DURAND           110      0    110
 FORTRAN SUPPR utilitai/folie2                durand C.DURAND           191      0    191
 FORTRAN SUPPR utilitai/folien                durand C.DURAND           518      0    518
 FORTRAN SUPPR utilitai/fonfft                durand C.DURAND           176      0    176
 FORTRAN SUPPR utilitai/fonoc0                durand C.DURAND           135      0    135
 FORTRAN SUPPR utilitai/fonoci                durand C.DURAND           481      0    481
 FORTRAN SUPPR utilitai/foveca                durand C.DURAND           164      0    164
 FORTRAN SUPPR utilitai/fovima                durand C.DURAND           130      0    130
 FORTRAN SUPPR utilitai/op0091                durand C.DURAND           545      0    545
  PYTHON AJOUT Macro/calc_fonction_ops        durand C.DURAND           322    322      0
  PYTHON AJOUT Macro/info_fonction_ops        durand C.DURAND           252    252      0
  PYTHON AJOUT Utilitai/UniteAster          mcourtoi M.COURTOIS         194    194      0
  PYTHON AJOUT Utilitai/t_fonction            durand C.DURAND           560    560      0
  PYTHON MODIF Macro/impr_fonction_ops      mcourtoi M.COURTOIS         400     20     22
  PYTHON MODIF Macro/impr_table_ops         mcourtoi M.COURTOIS         231      7      8
  PYTHON MODIF Utilitai/Graph               mcourtoi M.COURTOIS        1069     15      4
  PYTHON MODIF Utilitai/Table               mcourtoi M.COURTOIS         718      2      1


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :    9        1836      1836             +1836
 MODIF :   81       51235      1132     844      +288
 SUPPR :   41        6698              6698     -6698
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :  131       59769      2968    7542     -4574 
