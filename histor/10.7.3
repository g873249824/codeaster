========================================================================
Version 10.7.3 du : 09/08/2012
========================================================================


-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR assire       ASSIRE Aimery          DATE 07/10/2012 - 03:40:11

--------------------------------------------------------------------------------
RESTITUTION FICHE 019035 DU 2012-06-22 12:57:28
TYPE anomalie concernant Code_Aster (VERSION 11.3)
TITRE
    En NEW11.2.3, les cas-tests zzzz159b, f, sdls121a, b et c sxe2x80x99arrxc3xaatent en erreur fatale sur Aster4, Calibre 5 et Calibre7.
FONCTIONNALITE
   Suite à la dernière montée de version d'asrun, MACR_RECAL ne fonctionne plus (mode
   DISTRIBUTION)
   Le problème se situe dans l'appel à l'API Python d'asrun utilisée par MACR_RECAL pour
   lancer les calculs esclaves en mode distribué.
   Les cas-tests impactés sont zzzz159b et f, et sdls121a, b et c.
   
   On met à jour l'appel à l'API Python d'asrun dans MACR_REAL.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    zzzz159b et f, et sdls121a, b et c
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR berro        BERRO Hassan           DATE 08/07/2012 - 03:06:42

--------------------------------------------------------------------------------
RESTITUTION FICHE 018946 DU 2012-06-06 14:34:54
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    Problxc3xa8me IMPR_GENE
FONCTIONNALITE
   =========================================================================================
             1. RESUME
   =========================================================================================
   
   Impossible d'imprimer avec l'opérateur IMPR_GENE un résultat de calcul dynamique sur base 
   généralisée pour un modèle de sous-structuration dynamique, cf. cas-test sdll113b.
   
   =========================================================================================
             2. IDENTIFICATION DU PROBLEME
   =========================================================================================
   
   Pour toute impression d'une structure de données type tran_gene, on procède dans >irgene<
   par la "découpe" (filtrage) des résultats  selon les critères utilisateur saisies dans
   IMPR_GENE et on envoie des vect_asse_gene temporaires à la routine >irvgen< qui les 
   imprime ensuite un par un.
   
   Dans le cas de la sous-structuration dynamique, l'impression dans >irvgen< est un peu 
   différente par rapport au cas classiques (sans sous-structuration) dans le mesure où
   il n'existe pas une base modale "globale". du coup il est nécessaire dans l'impression
   de spécifier le nom des bases modales "locales" qui correspond à chaque coefficient 
   généralisé (DEPL/VITE...etc.) imprimé.
   
   Heureusement, >irvgen< a été pensé pour gérer le cas de la sous-structuration mais le 
   problème rencontré est dans la routine >irgen< qui ne traite pas de façon spéciale
   le cas des résultats en sous-structuration. Les impressions en sous-structuration ne sont
   pas dirigées vers le bloc conditionnel spécifique dans >irvgen<.
   
   =========================================================================================
             3. SOLUTION
   =========================================================================================
   
   Dans >irgene<, nous identifions si la sd tran_gene est issue d'un calcul avec 
   sous-structuration (.REFD[6] est un NUME_DDL_GENE):
   
   C        --- TYPE DE CONCEPT AU 6EME ENTREE DE .REFD DU TRAN_GENE  --
            CALL GETTCO ( ZK24(JREFE+5) , TYPREM )
   	 
   C        --- TEST POUR LE CAS DE LA SOUS-STRUCTURATION             --
            IF ( TYPREM(1:8).EQ. 'NUME_DDL' ) THEN
   C        --- MANQUE D'UNE BASE MODALE GLOBALE, DU COUP NOUS        --
   C        --- SAUVEGARDONS LE NUME_DDL_GENE AU 2EME ENTREE DU REFE  --
               ZK24(KREFE) = ' '
               ZK24(KREFE+1) = ZK24(JREFE+5)
            ELSE
   C        --- POUR LES AUTRES CAS, UNE BASE MODALE EST DEFINIE      --
   C        --- ELLE EST SAUVEGARDEE DANS LA 1ERE ENTREE DU REFE      --
               ZK24(KREFE) = ZK24(JREFE+5)
               ZK24(KREFE+1) = ' '
            ENDIF
   
   Avec ces définitions, >irvgen< imprime sans problème les vecteurs généralisés avec
   prise en compte du type de calcul en sous-structuration. 
   
   =========================================================================================
             4. EXEMPLE
   =========================================================================================
   
   Pour le cas-test sdll113b, un extrait de l'impression d'IMPR_GENE, désormais fonctionnelle :
   
   
   ASTER 11.02.02 CONCEPT TRANGENE CALCULE LE 15/06/2012 A 16:38:37 DE TYPE        
    TRAN_GENE                                                                       
   
    ======>
   
    ------>
    VECTEUR GENERALISE DE NOM SYMBOLIQUE  DEPL            
    NUMERO D'ORDRE:        0 INSTANT:  0.00000D+00
   
    NUME_CMP   VALEUR        BASE_MODALE  TYPE_MODE     FREQUENCE    APPLICATION  ________
          1    0.00000D+00    BAMO1       PROPRE       1.01652D+03               |    
          2    0.00000D+00    BAMO1       PROPRE       2.13263D+03               |  SS 
          3    0.00000D+00    BAMO1       PROPRE       3.43004D+03               | numéro 
          4    0.00000D+00    BAMO1       PROPRE       4.80468D+03               |   1
          5    0.00000D+00    BAMO1       CONTRAINT    0.00000D+00   N6      DX  |________    
          6    0.00000D+00    BAMO2       PROPRE       5.02059D+02               |    
          7    0.00000D+00    BAMO2       PROPRE       1.55594D+03               |   SS 
          8    0.00000D+00    BAMO2       PROPRE       2.75664D+03               | numéro
          9    0.00000D+00    BAMO2       PROPRE       4.13372D+03               |   2
         10    0.00000D+00    BAMO2       PROPRE       5.31685D+03               |    
         11    0.00000D+00    BAMO2       CONTRAINT    0.00000D+00   N1      DX  |________
   
   =========================================================================================
             5. IMPACT SOURCES
   =========================================================================================
   
   fortran   : irgene.f
   cas-tests : sdll113b, sdld34a (+ de tests de couverture)
   
   =========================================================================================
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sdll113b, sdld34a
DEJA RESTITUE DANS : 11.2.6
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 08/07/2012 - 03:06:42

--------------------------------------------------------------------------------
RESTITUTION FICHE 018924 DU 2012-05-30 09:50:28
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    getcolljev d'une collection contigue
FONCTIONNALITE
   Problème
   ========
   
   La récupération (par copie) d'une collection dans un dictionnaire produit une 
   erreur mémoire pour un nume_ddl issu du test sdls118a.
   
   Correction
   ==========
   
   On récupère l'objet .NUME.PRNO d'un nume_ddl. Il s'agit d'une collection numérotée 
   dont les clés sont 1 et 3. L'indice 2 a probablement été supprimé.
   
   Dans ce cas, getcolljev prévoit de mettre None à l'indice 2 et libère la zone 
   mémoire de la variable 'tup'. Or comme le tuple n'a pas été créé, on libère une 
   deuxième fois la référence vers le tuple créé pour l'indice 1 d'où l'erreur 
   mémoire.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sdls118a modifixc3xa9
DEJA RESTITUE DANS : 11.2.4
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR pellet       PELLET Jacques         DATE 08/07/2012 - 03:06:43

--------------------------------------------------------------------------------
RESTITUTION FICHE 019122 DU 2012-07-05 15:34:50
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    CALC_VECT_ELEM + EVOL_CHAR => rxc3xa9sultat faux
FONCTIONNALITE
   Problème :
   -----------
   Si on modifie le test zzzz137a pour faire :
     
   CH1=AFFE_CHAR_MECA(  MODELE=MO,
            PRES_REP=_F(  GROUP_MA = 'CD',   PRES = 1.),
            EVOL_CHAR=PRESLU , )
   
   VECEL1=CALC_VECT_ELEM(OPTION='CHAR_MECA', CHARGE=CH1, INST=0.5);
   
   VECAS1=ASSE_VECTEUR(VECT_ELEM=VECEL1, NUME_DDL=NU,);
    
   On peut constater :
   1) si SDVERI='OUI', VECEL1 est NOOK
   2) si on imprime VECAS1, on s'aperçoit que le chargement EVOL_CHAR n'a pas été pris en compte.
   
   Correction :
   ------------
   Il s'agit d'une erreur d'inattention dans la routine me2mme.f :
   Vers la ligne 619, l'appel à la routine REAJRE est fait trop tot (avant l'appel à copisd).
   Comme le champ "noté" dans le RESUELEM n'existe pas encore avant le copisd, il n'est pas
   stocké dans l'objet .RELR
                                                                                            
                          
   Validation :
   ------------
   Après correction de me2mme.f le test modifié est OK
   
   Résultats faux:
   ---------------
   Quand on calcule le vecteur assemblé (commande ASSE_VECTEUR) correspondant à une charge
   contenant un chargement de type EVOL_CHAR (AFFE_CHAR_MECA / EVOL_CHAR), ce chargement est
   "oublié" dans le vecteur assemblé : il n'est pas appliqué.
    
   Liste des fichiers impactés par la correction de la fiche:  19122
     me2mme.f
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 10.0
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 11.0
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    essai perso
DEJA RESTITUE DANS : 11.2.6
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR delmas       DELMAS Josselin        DATE 08/07/2012 - 03:06:43

--------------------------------------------------------------------------------
RESTITUTION FICHE 019172 DU 2012-07-12 13:23:40
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Alarme bizarre dans MODI_REPERE
FONCTIONNALITE
   Problème :
   ========
   Un utilisateur ne comprend pas pourquoi l'alarme suivante est émise dans MODI_REPERE :
   
   
      !----------------------------------------------------------------!
      ! <A> <ALGORITH2_1>                                              !
      !                                                                !
      ! Erreur utilisateur dans la commande CREA_RESU / AFFE :         !
      !  Le maillage associÃ© au mot clÃ© CHAM_GD           : xxxxxx     !
      !  est diffÃ©rent de celui associÃ© au mot clÃ© MODELE : xxxxxx     !
      !                                                                !
      !                                                                !
      ! Ceci est une alarme. Si vous ne comprenez pas le sens de cette !
      ! alarme, vous pouvez obtenir des rÃ©sultats inattendus !         !
      !----------------------------------------------------------------!
   
   Pourtant xxxxxx est bien égal à xxxxxx...
   
   Correction :
   ==========
   Cette alarme est émise par chrpel.f et crtype.f. Pour crtype, pas de soucis c'est le bon
   message. Mais pour chrpel le bon message est ALGORITH2_11 (modifié en 10.3.4).
   
   Le bon message est rétabli. On en profite pour l'améliorer.
   
   Impacts :
   =======
   F:
   chrpel.f
   
   PY:
   algorith2.py
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    passage de l'?tude jointe
DEJA RESTITUE DANS : 11.2.7
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR lefebvre     LEFEBVRE Jean-Pierre   DATE 08/07/2012 - 03:06:44

--------------------------------------------------------------------------------
RESTITUTION FICHE 018927 DU 2012-05-30 15:58:06
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    CREA_RESU et reuse
FONCTIONNALITE
   Effectivement, on s'arrête sur un ASSERT dans RSCRSD et le message n'est pas très compréhensible. Je 
   vais modifier les routines CRVRC1 et CRVRC2 pour tester l'existence de la structure de données 
   résultat et émettre un message lorsqu'elle est utilisée en reuse pour ce type d'opération.
   
      !----------------------------------------------------------------------------!
      ! <F> <CALCULEL7_6>                                                          !
      !                                                                            !
      !   Pour ce type d'opération, il n'est pas permis d'utiliser la structure de !
      !   données résultat existante TEMP derrière le mot clé reuse.               !
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    test zzzz118a modifixc3xa9 comme indiquxc3xa9
DEJA RESTITUE DANS : 11.2.8
NB_JOURS_TRAV  : 0.3
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desroche     DESROCHES Xavier       DATE 08/07/2012 - 03:06:44

--------------------------------------------------------------------------------
RESTITUTION FICHE 018989 DU 2012-06-15 08:15:40
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    POST_RELEVE_T plante sur l'extraction le long d'un INTE_MAIL_3D
FONCTIONNALITE
   Problème :
   --------
   A l'issue d'un calcul 3D on veut extraire le champ de déplacement dans une région.
   Si on définit la région par un groupe de noeuds, tout va bien.
   Si on définit la région par un chemin INTE_MAIL_3D (objectif initial), POST_RELEVE_T 
   plante, sans message d'erreur particulier.
   
   Correction :
   ----------
   Le bug vient du fait que l'extrémité du chemin défini dans INTE_MAIL_3D est un point 
   situé à l'intérieur d'un élément. Dans ce cas de figure il y a une incompatibilité 
   entre INTE_MAIL_3D et POST_RELEVE_T.
   INTE_MAIL_3D décompose le chemin en chemins élémentaires qui sont des segments repérant
   les numéros de face d'entrée et de sortie des éléments. Dans le cas où le chemin 
   élémentaire n'intersecte pas une face (en entrée ou en sortie) il stocke 0 comme 
   numéro de face. 
   Or POST_RELEVE_T considère que tous les numéros de face doivent être 
   non nuls et s'en sert pour accéder à un tableau, ce qui explique le plantage.
   
   Si on regarde la doc qui définit l'intersection d'un segment avec un maillage 
   [D4.02.03], on voit que les segments élémentaires retenus ont bien l'origine et 
   l'extrémité sur une face d'un élément 3D. Les autres sont donc à exclure.
   
   Conclusion : la correction est à faire dans INTE_MAIL_3D en excluant du chemin post-
   traité les segments élémentaires extrémités s'ils ne traversent pas entièrement un 
   élément 3D. De cette façon on est conforme à la doc et à ce qu'attend POST_RELEVE_T.
   On émet un message d'alarme pour dire que le chemin est tronqué à l'origine (ou 
   l'extrémité) si une des extrémités est à l'intérieur d'un élément.
   
   Routine impactée : i3imas
   ----------------
   Cas-test :
   ---------
    dans ssnp123c on rajoute un chemin tronqué pour imprimer le message d'alarme.
   
   Doc U :
   ------
    dans INTE_MAIL_3D (U4.81.12) on prévient de l'éventuelle troncature du chemin si une 
   des extrémités est à l'intérieur d'un élément.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.81.12
VALIDATION
    ssnp123c
DEJA RESTITUE DANS : 11.2.7
NB_JOURS_TRAV  : 1.5
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR lefebvre     LEFEBVRE Jean-Pierre   DATE 08/07/2012 - 03:06:45

--------------------------------------------------------------------------------
RESTITUTION FICHE 019135 DU 2012-07-06 17:07:25
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    [FORMA] DEFI_MATERIAU vide = erreur JEVEUX
FONCTIONNALITE
   Problème :
   ========
    
   Lorsque l'on définit un matériau, il faut que la commande contienne au moins un
   comportement. Dans l'exemple fourni : ACIER=DEFI_MATERIAU(), rien n'est défini !
   
   Correction apportée :
   ====================
   
   Dans l'opérateur, on récupère le nombre de mots clés facteurs NBCRME, si ce dernier vaut 0
   on émet un message d'erreur :
   
   
     # Commande No :  0002            Concept de type : mater_sdaster
     # ------------------------------------------------------------------------------------------
     ACIER=DEFI_MATERIAU(INFO=1,
                         );
   
      
      !-------------------------------------------------------------------------------------!
      ! <EXCEPTION> <MODELISA10_16>                                                         !
      !                                                                                     !
      ! Il est obligatoire de fournir au moins un comportement pour définir le matériau. !
      !-------------------------------------------------------------------------------------!
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    xc3xa9tude fournie
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 08/07/2012 - 03:06:45

--------------------------------------------------------------------------------
RESTITUTION FICHE 019089 DU 2012-07-02 08:37:10
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    Problxc3xa8me xc3xa9crasement mxc3xa9moire
FONCTIONNALITE
   Problème
   --------
   
   Il y a un écrasement mémoire lors d'un CALC_TABLE avec beaucoup d'occurrences de FILTRE.
   
   
   Correction
   ----------
   
   L'écrasement mémoire est toujours lié au nombre de TITREs lors de la création de la table 
   (comme dans issue18982). Cela se passe dans des routines très anciennes, avant la version 
   7.
   Ironie de l'histoire, c'est moi qui ait mis un premier garde-fou en 7.6.5 !
   
   La programmation des routines titre?.f est tout sauf claire... Au lieu de manipuler 
   l'indice dans le tableau, on s'amuse à incrémenter directement l'adresse.
   
   titre1: En cas de ligne trop longue, on utilise un indice supplémentaire dans le tableau à 
   remplir (incrément de l'adresse) mais le numéro de ligne dans le tableau initial n'est pas 
   incrémenté, or c'est lui qui est utilisé pour limiter les itérations...
   
   Ici, on ajoute un autre garde-fou pour s'assurer que l'adresse ne déborde pas du 
   dimensionnement initial :
   
   IF (LDONS1 .GT. LDONS-1+MXLIGS) THEN
    . LDONS1 = LDONS1 - 1
    . GOTO 1200
   ENDIF
   
   De plus, autant pour optimiser la taille des tableaux passés en argument que pour la 
   robustesse, on limite le nombre de titre lors de la construction des arguments pour 
   CREA_TABLE.
   
   
   Report en version 10: Table.py et titre1.f
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    xc3xa9tude jointe
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 019095 DU 2012-07-02 13:46:16
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    DEFI_FICHIER avec ACCES='NEW' nom tronqué à 80 caractères
FONCTIONNALITE
   Problème
   --------
   
   Lorsque l'on fait DEFI_FICHIER/ACCES='NEW' et TYPE != 'ASCII', le fichier est effacé s'il existe. 
   Dans le catalogue de DEFI_FICHIER, FICHIER est limité à 255 caractères, mais dans la fonction C 
   appelé pour effacer le fichier, le nom est tronqué à 80 caractères.
   
   
   Correction
   ----------
   
   La fonction rmfile est réécrite en utilisant les fonctions de copie de chaines de caractères au 
   lieu des boucles et en allouant dynamiquement les chaines à la longueur nécessaire.
   
   Il n'y a donc que la limite dans le catalogue et la variable fortran dans ops026 à 255 
   caractères.
   
   Remontée d'erreur de syntaxe : En 11.1.23, des erreurs se sont glissées dans N_VALIDATOR.py 
   (mauvais placements de parenthèses) qui conduisent à un traceback Python non formatté. Possible 
   que cette erreur ait été intégrée dans eficas 6.5.0.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    test élémentaire
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

       C MODIF supervis/astermodule         chansard F.CHANSARD        3932     32     36
       C MODIF utilitai/rmfile              chansard F.CHANSARD          67     27     33
 CASTEST MODIF sdld34a                      chansard F.CHANSARD         197     14      2
 CASTEST MODIF sdll113b                     chansard F.CHANSARD         649    171      8
 CASTEST MODIF zzzz159f                       assire A.ASSIRE           156      3      3
 FORTRAN MODIF algorith/chrpel              chansard F.CHANSARD         951      3      3
 FORTRAN MODIF algorith/crvrc1              chansard F.CHANSARD         134      8      3
 FORTRAN MODIF algorith/crvrc2              chansard F.CHANSARD         127      8      3
 FORTRAN MODIF calculel/me2mme              chansard F.CHANSARD         607      3      3
 FORTRAN MODIF modelisa/op0005              chansard F.CHANSARD         188      6      2
 FORTRAN MODIF postrele/i3imas              chansard F.CHANSARD         402     16      2
 FORTRAN MODIF prepost/irgene               chansard F.CHANSARD         181     24      8
 FORTRAN MODIF utilitai/titre1              chansard F.CHANSARD         168     16      5
  PYTHON MODIF Macro/reca_calcul_aster        assire A.ASSIRE           544      8      8
  PYTHON MODIF Macro/recal                    assire A.ASSIRE          1536      7      8
  PYTHON MODIF Messages/algorith2           chansard F.CHANSARD         298     10     10
  PYTHON MODIF Messages/calculel7           chansard F.CHANSARD          57      6      1
  PYTHON MODIF Messages/modelisa10          chansard F.CHANSARD          55      6      2
  PYTHON MODIF Messages/prepost6            chansard F.CHANSARD         180     18      2
  PYTHON MODIF Messages/utilitai4           chansard F.CHANSARD         336      3      3
  PYTHON MODIF Utilitai/Table               chansard F.CHANSARD        1074      3      2


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :    0           0         0                +0
 MODIF :   21       11839       392     147      +245
 SUPPR :    0           0                 0        +0
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :   21       11839       392     147      +245 
