# TITRE : COHERENCE DES MODES LOCAUX DES OPTIONS TOPOSE ET TOPOFA (D_PLAN)
# ======================================================================
# COPYRIGHT (C) 1991 - 2013  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                    
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================

DEBUT(CODE=_F(NIV_PUB_WEB='INTERNET'),
      PAR_LOT = 'NON',
      IGNORE_ALARM=('MODELISA4_6','SUPERVIS_1'),
      DEBUG=_F(SDVERI='OUI'),
      )

# ###################################################
# ###################################################
#
# Utilisation d'un maillage lineaire pour tester la
# coherence entre : 
#
#  - meca sans contact
#  - meca avec contact
#  - thermique
#
# ###################################################
# ###################################################

# ###################################################
# Maillage
# ###################################################

MA1 = LIRE_MAILLAGE(FORMAT = 'MED',);

MAILLAGE = CREA_MAILLAGE(MAILLAGE = MA1,
                         CREA_POI1 = (_F(NOM_GROUP_MA = 'POCOUPE1',
                                         GROUP_NO = 'NORPHHAU',),
                                      _F(NOM_GROUP_MA = 'POCOUPE2',
                                         GROUP_NO = 'NORPHBAS',),),)

# ###################################################
# Definition des modeles sains mecanique et thermique
# ###################################################

MODMES = AFFE_MODELE(MAILLAGE = MAILLAGE,
                     AFFE = (
                             _F(TOUT = 'OUI',
                                PHENOMENE = 'MECANIQUE',
                                MODELISATION = 'D_PLAN',),
                             _F(GROUP_MA = ('POCOUPE1','POCOUPE2',),
                                PHENOMENE = 'MECANIQUE',
                                MODELISATION = '2D_DIS_T',),
                             ),)

MODTHS = AFFE_MODELE(MAILLAGE = MAILLAGE,
                     AFFE = _F(TOUT = 'OUI',
                               PHENOMENE = 'THERMIQUE',
                               MODELISATION = 'PLAN',),)

# ###################################################
# Definition des fissures mecanique et thermique 
# ###################################################

a = 10.
h = a/18.

FISSME1 = DEFI_FISS_XFEM(MODELE = MODMES,
                        TYPE_DISCONTINUITE = 'FISSURE', 
                        DEFI_FISS = _F(FORM_FISS = 'DEMI_DROITE',
                                       PFON = (0.25*a, 0.25*a, 0.),
                                       DTAN = (1., 0., 0.),),)

FISSTH1 = DEFI_FISS_XFEM(MODELE = MODTHS,
                        TYPE_DISCONTINUITE = 'FISSURE', 
                        DEFI_FISS = _F(FORM_FISS = 'DEMI_DROITE',
                                       PFON = (0.25*a, 0.25*a, 0.),
                                       DTAN = (1., 0., 0.),),)

FISSME2 = DEFI_FISS_XFEM(MODELE = MODMES,
                        TYPE_DISCONTINUITE = 'FISSURE', 
                        DEFI_FISS = _F(FORM_FISS = 'DEMI_DROITE',
                                       PFON = (0.25*a, 0.75*a, 0.),
                                       DTAN = ( 1., 0., 0.),),)

FISSTH2 = DEFI_FISS_XFEM(MODELE = MODTHS,
                        TYPE_DISCONTINUITE = 'FISSURE', 
                        DEFI_FISS = _F(FORM_FISS = 'DEMI_DROITE',
                                       PFON = (0.25*a, 0.75*a, 0.),
                                       DTAN = ( 1., 0., 0.),),)

FISSME3 = DEFI_FISS_XFEM(MODELE = MODMES,
                        TYPE_DISCONTINUITE = 'FISSURE', 
                        DEFI_FISS = _F(FORM_FISS = 'DEMI_DROITE',
                                       PFON = (a-1.5*h, 0.5*h, 0.),
                                       DTAN = (-1., 0., 0.),),)

FISSTH3 = DEFI_FISS_XFEM(MODELE = MODTHS,
                        TYPE_DISCONTINUITE = 'FISSURE', 
                        DEFI_FISS = _F(FORM_FISS = 'DEMI_DROITE',
                                       PFON = (a-1.5*h, 0.5*h, 0.),
                                       DTAN = (-1., 0., 0.),),)

# ###################################################
# Definition des modeles xfem mecanique et thermique
# ###################################################

#  - meca sans contact
MODMEX = MODI_MODELE_XFEM(MODELE_IN = MODMES,
                          FISSURE = (FISSME1,FISSME2,FISSME3),)

#  - meca avec contact
MODMCX = MODI_MODELE_XFEM(MODELE_IN = MODMES,
                          FISSURE = (FISSME1,FISSME2,FISSME3),
                          CONTACT = 'OUI')

#  - thermique
MODTHX = MODI_MODELE_XFEM(MODELE_IN = MODTHS,
                          FISSURE = (FISSTH1,FISSTH2,FISSTH3),)

# ###################################################
# Impression du contenu des modeles xfem obtenus :
# -> meca, sans contact : MODMEX
# -> meca, avec contact : MODMCX
# -> thermique          : MODTHX
# ###################################################

DEFI_FICHIER(UNITE=31, FICHIER='./fort.31')
DEFI_FICHIER(UNITE=32, FICHIER='./fort.32')
DEFI_FICHIER(UNITE=33, FICHIER='./fort.33')

# tant que issue22486 n'est pas restituee : -> pas de SOMMI ou SOMMR 
# car les permutations peuvent changer la somme de controle
#IMPR_CO(UNITE=31,CONCEPT=_F(NOM=MODMEX),NIVEAU=-1,PERMUTATION='NON',)
#IMPR_CO(UNITE=32,CONCEPT=_F(NOM=MODMCX),NIVEAU=-1,PERMUTATION='NON',)
#IMPR_CO(UNITE=33,CONCEPT=_F(NOM=MODTHX),NIVEAU=-1,PERMUTATION='NON',)
IMPR_CO(UNITE=31,CONCEPT=_F(NOM=MODMEX),NIVEAU=-1,)
IMPR_CO(UNITE=32,CONCEPT=_F(NOM=MODMCX),NIVEAU=-1,)
IMPR_CO(UNITE=33,CONCEPT=_F(NOM=MODTHX),NIVEAU=-1,)

DEFI_FICHIER(ACTION='LIBERER',UNITE=31)
DEFI_FICHIER(ACTION='LIBERER',UNITE=32)
DEFI_FICHIER(ACTION='LIBERER',UNITE=33)

# ###################################################
# "Post-traitements" des fichiers obtenus avec IMPR_CO
# ###################################################

File31 = open('./fort.31', "r")
File32 = open('./fort.32', "r")
File33 = open('./fort.33', "r")

LinesFile31 = File31.readlines()
LinesFile32 = File32.readlines()
LinesFile33 = File33.readlines()
LinesFile31 = [line.split() for line in LinesFile31]
LinesFile32 = [line.split() for line in LinesFile32]
LinesFile33 = [line.split() for line in LinesFile33]

File31.close()
File32.close()
File33.close()

ListME = []
ListMC = []
ListTH = []

for il in xrange(len(LinesFile31)):
  lF31 = LinesFile31[il]
  if '&&UTIMSD' in lF31 :
    ind = lF31.index('MODMEX')
    lF31[ind] = ''
    for char in lF31:
      if ('TOPOFAC' in char) and ('.CELV' in char) or \
         ('TOPOSE'  in char) and ('.CELV' in char) :
        ListME.append(lF31)
        break
for il in xrange(len(LinesFile32)):
  lF32 = LinesFile32[il]
  if '&&UTIMSD' in lF32 :
    ind = lF32.index('MODMCX')
    lF32[ind] = ''
    for char in lF32:
      if ('TOPOFAC' in char) and ('.CELV' in char) or \
         ('TOPOSE'  in char) and ('.CELV' in char) :
        ListMC.append(lF32)
        break
for il in xrange(len(LinesFile33)):
  lF33 = LinesFile33[il]
  if '&&UTIMSD' in lF33 :
    ind = lF33.index('MODTHX')
    lF33[ind] = ''
    for char in lF33:
      if ('TOPOFAC' in char) and ('.CELV' in char) or \
         ('TOPOSE'  in char) and ('.CELV' in char) :
        ListTH.append(lF33)
        break

# tant que issue22486 n'est pas restituee : -> pas de SOMMI ou SOMMR 
# car les permutations peuvent changer la somme de controle
for i in xrange(len(ListME)):
  if 'SOMMR=' in ListME[i] : 
    char = 'SOMMR='
  elif 'SOMMI=' in ListME[i] :
    char = 'SOMMI='
  ind = ListME[i].index(char)
  ListME[i] = ListME[i][:ind]
for i in xrange(len(ListMC)):
  if 'SOMMR=' in ListMC[i] : 
    char = 'SOMMR='
  elif 'SOMMI=' in ListMC[i] :
    char = 'SOMMI='
  ind = ListMC[i].index(char)
  ListMC[i] = ListMC[i][:ind]
for i in xrange(len(ListTH)):
  if 'SOMMR=' in ListTH[i] : 
    char = 'SOMMR='
  elif 'SOMMI=' in ListTH[i] :
    char = 'SOMMI='
  ind = ListTH[i].index(char)
  ListTH[i] = ListTH[i][:ind]

#assert len(ListMC) == len(ListME)
#for i in xrange(len(ListMC)):
  #print ListMC[i] == ListME[i]
  #print ListMC[i]
  #print ListME[i]
  #print "&&"
#assert len(ListTH) == len(ListME)
#for i in xrange(len(ListTH)):
  #print ListTH[i] == ListME[i]
  #print ListTH[i]
  #print ListME[i]
  #print "&&"

# ###################################################
# Tests une fois les infos extraites de ces fichiers
# ###################################################

# -------
# nobj_ok == 1 si il y a le meme nombre de cham_elem out
# de TOPOSE et TOPOFA d'un modele a l'autre
# nobj_ok == 0 sinon
# -------

nME = len(ListME)
nMC = len(ListMC)
nTH = len(ListTH)

# -> entre MODMCX et MODMEX
nobj_ok = 0
if (nMC == nME) and (nMC > 0) : nobj_ok = 1
TOBJMCME = CREA_TABLE(TITRE = '',
                      LISTE = _F( LISTE_I = [nobj_ok], PARA = 'BOOLEEN'),)

# -> entre MODTHX et MODMEX
nobj_ok = 0
if (nTH == nME) and (nTH > 0) : nobj_ok = 1
TOBJTHME = CREA_TABLE(TITRE = '',
                      LISTE = _F( LISTE_I = [nobj_ok], PARA = 'BOOLEEN'),)

TEST_TABLE(REFERENCE='ANALYTIQUE',
           VALE_CALC_I=1,
           VALE_REFE_I=1,
           NOM_PARA='BOOLEEN',
           TABLE=TOBJMCME,)

TEST_TABLE(REFERENCE='ANALYTIQUE',
           VALE_CALC_I=1,
           VALE_REFE_I=1,
           NOM_PARA='BOOLEEN',
           TABLE=TOBJTHME,)

# -------
# vale_ok == 1 si le "resume" (IMPR_CO/NIVEAU=-1) des .CELV
# ou .VALE contenus dans les deux modeles sont identiques 
# (au nom du modele pres) 
# vale_ok == 0 sinon
# -------

# -> entre MODMCX et MODMEX
vale_ok = 0
if (ListMC == ListME) and (ListMC != []) : vale_ok = 1
TVALMCME = CREA_TABLE(TITRE = '',
                      LISTE = _F( LISTE_I = [vale_ok], PARA = 'BOOLEEN'),)

# -> entre MODTHX et MODMEX
vale_ok = 0
if (ListTH == ListME) and (ListTH != []) : vale_ok = 1
TVALTHME = CREA_TABLE(TITRE = '',
                      LISTE = _F( LISTE_I = [vale_ok], PARA = 'BOOLEEN'),)

TEST_TABLE(REFERENCE='ANALYTIQUE',
           VALE_CALC_I=1,
           VALE_REFE_I=1,
           NOM_PARA='BOOLEEN',
           TABLE=TVALMCME,)

TEST_TABLE(REFERENCE='ANALYTIQUE',
           VALE_CALC_I=1,
           VALE_REFE_I=1,
           NOM_PARA='BOOLEEN',
           TABLE=TVALTHME,)

# ###################################################
# ###################################################
#
# Utilisation d'un maillage quadratique pour tester 
# la coherence entre meca et hydro-meca
#
# Attention :
#
# -> pour la definition du modele enrichi HM, il n'existe
#    pas d'elements cracktip. On travaille donc uniquement
#    avec une interface
#
# ###################################################
# ###################################################

MAILLAGQ = CREA_MAILLAGE(MAILLAGE = MA1,
                         LINE_QUAD = _F(TOUT = 'OUI'))

# ################################################################
# Definition des modeles sains mecanique, hydro-meca
# ################################################################

MOQMES = AFFE_MODELE(MAILLAGE = MAILLAGQ,
                     AFFE = _F(TOUT = 'OUI',
                               PHENOMENE = 'MECANIQUE',
                               MODELISATION = 'D_PLAN',),)

MOQHMS = AFFE_MODELE(MAILLAGE = MAILLAGQ,
                     AFFE = _F(TOUT = 'OUI',
                               PHENOMENE = 'MECANIQUE',
                               MODELISATION = 'D_PLAN_HM',),)

# ###################################################
# Definition des fissures interface meca et HM
# ###################################################

LN = FORMULE(NOM_PARA=('X','Y'),VALE='Y-0.25*a');

INTQME = DEFI_FISS_XFEM(MODELE = MOQMES,
                        TYPE_DISCONTINUITE = 'INTERFACE', 
                        DEFI_FISS = _F(FONC_LN = LN,),)

INTQHM = DEFI_FISS_XFEM(MODELE = MOQHMS,
                        TYPE_DISCONTINUITE = 'INTERFACE', 
                        DEFI_FISS = _F(FONC_LN = LN,),)

# ###################################################
# Definition des modeles xfem
# ###################################################

# -> meca, sans contact
MOQMEX= MODI_MODELE_XFEM(MODELE_IN = MOQMES,
                          FISSURE  = INTQME,)

# -> hydro-meca
MOQHMX= MODI_MODELE_XFEM(MODELE_IN = MOQHMS,
                          FISSURE  = INTQHM,)

# ###################################################
# Impression du contenu des modeles xfem obtenus :
# -> meca, sans contact : MOQMEX
# -> hydro-meca         : MOQHMX
# ###################################################

DEFI_FICHIER(UNITE=34, FICHIER='./fort.34')
DEFI_FICHIER(UNITE=35, FICHIER='./fort.35')

# tant que issue22486 n'est pas restituee : -> pas de SOMMI ou SOMMR 
# car les permutations peuvent changer la somme de controle
#IMPR_CO(UNITE=34,CONCEPT=_F(NOM=MOQMEX),NIVEAU=-1,PERMUTATION='NON',)
#IMPR_CO(UNITE=35,CONCEPT=_F(NOM=MOQHMX),NIVEAU=-1,PERMUTATION='NON',)
IMPR_CO(UNITE=34,CONCEPT=_F(NOM=MOQMEX),NIVEAU=-1,)
IMPR_CO(UNITE=35,CONCEPT=_F(NOM=MOQHMX),NIVEAU=-1,)

DEFI_FICHIER(ACTION='LIBERER',UNITE=34)
DEFI_FICHIER(ACTION='LIBERER',UNITE=35)

# ###################################################
# "Post-traitements" des fichiers obtenus avec IMPR_CO
# ###################################################

File34 = open('./fort.34', "r")
File35 = open('./fort.35', "r")

LinesFile34 = File34.readlines()
LinesFile35 = File35.readlines()
LinesFile34 = [line.split() for line in LinesFile34]
LinesFile35 = [line.split() for line in LinesFile35]

File34.close()
File35.close()

ListQME = []
ListQHM = []

for il in xrange(len(LinesFile34)):
  lF34 = LinesFile34[il]
  if '&&UTIMSD' in lF34 :
    ind = lF34.index('MOQMEX')
    lF34[ind] = ''
    for char in lF34:
      if ('TOPOFAC' in char) and ('.CELV' in char) or \
         ('TOPOSE'  in char) and ('.CELV' in char) :
        ListQME.append(lF34)
        break
for il in xrange(len(LinesFile35)):
  lF35 = LinesFile35[il]
  if '&&UTIMSD' in lF35 :
    ind = lF35.index('MOQHMX')
    lF35[ind] = ''
    for char in lF35:
      if ('TOPOFAC' in char) and ('.CELV' in char) or \
         ('TOPOSE'  in char) and ('.CELV' in char) :
        ListQHM.append(lF35)
        break

# tant que issue22486 n'est pas restituee : -> pas de SOMMI ou SOMMR 
# car les permutations peuvent changer la somme de controle
for i in xrange(len(ListQME)):
  if 'SOMMR=' in ListQME[i] : 
    char = 'SOMMR='
  elif 'SOMMI=' in ListQME[i] :
    char = 'SOMMI='
  ind = ListQME[i].index(char)
  ListQME[i] = ListQME[i][:ind]
for i in xrange(len(ListQHM)):
  if 'SOMMR=' in ListQHM[i] : 
    char = 'SOMMR='
  elif 'SOMMI=' in ListQHM[i] :
    char = 'SOMMI='
  ind = ListQHM[i].index(char)
  ListQHM[i] = ListQHM[i][:ind]

#assert len(ListQHM) == len(ListQME)
#for i in xrange(len(ListQHM)):
  #print ListQHM[i] == ListQME[i]
  #print ListQHM[i]
  #print ListQME[i]
  #print "&&"

# ###################################################
# Tests une fois les infos extraites de ces fichiers
# ###################################################

# -------
# nobj_ok == 1 si il y a le meme nombre de cham_elem out
# de TOPOSE et TOPOFA d'un modele a l'autre
# nobj_ok == 0 sinon
# -------

nQME = len(ListQME)
nQHM = len(ListQHM)

# -> entre MOQMEX et MOQHMX
nobj_ok = 0
if (nQHM == nQME) and (nQHM > 0) : nobj_ok = 1
TOBJHMME = CREA_TABLE(TITRE = '',
                      LISTE = _F( LISTE_I = [nobj_ok], PARA = 'BOOLEEN'),)

TEST_TABLE(REFERENCE='ANALYTIQUE',
           VALE_CALC_I=1,
           VALE_REFE_I=1,
           NOM_PARA='BOOLEEN',
           TABLE=TOBJHMME,)

# -------
# vale_ok == 1 si le "resume" (IMPR_CO/NIVEAU=-1) des .CELV
# ou .VALE contenus dans les deux modeles sont identiques 
# (au nom du modele pres) 
# vale_ok == 0 sinon
# -------

# -> entre MOQMEX et MOQHMX
vale_ok = 0
if (ListQHM == ListQME) and (ListQHM != []) : vale_ok = 1
TVALHMME = CREA_TABLE(TITRE = '',
                      LISTE = _F( LISTE_I = [vale_ok], PARA = 'BOOLEEN'),)

TEST_TABLE(REFERENCE='ANALYTIQUE',
           VALE_CALC_I=1,
           VALE_REFE_I=1,
           NOM_PARA='BOOLEEN',
           TABLE=TVALHMME,)

FIN()
