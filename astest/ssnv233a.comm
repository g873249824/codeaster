
# ======================================================================
# COPYRIGHT (C) 1991 - 2013  EDF R&D                WWW.CODE-ASTER.ORG
#
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
# 1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# aslint: disable=W2005
# Subroutines
# ------------------------------------------------------------------------------  
def Defi_Xmcourbe(X=None,Y=None,FUNCTION=None,courbe=None,legend='X',color=0,mark=0,):

  if FUNCTION:
    def_co={'FONCTION': FUNCTION}
  else:
    def_co={'ABSCISSE': X}
    def_co['ORDONNEE'] = Y
    
  def_co['LEGENDE' ] = legend
  def_co['COULEUR' ] = color
  def_co['MARQUEUR'] = mark
  
  try:
    courbe.append(def_co);
  except:
    courbe=[def_co,];
      
  return courbe;

# Fin
# ------------------------------------------------------------------------------


# TITRE: ESSAI DE CISAILLEMENT SUR SABLE D'HOSTUN - LOI DE MOHR-COULOMB, SIMU_POINT_MAT

#
# REMARQUE IMPORTANTE:
# ---------------------
#
# Pour pouvoir utiliser VERI_MATR_TANG, il faut mettre SDVERI='NON'
#                                                      ------------
from Contrib.veri_matr_tang import VERI_MATR_TANG
import numpy as np

DEBUT(PAR_LOT='OUI', DEBUG=_F(SDVERI='NON'))

# modules mecaniques [kPa]
K=516.2E6
G=238.2E6
# =>
YOUNG = 9.*K*G /(3.*K+G)
POISSON = (3.*K-2.*G) /(6.*K+2.*G)

print 'young=',YOUNG,' /// nu=',POISSON

# pression de preconsolidation [en kPa]
PCO=50.E+3

#*******************************************************************
#    INCREMENTS DE TEMPS
#*******************************************************************

tarret =50.
tfin   =100.
npas   =100

epxy_min =-.0001
depxy    =epxy_min/npas
temps_max =100.
dtemps    =temps_max/npas

TEMPS1=DEFI_LIST_REEL(DEBUT=0.,
                      INTERVALLE=(_F(JUSQU_A = tarret   , NOMBRE = 5),
                                  _F(JUSQU_A = temps_max, NOMBRE = 5),),);
                                 
#***********************************************************************
#    ESSAI TRIAXIAL NON DRAINE CYCLIQUE
#***********************************************************************
SOL=DEFI_MATERIAU(ELAS=_F(E=YOUNG, NU=POISSON, ALPHA=0.),
                  MOHR_COULOMB=_F(
                            PHI      = 33.,
                            ANGDIL   = 27.,
                            COHESION = 1.0E+3,),);
                            
COEF0=DEFI_FONCTION(NOM_PARA    = 'INST',
                    PROL_DROITE = 'CONSTANT',
                    VALE=( 0.0, 0.,
                           temps_max, 0.,),);
                          
COEFH=DEFI_FONCTION(NOM_PARA    = 'INST',
                    PROL_DROITE = 'CONSTANT',
                    VALE=( 0.0, -PCO,
                           temps_max, -PCO,),);
                           
COEFV=DEFI_FONCTION(NOM_PARA    = 'INST',
                    PROL_DROITE = 'CONSTANT',
                    VALE=( 0.0, -3.*PCO,
                           temps_max, -3.*PCO,),);

COEXY=DEFI_FONCTION(NOM_PARA='INST',
                    PROL_DROITE='CONSTANT',
                    VALE=( 0.0, 0.0,
                           temps_max, epxy_min),);
axe_char ='DX'

if axe_char=='DX':
  sigm_impose=_F(SIXX=COEFV,
                 SIYY=COEFH,
                 SIZZ=COEFH,)
  epsi_impose=_F(EPXY=COEXY,
                 EPXZ=COEF0,
                 EPYZ=COEF0,)
  sigm_init=_F(SIXX=-3.*PCO,
               SIYY=-PCO,
               SIZZ=-PCO,)
               
elif axe_char=='DY':
  sigm_impose=_F(SIYY=COEFV,
                 SIXX=COEFH,
                 SIZZ=COEFH,)
  epsi_impose=_F(EPXY=COEXY,
                 EPXZ=COEF0,
                 EPYZ=COEF0,)
  sigm_init=_F(SIYY=-3.*PCO,
               SIXX=-PCO,
               SIZZ=-PCO,)
               
elif axe_char=='DZ':
  sigm_impose=_F(SIZZ=COEFV,
                 SIYY=COEFH,
                 SIXX=COEFH,)
  epsi_impose=_F(EPXZ=COEXY,
                 EPXY=COEF0,
                 EPYZ=COEF0,)
  sigm_init=_F(SIZZ=-3.*PCO,
               SIYY=-PCO,
               SIXX=-PCO,)

# Verification de la matrice tangente?
# ====================================
matr_tang =True
verif     =True

if matr_tang & verif:
  comp_incr =_F(RELATION='MOHR_COULOMB',
                TYPE_MATR_TANG='VERIFICATION',
                VALE_PERT_RELA=1.E-10,);
elif matr_tang:
  comp_incr =_F(RELATION='MOHR_COULOMB',
                TYPE_MATR_TANG='PERTURBATION',
                VALE_PERT_RELA=1.E-10,);
else:
  comp_incr =_F(RELATION='MOHR_COULOMB',);
  
TAB_SIG=SIMU_POINT_MAT(INFO=2,
                  COMP_INCR=comp_incr,
                  MATER=SOL,
                  INCREMENT=_F(LIST_INST=TEMPS1,
                               INST_INIT=0.,
                               INST_FIN =tfin,),
                  NEWTON=_F(MATRICE='TANGENTE',
                            REAC_ITER=1,
                            PREDICTION='ELASTIQUE'),
                  CONVERGENCE=_F(RESI_GLOB_RELA = 1.E-10,
                                 ITER_GLOB_MAXI = 15,
                                 ARRET='OUI',),
                  ARCHIVAGE=_F(LIST_INST=TEMPS1,),
                  SIGM_IMPOSE=sigm_impose,
                  EPSI_IMPOSE=epsi_impose,
                  SIGM_INIT=sigm_init,
                  EPSI_INIT=_F(EPXX=0.,
                               EPYY=0.,
                               EPZZ=0.,
                               EPXY=0.,
                               EPXZ=0.,
                               EPYZ=0.,),);
IMPR_TABLE(TABLE=TAB_SIG,);

# ================================================================
#
#            TEST DE LA MATRICE TANGENTE CONSISTENTE
#
# ================================================================

if matr_tang & verif:

  DIFF_MAT=VERI_MATR_TANG();

#   tabt = DIFF_MAT.EXTR_TABLE().values();
#   indi = tabt['I']
#   indj = tabt['J']
#   tab1 = tabt['MAT_TGTE']
#   tab2 = tabt['MAT_PERT']
#   tab3 = tabt['MAT_DIFF']
# 
#   tang = np.identity(6);
#   pert = np.identity(6);
#   diff = np.identity(6);
# 
#   for n,i in enumerate(indi):
#     tang[i-1,indj[n]-1] = tab1[n]
#     pert[i-1,indj[n]-1] = tab2[n]
#     diff[i-1,indj[n]-1] = tab3[n]
# 
#   unit=38       
#   Nom_Fichier= 'tb_tangent.dat';
# 
#   title ='#\n\
# #  VALIDATION DE LA LOI DE MOHR-COULOMB\n\
# #\n\
# #  F = sigma1 - sigma3 + (sigma1 + sigma3) sin(phi) - 2c cos(phi) <= 0\n\
# #\n\
# #  Solution analytique pour un essai triaxial draine\n\
# #\n\
# #  chargement impose: depsi1 = f(t)\n\
# #                     sigma3 = cte\n\
# #\n\
# #  3 inconnues:       sigma1, epsi3, dlambda\n\
# #\n\
# #    << VALIDATION DE LA MATRICE TANGENTE COHERENTE >>\n'
# 
#   DEFI_FICHIER(ACTION='ASSOCIER',
#               FICHIER='./REPE_OUT/'+Nom_Fichier,
#               UNITE=unit,);
#               
#   file =open('./REPE_OUT/'+Nom_Fichier,'w');
# 
#   file.write(title)
#   title=('\n#\n# INSTANT=%f     EPSI_XY=%e\n#\n' %(tfin,epxy_min))
#   file.write(title)
# 
#   impr ='%12.8e'
# 
#   file.write('\n\n MATRICE TANGENTE CALCULEE\n\n');
# 
#   np.savetxt(file,tang,impr,);
# 
#   file.write('\n\n MATRICE TANGENTE PERTURBEE\n\n');
# 
#   np.savetxt(file,pert,impr,);
# 
#   impr ='%.5f'
# 
#   file.write('\n\n DIFFERENCE\n\n');
# 
#   np.savetxt(file,diff,impr,);
# 
#   file.close();
#                   
#   DEFI_FICHIER(ACTION='LIBERER',
#                UNITE=unit,);

  IMPR_TABLE(TABLE=DIFF_MAT);
  
  TEST_TABLE(NOM_PARA='MAT_DIFF',
             TABLE=DIFF_MAT,
             TYPE_TEST='MAX',
             VALE_ABS='OUI',
             # Non-regression
             VALE_CALC=0.19211439881579,
             TOLE_MACHINE=1.e-5,    #TODO TOLE_MACHINE car on compare en absolu
             # Reference
             REFERENCE='AUTRE_ASTER',
             CRITERE='ABSOLU',
             PRECISION=.2,
             VALE_REFE=0.,);

# ================================================================
#                            POST-TRAITEMENTS
# ================================================================
# 
# tsigm = TAB_SIG.EXTR_TABLE().values();
# 
# epxx = tsigm['EPXX'];
# epyy = tsigm['EPYY'];
# epxy = tsigm['EPXY'];
# epzz = tsigm['EPZZ'];
# sixx = tsigm['SIXX'];
# siyy = tsigm['SIYY'];
# sixy = tsigm['SIXY'];
# sizz = tsigm['SIZZ'];
# epvp = tsigm['V1'];
# edvp = tsigm['V2'];
# indi = tsigm['V3'];
# 
# # Verif
# # -------------
# sig1_calc =list( -2.*PCO+np.sqrt(PCO**2.+np.array(sixy)**2.) )
# sig3_calc =list( -2.*PCO-np.sqrt(PCO**2.+np.array(sixy)**2.) )
# 
# co_sigm,co_epsi,co_vari,= [],[],[],;
# 
# # CHAMPS CINEMATIQUES
# # _____________________________
# co_sigm =Defi_Xmcourbe(courbe=co_sigm,
#         #X=epxy, Y=sizz,
#         X=epxy, Y=sig1_calc,
#         legend='SIG1_CALC',
#         color=1,);
#         
# co_sigm =Defi_Xmcourbe(courbe=co_sigm,
#         #X=epxy, Y=sixx,
#         X=epxy, Y=sig3_calc,
#         legend='SIG3_CALC',
#         color=2,);
#         
# co_sigm =Defi_Xmcourbe(courbe=co_sigm,
#         X=epxy, Y=siyy,
#         legend='SIYY',
#         color=3,);
#         
# co_sigm =Defi_Xmcourbe(courbe=co_sigm,
#         X=epxy, Y=sixy,
#         legend='SIXY',
#         color=4,);
#         
# co_epsi =Defi_Xmcourbe(courbe=co_epsi,
#         X=epxy, Y=epxx,
#         legend='EPXX',
#         color=1,);
#         
# co_epsi =Defi_Xmcourbe(courbe=co_epsi,
#         X=epxy, Y=epyy,
#         legend='EPYY',
#         color=4,);
#         
# co_epsi =Defi_Xmcourbe(courbe=co_epsi,
#         X=epxy, Y=epzz,
#         legend='EPZZ',
#         color=5,);
#         
# co_epsi =Defi_Xmcourbe(courbe=co_epsi,
#         X=epxy, Y=epvp,
#         legend='EPVP',
#         color=2,);
#         
# co_epsi =Defi_Xmcourbe(courbe=co_epsi,
#         X=epxy, Y=edvp,
#         legend='EDVP',
#         color=3,);
#         
# co_vari =Defi_Xmcourbe(courbe=co_vari,
#         X=epxy, Y=indi,
#         legend='INDICATEUR PLASTIQUE',
#         color=1,);
#         
# Courbes = [co_sigm,co_epsi,co_vari,];
#            
# Nom_Fichier= ['shear_sigm.agr','shear_epsi.agr','shear_vari.agr',];
#   
# unit=38
# for c in range(len(Nom_Fichier)):
# 
#   DEFI_FICHIER(ACTION='ASSOCIER',
#                FICHIER='./REPE_OUT/'+Nom_Fichier[c],
#                UNITE=unit,);
#                   
#   IMPR_FONCTION(FORMAT='XMGRACE',
#               UNITE=unit,
#               COURBE=Courbes[c]);
#                   
#   DEFI_FICHIER(ACTION='LIBERER',
#                UNITE=unit,);

FIN();
