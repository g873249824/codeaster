# MODIF  DATE 10/10/2012   AUTEUR COURTOIS M.COURTOIS 
# TITRE METHODE DES SOLUTIONS MANUFACTUREES : CONTACT GRANDES DEFORMATIONS 2D
# ssnp150a.para = tps_job 600 mem_job 512Mo ncpus 1 liste_test S
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2012  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                    
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================

# Import du module de calcul symbolique Sympy
import sympy
from Utilitai import TensorModule
from Utilitai import HookeTensor

DEBUT(CODE=_F(NOM='SSNP150A',NIV_PUB_WEB='INTERNET',),
      DEBUG=_F(SDVERI='OUI'),
      IGNORE_ALARM='CALCULEL2_63')


# importation de sympy
X,Y,Z = sympy.symbols('XYZ');


#================================================================================================
# Choix de la solution analytique
#================================================================================================
X3= 0.5

Ux = -0.2*Y*Y*Y*(X-X3)
Uy = -0.05*(X-X3)*(X-X3)*(1+Y)-0.01*Y
U=TensorModule.Tensor([Ux,Uy,0]);



#================================================================================================
# Definition des caracteristiques du materiau
#================================================================================================
E=1;
NU=0.3;


#================================================================================================
# Gradient de deformation et normale a la frontiere de contact
#================================================================================================

NormaleDroite =TensorModule.Tensor([ 1. , 0. , 0.]);
NormaleGauche =TensorModule.Tensor([-1. , 0. , 0.]);
NormaleHaut   =TensorModule.Tensor([ 0. , 1. , 0.]);
NormaleBas    =TensorModule.Tensor([ 0. ,-1. , 0.]);

TenseurIdentite = TensorModule.Tensor([[1.,0.,0],[0.,1.,0],[0.,0.,1.]])

GradientDeformation   = TensorModule.grad(U)+ TenseurIdentite
GradientDeformation_T = GradientDeformation.transpose()
Ftm1                  = GradientDeformation_T.inverse()

Ftm1_N             = Ftm1.produitSimpleContracte(NormaleBas)
ModuleCarre_Ftm1_N = Ftm1_N.produitSimpleContracte(Ftm1_N)
Module_Ftm1_N      = ModuleCarre_Ftm1_N.sqrt()
NormaleContact     = Ftm1_N / Module_Ftm1_N

#================================================================================================
# Tenseur de Green-Lagrange
#================================================================================================

Tenseur_Green__Lagrange =0.5*(GradientDeformation.transpose().produitSimpleContracte(GradientDeformation) - TenseurIdentite)


#================================================================================================
# Deuxieme Tenseur de Piola-Kirchhoff (Force sur configuration non deformee par unite de surface non deformee)
#================================================================================================

C_Iso=HookeTensor.HookeIsotropic(E,NU);

Piola_Kirchhoff_II = C_Iso.produitDoubleContracte(Tenseur_Green__Lagrange);


#================================================================================================
# Premier Tenseur de Piola-Kirchhoff  (Force en configuration deformee par unite de surface non deformee)
#================================================================================================

Piola_Kirchhoff_I = GradientDeformation .produitSimpleContracte(Piola_Kirchhoff_II)


#================================================================================================
# Divergence du Premier Tenseur de Piola-Kirchhoff == terme source
#================================================================================================

Fvol = -TensorModule.div(Piola_Kirchhoff_I);



#================================================================================================
# Assignation des conditions limites
#================================================================================================
#conditions de Neumann
Fsurf_Droite = Piola_Kirchhoff_I.produitSimpleContracte(NormaleDroite);
Fsurf_Gauche = Piola_Kirchhoff_I.produitSimpleContracte(NormaleGauche);
Fsurf_Haut   = Piola_Kirchhoff_I.produitSimpleContracte(NormaleHaut);
Fsurf_Bas    = Piola_Kirchhoff_I.produitSimpleContracte(NormaleBas);

# Valeurs du  Sigma sur la face de Contact
Fsurf_BAS_nn  =  Fsurf_Bas.produitSimpleContracte(NormaleContact);
Fsurf_BAS_t   =  Fsurf_Bas - Fsurf_BAS_nn*NormaleContact;


#================================================================================================
# Transformation des formules pour utilisation dans Aster
#================================================================================================

FUx=FORMULE(VALE=str(U[0]), NOM_PARA=('X','Y') );
FUy=FORMULE(VALE=str(U[1]), NOM_PARA=('X','Y') );

FsurfXD=FORMULE(VALE=str(Fsurf_Droite[0]), NOM_PARA=('X','Y') );
FsurfYD=FORMULE(VALE=str(Fsurf_Droite[1]), NOM_PARA=('X','Y') );

FsurfXG=FORMULE(VALE=str(Fsurf_Gauche[0]), NOM_PARA=('X','Y') );
FsurfYG=FORMULE(VALE=str(Fsurf_Gauche[1]), NOM_PARA=('X','Y') );

FsurfXH=FORMULE(VALE=str(Fsurf_Haut[0]), NOM_PARA=('X','Y') );
FsurfYH=FORMULE(VALE=str(Fsurf_Haut[1]), NOM_PARA=('X','Y') );

FsurfTX=FORMULE(VALE=str(Fsurf_BAS_t[0]), NOM_PARA=('X','Y') );
FsurfTY=FORMULE(VALE=str(Fsurf_BAS_t[1]), NOM_PARA=('X','Y') );

FvolX=FORMULE(VALE=str(Fvol[0]), NOM_PARA=('X','Y') );
FvolY=FORMULE(VALE=str(Fvol[1]), NOM_PARA=('X','Y') );


#================================================================================================
# Debut du modele
#================================================================================================


Mail=LIRE_MAILLAGE(FORMAT='MED',);

Mail=MODI_MAILLAGE(reuse=Mail,
                    MAILLAGE=Mail,
                    ORIE_PEAU_2D=(_F(GROUP_MA='MAITRE'),
                                  _F(GROUP_MA='BAS'),
                                  )
                            );


# Definition du materiau isotrope
Acier=DEFI_MATERIAU(ELAS=_F(E=E, NU=NU,),);

# Definition du transitoire
LINST=DEFI_LIST_REEL(DEBUT=0.0,
                     INTERVALLE=(
                                 _F(JUSQU_A=1., NOMBRE=10,),
                     ),);

RAMPE=DEFI_FONCTION(NOM_PARA='INST',
                    VALE=(0.0, 0.0,
                          1.,  1.0,),
                    PROL_DROITE='LINEAIRE',
                    PROL_GAUCHE='LINEAIRE',);


# Affectation du modele
Modele=AFFE_MODELE(MAILLAGE=Mail,
                 AFFE=_F(TOUT='OUI',
                         PHENOMENE='MECANIQUE',
                         MODELISATION='D_PLAN',),
                 );
# Affectation du materiau
Chmat=AFFE_MATERIAU(MAILLAGE=Mail,
                    AFFE=_F(TOUT='OUI',
                            MATER=Acier,),
                   );


# Affectation des conditions limites
Dirich=AFFE_CHAR_MECA_F(MODELE=Modele,
                        DDL_IMPO=_F(GROUP_MA='HAUT', DX=FUx, DY=FUy, ),
                        );

Neumann=AFFE_CHAR_MECA_F(MODELE=Modele,
                        FORCE_CONTOUR=(
                                       _F(GROUP_MA='DROITE', FX=FsurfXD, FY=FsurfYD,),
                                       _F(GROUP_MA='GAUCHE', FX=FsurfXG, FY=FsurfYG,),
                                       _F(GROUP_MA='BAS',    FX=FsurfTX, FY=FsurfTY,),
                                      ),
                          );

ForceInt=AFFE_CHAR_MECA_F(MODELE=Modele,
                          FORCE_INTERNE=_F(GROUP_MA='SURFACE', FX=FvolX, FY=FvolY,),
                         );

# Affectation des conditions limites
Contact=DEFI_CONTACT(MODELE=Modele,
                     FORMULATION='DISCRETE',
                     ZONE=_F(GROUP_MA_MAIT='MAITRE',
                             GROUP_MA_ESCL='BAS',),
                       );

BlocBase=AFFE_CHAR_CINE(MODELE=Modele,
                        MECA_IMPO=_F(GROUP_MA='MAITRE',
                                     DX=0,DY=0),
                       );
# Phase de resolution proprement dit
Evol=STAT_NON_LINE(MODELE=Modele,
                   CHAM_MATER=Chmat,
                   COMP_INCR=_F(RELATION='ELAS',
                                DEFORMATION='GROT_GDEP',
                                TOUT='OUI',),
                   INCREMENT=_F(LIST_INST=LINST,),
                   NEWTON=_F(REAC_ITER=1,),
                   CONVERGENCE=_F(ITER_GLOB_MAXI=100),
                   CONTACT=Contact,
                   EXCIT=(
                          _F(CHARGE=Neumann,FONC_MULT=RAMPE),
                          _F(CHARGE=Dirich,FONC_MULT=RAMPE),
                          _F(CHARGE=ForceInt,FONC_MULT=RAMPE),
                          _F(CHARGE=BlocBase,),
                          ),
                   SOLVEUR=_F(SYME='OUI'),
                   INFO=1,
                   );

# ========================================================================================
#          Creation de la solution analytique
# ========================================================================================

CHXN=CREA_CHAMP(OPERATION='EXTR', TYPE_CHAM='NOEU_GEOM_R',
                NOM_CHAM='GEOMETRIE', MAILLAGE=Mail, INFO=1);

TEMP1=CREA_CHAMP(OPERATION='AFFE',
                 TYPE_CHAM='NOEU_NEUT_F',
                 MAILLAGE=Mail,
                 AFFE=(_F( GROUP_MA='SURFACE', NOM_CMP = 'X1', VALE_F = FUx),
                       _F( GROUP_MA='SURFACE', NOM_CMP = 'X2', VALE_F = FUy),
                      )
                );

TEMP2=CREA_CHAMP(OPERATION='EVAL',
                 TYPE_CHAM='NOEU_NEUT_R',
                 CHAM_F=TEMP1,
                 CHAM_PARA=CHXN);

Uana=CREA_CHAMP(OPERATION='ASSE',
                TYPE_CHAM='NOEU_DEPL_R',
                MAILLAGE=Mail,
                ASSE=(_F(GROUP_MA='SURFACE',
                         CHAM_GD = TEMP2,
                         NOM_CMP = 'X1',
                         NOM_CMP_RESU = 'DX',),
                      _F(GROUP_MA='SURFACE',
                         CHAM_GD = TEMP2,
                         NOM_CMP = 'X2',
                         NOM_CMP_RESU = 'DY',)
                      )
                );

# ========================================================================================
#          Calcul de l'erreur DIFF = Uana - Ucalc
# ========================================================================================

Ucalc=CREA_CHAMP(OPERATION='EXTR', INST=1.0,
                 NOM_CHAM = 'DEPL' , TYPE_CHAM = 'NOEU_DEPL_R',
                 RESULTAT = Evol ,);


DIFF=CREA_CHAMP(OPERATION='ASSE', TYPE_CHAM='NOEU_DEPL_R',MODELE=Modele,
                PROL_ZERO='OUI',
                ASSE=(_F(GROUP_MA='SURFACE', CHAM_GD=Ucalc,CUMUL='OUI', COEF_R=+1., NOM_CMP='DX', NOM_CMP_RESU='DX',),
                      _F(GROUP_MA='SURFACE', CHAM_GD=Uana, CUMUL='OUI', COEF_R=-1., NOM_CMP='DX', NOM_CMP_RESU='DX',),
                      _F(GROUP_MA='SURFACE', CHAM_GD=Ucalc,CUMUL='OUI', COEF_R=+1., NOM_CMP='DY', NOM_CMP_RESU='DY',),
                      _F(GROUP_MA='SURFACE', CHAM_GD=Uana, CUMUL='OUI', COEF_R=-1., NOM_CMP='DY', NOM_CMP_RESU='DY',),
                      ),
                );


# ========================================================================================
#          Verifications
# ========================================================================================

TEST_RESU(CHAM_NO=_F(
                     TYPE_TEST='SOMM_ABS',
                     CHAM_GD=DIFF,
                     VALE_CALC=4.0388841109908997E-05,),
          )

IMPR_RESU(FORMAT='MED',
          UNITE=80,
          RESU=(_F(CHAM_GD=DIFF,),
                _F(CHAM_GD=Uana,),
                _F(CHAM_GD=Ucalc,),
               ),
          );


FIN();
