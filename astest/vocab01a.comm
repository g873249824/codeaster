# person_in_charge: Christophe-mmn.durand at edf.fr
# TITRE TEST FICTIF POUR PRODUIRE LE VOCABULAIRE DU CATALOGUE DE COMMANDES
# ======================================================================
# COPYRIGHT (C) 1991 - 2012  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
DEBUT(CODE=_F(NIV_PUB_WEB='INTERNET',VISU_EFICAS='NON'),DEBUG=_F(SDVERI='OUI'))


# Ceci n est pas un vrai cas test
#
# le programme python ci-dessous permet de naviguer dans l ensemble des
# commandes du catalogue, et d extraire pour chacune son vocabulaire :
# mots cles simple et facteurs.
#
# Ensuite ce vocabulaire est ordonne et on imprime dans le fichier message
# pour chaque mot la liste des commandes qui le contiennent :
#
#      DDL       :: AFFE_CHAR_ACOU   / AFFE_CHAR_THER   / ...
#      DDL_1     :: AFFE_CHAR_THER   / AFFE_CHAR_MECA_F / ...
#      DDL_2     :: AFFE_CHAR_THER   / AFFE_CHAR_MECA_F /
#
# la methode permettant de recuperer le vocabulaire d une commande est
# get_mc_simp/get_mc_fact de la classe ENTITE (B_ENTITE.py)

from pprint import pprint
from Cata import cata

def get_entite(obj):
    ret = obj.entites.values()
    lsub = []
    for sub in ret:
        if sub.label in ("BLOC", "FACT"):
            lsub.extend(get_entite(sub))
    ret.extend(lsub)
    return ret

commands = []
for name, elem in cata.__dict__.items() :
    if isinstance(elem, OPER):
        commands.append(elem)
    elif isinstance(elem, PROC):
        commands.append(elem)
    elif isinstance(elem, MACRO):
        commands.append(elem)

# extract fr/ang docstrings
lang = {}
for cmd in commands :
    objs = [cmd] + get_entite(cmd)
    for entity in objs:
        if entity.ang:
            lang[id(entity)] = (entity.fr, entity.ang)
for val in lang.values():
    fr = val[0].replace('"', r'\"')
    en = val[1].replace('"', r'\"')
    print "\"{0}\",\"{1}\"".format(fr, en)

vocabulaire = set()
com_voca = {}
for cmd in commands :
    com_voca[cmd.nom] = cmd.get_mc_simp(niv=2) + cmd.get_mc_fact()
    vocabulaire.update(com_voca[cmd.nom])

vocabulaire = list(vocabulaire)
vocabulaire.sort()
print '\n Nombre de mots cles = ', len(vocabulaire)

inv_voca = {}
for command, words in com_voca.items():
    for word in words:
        inv_voca[word] = inv_voca.get(word, set())
        inv_voca[word].add(command)

lines = []
for i in vocabulaire:
    texte = i.ljust(28) + ' :: '
    commands = list(inv_voca[i])
    commands.sort()
    for j in commands:
        texte = texte + j.ljust(17) + '/ '
    lines.append(texte)

print os.linesep.join(lines)


FO = DEFI_FONCTION(NOM_PARA='X',
                   NOM_RESU='Y',
                   VALE=(0., 0.),)

TEST_FONCTION(VALEUR=_F(VALE_CALC=0.0,
                        CRITERE='ABSOLU',
                        VALE_PARA=0.0,
                        FONCTION=FO,),)

FIN()
