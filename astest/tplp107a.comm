# MODIF  DATE 23/08/2011   AUTEUR TARDIEU N.TARDIEU 
# TITRE METHODE DES SOLUTIONS MANUFACTUREES : THERMIQUE 2D
# tplp107a.para = tps_job 600 mem_job 800Mo ncpus 1 liste_test R
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2011  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                    
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================

# Import du module de calcul symbolique Sympy
import sympy

DEBUT(CODE=_F( NOM = 'TPLP107A',NIV_PUB_WEB='INTERNET'),DEBUG=_F(SDVERI='OUI'))

# Concductivite thermique
Lambda=15;

# ========================================================================================
#          Creation de la solution manufacturee
# ========================================================================================

# definition des variables du calcul symbolique
X,Y=sympy.symbols('XY');
S=sympy.Function('S');
T=sympy.Function('T');
N=sympy.Function('N');
F=sympy.Function('F');


# Definition de la solution manufacturee
T=100*(X**6+Y**6);


# Deduction de la fonction source de chaleur, ie: S=-laplacien(F(X,Y))
S=-Lambda*(sympy.diff(sympy.diff(T,X),X)+sympy.diff(sympy.diff(T,Y),Y));


# Deduction des conditions de Neumann
N=Lambda*sympy.diff(T,X);


# ========================================================================================
#          Definition du probleme EF
# ========================================================================================

#Lecture du maillage de depart au format MED
MA=LIRE_MAILLAGE( FORMAT='MED');


#Definition du modele
MO=AFFE_MODELE(MAILLAGE=MA,
               AFFE=_F(TOUT = 'OUI',
                       PHENOMENE='THERMIQUE',
                       MODELISATION='PLAN',),
              );


#Definition du materiau
ACIER=DEFI_MATERIAU(THER=_F(LAMBDA=Lambda),);


# Affectation du champ de materiau
CHMAT=AFFE_MATERIAU(MAILLAGE=MA,
                    AFFE=_F(TOUT='OUI',
                            MATER=ACIER,),
                    );


# Transformation des formules Sympy en formules Aster
TT=FORMULE(NOM_PARA=('X','Y'),VALE=str(T));
SS=FORMULE(NOM_PARA=('X','Y'),VALE=str(S));
NN=FORMULE(NOM_PARA=('X','Y'),VALE=str(N));


# Definition des chargements et conditions aux limites
CLIMIT=AFFE_CHAR_THER_F(MODELE=MO,
                        TEMP_IMPO=(_F(GROUP_MA='GAUCHE',
                                      TEMP=TT,),
                                   _F(GROUP_MA='BAS',
                                      TEMP=TT,),
                                   _F(GROUP_MA='HAUT',
                                      TEMP=TT,),),
                        FLUX_REP=_F(GROUP_MA='DROITE',
                                    FLUN=NN,),
                        SOURCE=_F(GROUP_MA='SURFACE',
                                  SOUR=SS,),
                       );

# Resolution
RESO=THER_LINEAIRE(MODELE=MO,
                   CHAM_MATER=CHMAT,
                   EXCIT=_F(CHARGE=CLIMIT,),
                   );

# ========================================================================================
#          Creation de la solution analytique
# ========================================================================================

CHXN=CREA_CHAMP(OPERATION='EXTR', TYPE_CHAM='NOEU_GEOM_R',
                NOM_CHAM='GEOMETRIE', MAILLAGE=MA, INFO=1);

TEMP1=CREA_CHAMP(OPERATION='AFFE',
                 TYPE_CHAM='NOEU_NEUT_F',
                 MAILLAGE=MA,
                 AFFE=_F( GROUP_MA='SURFACE', NOM_CMP = 'X1', VALE_F = TT),
                );

TEMP2=CREA_CHAMP(OPERATION='EVAL',
                 TYPE_CHAM='NOEU_NEUT_R',
                 CHAM_F=TEMP1,
                 CHAM_PARA=CHXN);

Uana=CREA_CHAMP(OPERATION='ASSE',
                TYPE_CHAM='NOEU_TEMP_R',
                MAILLAGE=MA,
                ASSE=_F(GROUP_MA='SURFACE',
                         CHAM_GD = TEMP2,
                         NOM_CMP = 'X1',
                         NOM_CMP_RESU = 'TEMP',),
                );

# ========================================================================================
#          Calcul de l'erreur DIFF = Uana - Ucalc
# ========================================================================================

Ucalc = CREA_CHAMP(OPERATION='EXTR',
                   NOM_CHAM = 'TEMP' , TYPE_CHAM = 'NOEU_TEMP_R',
                   RESULTAT = RESO ,);


DIFF=CREA_CHAMP(OPERATION='ASSE', TYPE_CHAM='NOEU_TEMP_R',MODELE=MO,
                PROL_ZERO='OUI',
                ASSE=(_F(GROUP_MA='SURFACE', CHAM_GD = Ucalc,CUMUL='OUI',COEF_R=1.,
                         NOM_CMP='TEMP',NOM_CMP_RESU='TEMP',),
                      _F(GROUP_MA='SURFACE', CHAM_GD = Uana,CUMUL='OUI',COEF_R=-1.,
                         NOM_CMP='TEMP',NOM_CMP_RESU='TEMP',),
                      ),
                );

# ========================================================================================
#          Verification
# ========================================================================================

TEST_RESU(CHAM_NO= 
          _F(CHAM_GD= DIFF   , 
             REFERENCE= 'ANALYTIQUE', PRECISION= 1.E-10    ,
             TYPE_TEST= 'SOMM_ABS', VALE=  0.59734630434863 ),
          )


IMPR_RESU(FORMAT='MED',
          UNITE=80,
          RESU=(_F(CHAM_GD=DIFF,),
                _F(CHAM_GD=Uana,),
                _F(CHAM_GD=Ucalc,),
               ),
          );



FIN();

