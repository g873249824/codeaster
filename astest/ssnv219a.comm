# MODIF  DATE 17/01/2012   AUTEUR SELLENET N.SELLENET 
# TITRE METHODE DES SOLUTIONS MANUFACTUREES : CONTACT GRANDES DEFORMATIONS 3D
# ssnv219a.para = tps_job 600 mem_job 800Mo ncpus 1 liste_test R
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2012  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                    
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================

# Import du module de calcul symbolique Sympy
import sympy
import numpy
from Utilitai import TensorModule
from Utilitai import HookeTensor


DEBUT(CODE=_F(NOM='SSNV219A',NIV_PUB_WEB='INTERNET',),
      DEBUG=_F(SDVERI='OUI'),
      IGNORE_ALARM=('CALCULEL2_63','SUPERVIS_1'))

# importation de sympy
import sympy
X,Y,Z=sympy.symbols('XYZ');


#================================================================================================
#================================================================================================
# Principe de la MSM pour une formulation en deplacement de Saint-Venant-Kirchhoff
#================================================================================================
#================================================================================================

#================================================================================================
# Choix de la solution analytique
#================================================================================================
Ux=0.2*(Z**2)*X*Y
Uy=0.2*(Z**2)*X*Y
Uz=-0.2*(1. + X**2 + Y**2)*(1+0.01*Z) -0.01*Z -0.3
U=TensorModule.Tensor([Ux,Uy,Uz]);

#================================================================================================
# Definition des caracteristiques du materiau
#================================================================================================
E=1;
NU=0.3;

#================================================================================================
# Gradient de deformation et Normale a la frontiere de Contact
#================================================================================================

NormaleX =TensorModule.Tensor([ +1. , 0. , 0.]);
NormalemX=TensorModule.Tensor([ -1. , 0. , 0.]);
NormaleY =TensorModule.Tensor([ 0. , +1. , 0.]);
NormalemY=TensorModule.Tensor([ 0. , -1. , 0.]);

NormaleEsclave=TensorModule.Tensor([ 0. , 0. , -1.]);

TenseurIdentite=TensorModule.Tensor([[1.,0.,0],[0.,1.,0],[0.,0.,1.]])

GradientDeformation  =TensorModule.grad(U)+ TenseurIdentite
GradientDeformation_T=GradientDeformation.transpose()
Ftm1                 =GradientDeformation_T.inverse()

Ftm1_N            =Ftm1.produitSimpleContracte(NormaleEsclave)
ModuleCarre_Ftm1_N=Ftm1_N.produitSimpleContracte(Ftm1_N)
Module_Ftm1_N     =ModuleCarre_Ftm1_N.sqrt()
NormaleContact    =Ftm1_N / Module_Ftm1_N

#================================================================================================
# Le Tenseur de Green-Lagrange
#================================================================================================

Tenseur_Green__Lagrange =0.5*(GradientDeformation.transpose().produitSimpleContracte(GradientDeformation) - TenseurIdentite)


#================================================================================================
# Le Deuxieme Tenseur de Piola-Kirchhoff (Force sur configuration non deformee par unite de surface non deformee)
#================================================================================================

C_Iso=HookeTensor.HookeIsotropic(E,NU);

Piola_Kirchhoff_II=C_Iso.produitDoubleContracte(Tenseur_Green__Lagrange);


#================================================================================================
# Le Premier Tenseur de Piola-Kirchhoff  (Force en configuration deformee par unite de surface non deformee)
#================================================================================================

Piola_Kirchhoff_I=GradientDeformation .produitSimpleContracte(Piola_Kirchhoff_II)


#================================================================================================
# La Divergence du Premier Tenseur de Piola-Kirchhoff == terme source
#================================================================================================

Fvol=-TensorModule.div(Piola_Kirchhoff_I);



#================================================================================================
# Assiganation des conditions limites
#================================================================================================
#conditions de Neumann
Fsurf_X =Piola_Kirchhoff_I.produitSimpleContracte(NormaleX);
Fsurf_mX=Piola_Kirchhoff_I.produitSimpleContracte(NormalemX);
Fsurf_Y =Piola_Kirchhoff_I.produitSimpleContracte(NormaleY);
Fsurf_mY=Piola_Kirchhoff_I.produitSimpleContracte(NormalemY);

Fsurf_Esclave   =Piola_Kirchhoff_I.produitSimpleContracte(NormaleEsclave);

# Valeurs du  Sigma sur la face de Contact
Fsurf_Esclave_nn = Fsurf_Esclave.produitSimpleContracte(NormaleContact);
Fsurf_Esclave_t  = Fsurf_Esclave - Fsurf_Esclave_nn*NormaleContact;


#================================================================================================
# Transformation des formules pour utilisation dans Aster
#================================================================================================

FUx=FORMULE(VALE=str(U[0]), NOM_PARA=('X','Y','Z') );
FUy=FORMULE(VALE=str(U[1]), NOM_PARA=('X','Y','Z') );
FUz=FORMULE(VALE=str(U[2]), NOM_PARA=('X','Y','Z') );

FsurfXx=FORMULE(VALE=str(Fsurf_X[0]), NOM_PARA=('X','Y','Z') );
FsurfXy=FORMULE(VALE=str(Fsurf_X[1]), NOM_PARA=('X','Y','Z') );
FsurfXz=FORMULE(VALE=str(Fsurf_X[2]), NOM_PARA=('X','Y','Z') );

FsurfmXx=FORMULE(VALE=str(Fsurf_mX[0]), NOM_PARA=('X','Y','Z') );
FsurfmXy=FORMULE(VALE=str(Fsurf_mX[1]), NOM_PARA=('X','Y','Z') );
FsurfmXz=FORMULE(VALE=str(Fsurf_mX[2]), NOM_PARA=('X','Y','Z') );

FsurfYx=FORMULE(VALE=str(Fsurf_Y[0]), NOM_PARA=('X','Y','Z') );
FsurfYy=FORMULE(VALE=str(Fsurf_Y[1]), NOM_PARA=('X','Y','Z') );
FsurfYz=FORMULE(VALE=str(Fsurf_Y[2]), NOM_PARA=('X','Y','Z') );

FsurfmYx=FORMULE(VALE=str(Fsurf_mY[0]), NOM_PARA=('X','Y','Z') );
FsurfmYy=FORMULE(VALE=str(Fsurf_mY[1]), NOM_PARA=('X','Y','Z') );
FsurfmYz=FORMULE(VALE=str(Fsurf_mY[2]), NOM_PARA=('X','Y','Z') );


FsurfTx=FORMULE(VALE=str(Fsurf_Esclave_t[0]), NOM_PARA=('X','Y','Z') );
FsurfTy=FORMULE(VALE=str(Fsurf_Esclave_t[1]), NOM_PARA=('X','Y','Z') );
FsurfTz=FORMULE(VALE=str(Fsurf_Esclave_t[2]), NOM_PARA=('X','Y','Z') );

Fcontx=FORMULE(VALE=str(Fsurf_Esclave[0]), NOM_PARA=('X','Y','Z') );
Fconty=FORMULE(VALE=str(Fsurf_Esclave[1]), NOM_PARA=('X','Y','Z') );
Fcontz=FORMULE(VALE=str(Fsurf_Esclave[2]), NOM_PARA=('X','Y','Z') );

Fvolx=FORMULE(VALE=str(Fvol[0]), NOM_PARA=('X','Y','Z') );
Fvoly=FORMULE(VALE=str(Fvol[1]), NOM_PARA=('X','Y','Z') );
Fvolz=FORMULE(VALE=str(Fvol[2]), NOM_PARA=('X','Y','Z') );


#================================================================================================
# Debut du modele
#================================================================================================


Mail=LIRE_MAILLAGE(FORMAT='MED',);

Mail=MODI_MAILLAGE(reuse=Mail,
                    MAILLAGE=Mail,
                    ORIE_PEAU_3D=(_F(GROUP_MA='ESCLAVE'),
                                  _F(GROUP_MA='BORDX'),
                                  _F(GROUP_MA='BORDMX'),
                                  _F(GROUP_MA='BORDY'),
                                  _F(GROUP_MA='BORDMY'),
                                  )
                            );


#Definition du materiau cas isotrope
acier=DEFI_MATERIAU(ELAS=_F(E=E, NU=NU,),);

#Definition du transitoire
LINST=DEFI_LIST_REEL(DEBUT=0.0,
                     INTERVALLE=(
                                 _F(JUSQU_A=1., NOMBRE=1,),
                     ),);

RAMPE=DEFI_FONCTION(NOM_PARA='INST',
                    VALE=(0.0, 0.0,
                          1.,  1.0,),
                    PROL_DROITE='LINEAIRE',
                    PROL_GAUCHE='LINEAIRE',);



# Correspondance Modele Maillage
modl=AFFE_MODELE(MAILLAGE=Mail,
                 AFFE=_F(TOUT='OUI',
                         PHENOMENE='MECANIQUE',
                         MODELISATION='3D',),
                 );
## Affectation du materiau
chmat=AFFE_MATERIAU(MAILLAGE=Mail,
                    AFFE=_F(TOUT='OUI',
                            MATER=acier,),
                   );


# affectation des conditions limites
Dirich=AFFE_CHAR_CINE_F(MODELE=modl,
                       MECA_IMPO=_F(GROUP_MA='HAUT', DX=FUx, DY=FUy, DZ=FUz,),
                        );

Neumann=AFFE_CHAR_MECA_F(MODELE=modl,
                        FORCE_FACE=(_F(GROUP_MA='BORDX',   FX=FsurfXx,  FY=FsurfXy,  FZ=FsurfXz,),
                                    _F(GROUP_MA='BORDMX',  FX=FsurfmXx, FY=FsurfmXy, FZ=FsurfmXz,),
                                    _F(GROUP_MA='BORDY',   FX=FsurfYx,  FY=FsurfYy,  FZ=FsurfYz,),
                                    _F(GROUP_MA='BORDMY',  FX=FsurfmYx, FY=FsurfmYy, FZ=FsurfmYz,),
                                    _F(GROUP_MA='ESCLAVE', FX=FsurfTx,  FY=FsurfTy,  FZ=FsurfTz,),
                                      ),
                          );

ForceInt=AFFE_CHAR_MECA_F(MODELE=modl,
                          FORCE_INTERNE=_F(GROUP_MA='VOLUME', FX=Fvolx, FY=Fvoly, FZ=Fvolz,),
                         );

# affectation des conditions limites
Contact=DEFI_CONTACT(MODELE=modl,
                     FORMULATION='CONTINUE',
                     ALGO_RESO_CONT = 'NEWTON',
                     ZONE=_F(GROUP_MA_MAIT=('MAITRE',),
                             GROUP_MA_ESCL=('ESCLAVE',),
                             INTEGRATION='GAUSS',
                             ORDRE_INT=4,                                ),
                       );
                       
BlocEscl=AFFE_CHAR_CINE(MODELE=modl,
                        MECA_IMPO=_F(GROUP_MA='MAITRE',
                                     DX=0,DY=0,DZ=0,),
                       );

EVOLNOLI=STAT_NON_LINE(MODELE=modl,
                       CHAM_MATER=chmat,
                       COMP_INCR=_F(RELATION='ELAS',
                                    DEFORMATION='GROT_GDEP',
                                    TOUT='OUI',),
                       INCREMENT=_F(LIST_INST=LINST,),
                       NEWTON=_F(REAC_ITER=1,),
                       CONVERGENCE=_F(ITER_GLOB_MAXI=100,RESI_GLOB_RELA=1.e-8),
                       CONTACT=Contact,
                       EXCIT=(_F(CHARGE=Neumann,  FONC_MULT=RAMPE),
                              _F(CHARGE=Dirich,   FONC_MULT=RAMPE),
                              _F(CHARGE=ForceInt, FONC_MULT=RAMPE),
                              _F(CHARGE=BlocEscl,),
                              ),
                       );

# ========================================================================================
#          Creation de la solution analytique
# ========================================================================================

CHXN=CREA_CHAMP(OPERATION='EXTR', TYPE_CHAM='NOEU_GEOM_R',
                NOM_CHAM='GEOMETRIE', MAILLAGE=Mail, INFO=1);

TEMP1=CREA_CHAMP(OPERATION='AFFE',
                 TYPE_CHAM='NOEU_NEUT_F',
                 MAILLAGE=Mail,
                 AFFE=(_F( GROUP_MA='VOLUME', NOM_CMP='X1', VALE_F=FUx),
                       _F( GROUP_MA='VOLUME', NOM_CMP='X2', VALE_F=FUy),
                       _F( GROUP_MA='VOLUME', NOM_CMP='X3', VALE_F=FUz),
                      ),);

TEMP2=CREA_CHAMP(OPERATION='EVAL',
                 TYPE_CHAM='NOEU_NEUT_R',
                 CHAM_F=TEMP1,
                 CHAM_PARA=CHXN);

Uana=CREA_CHAMP(OPERATION='ASSE',
                TYPE_CHAM='NOEU_DEPL_R',
                MAILLAGE=Mail,
                ASSE=(_F(GROUP_MA='VOLUME',
                         CHAM_GD=TEMP2,
                         NOM_CMP='X1',
                         NOM_CMP_RESU='DX',),
                      _F(GROUP_MA='VOLUME',
                         CHAM_GD=TEMP2,
                         NOM_CMP='X2',
                         NOM_CMP_RESU='DY',),
                      _F(GROUP_MA='VOLUME',
                         CHAM_GD=TEMP2,
                         NOM_CMP='X3',
                         NOM_CMP_RESU='DZ',)
                      ));


# ========================================================================================
#          Calcul de l'erreur DIFF=Uana - Ucalc
# ========================================================================================

Ucalc=CREA_CHAMP(OPERATION='EXTR',
                 INST=1.,
                 NOM_CHAM='DEPL' , TYPE_CHAM='NOEU_DEPL_R',
                 RESULTAT=EVOLNOLI ,);


DIFF=CREA_CHAMP(OPERATION='ASSE', TYPE_CHAM='NOEU_DEPL_R',MODELE=modl,
                PROL_ZERO='OUI',
                ASSE=(_F(GROUP_MA='VOLUME', CHAM_GD=Ucalc,CUMUL='OUI',COEF_R=+1.,NOM_CMP='DX',NOM_CMP_RESU='DX',),
                      _F(GROUP_MA='VOLUME', CHAM_GD=Uana, CUMUL='OUI',COEF_R=-1.,NOM_CMP='DX',NOM_CMP_RESU='DX',),
                      _F(GROUP_MA='VOLUME', CHAM_GD=Ucalc,CUMUL='OUI',COEF_R=+1.,NOM_CMP='DY',NOM_CMP_RESU='DY',),
                      _F(GROUP_MA='VOLUME', CHAM_GD=Uana, CUMUL='OUI',COEF_R=-1.,NOM_CMP='DY',NOM_CMP_RESU='DY',),
                      _F(GROUP_MA='VOLUME', CHAM_GD=Ucalc,CUMUL='OUI',COEF_R=+1.,NOM_CMP='DZ',NOM_CMP_RESU='DZ',),
                      _F(GROUP_MA='VOLUME', CHAM_GD=Uana, CUMUL='OUI',COEF_R=-1.,NOM_CMP='DZ',NOM_CMP_RESU='DZ',),
                      ),);



# ========================================================================================
#          Verifications
# ========================================================================================

TEST_RESU(CHAM_NO=_F(CHAM_GD= DIFF   ,
                     REFERENCE='ANALYTIQUE', PRECISION=1.E-8    ,
                     TYPE_TEST='SOMM_ABS', VALE=0.088219316257937 ),
          )

IMPR_RESU(FORMAT='MED',
          RESU=(_F(CHAM_GD=DIFF,),
                _F(CHAM_GD=Uana,),
                _F(CHAM_GD=Ucalc,),
               ),
          );


FIN();





