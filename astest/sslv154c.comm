# TITRE  FISSURE CIRCULAIRE EN MODE MIXTE AVEC 3D_INCO_
# ======================================================================
# COPYRIGHT (C) 1991 - 2015  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
DEBUT(CODE=_F(
              NIV_PUB_WEB='INTERNET',
              VISU_EFICAS='OUI'),
      DEBUG=_F(SDVERI='OUI'))

# MODELISATION C : FEM, MAILLAGE QUADRATIQUE ET ELEMENT INCOMPRESSIBLES

# parametres utiles
#------------------

# angle d'inclinaison de la force imposee
alpha = pi / 4.0

# valeur nominale de la force imposee
sig = 1000000.

# rayon de la fissure
a = 2

#-----------------------------------------------------------------------------------------------------------------------------
#                                 CALCUL
#-----------------------------------------------------------------------------------------------------------------------------

MA=LIRE_MAILLAGE(FORMAT='MED')

MA=DEFI_GROUP(reuse =MA,
              MAILLAGE=MA,
              CREA_GROUP_NO=_F(OPTION='NOEUD_ORDO',
                               NOM='NFF3',
                               GROUP_MA='LFF1',
                               GROUP_NO_ORIG='NFF1',
                               GROUP_NO_EXTR='NFF2',),);

# Barsoum
MA=MODI_MAILLAGE(reuse=MA,
                 MAILLAGE=MA,
                 MODI_MAILLE=_F(OPTION='NOEUD_QUART',
                                GROUP_NO_FOND='NFF3'))

MA=MODI_MAILLAGE(reuse =MA,
                 MAILLAGE=MA,
                 ORIE_PEAU_3D=_F(GROUP_MA=('FACE_AV','FACE_SUP','FACE_INF','FACE_LAD','FACE_LAG',),),);

MO = [None]*2
MO[0]=AFFE_MODELE(MAILLAGE=MA,
               AFFE=_F(TOUT='OUI',
                       PHENOMENE='MECANIQUE',
                       MODELISATION='3D_INCO_UPG',),);

MO[1]=AFFE_MODELE(MAILLAGE=MA,
               AFFE=_F(TOUT='OUI',
                       PHENOMENE='MECANIQUE',
                       MODELISATION='3D_INCO_UP',),);
E=2.E11
nu = 0.3
MAT=DEFI_MATERIAU(ELAS=_F(E=E,
                          NU=nu),)


CHMAT=AFFE_MATERIAU(MAILLAGE=MA,
                    AFFE=_F(TOUT='OUI',
                            MATER=MAT,),);

LINST = DEFI_LIST_REEL   ( DEBUT      =  0.,
                           INTERVALLE =_F (JUSQU_A= 1.0, NOMBRE = 1   )
                                         );

FISS=DEFI_FOND_FISS(MAILLAGE=MA,
                    FOND_FISS=_F(GROUP_NO='NFF3'),
                    LEVRE_SUP=_F(GROUP_MA='LEVSUP'),
                    LEVRE_INF=_F(GROUP_MA='LEVINF'),
                    )

RSUP = 0.528
RINF = 0.12

SYME = [None]*2
PRESS = [None]*2
RESU = [None]*2
CG = [None]*2
for i in range(2) :
   SYME[i]=AFFE_CHAR_MECA(MODELE=MO[i],
                      DDL_IMPO=(_F(GROUP_NO='D1',
                                   DX=0,
                                   DZ=0,),
                                _F(GROUP_NO='D2',
                                   DZ=0,),),
                      FACE_IMPO=_F(GROUP_MA='FACE_AV',
                                   DY=0.,),);

   PRESS[i]=AFFE_CHAR_MECA(MODELE=MO[i],
                        FORCE_FACE=(_F(GROUP_MA='FACE_SUP', FX= cos(alpha)*sin(alpha)*sig, FZ= sin(alpha)*sin(alpha)*sig ),
                                    _F(GROUP_MA='FACE_INF', FX=-cos(alpha)*sin(alpha)*sig, FZ=-sin(alpha)*sin(alpha)*sig ),
                                    _F(GROUP_MA='FACE_LAG', FX=-cos(alpha)*cos(alpha)*sig, FZ=-cos(alpha)*sin(alpha)*sig ),
                                    _F(GROUP_MA='FACE_LAD', FX= cos(alpha)*cos(alpha)*sig, FZ= cos(alpha)*sin(alpha)*sig ),
                                    )
                        )

   RESU[i] = STAT_NON_LINE (  MODELE     =   MO[i],
                        CHAM_MATER =   CHMAT,
                        EXCIT=(_F(CHARGE=PRESS[i],),
                               _F(CHARGE=SYME[i],),),
                        COMPORTEMENT  =_F ( RELATION     = 'ELAS',
                                         DEFORMATION  = 'PETIT',
                                         TOUT         = 'OUI'    ),
                        INCREMENT  =_F ( LIST_INST    = LINST, ),
                        CONVERGENCE = _F(
                              RESI_GLOB_MAXI=1e-07,
                              ITER_GLOB_MAXI = 15,
                  ),
                        NEWTON     =_F ( REAC_INCR    = 1,REAC_ITER=0))


#-----------------------------------------------------------------------------------------------------------------------------
#                                 POST-TRAITEMENT
#-----------------------------------------------------------------------------------------------------------------------------

# Methode G-theta
   CG[i]=CALC_G(THETA=_F(FOND_FISS=FISS,
                   R_INF=RINF,
                   R_SUP=RSUP),
          RESULTAT=RESU[i],
          INST = 1,
          OPTION='CALC_K_G')


# formule pour le calcul de l'angle en degre
ANGLE=FORMULE(NOM_PARA=('ABSC_CURV'),VALE='ABSC_CURV/a * 180./pi')

# formules pour les valeurs de reference
K1REF=FORMULE(NOM_PARA=('ANGLE'),VALE=' 2/pi * sig * sin(alpha)**2 * sqrt(pi*a) ')
K2REF=FORMULE(NOM_PARA=('ANGLE'),VALE=' 4./(pi*(2.-nu)) * sig*sin(alpha)*cos(alpha) * cos(ANGLE/180*pi) * sqrt(pi*a)')
K3REF=FORMULE(NOM_PARA=('ANGLE'),VALE=' 4.*(1 - nu)/(pi*(2.-nu)) * sig*sin(alpha)*cos(alpha) * sin(ANGLE/180*pi) * sqrt(pi*a) ')
GREF =FORMULE(NOM_PARA=('ANGLE'),VALE=' (1-nu**2)/E * ( K1REF(ANGLE)**2 + K2REF(ANGLE)**2 ) + (1+nu)/E * K3REF(ANGLE)**2 ')

# valeurs de ref pour les tests obtenus avec sslv134a
k1ref = 8.3611195825061E+05
k2ref_0 = 8.6435469393827E+05
k3ref_90 = 6.7469786391964E+05

# valeurs de ref calcule abtenus avec aster4
k1calmax = 8.5656320339502E+05
k1calmin = 8.4012855590544E+05
k2calc = 8.3533060485032E+05
k3calc = 6.8411187662648E+05

# ajout des colonnes 'angle' et valeurs de ref dans les tables

for i in range(2):
   CG[i]=CALC_TABLE(TABLE=CG[i],
              reuse=CG[i],
              ACTION=(_F(OPERATION='OPER',FORMULE=ANGLE,NOM_PARA='ANGLE'),
                      _F(OPERATION='OPER',FORMULE=K1REF,NOM_PARA='K1REF'),
                      _F(OPERATION='OPER',FORMULE=K2REF,NOM_PARA='K2REF'),
                      _F(OPERATION='OPER',FORMULE=K3REF,NOM_PARA='K3REF'),
                      _F(OPERATION='OPER',FORMULE=GREF ,NOM_PARA='GREF'),
                      )
              )


# impression de chaque table
   IMPR_TABLE(TABLE=CG[i])

#-----------------------------------------------------------------------------------------------------------------------------
#                                 TESTS DES TABLES
#-----------------------------------------------------------------------------------------------------------------------------
# TEST DE CALC_G
#---------------

# test de KI sur tout le fond de fissure
   TEST_TABLE(TABLE=CG[i],
           TYPE_TEST='MAX',
           NOM_PARA='K1',
           VALE_CALC=k1calmax,
           VALE_REFE=k1ref,
           CRITERE='RELATIF',
           PRECISION=0.03,
           REFERENCE='ANALYTIQUE')

   TEST_TABLE(TABLE=CG[i],
           TYPE_TEST='MIN',
           NOM_PARA='K1',
           VALE_CALC=k1calmin,
           VALE_REFE=k1ref,
           CRITERE='RELATIF',
           PRECISION=0.01,
           REFERENCE='ANALYTIQUE')

# test de KII au premier point du fond (angle = 0)
# le signe n'est pas important, mais on ne peut pas tester |K2|
# il se trouve que le K2 de CALC_G est de signe oppose a celui de POST_K
   TEST_TABLE(TABLE=CG[i],
           FILTRE=_F(NOM_PARA='ANGLE',
                     VALE=0.),
           NOM_PARA='K2',
           VALE_CALC=k2calc,
           VALE_REFE=k2ref_0,
           CRITERE='RELATIF',
           PRECISION=0.045,
           REFERENCE='ANALYTIQUE')

# test de KIII au milieu du fond (angle = 90 avec + ou -0.5 degre)
# le signe n'est pas important, mais on ne peut pas tester |K3|
# il se trouve que le K3 de CALC_G est de signe oppose a celui de POST_K
   TEST_TABLE(TABLE=CG[i],
           FILTRE=_F(NOM_PARA='ANGLE',
                     VALE=90.,
                     CRITERE='ABSOLU',
                     PRECISION=0.5,),
           NOM_PARA='K3',
           VALE_CALC=k3calc,
           VALE_REFE=k3ref_90,
           CRITERE='RELATIF',
           PRECISION=0.03,
           REFERENCE='ANALYTIQUE')

FIN()
