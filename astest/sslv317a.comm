# MODIF  DATE 04/10/2010   AUTEUR GNICOLAS G.NICOLAS 
# TITRE PROPAGATION MIXTE D'UNE FISSURE 3D AVEC X-FEM ET RAFFINEMENT ADAPTATIF
# sslv317a.para = tps_job 180 mem_job 512Mo liste_test S
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2010  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                    
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# RESPONSABLE GENIAUT S.GENIAUT
# MODELISATION A : METHODE MAILLAGE DE PROPA_FISS

DEBUT(CODE =_F(NOM='SSLV317A',NIV_PUB_WEB='INTERNET',VISU_EFICAS='NON'),
      DEBUG=_F(SDVERI='OUI'),
      IGNORE_ALARM='CALCULEL2_63',
#      PAR_LOT='NON'
      )

# le PAR_LOT='NON' est necessaire pour :
# - detruire le fort.24 (maillage raffine) entre chaque pas de propagation
# on peut passer en PAR_LOT='OUI', mais il faut alors changer d'UL a chaque fois :
# 24 -> 24+i_propa

import os
longueur=[None]*2
distance=[None]*2
long=[None]*2
dist=[None]*2


#---------------------------------------------------------------------
#                 PARAMETRES UTILISATEUR
#---------------------------------------------------------------------

# taille des elements du maillage grossier initial
h0 = 1.e-3

# caracteristiques de la fissure initiale : centre, rayon et point origine de fond
x0=0.
y0=0.
z0=0.
rayon = 1e-3
pfx= 1.2E-01
pfy= 0
pfz=0


# nombre de pas de propagation a simuler
nb_pas = 2


# Pour la loi de Paris :
damax = 0.1e-3
C = 1.81e-6
m = 3.27
n = 0

# nombre de pas de raffinement Homard
nb_raff = 4

# parametres numeriques pour CALC_G :
h = h0/(2**nb_raff)
rinf = 2.*h
rsup = 5*h


#--------------------------------------------------------------------
#     CONCEPT INDEPENDANT DE L'ITERATION DE PROPAGATION
#--------------------------------------------------------------------

# MATERIAU
MAT=DEFI_MATERIAU(ELAS=_F(E=2.1E11,NU=0.3));
                          

# PSEUDO liste d'instants
L_INST=DEFI_LIST_REEL(DEBUT=0.,INTERVALLE=_F(JUSQU_A=1.0,NOMBRE=1))


# lecture du maillage grossier de la structure
MASTR = LIRE_MAILLAGE(FORMAT='MED')



#--------------------------------------------------------------------
#           boucle sur les pas de propagations
#--------------------------------------------------------------------

lect_ma_ini = 'true'

# modifier cette valeur permet de faire une reprise
pas_debut = 0

for i_propa in xrange(pas_debut,nb_pas) :
   
   print '\n'*2+'#'*60+'\n'+' '*5+'pas de propagation numero',i_propa,'\n'+'#'*60

   # Lecture du maillage de la fissure 
   if i_propa == 0 :
   
      # creation de la fissure initiale : maillage surfacique d'une fissure circulaire de 1 mm de rayon 
      MAX=CO('MAX')
      MABID=CO('MABID')

      PROPA_FISS(METHODE_PROPA='INITIALISATION',
                 MAIL_STRUC=MASTR,
                 MAIL_FISS = MAX,
                 MAIL_TOTAL = MABID,
                 FORM_FISS='ELLIPSE',
                 CENTRE = (x0, y0, z0),
                 DEMI_GRAND_AXE =rayon,
                 DEMI_PETIT_AXE =rayon,
                 VECT_X         =(1.,0.,0.),
                 VECT_Y         =(0.,1.,0.),
                 ANGLE_ORIG     = 0.,
                 ANGLE_EXTR     = 90.,
                 GROUP_MA_FISS  ='FISS',
                 GROUP_MA_FOND  ='FOND',
                 NB_POINT_FOND  = 20 );

      DETRUIRE(CONCEPT=_F(NOM=MABID),INFO=1) 

      # impression du maillage surfacique de la fissure initiale
      # IMPR_RESU(FORMAT='MED',UNITE=22,RESU=_F(MAILLAGE=MAX))   
   
   elif i_propa != 0 :

      # reprise avec un maillage existant
      if lect_ma_ini == 'true' :
         MAX=LIRE_MAILLAGE(FORMAT='MED',UNITE=21)

      # relecture du maillage cree a l'iteration precedente
      else :
         MAX=LIRE_MAILLAGE(FORMAT='MED',UNITE=200+i_propa-1)
         DEFI_FICHIER(ACTION='LIBERER',UNITE=200+i_propa-1)
      
   lect_ma_ini = 'false'


      
#-----------------------------------------------------------------------------------------
#                RAFFINEMENT DU MAILLAGE
#-----------------------------------------------------------------------------------------

 
   # cette procedure raffine le maillage grace a un critere en distance
   # autour de la fissure definie par un GROUP_MA

   # Initialisation
   MA    = [None]*(nb_raff+1)
   LSN   = [None]*(nb_raff+1)
   LST   = [None]*(nb_raff+1)
   CHERR = [None]*(nb_raff+1)


   # Valeur seuil de la taille des mailles raffinees, qui depend du nombre de raffinements prevus
   # Remarque : au debut, les mailles sont tellement grossieres que l'on est oblige de 'forcer' 
   # leur raffinement dans un tore dont le rayon diminue au fur et a mesure des iterations de raffinement
   
   val=[min(1./exp(rayon/5.),1./exp(h0/(2.**k))) for k in range(nb_raff)]
   
   # Superposition du maillage initial grossier de la structure avec le maillae de la fissure
   MA[0] = ASSE_MAILLAGE(MAILLAGE_1 = MASTR,
                         MAILLAGE_2 = MAX,
                         OPERATION='SUPERPOSE')

   MOD=AFFE_MODELE(MAILLAGE=MA[0],
                   AFFE=_F(GROUP_MA='M_TOUT',
                           PHENOMENE='MECANIQUE',
                           MODELISATION='3D'))
                          
   #Definition de la fissure sur le maillage en entree
   FISS=DEFI_FISS_XFEM(MODELE=MOD,
                       DEFI_FISS=_F(GROUP_MA_FISS='FISS_'+str(i_propa),
                                    GROUP_MA_FOND='FOND_'+str(i_propa),),
                       ORIE_FOND=_F(PFON_INI  = (pfx,pfy,pfz),
                                    VECT_ORIE = ( 0., 0., 1.),
                                    POINT_ORIG= ( x0, y0, z0),),)

   # Extraction des level sets
   LSN[0]=CREA_CHAMP(TYPE_CHAM='NOEU_NEUT_R',
                     OPERATION='EXTR',
                     FISSURE=FISS,
                     NOM_CHAM='LNNO')

   LST[0]=CREA_CHAMP(TYPE_CHAM='NOEU_NEUT_R',
                     OPERATION='EXTR',
                     FISSURE=FISS,
                     NOM_CHAM='LTNO')
 
   # Critere initial : on peut utiliser RAFF_XFEM ici car la fissure
   # est definie sur le maillage en entree du raffinement 
   CHERR[0] = RAFF_XFEM(FISSURE=FISS)

   # Formule distance pour une fissure: 1/exp(r)
   MDISTF=FORMULE(NOM_PARA=('X1','X2'),VALE= '1./exp(sqrt(X1**2+X2**2))');

   
   # Raffinements successifs autour du fond de fissure
   # la boucle de raffinement recalcule les level sets par interpolation Homard, puis re-calcul du critere

   for i_raff in xrange(nb_raff) :

      MA[i_raff+1] =CO('MA_%d' % (i_raff+1))
      LSN[i_raff+1]=CO('LSN_%d' % (i_raff+1))
      LST[i_raff+1]=CO('LST_%d' % (i_raff+1))

      MACR_ADAP_MAIL( ADAPTATION='RAFFINEMENT',
                     NIVE_MAX = 8,
                     GROUP_MA='M_ENRI',
                     CHAM_GD = CHERR[i_raff],
                     TYPE_VALEUR_INDICA='V_ABSOLUE',
                     CRIT_RAFF_ABS =val[i_raff],
                     MAILLAGE_N   = MA[i_raff],
                     MAILLAGE_NP1 = MA[i_raff+1],
                     MAJ_CHAM=(_F(TYPE_CHAM='NOEU_NEUT_R',
                                  CHAM_GD  = LSN[i_raff],
                                  CHAM_MAJ = LSN[i_raff+1]),
                               _F(TYPE_CHAM='NOEU_NEUT_R',
                                  CHAM_GD  = LST[i_raff],
                                  CHAM_MAJ = LST[i_raff+1]),),                             
                     ELEMENTS_NON_HOMARD='IGNORER')

      # pour re-calculer le critere, on ne peut plus utiliser RAFF_XFEM 
      # car cette commande aurait besoin de la fissure sur le dernier maillage raffine
      # (on n'a plus de concept sf_fiss_xfem)
      # on re-calcule le critere de distance a la main, a partir des level sets actualisees

      #On renomme le composante X1 en X2
      LSTB=CREA_CHAMP(TYPE_CHAM='NOEU_NEUT_R',
                      OPERATION='ASSE',
                      MAILLAGE=MA[i_raff+1],
                      ASSE=_F(TOUT='OUI',
                              CHAM_GD = LST[i_raff+1],
                              NOM_CMP='X1',
                              NOM_CMP_RESU='X2',),
                        );

      #On affecte a chaque noeud du maillage MA[i_raff+1] la formule MDISTF 
      CHFOR=CREA_CHAMP(TYPE_CHAM='NOEU_NEUT_F',
                        OPERATION='AFFE',
                        MAILLAGE=MA[i_raff+1],
                        AFFE=_F(TOUT='OUI',
                                NOM_CMP='X1',
                                VALE_F=MDISTF,),
                       );

      # On evalue en tout noeud le champ de formules
      CERRB=CREA_CHAMP(TYPE_CHAM='NOEU_NEUT_R',
                       OPERATION='EVAL',
                       CHAM_F=CHFOR,
                       CHAM_PARA=(LSN[i_raff+1],LSTB,));


      #Champ d'Erreur de la fissure 
      CHERR[i_raff+1]=CREA_CHAMP(TYPE_CHAM='NOEU_NEUT_R',
                          OPERATION='ASSE',
                          MAILLAGE=MA[i_raff+1],
                          ASSE=_F(TOUT='OUI',
                                  CHAM_GD = CERRB,
                                  NOM_CMP='X1',
                                  NOM_CMP_RESU='X1',
                                ),
                        ); 

      DETRUIRE(CONCEPT=_F(NOM=(LSTB,CHFOR,CERRB)),INFO=1) 

   # Creation des listes des groupes surfaciques et lineiques correspondants a la fissure
   list_FISS = []
   list_FOND = []
   for i in range(i_propa+1) :
      list_FISS.append('FISS_'+str(i))
      list_FOND.append('FOND_'+str(i))


   # Destruction des groupes surfaciques et lineiques correspondants a la fissure
   MA[nb_raff]=DEFI_GROUP(reuse =MA[nb_raff],
                           MAILLAGE=MA[nb_raff],
                           DETR_GROUP_MA=(_F(NOM=list_FISS),
                                          _F(NOM=list_FOND),),)


   #Impression du dernier maillage raffine de la structure 
   IMPR_RESU(FORMAT='MED',UNITE=24+i_propa,RESU=_F(MAILLAGE=MA[nb_raff]))

   DEFI_FICHIER(ACTION='LIBERER',UNITE=24+i_propa)


   # Menage
   for i in xrange(nb_raff+1) :
      DETRUIRE(CONCEPT=_F(NOM=(MA[i],CHERR[i],LSN[i],LST[i])),INFO=1)

   DETRUIRE(CONCEPT=_F(NOM=(MOD,FISS,MDISTF)),INFO=1)


 
#-----------------------------------------------------------------------------------------
#               RESOLUTION DU PROBLEME
#-----------------------------------------------------------------------------------------


   # Relecture du maillage de la structure raffine
   MA=LIRE_MAILLAGE(FORMAT='MED',UNITE=24+i_propa)  
           
                    
   #Superposition du maillage raffine de la structure avec la fissure 
   MA_INI = ASSE_MAILLAGE(MAILLAGE_1 = MA,
                          MAILLAGE_2 = MAX,
                          OPERATION='SUPERPOSE')

   MOD_SAIN=AFFE_MODELE(MAILLAGE=MA_INI,
                        AFFE=_F(GROUP_MA=('M_TOUT','M_BAS','M_HAUT','M_COTE'),
                                PHENOMENE='MECANIQUE',
                                MODELISATION='3D',),);

   # Definition de la fissure
   FISS=DEFI_FISS_XFEM(MODELE=MOD_SAIN,
                       DEFI_FISS=_F(GROUP_MA_FISS='FISS_'+str(i_propa),
                                    GROUP_MA_FOND='FOND_'+str(i_propa),),
                       ORIE_FOND=_F(PFON_INI  = (pfx,pfy,pfz),   
                                    VECT_ORIE = ( 0., 0., 1.),
                                    POINT_ORIG= ( x0, y0, z0),),)
    
#    #On verifie que la fissure a bien un seul fond, sinon arret immediat du calcul 
#    NBFOND=FISS.FONDMULT.get()
#    if len(NBFOND)!=2 :
#      print'Plusieurs fonds de fissure : ',len(NBFOND)/2
#      FIN()


   MOD_X=MODI_MODELE_XFEM(MODELE_IN=MOD_SAIN,
                          FISSURE=FISS,);


   CHMAT=AFFE_MATERIAU(MAILLAGE=MA_INI,
                       MODELE=MOD_X,
                       AFFE=_F(TOUT='OUI',
                               MATER=MAT,),);

   # Chargements :
   #Encastrement
   ENCAST=AFFE_CHAR_MECA(MODELE=MOD_X,
                         DDL_IMPO=_F(GROUP_MA='M_BAS',DX=0.,DY=0.,DZ=0.))

   #Pression de 1 MPa
   PRESSION=AFFE_CHAR_MECA(MODELE=MOD_X,
                           PRES_REP=_F(GROUP_MA=('M_HAUT','M_COTE'),PRES=-1.e6))

   CHXFEM=AFFE_CHAR_MECA(MODELE=MOD_X,
                         LIAISON_XFEM='OUI')

   # Resolution
   RESU=STAT_NON_LINE(MODELE=MOD_X,
                      CHAM_MATER=CHMAT,
                      EXCIT=(_F(CHARGE=CHXFEM),
                             _F(CHARGE=ENCAST),
                             _F(CHARGE=PRESSION),),
                      COMP_ELAS=_F(RELATION='ELAS'),
                      INCREMENT=_F(LIST_INST=L_INST),
                      NEWTON=_F(REAC_ITER=1),
                      )
                    
  
   # Visualisation X-FEM 
   MA_XFEM=POST_MAIL_XFEM(MODELE=MOD_X)

   MOD_VISU=AFFE_MODELE(MAILLAGE=MA_XFEM,
                        AFFE=_F(TOUT='OUI',
                                PHENOMENE='MECANIQUE',
                                MODELISATION='3D'))

   RES_XFEM=POST_CHAM_XFEM(MODELE_VISU=MOD_VISU,
                           RESULTAT=RESU)

   # Contraintes equivalentes
   RES_XFEM=CALC_ELEM(reuse =RES_XFEM,
                      RESULTAT=RES_XFEM,
                      OPTION=('EQUI_ELGA_SIGM', 'EQUI_ELNO_SIGM'))

   DEFI_FICHIER(ACTION='ASSOCIER',UNITE=100+i_propa,FICHIER='./REPE_OUT/resu_iter_'+str(i_propa)+'.med')

   IMPR_RESU(FORMAT='MED',UNITE=100+i_propa,RESU=_F(RESULTAT=RES_XFEM))

   DEFI_FICHIER(ACTION='LIBERER',UNITE=100+i_propa)


   #-----------------------------------------------------------------------------------------
   #                POST-TRAITEMENT EN MECANIQUE DE LA RUPTURE
   #-----------------------------------------------------------------------------------------

   # LISSAGE LEGENDRE
   # les K sont en Pa.sqrt(m)
   TAB_KG=CALC_G( RESULTAT=RESU,
                  OPTION='CALC_K_G',
                  LISSAGE = _F(LISSAGE_THETA='LEGENDRE',
                               LISSAGE_G='LEGENDRE',
                               DEGRE=3),
                  THETA = _F(R_INF=rinf,
                             R_SUP=rsup,
                             FISSURE=FISS,),);

              
   #Impression de la table brute
   IMPR_TABLE(TABLE=TAB_KG,);

   # test des valeurs de K au dernier pas de propagation
   if i_propa == nb_pas-1 :
   
      TEST_TABLE(TABLE=TAB_KG,
                 NOM_PARA='K1_LOCAL',
                 TYPE_TEST='MAX',
                 VALE=7.92678E+04,
                 CRITERE='RELATIF',
                 PRECISION=0.0001,
                 REFERENCE='NON_REGRESSION');   

      TEST_TABLE(TABLE=TAB_KG,
                 NOM_PARA='K1_LOCAL',
                 TYPE_TEST='MIN',
                 VALE=4.54730E+04,
                 CRITERE='RELATIF',
                 PRECISION=0.0001,
                 REFERENCE='NON_REGRESSION');   

#-----------------------------------------------------------------------------------------
#                PROPAGATION
#-----------------------------------------------------------------------------------------

   MAX1=CO('MAX1')
   MA1=CO('MA1')      

   # attention : les cefficients de la loi de Paris donnes par CENAERO fonctionnent pour un
   # deltaKeq en MPa.sqrt(mm), or la table des K en entree est en Pa.sqrt(m)
   

   PROPA_FISS(METHODE_PROPA='MAILLAGE',
              ITERATION=i_propa+1,
              DA_MAX=damax, # increment d'avancee maximal
              MAIL_STRUC=MA,  #maillage de la structure
              FISSURE=_F(FISS_ACTUELLE  = FISS,
                         MAIL_ACTUEL    = MAX, # maillage initial de la fissure (entree) 
                         MAIL_PROPAGE   = MAX1,# maillage de la fissure surfacique propagee (sortie)
                         TABLE          = TAB_KG,
                         GROUP_MA_FISS='FISS',
                         GROUP_MA_FOND='FOND',
                         ),
              LOI_PROPA=_F(LOI='PARIS',
                           M=m,
                           N=n,
                           C=C*(sqrt(1e3)*1e-6)**m,  
                           MATER=MAT),                                      
              MAIL_TOTAL = MA1,                #fissure en sortie
              COMP_LINE=_F(COEF_MULT_MINI=0.,
                           COEF_MULT_MAXI=1.),
              INFO=1,);

   # Impression du maillage surfacique de la fissure apres propagation
   DEFI_FICHIER(ACTION='ASSOCIER',UNITE=200+i_propa,FICHIER='./REPE_OUT/mail_fiss_fin_iter_'+str(i_propa)+'.med')

   IMPR_RESU(FORMAT='MED',UNITE=200+i_propa,RESU=_F(MAILLAGE=MAX1));

   # Menage avant iteration de propagation suivante
   DETRUIRE(CONCEPT=_F(NOM=(MA,MA_INI,MOD_SAIN,FISS,MOD_X,CHMAT,ENCAST,PRESSION,CHXFEM,
                            RESU,MA_XFEM,MOD_VISU,RES_XFEM,TAB_KG,
                            MAX,MA1,MAX1)),INFO=1)

   # Destruction du fort.24 : fichier contenant le maillage raffine
#   os.remove('fort.24')


FIN()
