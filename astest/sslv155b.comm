# MODIF  DATE 30/04/2012   AUTEUR GENIAUT S.GENIAUT 
# TITRE  FISSURE LENTILLE EN TRACTION
# sslv155b.para = tps_job 30 mem_job 512Mo liste_test S
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2012  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                    
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================

DEBUT(CODE=_F(NOM='SSLV155B',
              NIV_PUB_WEB='INTERNET',
              VISU_EFICAS='OUI'),
      DEBUG=_F(SDVERI='OUI'),
      IGNORE_ALARM='CALCULEL2_63')

# MODELISATION B : X-FEM 2D-AXI, MAILLAGE LINEAIRE

# parametres utiles
#------------------

# angle de la lentile
alpha = pi / 4.0

# valeur nominale de la force imposee
sig = 1000000.

# rayon de la fissure
R = 2.

# rayon circulaire de la lentille
a = R * sin(alpha)

# taille des mailles initiales
h0 = 1.

# taille cible des mailles apres raffinement (la moitie de h de la modelisation A)
h = 0.0125

# nombre de raffinements
# attention, en python log = ln (logarithme neperien)
n = (log(h0)-log(h))/log(2)
nb_raff = int(n)+1

# rayon du disque de raffinement
r_raff = 10*h

# definition des formules utiles pour le calcul des level sets
Rp = R * tan(alpha)
Yh = R - R/cos(alpha)
LN = FORMULE(NOM_PARA=('X','Y'),VALE='sqrt(X**2+(Y-R)**2)-R')
LT = FORMULE(NOM_PARA=('X','Y'),VALE='sqrt(X**2+(Y-Yh)**2)-Rp')

# initialisation
MA    = [None]*(nb_raff+1)
MO    = [None]*nb_raff
CHERR = [None]*nb_raff
FISS  = [None]*nb_raff 

i_raff=0   
MA[i_raff]=LIRE_MAILLAGE(FORMAT='MED')

# boucle de raffinements
for i_raff in range(nb_raff) :

   MO[i_raff]=AFFE_MODELE(MAILLAGE=MA[i_raff],
                          AFFE=_F(TOUT='OUI',
                                  PHENOMENE='MECANIQUE',
                                  MODELISATION='AXIS'))

   FISS[i_raff]=DEFI_FISS_XFEM(MODELE=MO[i_raff],
                               DEFI_FISS=_F(FONC_LT=LT,
                                            FONC_LN=LN,))
      
   # evaluation de l'erreur       
   CHERR[i_raff]=RAFF_XFEM(FISSURE=FISS[i_raff])
   
   # definition du type du maillage n+1
   MA[i_raff+1]=CO('MA_%d' % (i_raff+1))
   
   # valeur du critere de raffinement
   crit = -max(r_raff , h0/(2.**i_raff) )
   
   MACR_ADAP_MAIL(ADAPTATION         = 'RAFFINEMENT',
                  CHAM_GD            = CHERR[i_raff],
                  CRIT_RAFF_ABS      = crit,
                  USAGE_CMP          = 'RELATIF', 
                  MAILLAGE_N         = MA[i_raff],
                  MAILLAGE_NP1       = MA[i_raff+1],
                  ELEMENTS_NON_HOMARD= 'IGNORER')
   
assert(nb_raff == i_raff+1)

# impression du dernier maillage
IMPR_RESU(FORMAT='MED',UNITE=80,RESU=_F(MAILLAGE=MA[nb_raff]))

MA[nb_raff]=MODI_MAILLAGE(reuse =MA[nb_raff],
                          MAILLAGE=MA[nb_raff],
                          ORIE_PEAU_2D=_F(GROUP_MA=('SUP','INF','EXT','AXI')))

MODE=AFFE_MODELE(MAILLAGE=MA[nb_raff],
                 AFFE=_F(TOUT='OUI',
                         PHENOMENE='MECANIQUE',
                         MODELISATION='AXIS',),);

FISSX=DEFI_FISS_XFEM(MODELE=MODE,
                     DEFI_FISS=_F(FONC_LT=LT,
                                  FONC_LN=LN,))

MODX=MODI_MODELE_XFEM(MODELE_IN=MODE,
                      FISSURE=FISSX)

ACIER=DEFI_MATERIAU(ELAS=_F(E=210000e6,
                            NU=0.3))

MATE=AFFE_MATERIAU(MAILLAGE=MA[nb_raff],
                   AFFE=_F(TOUT='OUI',
                           MATER=ACIER))

CHAR=AFFE_CHAR_MECA(MODELE=MODX,
                    DDL_IMPO=(_F(GROUP_MA='AXI',DX=0,),
                              _F(GROUP_NO='D'  ,DY=0,),),
                    PRES_REP=_F(GROUP_MA=('SUP','INF','EXT'),PRES=-sig))

CHXFEM=AFFE_CHAR_MECA(MODELE=MODX,
                      LIAISON_XFEM='OUI')

LIST=DEFI_LIST_REEL(DEBUT=0.,
                    INTERVALLE=_F(JUSQU_A=1.,
                                  NOMBRE=1))

RESU=MECA_STATIQUE(MODELE=MODX,
                   CHAM_MATER=MATE,
                   EXCIT=(_F(CHARGE=CHAR,),
                          _F(CHARGE=CHXFEM)),
                   INST=1.)

# visualisation
MA_VISU=POST_MAIL_XFEM(MODELE=MODX)

MO_VISU=AFFE_MODELE(MAILLAGE=MA_VISU,
                    AFFE=_F(TOUT='OUI',
                            PHENOMENE='MECANIQUE',
                            MODELISATION='AXIS'))

RE_VISU=POST_CHAM_XFEM(MODELE_VISU=MO_VISU,
                       RESULTAT=RESU)

IMPR_RESU(FORMAT='MED',UNITE=81,RESU=_F(RESULTAT=RE_VISU))

CGX=CALC_G(THETA=_F(FISSURE=FISSX,
                    DIRECTION=(cos(alpha),sin(alpha),0),
                    R_INF=2*h,
                    R_SUP=5*h,),
          RESULTAT=RESU,
          INST=1.,
          OPTION='CALC_K_G')

IMPR_TABLE(TABLE=CGX)

PK=POST_K1_K2_K3(MODELISATION='AXIS',
                 FISSURE=FISSX,
                 MATER=ACIER,
                 RESULTAT=RESU,
                 INST=1.,
                 ABSC_CURV_MAXI=5*h)

IMPR_TABLE(TABLE=PK)

K1ref = 0.877*(2/pi)*sig*sqrt(pi*a)
K2ref = 0.235*(2/pi)*sig*sqrt(pi*a)

TEST_TABLE(TABLE=CGX,
           NOM_PARA='K1',
           VALE=K1ref,
           PRECISION=0.015,
           REFERENCE='ANALYTIQUE')

TEST_TABLE(TABLE=CGX,
           NOM_PARA='K2',
           VALE=K2ref,
           PRECISION=0.035,
           REFERENCE='ANALYTIQUE')

TEST_TABLE(TABLE=PK,
           NOM_PARA='K1',
           VALE=K1ref,
           PRECISION=0.065,
           REFERENCE='ANALYTIQUE')

TEST_TABLE(TABLE=PK,
           NOM_PARA='K2',
           VALE=K2ref,
           PRECISION=0.025,
           REFERENCE='ANALYTIQUE')

FIN()
