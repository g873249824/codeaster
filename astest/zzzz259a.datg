# coding=utf-8
######################################################################
######################################################################
######## Fichier principal pour la reconstitution du maillage ########
######################################################################
######################################################################

### This file is generated by SALOME automatically by dump python functionality
######################################################
# DELTA : la structure est de taille (20.0*DELTA, 20.0*DELTA, 60.0*DELTA)
DELTA = 5.
# LG_ARETE = longueur typique d'une arete du maillage
LG_ARETE = 5.*DELTA
#
verbose = 1

import sys
import salome

salome.salome_init()

import salome_notebook
notebook = salome_notebook.notebook
sys.path.insert( 0, r'/home/D68518')

import iparameters
ipar = iparameters.IParameters(salome.myStudy.GetCommonParameters("Interface Applicative", 1))

#Set up visual properties:
ipar.setProperty("AP_ACTIVE_VIEW", "OCCViewer_0_0")
ipar.setProperty("AP_WORKSTACK_INFO", "0000000100000000000000020100000001000003ec000000040000000100000001000000080000001a004f00430043005600690065007700650072005f0030005f00300000000102")
ipar.setProperty("AP_ACTIVE_MODULE", "Geometry")
ipar.setProperty("AP_SAVEPOINT_NAME", "GUI state: 1")
#Set up lists:
# fill list AP_VIEWERS_LIST
ipar.append("AP_VIEWERS_LIST", "OCCViewer_1")
# fill list OCCViewer_1
ipar.append("OCCViewer_1", "OCC scene:1 - viewer:1")
ipar.append("OCCViewer_1", "scale=1.000000000000e+00*centerX=0.000000000000e+00*centerY=0.000000000000e+00*projX=5.773502588272e-01*projY=-5.773502588272e-01*projZ=5.773502588272e-01*twist=0.000000000000e+00*atX=0.000000000000e+00*atY=0.000000000000e+00*atZ=0.000000000000e+00*eyeX=2.886751294136e+02*eyeY=-2.886751294136e+02*eyeZ=2.886751294136e+02*scaleX=1.000000000000e+00*scaleY=1.000000000000e+00*scaleZ=1.000000000000e+00*isVisible=1*size=1.00*gtIsVisible=0*gtDrawNameX=1*gtDrawNameY=1*gtDrawNameZ=1*gtNameX=X*gtNameY=Y*gtNameZ=Z*gtNameColorRX=255*gtNameColorGX=0*gtNameColorBX=0*gtNameColorRY=0*gtNameColorGY=255*gtNameColorBY=0*gtNameColorRZ=0*gtNameColorGZ=0*gtNameColorBZ=255*gtDrawValuesX=1*gtDrawValuesY=1*gtDrawValuesZ=1*gtNbValuesX=3*gtNbValuesY=3*gtNbValuesZ=3*gtOffsetX=2*gtOffsetY=2*gtOffsetZ=2*gtColorRX=255*gtColorGX=0*gtColorBX=0*gtColorRY=0*gtColorGY=255*gtColorBY=0*gtColorRZ=0*gtColorGZ=0*gtColorBZ=255*gtDrawTickmarksX=1*gtDrawTickmarksY=1*gtDrawTickmarksZ=1*gtTickmarkLengthX=5*gtTickmarkLengthY=5*gtTickmarkLengthZ=5")
# fill list AP_MODULES_LIST
ipar.append("AP_MODULES_LIST", "Geometry")


import a_GEOM
a_GEOM.RebuildData(salome.myStudy, DELTA, verbose)
import a_SMESH
a_SMESH.RebuildData(salome.myStudy, DELTA, LG_ARETE, verbose)

if salome.sg.hasDesktop():
        salome.sg.updateObjBrowser(1)
        iparameters.getSession().restoreVisualState(1)
#
from geompy import *
#fic = os.path.join ( "/home", "D68518", "a.hdf" )
import os
fic = os.path.join ( "/local00", "a.hdf" )
###myStudyManager.SaveAs ( fic, myStudy, 0 )
###myStudyManager.Close ( myStudy )
#
#
###sys.exit(None)
######################################################

######################################################################
######################################################################
############## Fichier des instructions du module GEOM ###############
######################################################################
######################################################################
# coding=utf-8
### This file is generated by SALOME automatically by dump python functionality
### of GEOM component

import GEOM
import geompy
import math
import SALOMEDS

def RebuildData(theStudy, DELTA, verbose):
#
  geompy.init_geom(theStudy)
#
  global ORIGINE_1, ORIGINE_2, AXE_1, AXE_2
  global NORMALE, PLAN, BLOC
  global Piq_d
#
  global POINT
#
  global IN2_EA, IN2_EB
  global IN2_IA, IN2_IB
  global INT_EA, INT_EB
  global INT_IA, INT_IB
#
  global T1_EXT_I, T1_EXT_O, T1_INT_I, T1_INT_O
  global T2_EXT, T2_INT
  global OUT
  global IN1, IN2
#
  global VOLUME
#
# 1. Les bases de construction
#
  LG = 5.*DELTA
#
  axe_1_x = 1.
  axe_1_y = 2.
  axe_1_z = 3.
  AXE_1 = geompy.MakeVectorDXDYDZ(axe_1_x*LG, axe_1_y*LG, axe_1_z*LG)
  ORIGINE_1 = geompy.MakeVertex(0, LG, -LG)
#
  axe_2_x = -4.
  axe_2_y = -3.
  axe_2_z = -1.
#       On decale l'origine dans le sens perpendiculaire aux plans
#       forme par les deux axes
  d_x = (axe_1_y*axe_2_z) - (axe_1_z*axe_2_y)
  d_y = (axe_1_z*axe_2_x) - (axe_1_x*axe_2_z)
  d_z = (axe_1_x*axe_2_y) - (axe_1_y*axe_2_x)
#  print d_x,d_y,d_z
  aux = 0.1*LG
  ORIGINE_2 = geompy.MakeTranslation(ORIGINE_1, d_x*aux, d_y*aux, d_z*aux)
  ORIGINE_2a = geompy.MakeTranslation(ORIGINE_2, axe_2_x*LG, axe_2_y*LG, axe_2_z*LG)
  AXE_2 = geompy.MakeVector(ORIGINE_2, ORIGINE_2a)
# On cree un plan pour la future partition
  axe_1_x = 4.
  axe_1_y = 4.
  axe_1_z = 1.
  NORMALE = geompy.MakeVectorDXDYDZ(axe_1_x*LG, axe_1_y*LG, axe_1_z*LG)
  PLAN = geompy.MakePlane(ORIGINE_2, NORMALE, 20.*LG)
#
# 2. La forme
# 2.1. Le tuyau principal
#
  geompy.TrsfOp.TranslateVectorDistance(ORIGINE_1, AXE_1, -10.*LG, 0)
  lg_tuyau_1 = 16.*LG
  ri_tuyau_1 = 3.*LG
  re_tuyau_1 = 4.*LG
  if ( verbose ) :
    print 'Tuyau 1 (ri, re, h) :', ri_tuyau_1, re_tuyau_1, lg_tuyau_1
  Cylindre_1 = geompy.MakeCylinder(ORIGINE_1, AXE_1, re_tuyau_1, lg_tuyau_1)
#
# 2.2. Le tuyau secondaire, avec une coupe sur une extremite
#      On le tourne pour ne pas avoir de trop petits segments sur l'intersection
#
  lg_tuyau_2 = 15.*LG
  ri_tuyau_2 = 1.*LG
  re_tuyau_2 = 2.*LG
  angle_2 = 60.
  if ( verbose ) :
    print 'Tuyau 2 (ri, re, h) :', ri_tuyau_2, re_tuyau_2, lg_tuyau_2
    print '         angle :', angle_2
  Cylindre_2_init = geompy.MakeCylinder(ORIGINE_2, AXE_2, re_tuyau_2, lg_tuyau_2)
  geompy.Rotate(Cylindre_2_init, AXE_2, angle_2*math.pi/180.0)
#
  tuyau_2_coupe = geompy.MakeBoxDXDYDZ(40.*DELTA, 40.*DELTA, 40.*DELTA)
  geompy.TranslateDXDYDZ(tuyau_2_coupe, -86.*DELTA, -60*DELTA, -30.*DELTA)
  Cylindre_2 = geompy.MakeCut(Cylindre_2_init, tuyau_2_coupe)
#
# 2.3. Le piquage
#
  Piq_a = geompy.MakeFuse(Cylindre_1, Cylindre_2)
#
# 2.3. Percement du piquage
#
  tuyau_1_perce = geompy.MakeCylinder(ORIGINE_1, AXE_1, ri_tuyau_1, 10.*lg_tuyau_1)
  geompy.TrsfOp.TranslateVectorDistance(tuyau_1_perce, AXE_1, -5.*lg_tuyau_1, 0)
  tuyau_2_perce = geompy.MakeCylinder(ORIGINE_2, AXE_2, ri_tuyau_2, 2.*lg_tuyau_2)
  geompy.Rotate(tuyau_2_perce, AXE_2, angle_2*math.pi/180.0)
#
#       Dans cet ordre, c'est bon :
  Piq_b = geompy.MakeCut(Piq_a, tuyau_2_perce)
  Piq_c = geompy.MakeCut(Piq_b, tuyau_1_perce)
#
#       Dans cet ordre, c'est pas bon :
#  Piq_b_bis = geompy.MakeCut(Piq_a, tuyau_1_perce)
#  Piq_c_bis = geompy.MakeCut(Piq_b_bis, tuyau_2_perce)
#
# 2.4. Partionnement du piquage
#
  BLOC = geompy.MakePrismVecH(PLAN, NORMALE, 8*LG)
  Piq_d = geompy.MakePartition([Piq_c], [BLOC], [], [], geompy.ShapeType["SOLID"], 0, [], 0)
#
# 3. Les groupes
# 3.1. Outils auxiliaires
  sphere_englobante = geompy.MakeSpherePntR(ORIGINE_1, 100.*LG)
#
# 3.2. Le volume
#
  l_aux = geompy.GetShapesOnShapeIDs(sphere_englobante, Piq_d, geompy.ShapeType["SOLID"], geompy.GEOM.ST_ONIN)
  if ( verbose ) :
    print 'tous les volumes :', l_aux
  VOLUME = geompy.CreateGroup(Piq_d, geompy.ShapeType["SOLID"])
  geompy.UnionIDs(VOLUME, l_aux)
  Piq_d = geompy.GetMainShape(VOLUME)
#
# 3.2. Les faces
# 3.2.1. Toutes les faces
#
  l_aux = geompy.GetShapesOnShapeIDs(sphere_englobante, Piq_d, geompy.ShapeType["FACE"], geompy.GEOM.ST_ONIN)
  if ( verbose ) :
    print 'toutes les faces :', l_aux
#
# 3.2.1. Les entrees
#
  l_IN1 = geompy.GetShapesOnSphereIDs ( Piq_d,geompy.ShapeType["FACE"], ORIGINE_1, re_tuyau_1,geompy.GEOM.ST_ONIN)
  if ( verbose ) :
    print "faces entree 1 :", l_IN1
  IN1 = geompy.CreateGroup(Piq_d, geompy.ShapeType["FACE"])
  geompy.UnionIDs(IN1, l_IN1)
  Piq_d = geompy.GetMainShape(IN1)
  for face_id in l_IN1 :
    l_aux.remove(face_id)
  if ( verbose ) :
    print '. faces restantes :', l_aux
#
  l_IN2 = geompy.GetShapesOnShapeIDs(tuyau_2_coupe, Piq_d, geompy.ShapeType["FACE"], geompy.GEOM.ST_ONIN)
  if ( verbose ) :
    print "faces entree 2 :", l_IN2
  IN2 = geompy.CreateGroup(Piq_d, geompy.ShapeType["FACE"])
  geompy.UnionIDs(IN2, l_IN2)
  Piq_d = geompy.GetMainShape(IN2)
  for face_id in l_IN2 :
    l_aux.remove(face_id)
  if ( verbose ) :
    print '. faces restantes :', l_aux
#
# 3.2.2. Le tuyau principal
#        On trie les faces selon leur inclusion dans le bloc qui a servi a la partition
# 3.2.2.1. Interieur
#
  l_T1_INT = geompy.GetShapesOnShapeIDs(tuyau_1_perce, Piq_d, geompy.ShapeType["FACE"], geompy.GEOM.ST_ONIN)
  l_aux_1 = geompy.GetShapesOnShapeIDs(BLOC, Piq_d, geompy.ShapeType["FACE"], geompy.GEOM.ST_IN)
  if ( verbose ) :
    print "faces interieures 1 :", l_T1_INT
    print "faces dans le bloc :", l_aux_1
  l_aux_i = []
  l_aux_o = []
  for face_id in l_T1_INT :
    if face_id in l_aux_1 :
      l_aux_o.append(face_id)
    else :
      l_aux_i.append(face_id)
  T1_INT_I = geompy.CreateGroup(Piq_d, geompy.ShapeType["FACE"])
  geompy.UnionIDs(T1_INT_I, l_aux_i)
  Piq_d = geompy.GetMainShape(T1_INT_I)
  T1_INT_O = geompy.CreateGroup(Piq_d, geompy.ShapeType["FACE"])
  geompy.UnionIDs(T1_INT_O, l_aux_o)
  Piq_d = geompy.GetMainShape(T1_INT_O)
  for face_id in l_T1_INT :
    l_aux.remove(face_id)
  if ( verbose ) :
    print '. faces restantes :', l_aux
#
# 3.2.2.2. Exterieur
#
  Cylindre_10 = geompy.MakeCylinder(ORIGINE_1, AXE_1, re_tuyau_1, 2*lg_tuyau_1)
  geompy.TranslateVectorDistance(Cylindre_10, AXE_1, -10*LG, 0)
  l_T1_EXT = geompy.GetShapesOnShapeIDs(Cylindre_10, Piq_d, geompy.ShapeType["FACE"], geompy.GEOM.ST_ON)
  l_aux_1 = geompy.GetShapesOnShapeIDs(BLOC, Piq_d, geompy.ShapeType["FACE"], geompy.GEOM.ST_IN)
  if ( verbose ) :
    print "faces exterieures 1 :", l_T1_EXT
    print "faces dans le bloc :", l_aux_1
  l_aux_i = []
  l_aux_o = []
  for face_id in l_T1_EXT :
    if face_id in l_aux_1 :
      l_aux_o.append(face_id)
    else :
      l_aux_i.append(face_id)
  T1_EXT_I = geompy.CreateGroup(Piq_d, geompy.ShapeType["FACE"])
  geompy.UnionIDs(T1_EXT_I, l_aux_i)
  Piq_d = geompy.GetMainShape(T1_EXT_I)
  T1_EXT_O = geompy.CreateGroup(Piq_d, geompy.ShapeType["FACE"])
  geompy.UnionIDs(T1_EXT_O, l_aux_o)
  Piq_d = geompy.GetMainShape(T1_EXT_O)
  for face_id in l_T1_EXT :
    l_aux.remove(face_id)
  if ( verbose ) :
    print '. faces restantes :', l_aux
#
# 3.2.3. Le tyau secondaire
# 3.2.3.1. Interieur
#
  l_T2_INT = geompy.GetShapesOnShapeIDs(tuyau_2_perce, Piq_d, geompy.ShapeType["FACE"], geompy.GEOM.ST_ONIN)
  if ( verbose ) :
    print "faces interieures 2 :", l_T2_INT
  T2_INT = geompy.CreateGroup(Piq_d, geompy.ShapeType["FACE"])
  geompy.UnionIDs(T2_INT, l_T2_INT)
  Piq_d = geompy.GetMainShape(T2_INT)
  for face_id in l_T2_INT :
    l_aux.remove(face_id)
  if ( verbose ) :
    print '. faces restantes :', l_aux
#
# 3.2.3.2. Exterieur
#
  Cylindre_20 = geompy.MakeCylinder(ORIGINE_2, AXE_2, re_tuyau_2, 100.*LG)
  geompy.Rotate(Cylindre_20, AXE_2, angle_2*math.pi/180.0)
  l_T2_EXT = geompy.GetShapesOnShapeIDs(Cylindre_20, Piq_d, geompy.ShapeType["FACE"], geompy.GEOM.ST_ON)
  if ( verbose ) :
    print "faces exterieures 2 :", l_T2_EXT
  T2_EXT = geompy.CreateGroup(Piq_d, geompy.ShapeType["FACE"])
  geompy.UnionIDs(T2_EXT, l_T2_EXT)
  Piq_d = geompy.GetMainShape(T2_EXT)
  for face_id in l_T2_EXT :
    l_aux.remove(face_id)
  if ( verbose ) :
    print '. faces restantes :', l_aux
#
# 3.2.4. La sortie
#
  l_aux_1 = geompy.GetShapesOnShapeIDs(BLOC, Piq_d, geompy.ShapeType["FACE"], geompy.GEOM.ST_IN)
  if ( verbose ) :
    print "La sortie :", l_aux
    print "faces dans le bloc :", l_aux_1
  l_aux_o = []
  for face_id in l_aux :
    if face_id in l_aux_1 :
      l_aux_o.append(face_id)
  OUT = geompy.CreateGroup(Piq_d, geompy.ShapeType["FACE"])
  geompy.UnionIDs(OUT, l_aux_o)
  Piq_d = geompy.GetMainShape(OUT)
#
# 3.3. Les aretes
# 3.3.1. Les aretes de l'entree du tuyau 2
#
  l_IN2 = geompy.GetShapesOnShapeIDs(tuyau_2_coupe, Piq_d, geompy.ShapeType["EDGE"], geompy.GEOM.ST_ONIN)
  if ( verbose ) :
    print "aretes IN2 :", l_IN2
  l_T2_EXT = geompy.GetShapesOnShapeIDs(Cylindre_20, Piq_d, geompy.ShapeType["EDGE"], geompy.GEOM.ST_ON)
  if ( verbose ) :
    print "aretes exterieures 2 :", l_T2_EXT
  l_aux_i = []
  l_aux_e = []
  for edge_id in l_IN2 :
    if edge_id in l_T2_EXT :
      l_aux_e.append(edge_id)
    else :
      l_aux_i.append(edge_id)
  if ( verbose ) :
    print 'aretes externes entree 2 :', l_aux_e
    print 'aretes internes entree 2 :', l_aux_i
# Attention il faut scinder en 2 à cause du suivi de frontiere HOMARD
# On coupe n'importe ou.
  IN2_EA = geompy.CreateGroup ( Piq_d, geompy.ShapeType["EDGE"] )
  geompy.UnionIDs ( IN2_EA, [l_aux_e[0]] )
  Piq_d = geompy.GetMainShape(IN2_EA)
  IN2_EB = geompy.CreateGroup ( Piq_d, geompy.ShapeType["EDGE"] )
  geompy.UnionIDs ( IN2_EB, l_aux_e[1:] )
  Piq_d = geompy.GetMainShape(IN2_EB)
  IN2_IA = geompy.CreateGroup ( Piq_d, geompy.ShapeType["EDGE"] )
  geompy.UnionIDs ( IN2_IA, [l_aux_i[0]] )
  Piq_d = geompy.GetMainShape(IN2_IA)
  IN2_IB = geompy.CreateGroup ( Piq_d, geompy.ShapeType["EDGE"] )
  geompy.UnionIDs ( IN2_IB, l_aux_i[1:] )
  Piq_d = geompy.GetMainShape(IN2_IB)
#
# 3.3.2. Les aretes de l'intersection
# 3.3.2.1. Exterieur
#
  l_T2_EXT = geompy.GetShapesOnShapeIDs(Cylindre_20, Piq_d, geompy.ShapeType["EDGE"], geompy.GEOM.ST_ONIN)
  if ( verbose ) :
    print "aretes exterieures 2 :", l_T2_EXT
  l_T1_EXT = geompy.GetShapesOnShapeIDs(Cylindre_10, Piq_d, geompy.ShapeType["EDGE"], geompy.GEOM.ST_ON)
  if ( verbose ) :
    print "aretes exterieures 1 :", l_T1_EXT
  l_aux = []
  for edge_id in l_T2_EXT :
    if edge_id in l_T1_EXT :
      l_aux.append(edge_id)
  if ( verbose ) :
    print 'aretes externes intersection :', l_aux
# Attention il faut scinder en 2 à cause du suivi de frontiere HOMARD
# On coupe n'importe ou.
  INT_EA = geompy.CreateGroup ( Piq_d, geompy.ShapeType["EDGE"] )
  geompy.UnionIDs ( INT_EA, [l_aux[0]] )
  Piq_d = geompy.GetMainShape(INT_EA)
  INT_EB = geompy.CreateGroup ( Piq_d, geompy.ShapeType["EDGE"] )
  geompy.UnionIDs ( INT_EB, l_aux[1:] )
  Piq_d = geompy.GetMainShape(INT_EB)
#
# 3.3.2.2. Interieur
#
  l_T1_INT = geompy.GetShapesOnShapeIDs(tuyau_1_perce, Piq_d, geompy.ShapeType["EDGE"], geompy.GEOM.ST_ON)
  if ( verbose ) :
    print "aretes interieures 1 :", l_T1_INT
  l_T2_INT = geompy.GetShapesOnShapeIDs(tuyau_2_perce, Piq_d, geompy.ShapeType["EDGE"], geompy.GEOM.ST_ON)
  if ( verbose ) :
    print "aretes interieures 2 :", l_T2_INT
  l_aux = []
  for edge_id in l_T2_INT :
    if edge_id in l_T1_INT :
      l_aux.append(edge_id)
  if ( verbose ) :
    print 'aretes internes intersection :', l_aux
# Attention il faut scinder en 2 à cause du suivi de frontiere HOMARD
# On coupe n'importe ou.
  INT_IA = geompy.CreateGroup ( Piq_d, geompy.ShapeType["EDGE"] )
  geompy.UnionIDs ( INT_IA, [l_aux[0]] )
  Piq_d = geompy.GetMainShape(INT_IA)
  INT_IB = geompy.CreateGroup ( Piq_d, geompy.ShapeType["EDGE"] )
  geompy.UnionIDs ( INT_IB, l_aux[1:] )
  Piq_d = geompy.GetMainShape(INT_IB)
#
# 3.4. Un point de l'intersection externe
#
  l_T1_EXT = geompy.GetShapesOnShapeIDs(Cylindre_10, Piq_d, geompy.ShapeType["VERTEX"], geompy.GEOM.ST_ON)
  l_T2_EXT = geompy.GetShapesOnShapeIDs(Cylindre_20, Piq_d, geompy.ShapeType["VERTEX"], geompy.GEOM.ST_ON)
  if ( verbose ) :
    print "sommets exterieurs 1 :", l_T1_EXT
    print "sommets exterieurs 2 :", l_T2_EXT
  l_aux = []
  for vertex_id in l_T2_EXT :
    if vertex_id in l_T1_EXT :
      l_aux.append(vertex_id)
  if ( verbose ) :
    print 'sommets externes intersection :', l_aux
    print 'on garde :', l_aux[0]
  POINT = geompy.CreateGroup ( Piq_d, geompy.ShapeType["VERTEX"] )
  geompy.UnionIDs ( POINT, [l_aux[0]] )
  Piq_d = geompy.GetMainShape(POINT)
#
# 4. L'afichage
#
  geompy.addToStudy( ORIGINE_1, "ORIGINE_1" )
  geompy.addToStudy( ORIGINE_2, "ORIGINE_2" )
  geompy.addToStudy( ORIGINE_2a, "ORIGINE_2a" )
  geompy.addToStudy( AXE_1, "AXE_1" )
  geompy.addToStudy( AXE_2, "AXE_2" )
  geompy.addToStudy( NORMALE, "NORMALE" )
  geompy.addToStudy( PLAN, "PLAN" )
  geompy.addToStudy( BLOC, "BLOC" )
#
  geompy.addToStudy( Cylindre_1, "Cylindre_1" )
  geompy.addToStudy( Cylindre_2_init, "Cylindre_2_init" )
  geompy.addToStudy( Cylindre_2, "Cylindre_2" )
#
  geompy.addToStudy( tuyau_2_coupe, "tuyau_2_coupe" )
  geompy.addToStudy( tuyau_1_perce, "tuyau_1_perce" )
  geompy.addToStudy( tuyau_2_perce, "tuyau_2_perce" )
#
  geompy.addToStudy( Piq_a, "Piq_a" )
  geompy.addToStudy( Piq_b, "Piq_b" )
  geompy.addToStudy( Piq_c, "Piq_c" )
  geompy.addToStudy( Piq_d, "PIQUAGE" )
#  geompy.addToStudy( Piq_b_bis, "Piq_b_bis" )
#  geompy.addToStudy( Piq_c_bis, "PIQUAGE_NOOK" )
#
  geompy.addToStudyInFather( Piq_d, VOLUME, "VOLUME" )
#
  geompy.addToStudyInFather( Piq_d, T1_EXT_I, "T1_EXT_I" )
  geompy.addToStudyInFather( Piq_d, T1_EXT_O, "T1_EXT_O" )
  geompy.addToStudyInFather( Piq_d, T1_INT_I, "T1_INT_I" )
  geompy.addToStudyInFather( Piq_d, T1_INT_O, "T1_INT_O" )
  geompy.addToStudyInFather( Piq_d, T2_INT, "T2_INT" )
  geompy.addToStudyInFather( Piq_d, T2_EXT, "T2_EXT" )
  geompy.addToStudyInFather( Piq_d, OUT, "OUT" )
  geompy.addToStudyInFather( Piq_d, IN1, "IN1" )
  geompy.addToStudyInFather( Piq_d, IN2, "IN2" )
#
  geompy.addToStudyInFather( Piq_d, IN2_EA, "IN2_EA" )
  geompy.addToStudyInFather( Piq_d, IN2_EB, "IN2_EB" )
  geompy.addToStudyInFather( Piq_d, IN2_IA, "IN2_IA" )
  geompy.addToStudyInFather( Piq_d, IN2_IB, "IN2_IB" )
  geompy.addToStudyInFather( Piq_d, INT_EA, "INT_EA" )
  geompy.addToStudyInFather( Piq_d, INT_EB, "INT_EB" )
  geompy.addToStudyInFather( Piq_d, INT_IA, "INT_IA" )
  geompy.addToStudyInFather( Piq_d, INT_IB, "INT_IB" )
#
  geompy.addToStudyInFather( Piq_d, POINT, "POINT" )
#
  pass


######################################################################
######################################################################
############## Fichier des instructions du module SMESH ##############
######################################################################
######################################################################
# coding=utf-8
### This file is generated by SALOME automatically by dump python functionality of SMESH component

import salome, SMESH
import smesh

## import GEOM dump file ##
import string, os, sys, re
sys.path.insert( 0, os.path.dirname(__file__) )
exec("from "+re.sub("SMESH$","GEOM",__name__)+" import *")

#
def RebuildData(theStudy, DELTA, LG_ARETE, verbose):
#
  global ORIGINE, AXE_1, AXE_2
  global Piq_d
#
  global POINT
#
  global IN2_EA, IN2_EB
  global IN2_IA, IN2_IB
  global INT_EA, INT_EB
  global INT_IA, INT_IB
#
  global T1_EXT_I, T1_EXT_O, T1_INT_I, T1_INT_O
  global T2_EXT, T2_INT
  global OUT
  global IN1, IN2
#
  global VOLUME
#
  aFilterManager = smesh.smesh.CreateFilterManager()
  smesh.smesh.SetCurrentStudy(theStudy)
  import BLSURFPlugin
  import GHS3DPlugin
  pattern = smesh.GetPattern()
#
# 1. Maillage du volume
#
#       Parametrage de GHS3D
#
  GHS3D_Parameters_1 = smesh.smesh.CreateHypothesis('GHS3D_Parameters', 'GHS3DEngine')
#
#       Parametrage de BLSURF
#
  BLSURF_Parameters_1 = smesh.smesh.CreateHypothesis('BLSURF_Parameters', 'BLSURFEngine')
  BLSURF_Parameters_1.SetGeometricMesh( 0 )
  BLSURF_Parameters_1.SetPhySize( 1.*LG_ARETE )
###  BLSURF_Parameters_1.SetGradation( 1.9 )
###  BLSURF_Parameters_1.SetAngleMeshC( 16 )
###  BLSURF_Parameters_1.SetAngleMeshS( 16 )
###  BLSURF_Parameters_1.SetGeoMax( RG*45./50. )
  BLSURF = smesh.smesh.CreateHypothesis('BLSURF', 'BLSURFEngine')
#
#       Maillage
#
  PIQUAGE = smesh.Mesh(Piq_d)
  status = PIQUAGE.AddHypothesis(BLSURF)
  status = PIQUAGE.AddHypothesis(BLSURF_Parameters_1)
  status = PIQUAGE.AddHypothesis(GHS3D_Parameters_1)
  Tetrahedron_GHS3D = PIQUAGE.Tetrahedron(algo=smesh.GHS3D)
#
  isDone = PIQUAGE.Compute()
#
#       Suppression des noeuds coincidents, puis des elements coincidents
#
  coincident_nodes = PIQUAGE.FindCoincidentNodes( 1e-05 )
##  print "NC VOL = ",coincident_nodes
  if len (coincident_nodes) :
    PIQUAGE.MergeNodes(coincident_nodes)
    PIQUAGE.RenumberNodes()
#
  PIQUAGE.MergeEqualElements( )
  PIQUAGE.RenumberElements()
#
#       Groupes
#
  POINT1 = PIQUAGE.Group(POINT)
#
  INT_EA_1 = PIQUAGE.Group(INT_EA)
  INT_EB_1 = PIQUAGE.Group(INT_EB)
  INT_IA_1 = PIQUAGE.Group(INT_IA)
  INT_IB_1 = PIQUAGE.Group(INT_IB)
  IN2_EA_1 = PIQUAGE.Group(IN2_EA)
  IN2_EB_1 = PIQUAGE.Group(IN2_EB)
  IN2_IA_1 = PIQUAGE.Group(IN2_IA)
  IN2_IB_1 = PIQUAGE.Group(IN2_IB)
#
  T1_INT_I1 = PIQUAGE.Group(T1_INT_I)
  T1_INT_O1 = PIQUAGE.Group(T1_INT_O)
  T1_EXT_I1 = PIQUAGE.Group(T1_EXT_I)
  T1_EXT_O1 = PIQUAGE.Group(T1_EXT_O)
  T2_INT1 = PIQUAGE.Group(T2_INT)
  T2_EXT1 = PIQUAGE.Group(T2_EXT)
  OUT1 = PIQUAGE.Group(OUT)
  IN1_1 = PIQUAGE.Group(IN1)
  IN2_1 = PIQUAGE.Group(IN2)
#
  VOLUME_1 = PIQUAGE.Group(VOLUME)
#
#       Sauvegarde du maillage du volume
#
  PIQUAGE.ExportMED( '/local00/maill.init.med', 0, SMESH.MED_V2_2 )
#
# 2. Maillage de la frontiere
#
#       Parametrage des elements
#
  front = smesh.Mesh(Piq_d)
  Regular_1D = front.Segment()
  Nb_Segments_1 = Regular_1D.NumberOfSegments(1000)
  Nb_Segments_1.SetDistrType( 0 )
#
  isDone = front.Compute()
#
#       Suppression des noeuds coincidents, puis des elements coincidents
#
  coincident_nodes = front.FindCoincidentNodes( 1e-05 )
##  print "NC FRO = ",coincident_nodes
  if len (coincident_nodes) :
    front.MergeNodes(coincident_nodes)
    front.RenumberNodes()
#
  front.MergeEqualElements( )
  front.RenumberElements()
#
#       Groupes
#
  INT_EA_f = front.Group(INT_EA)
  INT_EB_f = front.Group(INT_EB)
  INT_IA_f = front.Group(INT_IA)
  INT_IB_f = front.Group(INT_IB)
  IN2_EA_f = front.Group(IN2_EA)
  IN2_EB_f = front.Group(IN2_EB)
  IN2_IA_f = front.Group(IN2_IA)
  IN2_IB_f = front.Group(IN2_IB)
#
#       Sauvegarde du maillage de la frontiere
#
  front.ExportMED( '/local00/front.med', 0, SMESH.MED_V2_2 )
#
#       Options graphiques
#
  ## set object names
  isGUIMode = 1
  if isGUIMode and salome.sg.hasDesktop():
    smesh.SetName(GHS3D_Parameters_1, 'GHS3D Parameters_1')
    smesh.SetName(BLSURF_Parameters_1, 'BLSURF Parameters_1')
    smesh.SetName(PIQUAGE.GetMesh(), 'PIQUAGE')
    smesh.SetName(BLSURF, 'BLSURF')
    smesh.SetName(Tetrahedron_GHS3D.GetAlgorithm(), 'Tetrahedron (GHS3D)')
    smesh.SetName(POINT1, 'POINT')
    smesh.SetName(INT_EA_1, 'INT_EA')
    smesh.SetName(INT_EB_1, 'INT_EB')
    smesh.SetName(INT_IA_1, 'INT_IA')
    smesh.SetName(INT_IB_1, 'INT_IB')
    smesh.SetName(IN2_EA_1, 'IN2_EA')
    smesh.SetName(IN2_EB_1, 'IN2_EB')
    smesh.SetName(IN2_IA_1, 'IN2_IA')
    smesh.SetName(IN2_IB_1, 'IN2_IB')
    smesh.SetName(OUT1, 'OUT')
    smesh.SetName(IN1_1, 'IN1')
    smesh.SetName(IN2_1, 'IN2')
    smesh.SetName(OUT1, 'OUT')
    smesh.SetName(T1_INT_I1, 'T1_INT_I')
    smesh.SetName(T1_INT_O1, 'T1_INT_O')
    smesh.SetName(T1_EXT_I1, 'T1_EXT_I')
    smesh.SetName(T1_EXT_O1, 'T1_EXT_O')
    smesh.SetName(T2_INT1, 'T2_INT')
    smesh.SetName(T2_EXT1, 'T2_EXT')
    smesh.SetName(VOLUME_1, 'VOLUME')
    smesh.SetName(INT_EA_f, 'INT_EA')
    smesh.SetName(INT_EB_f, 'INT_EB')
    smesh.SetName(INT_IA_f, 'INT_IA')
    smesh.SetName(INT_IB_f, 'INT_IB')
    smesh.SetName(IN2_EA_f, 'IN2_EA')
    smesh.SetName(IN2_EB_f, 'IN2_EB')
    smesh.SetName(IN2_IA_f, 'IN2_IA')
    smesh.SetName(IN2_IB_f, 'IN2_IB')
#
#    smesh.SetName(front.GetMesh(), 'front')

    salome.sg.updateObjBrowser(0)

  pass
