# MODIF  DATE 10/10/2012   AUTEUR COURTOIS M.COURTOIS 
# RESPONSABLE DURAND C.DURAND
# TITRE  SUPERVISEUR : POURSUITE, espace de noms, acces python-jeveux
# efica02a.para = tps_job 60 mem_job 256Mo ncpus 1 liste_test S
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2012  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
DEBUT(CODE=_F( NOM = 'EFICA02A',NIV_PUB_WEB='INTERNET',VISU_EFICAS='NON'),PAR_LOT="NON",DEBUG=_F(SDVERI='OUI'))

#######################################################################
# cas test du superviseur dedie a l appel de la methode getvectjev    #
# Il valide aussi la recuperation en poursuite des parametres python  #
# de la premiere execution en plus des concepts ASTER standards       #
#######################################################################

import aster

MA=LIRE_MAILLAGE( )
print aster.getvectjev("MA      .COORDO    .VALE        ")
print aster.getcolljev("MA      .CONNEX         ")
print aster.getvectjev("MA      .NOMMAI                 ")
print aster.getvectjev("MA      .NOMNOE                 ")

UN=1
DEUX=2
TUP=(10.,11.,12.,13.)

I02=DEFI_LIST_ENTI(VALE=UN)
I03=DEFI_LIST_ENTI(VALE=(5,6,7))
print aster.getvectjev("I02                .VALE")

FO3=DEFI_FONCTION(  NOM_PARA='X',
                    NOM_RESU='Y',
                    VALE=TUP )

# on teste la methode Valeurs de la SD fonction
# (on fait un traitement pour retrouver l'ordre du VALE)
# Valeurs fait appel a getvectjev (voir sa definition dans accas.capy)
lx,ly=FO3.Valeurs()
lv=[]
for i in range(len(lx)):
   lv.append(lx[i])
   lv.append(ly[i])

# F04 est une fonction identique a F03
FO4=DEFI_FONCTION(  NOM_PARA='X',
                    NOM_RESU='Y',
                    VALE=lv )

TEST_FONCTION(VALEUR=(_F(VALE_CALC=11.0,
                         VALE_PARA=10.0,
                         FONCTION=FO4,
                         ),
                      _F(VALE_CALC=13.0,
                         VALE_PARA=12.0,
                         FONCTION=FO4,
                         ),
                      ),
              )

# on passe dans la programmation de la methode Parametres de la SD fonction
# on ne teste pas les valeurs retournees
dicpara=FO4.Parametres()

xxx=34.5

FIN()
