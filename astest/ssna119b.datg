# FICHIER DE BASE REFERENCE, C'EST DANS CE FICHIER QUE NOUS ALLONS RENSEIGNER LES CHEMINS D'ACCES SPECIFIQUE AUX SCRIPTS POUR LA GEOMETRIE, LE MAILLAGE ETC.

# IMPORTATION DES LIBRAIRIES
import sys
import salome

salome.salome_init()

import salome_notebook
notebook = salome_notebook.notebook

#REPERTOIRE CONTENANT LES SCRIPTS PYTHON POUR SALOME
sys.path.insert( 0, r'/local00/Partage/Rabota/CIWAP/BENCHMARK_ENDO/eprouvette_entaillee/maillage')


# INITIALISATION DES DIFFERENTS PARAMETRES POUR LA VISUALISATION EN SALOME

import iparameters
ipar = iparameters.IParameters(salome.myStudy.GetCommonParameters("Interface Applicative", 1))

#Set up visual properties:
ipar.setProperty("AP_ACTIVE_VIEW", "OCCViewer_0_0")
ipar.setProperty("AP_WORKSTACK_INFO", "0000000100000000000000020100000001000008f8000000040000000200000000000000080000001a004f00430043005600690065007700650072005f0030005f00300000000002000000080000001a00560054004b005600690065007700650072005f0030005f00300000000102")
ipar.setProperty("AP_ACTIVE_MODULE", "Geometry")
ipar.setProperty("AP_SAVEPOINT_NAME", "GUI state: 2")
#Set up lists:
# fill list AP_VIEWERS_LIST
ipar.append("AP_VIEWERS_LIST", "OCCViewer_1")
ipar.append("AP_VIEWERS_LIST", "VTKViewer_2")
# fill list OCCViewer_1
ipar.append("OCCViewer_1", "OCC scene:1 - viewer:1")
ipar.append("OCCViewer_1", "4.125412782479e+01*5.000000610881e+00*-1.867483820917e-06*0.000000000000e+00*0.000000000000e+00*1.000000000000e+00*0.000000000000e+00*0.000000000000e+00*0.000000000000e+00*0.000000000000e+00*0.000000000000e+00*0.000000000000e+00*5.000000000000e+02*1.000000000000e+00*1.000000000000e+00*1.000000000000e+00*1*100.00")
# fill list VTKViewer_2
ipar.append("VTKViewer_2", "VTK scene:1 - viewer:1")

ipar.append("VTKViewer_2", """<?xml version="1.0"?>
<ViewState>
    <Position X="738.946" Y="-738.946" Z="738.946"/>
    <FocalPoint X="0" Y="0" Z="0"/>
    <ViewUp X="0" Y="0" Z="1"/>
    <ViewScale Parallel="363.749" X="1" Y="1" Z="1"/>
    <DisplayCubeAxis Show="0"/>
    <GraduatedAxis Axis="X">
        <Title isVisible="1" Text="X" Font="0" Bold="0" Italic="0" Shadow="0">
            <Color R="1" G="0" B="0"/>
        </Title>
        <Labels isVisible="1" Number="3" Offset="2" Font="0" Bold="0" Italic="0" Shadow="0">
            <Color R="1" G="0" B="0"/>
        </Labels>
        <TickMarks isVisible="1" Length="5"/>
    </GraduatedAxis>
    <GraduatedAxis Axis="Y">
        <Title isVisible="1" Text="Y" Font="0" Bold="0" Italic="0" Shadow="0">
            <Color R="0" G="1" B="0"/>
        </Title>
        <Labels isVisible="1" Number="3" Offset="2" Font="0" Bold="0" Italic="0" Shadow="0">
            <Color R="0" G="1" B="0"/>
        </Labels>
        <TickMarks isVisible="1" Length="5"/>
    </GraduatedAxis>
    <GraduatedAxis Axis="Z">
        <Title isVisible="1" Text="Z" Font="0" Bold="0" Italic="0" Shadow="0">
            <Color R="0" G="0" B="1"/>
        </Title>
        <Labels isVisible="1" Number="3" Offset="2" Font="0" Bold="0" Italic="0" Shadow="0">
            <Color R="0" G="0" B="1"/>
        </Labels>
        <TickMarks isVisible="1" Length="5"/>
    </GraduatedAxis>
    <Trihedron isShown="1" Size="105"/>
</ViewState>
""")
# LISTE DES MODULES UTILISES POUR REALISER L'ETUDES ICI UNE GEOMETRIE PUIS UN MAILLAGE

ipar.append("AP_MODULES_LIST", "Geometry")
ipar.append("AP_MODULES_LIST", "Mesh")

# IMPORTATION ET APPEL DES DIFFERENTS SCRIPTS, CREATION D'UN OBJET MAINOBJECT
# PARTIE GEOMETRIE
import eprouvetteAXI_GEOM
MainObject,SD=eprouvette_droit_GEOM.RebuildData(salome.myStudy)

# PARTIE MAILLAGE
import eprouvetteAXI_SMESH
eprouvette_droit_SMESH.RebuildData(salome.myStudy,MainObject,SD)

if salome.sg.hasDesktop():
        salome.sg.updateObjBrowser(1)
        iparameters.getSession().restoreVisualState(1)






# ===================================================
# MODULE ssna119b_GEOM.py
# ===================================================

# -*- coding: iso-8859-1 -*-

###
### This file is generated automatically by SALOME v5.1.4 with dump python functionality (GEOM component)
###





import GEOM
import geompy
import math
import SALOMEDS
from math import *





def RebuildData(theStudy):
        geompy.init_geom(theStudy)

        SD={} # CREATION D'UN DICTIONNAIRE, OUTIL SIMPLE POUR CATALOGUER LES DIFFERENTS SOUS OBJETS ET LES DIFFERENTES OPERATIONS QUE L'ON VEUT AFFICHER DANS L'HISTORIQUE DE SALOME
        

        # PARAMETRES POUR PLACER DIFFERENTS POINTS DE FACON INTERACTIVE, CES POINTS SERONT UTILISE POUR LA CREATION DU MAILLAGE AFIN DE PARAMATRER L'ORIENTATION DU MAILLAGE

        alpha = 10. # ANGLE D'ORIENTATION DU MAILLAGE EN DEGRES (ORIENTATION DU RECTANGLE HECK)
        L = 5.      # LONGUEUR DE LA PREMIERE PARTIE DU MAILLAGE ORIENTE (L DISTANCE ENTRE LES POINTS H ET E OU K ET C ) 
        h = 10.     # DEMI HAUTEUR DE L'EPROUVETTE (LE REPERE EST PLACE SUR LA PARTIE CENTRALE DE L'EPROUVETTE (AXE DE SYMETRIE) A MI HAUTEUR (DISTANCE GA/2)
        e = 10.     # LARGEUR DE L'EPROUVETTE (DISTANCE AB OU GF
        P1y = 1.7   # COORDONNEES Y DE L'EXTREMITIE DE L'ARC DE CERCLE QUI DEFINIT L'ENTAILLE DE L'EPROUVETTE 
        P2x = 9.    # COORDONNEES X SITUE A MI HAUTEUR , UTILE POUR PLACE LE POINT MILIEU DE L'ARC DE CERCLE ET DONC DEFINIR LA PROFONDEUR DE L'ENTAILLE
        


        # CONVERSION DE L'ANGLE EN RADIAN POUR LES FONCTIONS PYTHONS
        alpharad =  alpha*pi/180

        

        #Points de references pour le contour exterieur on commence par le BAS et on tourne dans le sens direct

#                                                                     #   G ____________F
#                                                                     #    |      H    |
                                                                      #    |     /\    |
                                                                      #    |    /  \   |    
                                                                      #    |   /    \  |  
        SD["A"] = geompy.MakeVertex(0, -h, 0)                         #    |  /  /\  \ |  
        SD["B"] = geompy.MakeVertex(e, -h, 0)                         #    | /  / K\  \|
        SD["C"] = geompy.MakeVertex(e, -P1y, 0)                       #   I|/  /    \  \E
        SD["D"] = geompy.MakeVertex(P2x,0, 0)                         #       /      \D 
        SD["E"] = geompy.MakeVertex(e, P1y, 0)                        #      /        \  
        SD["F"] = geompy.MakeVertex(e, h, 0)                          #   J /          \C
        SD["G"] = geompy.MakeVertex(0, h, 0)                          #    |           | 
                                                                      #    |           |
                                                                      #    |           |
                                                                      #    |           |
                                                                      #    |           |
                                                                      #    |___________|
#                                                                         A            B
                                                                          

        #Points de references pour le maillage interne on commence par le HAUT et on tourne dans le sens direct

        SD["H"] = geompy.MakeVertex(e-cos(alpharad)*L, P1y + sin(alpharad)*L , 0)
        SD["I"] = geompy.MakeVertex(0,P1y, 0)
        SD["J"] = geompy.MakeVertex(0,-P1y, 0)
        SD["K"] = geompy.MakeVertex(e-cos(alpharad)*L,-P1y + sin(alpharad)*L, 0)


        #UNE FOIS LES POINTS DE REFERENCES CREES ET STOCKES DANS LE DICTIONNAIRE NOUS LES RELIENS PAR DES POLYLINES ET POUR LES POINTS EDC UN ARC DE CERCLE
        
        #On cree des polylines/arc de cercle/ wire (groupement de lignes polylines etc pour apres faire les faces

        CONTOUR = geompy.MakePolyline([SD["E"],SD["F"],SD["G"],SD["A"],SD["B"],SD["C"]])

        RECT = geompy.MakePolyline([SD["H"],SD["I"],SD["J"],SD["K"],SD["H"]])
        
        ARC = geompy.MakeArc(SD["C"],SD["D"],SD["E"])

        TRAPEZE = geompy.MakePolyline([SD["C"],SD["K"],SD["H"],SD["E"]])

        # UNE FOIS LES LIGNES TRACE NOUS INTRODUISONS LE CONCEPT DE FILE QUI EST LE CONTOUR DES DIFFERENTES FACES QUE NOUS DEVONS CONSTRUIRES ( LE PERIMETRE DE CHAQUE FACE )

        WIRE1 = geompy.MakeWire([ARC,TRAPEZE], 1)

        WIRE2 = geompy.MakeWire([CONTOUR,ARC], 1)


        # CREATION DES FACES A PARTIR DES CONTOURS 
        

        FaceTrap = geompy.MakeFace(WIRE1, 1)

        FaceRect = geompy.MakeFace(RECT, 1)

        FaceCountour = geompy.MakeFace(WIRE2, 1)


        # UNE FOIS LES FACES CONSTRUITES ON DECOUPE LA FACE PRINCIPALE (FACECOUNTOUR) PAR LES DEUX RECTANGE (FACERECT (HIJK) ET FACETRAP(KCEH)) ET ON ATTACHE LE RESULTAT DE CETTE OPERATION A UN OBJET : MAINOBJET.

        MainObject = geompy.MakePartition([FaceCountour], [FaceRect,FaceTrap], [], [], geompy.ShapeType["FACE"], 0, [], 0)


        # CREATION DES DIFFERENTS GROUPE DE NOEUDS
        # ON NOMME DIFFERENTES PARTIE DE LA GEOMETRIE POUR APPLIQUER LES CONDITIONS AUX LIMITES CES GROUPES, BASES SUR LA GEOMETRIE SERVIRONT A CREER LES GROUPES DE NOEUDS           # SUR LE MAILLAGE. (ON UTILISERA PAR LA SUITE UNE FONCTION QUI RECUPERERA LES NOEUDS DU MAILLAGES SITUÃ‰ SUR LE GROUPE QUE L'ON VIENT DE DEFINIR A SAVOIR :                    # LES BORDS GF(LHAUT)  AB(LBAS) ET AG(AXE1)

               
        LHAUT=geompy.GetSame(MainObject,geompy.MakeLineTwoPnt(SD["G"],SD["F"]))

        AXE1=geompy.GetInPlace(MainObject,geompy.MakeLineTwoPnt(SD["A"],SD["G"]))

        LBAS=geompy.GetSame(MainObject,geompy.MakeLineTwoPnt(SD["A"],SD["B"]))

        LMILIEUG=geompy.GetSame(MainObject,geompy.MakeLineTwoPnt(SD["I"],SD["J"]))
        LMILIEU=geompy.GetSame(MainObject,geompy.MakeLineTwoPnt(SD["K"],SD["H"]))
        LMILIEUD=geompy.GetInPlace(MainObject,ARC)

        VERTICALE1=geompy.GetInPlace(MainObject,geompy.MakeLineTwoPnt(SD["I"],SD["H"]))
        VERTICALE2=geompy.GetInPlace(MainObject,geompy.MakeLineTwoPnt(SD["E"],SD["H"]))
        VERTICALE3=geompy.GetInPlace(MainObject,geompy.MakeLineTwoPnt(SD["C"],SD["K"]))
        VERTICALE4=geompy.GetInPlace(MainObject,geompy.MakeLineTwoPnt(SD["J"],SD["K"]))

        SD["RectFacePart"]=geompy.GetInPlace(MainObject,FaceRect )
        toto=geompy.GetShapesOnSphere(MainObject,geompy.ShapeType["FACE"],SD["D"],P2x,geompy.GEOM.ST_IN)


              #on cree le point P_Haut 1) on recupere les coordonnes 2) on les passe en arguments
        coords = geompy.PointCoordinates(SD["F"])
        SD["P_HAUT"]=geompy.GetInPlace(MainObject,geompy.MakeVertex(coords[0],coords[1],coords[2]))


        #       ON DECLARE LES DIFFERENTS GROUPE GEOMETRIQUE
               
        SD["HAUT"]= geompy.CreateGroup(MainObject, geompy.ShapeType["EDGE"])

        SD["AXE"]= geompy.CreateGroup(MainObject, geompy.ShapeType["EDGE"])

        SD["BAS"]= geompy.CreateGroup(MainObject, geompy.ShapeType["EDGE"])
        
        SD["MILIEU"]= geompy.CreateGroup(MainObject, geompy.ShapeType["EDGE"])

        SD["VERTICALE"]= geompy.CreateGroup(MainObject, geompy.ShapeType["EDGE"])

        SD["TrapFacePart"]= geompy.CreateGroup(MainObject, geompy.ShapeType["FACE"])



        
        # ON LIE LES DIFFERENTS NOMS DE GROUPES AUX DIFFERENTS GROUPES GEOMETRIQUE CREE     

        #creations des groupes pour les conditions limites, on tire sur Haut et Bas et on fixera en X sur axe
        geompy.UnionList(SD["HAUT"],[LHAUT])
        geompy.UnionList(SD["AXE"],[AXE1])      
        geompy.UnionList(SD["BAS"],[LBAS])
        

        #groupe pour controler le rafinement au milieu de l'eprouvette  
        geompy.UnionList(SD["MILIEU"],[LMILIEU,LMILIEUG,LMILIEUD])
        geompy.UnionList(SD["VERTICALE"],[VERTICALE1,VERTICALE2,VERTICALE3,VERTICALE4])
        geompy.UnionList(SD["TrapFacePart"],toto)


        #creation de l'objet principale
        
        geompy.addToStudy( MainObject, "MainObject" )

        # ON RELIE L'ENSEMBLE DES SOUS OBJETS A L'OBJET PRINCIPALE POUR LES CONSERVER DANS L'HISTORIQUE
        keys=SD.keys()
        for name in keys:
                geompy.addToStudyInFather(MainObject,SD[name],name)
                
        
        ### Store presentation parameters of displayed objects
        import iparameters
        ipar = iparameters.IParameters(theStudy.GetModuleParameters("Interface Applicative", "GEOM", 1))

        #Set up entries:
        # set up entry GEOM_1 (Vertex_1) parameters
        ipar.setParameter("GEOM_1", "OCCViewer_0_Visibility", "Oxfn")
        ipar.setParameter("GEOM_1", "OCCViewer_0_DisplayMode", "0")
        ipar.setParameter("GEOM_1", "OCCViewer_0_Transparency", "0")
        ipar.setParameter("GEOM_1", "OCCViewer_0_Isos", "1:1")
        # ON REPASSE DANS LE SCRIPT PRINCIPALE L'OBJET PRINCIPALE ET LE DICTIONNAIRE POUR QU'ILS SOIENT VISIBLE PAR LES AUTRES MODULES/SCRIPTS
        return MainObject,SD
        pass






# ===================================================
# MODULE ssna119b_SMESH.py
# ===================================================

#MODULE/SCRIPT POUR LE MAILLAGE

# IMPORTATION DES DIFFERENTS LIBRAIRIES POUR SALOME

import salome, SMESH, SALOMEDS
import smesh

## import GEOM dump file ## 
import string, os, sys, re
sys.path.insert( 0, os.path.dirname(__file__) )
exec("from "+re.sub("SMESH$","GEOM",__name__)+" import *")



def RebuildData(theStudy,MainObject,SD):
        smesh.SetCurrentStudy(theStudy)
        import StdMeshers
        import NETGENPlugin

        # Parametres
      
        NbEltsTri= 21#7 #51 #Nombre d'elements du maillage triangulaire par cote
        NbEltsQuadX =41#21 #51 # 101 Nombre d'elements du maillage regulier par cote
        NbEltsQuadY =31#11 #51 # 201 Nombre d'elements du maillage regulier par cote

        # On Cree un maillage (TYPE TRIANGLE SUR L'ENSEMBLE DE L'OBJET)
        # NOM DE L'OBJET
        Triangles = smesh.Mesh(MainObject,"Maillage")
        # DETERMINATION ET DES ALGORITHMES ICI ON SPECIFIE LE NOMBRE D'ELEMENTS SUR CHAQUE BORD
        algo1D = Triangles.Segment()
        hyp1D = algo1D.NumberOfSegments( NbEltsTri )

        # NETGEN (TYPE DE MAILLAGE)
        algo2D = Triangles.Triangle(algo=smesh.NETGEN_2D)
        hyp2D = algo2D.LengthFromEdges()

        # UNE FOIS LE MAILLAGE PRINCIPALE FAIT IL FAUT CREER DES SOUS MAILLAGES QUE L'ON PLONGERA DANS LE MAILLAGE PRINCIPALE, DEFINITION DES SOUS MAILLAGES POUR CHAQUE FACE QUE L'ON A REALISE DANS LE MODULE GEOMETRIE
          
        # Submesh sur la partie trapezoidale

        #
        algo_trap2D = Triangles.Quadrangle(SD["TrapFacePart"])

        # Submesh sur la partie rectangulaire

        algo_rect2D = Triangles.Quadrangle(SD["RectFacePart"])


        #Discretisation 1D sur les verticales des rectangles avec NbEltsQuadX elements sur chaque bord

        algo_rect1D  = Triangles.Segment(geom=SD["VERTICALE"])
        
        hyp1D_rect = algo_rect1D.NumberOfSegments(NbEltsQuadX)


        #Discretisation 1D sur les horizontales des reclangles NbEltsQuadY elements sur chaque bord

        algo_rect1D  = Triangles.Segment(geom=SD["MILIEU"])
        hyp1D_rect = algo_rect1D.NumberOfSegments(NbEltsQuadY)     
        

        mesh_group=[]

        # ON LISTE L'ENSEMBLE DES GROUPES GEOMETRIQUES SOUS FORME DE GROUPES DE NOEUDS (CONVERSION GROUPE GEOMETRIQUE -> GROUPE DE NOEUDS)
        mesh_group.append(Triangles.Group(SD["P_HAUT"]))
        mesh_group.append(Triangles.Group(SD["BAS"]))
        mesh_group.append(Triangles.Group(SD["HAUT"]))
        mesh_group.append(Triangles.Group(SD["AXE"]))
        

        # ON PEUT MAINTENANT CALCULER LE MAILLAGE AVEC COMPUTE ET SPECIFIER SI ON VEUT DES ELEMENTS LINEAIRES OU QUADRATIQUES
        Triangles.Compute()
        Triangles.ConvertToQuadratic( 1 )
        Triangles.Compute()

        # ENFIN ON EXPORTE LE MAILLAGE SOUS LE FORMAT MED POUR POUVOIR L'UTILISER DANS LA SIMULATION
    #   Triangles.ExportMED("/local01/eprouvette/droitlight.med", 0)


        

        if salome.sg.hasDesktop():
                salome.sg.updateObjBrowser(0)

        ### Store presentation parameters of displayed objects
        import iparameters
        ipar = iparameters.IParameters(theStudy.GetModuleParameters("Interface Applicative", "SMESH", 1))



        pass
