# MODIF  DATE 01/07/2003   AUTEUR GNICOLAS G.NICOLAS 
# RESPONSABLE BOITEAU O.BOITEAU
# TITRE validation de la sensibilite par rapport a la chaleur volumique et
# a l'emissivite en thermique non-lineaire transitoire lumpe
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2002  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
#
DEBUT( CODE=_F(  NOM = 'SENST05A',NIV_PUB_WEB='INTERNET') ,PAR_LOT='NON' )
#
#
#          J    BORD_SU1       BORD_SU2    
#           *-------------------------------*
#           !               !               !
#           !               !               !
#           !               !               !
#  BORD_GAU !    MOITIE1    *   MOITIE2     ! BORD_DRO
#  COEFH:   !               !               ! RAYONNEMENT
#   30      !            CENTRE             ! SIGMA: 1.E-8
#  T_EXT:   !               !               ! EPSILON: 0.3 (EPS2)
#  140      *-------------------------------* TEMP_EXT: 500
#       ORIGINE   BORD_IN1     BORD_IN2     I
#       TEMP_IMPO: 100*(1+0.1*INST)
#
#    TRANSITOIRE T DE 0 A 10 PAR PAS DE 5       
#              1   < X < 11
#             -1.5 < Y <  1.5
#        55 NOEUDS, 28 SEG2 ET 80 TRIA3
#
# On calcule les sensibilites par rapport a la chaleur volumique (PS1)
# et par rapport a la caracteristique d'emissivite de la CL de rayonnement
# (PS2) sur BORD_DRO, et ce, de deux manieres differentes: par differences 
# finies (via PYTHON) et de maniere numerique (via l'option
# idoine de THER_NON_LINE). La deuxieme strategie est evidemment celle qui
# est preconisee (plus rapide, plus commode a utiliser, plus robuste...)
# mais, dans un cas test aussi tordu que celui-ci, elle est la seule voie
# de validation possible.
# On teste l'ecart, pour ces deux derivees, entre la valeur obtenue en
# resolvant le probleme derive et la valeur par differences finies. Et ce,
# en tous les instants du transitoire (via la boucle PYTHON) et pour les
# trois points I, CENTRE et J.
# DETAILS:
#   * La difference finie est une difference centree.
#   * L'ecart qui est teste est un ecart relatif par rapport a la valeur par
#     differences finies. Il doit etre inferieur a 1.e-03 %. Cet ecart est
#     trace dans le fichier message.
# Dans le fichier resultat on trace les cartes contenants le champ de tempe
# rature a tous les points du transitoire et aux points I, CENTRE et J.
# On fait des tests de non-regression, au dernier instant, au CENTRE et pour
# les deux sensibilites:
#   * sur les differences finies, via un TEST_FONCTION.
#   * sur les sensibilites analytiques, via un TEST_RESU.
#
# 1. Definition/memorisation des fonctions constantes
#
PS_UN=DEFI_CONSTANTE(VALE=1.0,);
MEMO_NOM_SENSI ( NOM_UN = PS_UN ) ;
#
PS_ZERO=DEFI_CONSTANTE(VALE=0.0,);
MEMO_NOM_SENSI ( NOM_ZERO = PS_ZERO ) ;
#
# 2. Definition des parametres sensibles et des autres parametres
#
PS1=DEFI_PARA_SENSI(VALE=2.0,);
MEMO_NOM_SENSI(NOM=_F(NOM_COMPOSE='PS_UN',PARA_SENSI=PS1,NOM_SD='PS1',),);
PS2=DEFI_PARA_SENSI(VALE=0.3,);
MEMO_NOM_SENSI(NOM=_F(NOM_COMPOSE='PS_UN',PARA_SENSI=PS2,NOM_SD='PS2',),);
#
EPSA=DEFI_VALEUR(R8=1.E-6);
eps = 1.0e-6
eps1 = 1.e-4
A1=DEFI_CONSTANTE(VALE=30.0);
A2=DEFI_CONSTANTE(VALE=140.0);
A3=DEFI_CONSTANTE(VALE=1.E-8);
A4=DEFI_CONSTANTE(VALE=500.0);
PS1P=DEFI_CONSTANTE(VALE=2.0001);
PS1M=DEFI_CONSTANTE(VALE=1.9999);
PS2P = FORMULE(REEL="""(REEL:INST) =0.3+EPSA""");
PS2M = FORMULE(REEL="""(REEL:INST) =0.3-EPSA""");
T_ORI = FORMULE(REEL="""(REEL:INST) = 100.*(1.D0+0.1D0*INST)""");
LAMB = DEFI_CONSTANTE(VALE=0.75);
#
# 3. Prealable
#
MAILLAGE=LIRE_MAILLAGE();
#
# 3.1. Mise en place du materiau, de sa derivee et de ses translates
#
MAT=DEFI_MATERIAU(THER_NL=_F(  LAMBDA = LAMB, RHO_CP = PS1));
#                       
MEMO_NOM_SENSI(NOM=(_F(NOM_SD='MAT',
                      PARA_SENSI=PS1,
                      NOM_COMPOSE='MAT_PS1',
                      VALEUR='PS1',
                      MOT_FACT='THER_NL',
                      MOT_CLE='RHO_CP',),));
MAT_PS1=DEFI_MATERIAU(THER_NL=_F( LAMBDA = PS_ZERO,RHO_CP = PS_UN))
#
CMAT=AFFE_MATERIAU(MAILLAGE=MAILLAGE,AFFE=_F(TOUT='OUI',MATER=MAT));
MEMO_NOM_SENSI(NOM=(_F(NOM_SD='CMAT',
                      PARA_SENSI=PS1,
                      NOM_COMPOSE='CMAT_PS1',
                      VALEUR='MAT',
                      MOT_FACT='AFFE',
                      MOT_CLE='MATER',)));
CMAT_PS1=AFFE_MATERIAU(MAILLAGE=MAILLAGE,AFFE=_F(TOUT='OUI',MATER=MAT_PS1))
#
MATP=DEFI_MATERIAU(THER_NL=_F(  LAMBDA = LAMB, RHO_CP = PS1P));
CMATP=AFFE_MATERIAU(MAILLAGE=MAILLAGE,AFFE=_F(TOUT='OUI',MATER=MATP));
MATM=DEFI_MATERIAU(THER_NL=_F(  LAMBDA = LAMB, RHO_CP = PS1M));
CMATM=AFFE_MATERIAU(MAILLAGE=MAILLAGE,AFFE=_F(TOUT='OUI',MATER=MATM));
#
# 3.2. Modele
#
MODEPLAN=AFFE_MODELE(MAILLAGE=MAILLAGE,
                     AFFE=_F(TOUT='OUI',
                             PHENOMENE='THERMIQUE',
                             MODELISATION='PLAN_DIAG'));
#
# 3.3. Chargements non sensibles (echange/temp_impo)
#
CH_0=AFFE_CHAR_THER_F(MODELE=MODEPLAN,
                      ECHANGE=_F(GROUP_MA='BORD_GAU',COEF_H=A1,TEMP_EXT=A2),
                      TEMP_IMPO=_F(GROUP_NO='ORIGINE',TEMP=T_ORI),);
#
# 3.4. Chargements sensibles (rayonnement)
#
CH_1=AFFE_CHAR_THER_F(MODELE=MODEPLAN,RAYONNEMENT=_F(GROUP_MA='BORD_DRO',
                     SIGMA=A3,EPSILON=PS2,TEMP_EXT=A4));
MEMO_NOM_SENSI(NOM=_F(NOM_SD='CH_1',
                      PARA_SENSI=PS2,
                      NOM_COMPOSE='CH_1_PS2',
                      VALEUR='PS2',
                      MOT_FACT='RAYONNEMENT',
                      MOT_CLE='EPSILON',));
CH_1_PS2=AFFE_CHAR_THER_F(MODELE=MODEPLAN,RAYONNEMENT=_F(GROUP_MA='BORD_DRO',
                          SIGMA=PS_ZERO,EPSILON=PS_UN,TEMP_EXT=PS_ZERO));
#
# 3.4 Chargements translates pour differences finies
#
CH_1P=AFFE_CHAR_THER_F(MODELE=MODEPLAN,RAYONNEMENT=_F(GROUP_MA='BORD_DRO',
                     SIGMA=A3,EPSILON=PS2P,TEMP_EXT=A4));
CH_1M=AFFE_CHAR_THER_F(MODELE=MODEPLAN,RAYONNEMENT=_F(GROUP_MA='BORD_DRO',
                     SIGMA=A3,EPSILON=PS2M,TEMP_EXT=A4));                     
#
# 4.1. Calcul standard + 2 calculs de sensibilite
#
MEMO_NOM_SENSI(NOM=(_F(NOM_SD='RETH',
                       PARA_SENSI=PS1,
                       NOM_COMPOSE='RETH_PS1'),
                    _F(NOM_SD='RETH',
                       PARA_SENSI=PS2,
                       NOM_COMPOSE='RETH_PS2')));
LR8=DEFI_LIST_REEL(DEBUT=0.,INTERVALLE=_F(JUSQU_A = 10.,NOMBRE=2));
RETH=THER_NON_LINE(MODELE=MODEPLAN,
                   CHAM_MATER=CMAT,
                   INCREMENT=_F(LIST_INST = LR8), 
                   TEMP_INIT=_F(STATIONNAIRE = 'OUI'),
                   CONVERGENCE=_F(ITER_GLOB_MAXI=20,
                                  RESI_GLOB_MAXI=1.E-12),
                   NEWTON=_F(RESI_LINE_RELA=1.E-3,
                             REAC_ITER=1,
                             ITER_LINE_MAXI=5),
                   INFO=2,
                   EXCIT=(_F(CHARGE=CH_0,),_F(CHARGE=CH_1,),),
                   SENSIBILITE=(PS1,PS2));
#
# 4.2. Calculs pour evaluer les differences finies
#
RETH1M=THER_NON_LINE(MODELE=MODEPLAN,
                   CHAM_MATER=CMATM,
                   INCREMENT=_F(LIST_INST = LR8), 
                   TEMP_INIT=_F(STATIONNAIRE = 'OUI'),
                   CONVERGENCE=_F(ITER_GLOB_MAXI=20,
                                  RESI_GLOB_MAXI=1.E-12),
                   NEWTON=_F(RESI_LINE_RELA=1.E-3,
                             REAC_ITER=1,
                             ITER_LINE_MAXI=5),
                   EXCIT=(_F(CHARGE=CH_0),_F(CHARGE=CH_1)));
RETH1P=THER_NON_LINE(MODELE=MODEPLAN,
                   CHAM_MATER=CMATP,
                   INCREMENT=_F(LIST_INST = LR8), 
                   TEMP_INIT=_F(STATIONNAIRE = 'OUI'),
                   CONVERGENCE=_F(ITER_GLOB_MAXI=20,
                                  RESI_GLOB_MAXI=1.E-12),
                   NEWTON=_F(RESI_LINE_RELA=1.E-3,
                             REAC_ITER=1,
                             ITER_LINE_MAXI=5),
                   EXCIT=(_F(CHARGE=CH_0),_F(CHARGE=CH_1)));
RETH2M=THER_NON_LINE(MODELE=MODEPLAN,
                   CHAM_MATER=CMAT,
                   INCREMENT=_F(LIST_INST = LR8), 
                   TEMP_INIT=_F(STATIONNAIRE = 'OUI'),
                   CONVERGENCE=_F(ITER_GLOB_MAXI=20,
                                  RESI_GLOB_MAXI=1.E-12),
                   NEWTON=_F(RESI_LINE_RELA=1.E-3,
                             REAC_ITER=1,
                             ITER_LINE_MAXI=5),
                   EXCIT=(_F(CHARGE=CH_0),_F(CHARGE=CH_1M)));
RETH2P=THER_NON_LINE(MODELE=MODEPLAN,
                   CHAM_MATER=CMAT,
                   INCREMENT=_F(LIST_INST = LR8), 
                   TEMP_INIT=_F(STATIONNAIRE = 'OUI'),
                   CONVERGENCE=_F(ITER_GLOB_MAXI=20,
                                  RESI_GLOB_MAXI=1.E-12),
                   NEWTON=_F(RESI_LINE_RELA=1.E-3,
                             REAC_ITER=1,
                             ITER_LINE_MAXI=5),
                   EXCIT=(_F(CHARGE=CH_0),_F(CHARGE=CH_1P)));
#
# 4.3. Releve des temperatures (ou sensibilite de temperature)
#
RLTH=POST_RELEVE_T(ACTION=_F(RESULTAT = RETH,
                   INTITULE='TEMPERATURE',
                   NOM_CHAM='TEMP',
                   OPERATION='EXTRACTION',
                   GROUP_NO=('I','CENTRE','J'),
                   NOM_CMP=('TEMP')));
RLTHS1=POST_RELEVE_T(ACTION=_F(RESULTAT = RETH,
                   INTITULE='TEMPERATURE',
                   NOM_CHAM='TEMP',
                   OPERATION='EXTRACTION',
                   GROUP_NO=('I','CENTRE','J'),
                   NOM_CMP=('TEMP'),
                   SENSIBILITE=(PS1)));
RLTHS2=POST_RELEVE_T(ACTION=_F(RESULTAT = RETH,
                   INTITULE='TEMPERATURE',
                   NOM_CHAM='TEMP',
                   OPERATION='EXTRACTION',
                   GROUP_NO=('I','CENTRE','J'),
                   NOM_CMP=('TEMP'),
                   SENSIBILITE=(PS2)));
RLTH1M=POST_RELEVE_T(ACTION=_F(RESULTAT = RETH1M,
                   INTITULE='TEMPERATURE',
                   NOM_CHAM='TEMP',
                   OPERATION='EXTRACTION',
                   GROUP_NO=('I','CENTRE','J'),
                   NOM_CMP=('TEMP')));
RLTH1P=POST_RELEVE_T(ACTION=_F(RESULTAT = RETH1P,
                   INTITULE='TEMPERATURE',
                   NOM_CHAM='TEMP',
                   OPERATION='EXTRACTION',
                   GROUP_NO=('I','CENTRE','J'),
                   NOM_CMP=('TEMP')));
RLTH2M=POST_RELEVE_T(ACTION=_F(RESULTAT = RETH2M,
                   INTITULE='TEMPERATURE',
                   NOM_CHAM='TEMP',
                   OPERATION='EXTRACTION',
                   GROUP_NO=('I','CENTRE','J'),
                   NOM_CMP=('TEMP')));
RLTH2P=POST_RELEVE_T(ACTION=_F(RESULTAT = RETH2P,
                   INTITULE='TEMPERATURE',
                   NOM_CHAM='TEMP',
                   OPERATION='EXTRACTION',
                   GROUP_NO=('I','CENTRE','J'),
                   NOM_CMP=('TEMP')));
#
# 5. Boucle Python de comparaison difference finie/derivee analytique
#
print "**********************************************************"
print "*        IMPRESSION DES TESTS DERIVEES ANALYTIQUES       *"
print "*                  VS DIFFERENCES FINIES                 *"
print "**********************************************************"
erreur = 0.
for k in range(1,4):

  k1 = (k-1)*3+1
  print ""
  instk = (k-1)*5
  print "Instant= ",instk

#
# 5.1. point 'I'
#
  temp=RLTH['TEMP',k1]
  print "Temperature en I= ",temp
  tempm=RLTH1M['TEMP',k1]
  tempp=RLTH1P['TEMP',k1]
  daps1=RLTHS1['TEMP',k1]
  dfps1 = (tempp-tempm)/(2.*eps1)
  ecart1 = -9999
  if (abs(dfps1)>1.0e-200): ecart1 = 100.*((dfps1 - daps1)/dfps1)
  print "Derivee par rapport a la chaleur volumique"
  print "Analytique/difference finie/ecart",daps1,dfps1,ecart1
  if abs(ecart1)>1.0e-3:
    print "****** Ecart trop important ******"
    erreur = erreur + 1
  tempm=RLTH2M['TEMP',k1]
  tempp=RLTH2P['TEMP',k1]
  daps2=RLTHS2['TEMP',k1]
  dfps2 = (tempp-tempm)/(2.*eps)
  ecart2 = 100.*((dfps2 - daps2)/dfps2)
  print "Derivee par rapport a l'emissivite"
  print "Analytique/difference finie/ecart",daps2,dfps2,ecart2
  if abs(ecart2)>1.0e-3:
    print "****** Ecart trop important ******"
    erreur = erreur + 1
#
# 5.2. point 'CENTRE'
#
  k1=k1+1
  temp=RLTH['TEMP',k1]
  print "Temperature au CENTRE= ",temp
  tempm=RLTH1M['TEMP',k1]
  tempp=RLTH1P['TEMP',k1]
  daps1=RLTHS1['TEMP',k1]
  ecart1 = -9999
  dfps1 = (tempp-tempm)/(2.*eps1)
  if (abs(dfps1)>1.0e-200): ecart1 = 100.*((dfps1 - daps1)/dfps1)
  print "Derivee par rapport a la chaleur volumique"
  print "Analytique/difference finie/ecart",daps1,dfps1,ecart1
  if abs(ecart1)>1.0e-3:
    print "****** Ecart trop important ******"
    erreur = erreur + 1
  tempm=RLTH2M['TEMP',k1]
  tempp=RLTH2P['TEMP',k1]
  daps2=RLTHS2['TEMP',k1]
  dfps2 = (tempp-tempm)/(2.*eps)
  ecart2 = 100.*((dfps2 - daps2)/dfps2)
  print "Derivee par rapport a l'emissivite"
  print "Analytique/difference finie/ecart",daps2,dfps2,ecart2
  if abs(ecart2)>1.0e-3:
    print "****** Ecart trop important ******"
    erreur = erreur + 1
#
# 5.3. Conversion PYTHON>ASTER des differences finies au dernier instant
#  
  if (k==3) :
# Transmet la valeur de la difference finie au point CENTRE et au dernier
# instant, des variables PYTHON dfps1/dfps2 aux variables ASTER DFA1/DFA2
# Elles sont definies comme des fonctions ASTER pour pouvoir avoir recourt
# a TEST_FONCTION et pour pouvoir transmettre des donnees provenant de PYTHON
    print "" 
    DFA1=FORMULE(REEL="""(REEL:INST) =dfps1*1.""")  
    DFA2=FORMULE(REEL="""(REEL:INST) =dfps2*1.""")
    print ""
  
#
# 5.4. point 'J'
#
  k1=k1+1
  temp=RLTH['TEMP',k1]
  print "Temperature en J= ",temp
  tempm=RLTH1M['TEMP',k1]
  tempp=RLTH1P['TEMP',k1]
  daps1=RLTHS1['TEMP',k1]
  dfps1 = (tempp-tempm)/(2.*eps1)
  ecart1 = -9999
  if (abs(dfps1)>1.0e-200):ecart1 = 100.*((dfps1 - daps1)/dfps1)
  print "Derivee par rapport a la chaleur volumique"
  print "Analytique/difference finie/ecart",daps1,dfps1,ecart1
  if abs(ecart1)>1.0e-3:
    print "****** Ecart trop important ******"
    erreur = erreur + 1
  tempm=RLTH2M['TEMP',k1]
  tempp=RLTH2P['TEMP',k1]
  daps2=RLTHS2['TEMP',k1]
  dfps2 = (tempp-tempm)/(2.*eps)
  ecart2 = 100.*((dfps2 - daps2)/dfps2)
  print "Derivee par rapport a l'emissivite"
  print "Analytique/difference finie/ecart",daps2,dfps2,ecart2
  if abs(ecart2)>1.0e-3:
    print "****** Ecart trop important ******"
    erreur = erreur + 1
    
print ""
print "nombre d'erreur :",erreur
print "**********************************************************"
#
# 6. Impressions des cartes resultats et test_resu:fonction
#
#IMPR_TABLE( TABLE=RLTH )
#IMPR_TABLE( TABLE=RLTHS1 )
#IMPR_TABLE( TABLE=RLTHS2 )

# test de non-regression sur les valeurs de differences finies calculees
# au 5.3. et sur les valeurs de sensibilite calculees au 4.1
TEST_FONCTION(VALEUR=(
          _F( FONCTION = DFA1, NOM_PARA='INST',CRITERE = 'RELATIF',
              PRECISION = 1.E-8,VALE_PARA=1.,
              VALE_REFE = -2.1699345353454E-01,REFERENCE = 'AUTRE_ASTER'),
          _F( FONCTION = DFA2, NOM_PARA='INST',CRITERE = 'RELATIF',
              PRECISION = 1.E-8,VALE_PARA=1.,
              VALE_REFE = 8.1229600255028E+00,REFERENCE = 'AUTRE_ASTER')));
TEST_RESU(RESU=(
          _F( RESULTAT = RETH, NUME_ORDRE = 2,
              SENSIBILITE=(PS1),
              NOM_CHAM = 'TEMP', GROUP_NO = 'CENTRE', CRITERE = 'RELATIF',
              PRECISION = 1.E-8, NOM_CMP = 'TEMP',
              VALE = -2.1699345343882E-01, REFERENCE = 'NON_REGRESSION' ),
          _F( RESULTAT = RETH, NUME_ORDRE = 2,
              SENSIBILITE=(PS2),
              NOM_CHAM = 'TEMP',GROUP_NO = 'CENTRE', CRITERE = 'RELATIF',
              PRECISION = 1.E-8, NOM_CMP = 'TEMP',
              VALE = 8.1229600535215E+00,REFERENCE = 'NON_REGRESSION' )));
FIN();
