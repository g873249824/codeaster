      SUBROUTINE MUMMPI(OPTMPI,IFM,NIV,ACH24,ARGI1,ARGI2)
!           CONFIGURATION MANAGEMENT OF EDF VERSION                  
!& MODIF MUMMPI UTILITAI  DATE 16/02/2010   AUTEUR PELLET J.PELLET 
! ================================================================== 
! COPYRIGHT (C) 1991 - 2010  EDF R&D              WWW.CODE-ASTER.ORG 
!                                                                    
! THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR      
! MODIFY IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS     
! PUBLISHED BY THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE 
! LICENSE, OR (AT YOUR OPTION) ANY LATER VERSION.                    
! THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,    
! BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF     
! MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU   
! GENERAL PUBLIC LICENSE FOR MORE DETAILS.                           
!                                                                    
! YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE  
! ALONG WITH THIS PROGRAM; IF NOT, WRITE TO : EDF R&D CODE_ASTER,    
!    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.     
! ================================================================== 
!-----------------------------------------------------------------------
!    - FONCTION REALISEE:  APPELS MPI POUR MUMPS
!
! ARGUMENTS D'APPELS
! IN OPTMPI   : IN  : OPTION DE LA ROUTINE
!    =0        DISTRIBUTION DE LA CHARGE SD/PROC
!
! IN IFM,NIV  : IN  : AFFICHAGE
! IN	ACH24 : K24 : NOM JEVEUX DU VECTEUR A COMMUNIQUER
! INOUT ARGI1 : IN  : 1ERE ARGUMENT ENTIER
! INOUT ARGI2 : IN  : 2ND ARGUMENT ENTIER
!----------------------------------------------------------------------
! RESPONSABLE BOITEAU O.BOITEAU
! CORPS DU PROGRAMME
      IMPLICIT NONE
C DECLARATION PARAMETRES D'APPELS
      INTEGER      OPTMPI,IFM,NIV,ARGI1,ARGI2
      CHARACTER*24 ACH24

C --- DEBUT DECLARATIONS NORMALISEES JEVEUX ----------------------------
      INTEGER*4          ZI4
      COMMON  / I4VAJE / ZI4(1)
      INTEGER ZI
      COMMON /IVARJE/ZI(1)
      REAL*8 ZR
      COMMON /RVARJE/ZR(1)
      COMPLEX*16 ZC
      COMMON /CVARJE/ZC(1)
      CHARACTER*8 ZK8
      CHARACTER*16 ZK16
      CHARACTER*24 ZK24
      CHARACTER*32 ZK32,JEXNUM
      CHARACTER*80 ZK80
      COMMON /KVARJE/ZK8(1),ZK16(1),ZK24(1),ZK32(1),ZK80(1)
C --- FIN DECLARATIONS NORMALISEES JEVEUX ------------------------------

#ifdef _USE_MPI
      INCLUDE 'mpif.h'

C DECLARATION VARIABLES LOCALES
      INTEGER      VALI(2),IACH,IEXIST,ILIST,NBPROC,RANG,NBSDP0,IAUX1
      INTEGER      IBID,NBSD,NBSD1,IAUX4,IPROC2,IDD,NBPRO1,IPROC
      INTEGER      IPROC1,IAUX2,IAUX3,DECAL,ILOG,LOISEM,K,NLONG
      INTEGER      IOBJ,NBOBJ
      INTEGER*4    RANG4,IERMPI,LR8,LINT,NBPRO4,N4,LC8
      CHARACTER*1  TYPSCA,XOUS
      CHARACTER*8  K8BID
      CHARACTER*24 NOMLOG
      LOGICAL      FIRST
      SAVE         LR8,LINT,FIRST,LC8
      DATA         FIRST /.TRUE./

C CORPS DU PROGRAMME
      CALL JEMARQ()
C INITS.
      IF (FIRST) THEN
C POUR LA GESTION DES ERREURS PAR LE DEVELOPPEUR
        CALL MPI_ERRHANDLER_SET(MPI_COMM_WORLD,MPI_ERRORS_RETURN,IERMPI)
        CALL FETMER(IERMPI)
        IF (LOISEM().EQ.8) THEN
          LINT=MPI_INTEGER8
        ELSE
          LINT=MPI_INTEGER
        ENDIF
        LR8 = MPI_DOUBLE_PRECISION
        LC8 = MPI_DOUBLE_COMPLEX
        FIRST= .FALSE.
      ENDIF

C FILTRE POUR EVITER DU TRAVAIL SUPPLEMENTAIRE SI NBPROC=1
      IF ((OPTMPI.NE.0).AND.(OPTMPI.NE.2).AND.(OPTMPI.NE.3)) THEN
        CALL MPI_COMM_SIZE(MPI_COMM_WORLD,NBPRO4,IERMPI)
        CALL FETMER(IERMPI)
        IF (NBPRO4.EQ.1) GOTO 999
      ENDIF
C---------------------------------------------- OPTION = 0
      IF (OPTMPI.EQ.0) THEN
C REPARTITION DE LA CHARGE SD/PROC. ON REPREND LA MEME HEURISTIQUE
C QUE CELLE DE FETI (CF. BIBFOR/FROM_C/FETAM.F)
        NBSDP0=ARGI2
        NBSD=ARGI1
        NBSD1=NBSD+1
C OBJET TEMPORAIRE POUR PARALLELISME MPI:
C ZI(ILIST+I)=1 IEME SOUS-DOMAINE CALCULE PAR PROCESSEUR COURANT
C            =0 ELSE
        NOMLOG='&MUMPS.LISTE.SD.MPI'
        CALL JEEXIN(NOMLOG,IEXIST)
        IF (IEXIST.NE.0) CALL ASSERT(.FALSE.)
        CALL WKVECT(NOMLOG,'V V I',NBSD1,ILIST)

        CALL MPI_COMM_SIZE(MPI_COMM_WORLD,NBPRO4,IERMPI)
        CALL FETMER(IERMPI)
        NBPROC=NBPRO4
        CALL MPI_COMM_RANK(MPI_COMM_WORLD,RANG4,IERMPI)
        CALL FETMER(IERMPI)
        RANG=RANG4

C DECOUPAGE DU TRAVAIL PAR PROCESSEUR. COMME ON SE SERT DE L'HEURISTIQUE
C DEVELOPPEE POUR FETI, ON GROUPE LES SD PAR SOUS-DOMAINES CONTIGUS
C D'AUTRE PART, ON SOULAGE D'UN POINT DE VUE MEMOIRE, SI POSSIBLE, LE
C PROCESSEUR DE RANG 0 . DONC, SI NBPROC < NBSD, ON REDISTRIBUE LES SD
C EXCEDENTAIRES EN COMMENCANT PAR LE PROC 1
C EXEMPLE: 8 SD ET 4 PROC
C PROC 0 : SD1/SD2
C PROC 1 : SD3/SD4
C ...
C EXEMPLE: 9 SD ET 4 PROC
C PROC 0 : SD1/2
C PROC 1 : SD3/SD4/SD5
C PROC 2 : SD6/SD7
C...
C DOMAINE GLOBALE (IDD=0) CONCERNE TOUS LES PROCESSEURS
        ZI(ILIST)=1
        DO 90 IDD=1,NBSD
          ZI(ILIST+IDD)=0
   90   CONTINUE
        IF (NBSDP0.EQ.0) THEN
          IAUX1=NBSD/NBPROC
          IAUX4=NBSD-(NBPROC*IAUX1)
          IPROC2=0
        ELSE
C ATTRIBUTIONS DU PROC 0
          DO 92 IDD=1,NBSDP0
            IF (RANG.EQ.0) ZI(ILIST+IDD)=1
   92     CONTINUE
C RESTE AUX AUTRES PROC
          IAUX1=(NBSD-NBSDP0)/(NBPROC-1)
          IAUX4=(NBSD-NBSDP0)-((NBPROC-1)*IAUX1)
          IPROC2=1
        ENDIF
        NBPRO1=NBPROC-1
        DO 100 IPROC=IPROC2,NBPRO1
C INDICE RELATIF DU PROCESSEUR A EQUILIBRER
          IPROC1=IPROC-IPROC2
C BORNES DES SDS A LUI ATTRIBUER
          IAUX2=1+NBSDP0+IPROC1*IAUX1
          IAUX3=NBSDP0+(IPROC1+1)*IAUX1
C CALCUL D'UN DECALAGE EVENTUEL DU AU RELIQUAT DE SD
          IF (IAUX4.LT.IPROC1) THEN
            DECAL=IAUX4
          ELSE
            IF (IPROC1.EQ.0) THEN
              DECAL=0
            ELSE
              DECAL=IPROC1-1
              IAUX3=IAUX3+1
            ENDIF
          ENDIF
C ATTRIBUTIONS SD/PROC
          DO 95 IDD=IAUX2,IAUX3
            IF (IPROC.EQ.RANG) ZI(ILIST+DECAL+IDD)=1
   95     CONTINUE
  100   CONTINUE

C
C---------------------------------------------- MAUVAISE OPTION
      ELSE
        CALL MPI_COMM_RANK(MPI_COMM_WORLD,RANG4,IERMPI)
        CALL FETMER(IERMPI)
        VALI(1)=RANG4
        VALI(2)=OPTMPI
        CALL U2MESI('F','APPELMPI_6',2,VALI)
      ENDIF
  999 CONTINUE
      CALL JEDEMA()


#else
C======================================================================

C DECLARATION VARIABLES LOCALES
      INTEGER      VALI(2),IEXIST,ILIST,I,NB
      CHARACTER*24 NOMLOG

C CORPS DU PROGRAMME

C---------------------------------------------- OPTION = 0
      IF (OPTMPI.EQ.0) THEN
C REPARTITION DE LA CHARGE SD/PROC. ON REPREND LA MEME HEURISTIQUE
C QUE CELLE DE FETI (CF. BIBFOR/FROM_C/FETAM.F)
C OBJET TEMPORAIRE POUR PARALLELISME MPI:
C ZI(ILIST+I)=1 IEME SOUS-DOMAINE CALCULE PAR PROCESSEUR COURANT
C            =0 ELSE
        NOMLOG='&MUMPS.LISTE.SD.MPI'
        CALL JEEXIN(NOMLOG,IEXIST)
        CALL ASSERT(IEXIST.EQ.0)
        NB=ARGI1+1
        CALL WKVECT(NOMLOG,'V V I',NB,ILIST)
        DO 10 I=1,NB
          ZI(ILIST-1+I)=1
   10   CONTINUE

      ELSE
        VALI(1)=0
        VALI(2)=OPTMPI
        CALL U2MESI('F','APPELMPI_6',2,VALI)
      ENDIF

#endif
      END
