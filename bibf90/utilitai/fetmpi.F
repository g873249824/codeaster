      SUBROUTINE FETMPI(OPTMPI,NBSD,IFM,NIV,RANG,NBPROC,ACH24,ACH241,
     &                 ACH242,ARGR1)
      IMPLICIT NONE
      INCLUDE 'jeveux.h'
      INTEGER      OPTMPI,IFM,NIV,NBSD,NBPROC,RANG
      CHARACTER*24 ACH24,ACH241,ACH242
      REAL*8       ARGR1
! RESPONSABLE BOITEAU O.BOITEAU
!-----------------------------------------------------------------------
!           CONFIGURATION MANAGEMENT OF EDF VERSION
!& MODIF FETMPI UTILITAI  DATE 26/02/2013   AUTEUR BOITEAU O.BOITEAU 
! ==================================================================
! COPYRIGHT (C) 1991 - 2013  EDF R&D              WWW.CODE-ASTER.ORG
!
! THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR
! MODIFY IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS
! PUBLISHED BY THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE
! LICENSE, OR (AT YOUR OPTION) ANY LATER VERSION.
! THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
! BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
! MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
! GENERAL PUBLIC LICENSE FOR MORE DETAILS.
!
! YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
! ALONG WITH THIS PROGRAM; IF NOT, WRITE TO : EDF R&D CODE_ASTER,
!    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
! ==================================================================
!-----------------------------------------------------------------------
!    - FONCTION REALISEE:  APPELS MPI POUR FETI
!
! ARGUMENTS D'APPELS
! IN OPTMPI  : OPTION DE LA ROUTINE (CHANGER NBOPT DANS LE SOURCE SI
!       VOUS MODIFIER LE NBRE D'OPTIONS)
!    =1        CREATION OBJET JEVEUX  '&FETI.LISTE.SD.MPI' POUR BOUCLE
!          SUR LES SOUS-DOMAINES PARALLELISEE
!    =2        RANG DU PROCESSUS
!    =3        NOMBRE DE PROCESSEURS
!    =4 OU 5   REDUCTION SUR L'OBJET ACH24 (MPI_INTEGER OU MPI_DOUBLE
!          _PRECISION AVEC SUBTILITE QUANT AU NBRE DE DONNEES)
!    =6        REDUCTION PUIS DIFFUSION SUR L'OBJET ACH24
!    =7        REDUCTION SUR L'OBJET ACH24 EN MPI_DOUBLE_PRECISION
!    =8        COLLECTE SELECTIVE DE L'OBJET ACH24 PAR UN MPI_GATHERV
!    =9        DISTRIBUTION DE L'OBJET ACH24
!    =10       DISTRIBUTION DU REEL ARGR1
!    =71       IDEM QUE 7 PUIS DIFFUSION A TOUS LES PROCS
! IN NBSD    : NOMBRE DE SOUS-DOMAINES SI OPTMI=1
!          TAILLE DU MPI_** SI OPTMPI=4,5,6,7, 71 OU 9
! IN IFM,NIV : NIVEAU D'IMPRESSION (SI NIV.GE.2 IMPRESSION, DOIT ETRE
!          CONTROLE PAR INFOFE(10:10)
! IN  ACH24  : ARGUMENT CH24 POUR OPTMPI=4,5,6,7,71,8 OU 9
! IN  ACH241 : ARGUMENT CH24 POUR OPTMPI=8
! IN  ACH242 : ARGUMENT CH24 POUR OPTMPI=8
! IN  ARGR1  : ARGUMENR REEL POUR OPTMPI=10
! IN/OUT RANG: RANG DU PROCESSUS SI OPTMPI=1,2 OU 8
! IN/OUT NBPROC : RANG DU PROCESSUS SI OPTMPI=1,3 OU 8
!----------------------------------------------------------------------


#ifdef _USE_MPI
      INCLUDE 'mpif.h'

! DECLARATION VARIABLES LOCALES
      INTEGER      IAUX1,IDD,NBSD1,ILIST,IEXIST,IRED,I,IACH
      INTEGER      IAUX2,IAUX3,IAUX4,DECAL,IBID,IPROC2
      INTEGER      ILIST1,IPROC,NBPRO1,IPROC1,NBSDP0,IACH1,IACH2
      INTEGER      IMON,NBOPT,OPT,LOISEM
      INTEGER*4    NBPRO4,RANG4,NBSD4,IERMPI,NBSD41,LR8,LINT,IARG,
     &             COMCOU,MPICOU
      CHARACTER*8  K8BID
      CHARACTER*24 NOM1,NOMLOG,NOMLO1,NOMMON
      REAL*8       TEMPS(6)

      CALL JEMARQ()
! --- COMMUNICATEUR MPI DE TRAVAIL
      MPICOU=COMCOU(1)
! INITS.
      IF (LOISEM().EQ.8) THEN
        LINT=MPI_INTEGER8
      ELSE
        LINT=MPI_INTEGER
      ENDIF
      LR8 = MPI_DOUBLE_PRECISION
      NBSD4=NBSD
! NBRE D'OPTION DE FETMPI
      NBOPT=11*2
! POUR LE MONITORING DU PARALLELISME
      IF (NIV.GE.2) THEN
        NOMMON='&FETI.MONITORING.MPI'
        CALL JEEXIN(NOMMON,IEXIST)
        IF (IEXIST.EQ.0) THEN
          CALL WKVECT(NOMMON,'V V R',NBOPT,IMON)
          CALL JERAZO(NOMMON,NBOPT,1)
        ELSE
          CALL JEVEUO(NOMMON,'E',IMON)
        ENDIF
      ENDIF
! RANG DU PROCESSEUR POUR LIMITER LES AFFICHAGES
      IF (NIV.GE.2) THEN
        CALL MPI_COMM_RANK(MPICOU,RANG4,IERMPI)
        CALL MPIERR(IERMPI)
        RANG=RANG4
        IF (RANG.NE.0) NIV=0
      ENDIF

!---------------------------------------------- OPTION = 1
      IF (OPTMPI.EQ.1) THEN
! POUR LE MONITORING DU PARALLELISME
        IF (NIV.GE.2) THEN
          CALL UTTCPU('CPU.FETMPI.1','INIT',' ')
          CALL UTTCPU('CPU.FETMPI.1','DEBUT',' ')
        ENDIF
        NBSD1=NBSD+1
! OBJET TEMPORAIRE POUR PARALLELISME MPI:
! ZI(ILIST+I)=1 IEME SOUS-DOMAINE CALCULE PAR PROCESSEUR COURANT
!            =0 ELSE
        NOMLOG='&FETI.LISTE.SD.MPI'
        CALL JEEXIN(NOMLOG,IEXIST)
! SI L OBJET NOMLOG EXISTE DEJA : ARRET
        CALL ASSERT(IEXIST.EQ.0)
        CALL WKVECT(NOMLOG,'V V I',NBSD1,ILIST)
! OBJET TEMPORAIRE POUR PARALLELISME MPI:
! ZI(ILIST1+I-1)=NUMERO DU PROCESSEUR QUI LE CONCERNE
        NOMLO1='&FETI.LISTE.SD.MPIB'
        CALL JEEXIN(NOMLO1,IEXIST)
! SI L OBJET NOMLO1 EXISTE DEJA : ARRET
        CALL ASSERT(IEXIST.EQ.0)
        CALL WKVECT(NOMLO1,'V V I',NBSD,ILIST1)

        CALL MPI_COMM_SIZE(MPICOU,NBPRO4,IERMPI)
        CALL MPIERR(IERMPI)
        NBPROC=NBPRO4
        CALL MPI_COMM_RANK(MPICOU,RANG4,IERMPI)
        CALL MPIERR(IERMPI)
        RANG=RANG4
        IF (NBPROC.GT.1) THEN
! ON EST EN PARALLELE, L'UTILISATEUR A PEUT-ETRE EMIS UN SOUHAIT QUANT
! AU NBRE DE SD POUR LE PROCESSEUR MAITRE
          CALL GETVIS(ACH24(1:16),'NB_SD_PROC0',1,IARG,1,NBSDP0,IBID)
          IF ((NBSD-NBSDP0).LT.(NBPROC-1))
     &      CALL U2MESS('F','APPELMPI_3')
        ELSE
          NBSDP0=0
        ENDIF
! DECOUPAGE DU TRAVAIL PAR PROCESSEUR. POUR FACILITER LE TRAVAIL DES
! ENVOI DE MODES RIGIDES ON PREFERE GROUPER LES SD PAR SOUS-DOMAINES
! D'AUTRE PART, ON SOULAGE D'UN POINT DE VUE MEMOIRE, SI POSSIBLE LE
! PROCESSEUR DE RANG 0 QUI AURA AUSSI A STOCKER GI, GIT*GI ET LES VEC
! TEURS DE REORTHO. DONC, SI NBPROC < NBSD, ON REDISTRIBUE LES SD COMP
! LEMENTAIRES EN COMMENCANT PAR LE PROC 1
! EXEMPLE: 8 SD ET 4 PROC
! PROC 0 : SD1/SD2
! PROC 1 : SD3/SD4
! ...
! EXEMPLE: 9 SD ET 4 PROC
! PROC 0 : SD1/2
! PROC 1 : SD3/SD4/SD5
! PROC 2 : SD6/SD7
!...
! DOMAINE GLOBALE (IDD=0) CONCERNE TOUS LES PROCESSEURS
        ZI(ILIST)=1
        DO 90 IDD=1,NBSD
          ZI(ILIST+IDD)=0
          ZI(ILIST1+IDD-1)=0
   90   CONTINUE
        IF (NBSDP0.EQ.0) THEN
          IAUX1=NBSD/NBPROC
          IAUX4=NBSD-(NBPROC*IAUX1)
          IPROC2=0
        ELSE
! ATTRIBUTIONS DU PROC 0
          DO 92 IDD=1,NBSDP0
            IF (RANG.EQ.0) ZI(ILIST+IDD)=1
            ZI(ILIST1+IDD-1)=0
   92     CONTINUE
! RESTE AUX AUTRES PROC
          IAUX1=(NBSD-NBSDP0)/(NBPROC-1)
          IAUX4=(NBSD-NBSDP0)-((NBPROC-1)*IAUX1)
          IPROC2=1
        ENDIF
        NBPRO1=NBPROC-1
        DO 100 IPROC=IPROC2,NBPRO1
! INDICE RELATIF DU PROCESSEUR A EQUILIBRER
          IPROC1=IPROC-IPROC2
! BORNES DES SDS A LUI ATTRIBUER
          IAUX2=1+NBSDP0+IPROC1*IAUX1
          IAUX3=NBSDP0+(IPROC1+1)*IAUX1
! CALCUL D'UN DECALAGE EVENTUEL DU AU RELIQUAT DE SD
          IF (IAUX4.LT.IPROC1) THEN
            DECAL=IAUX4
          ELSE
            IF (IPROC1.EQ.0) THEN
              DECAL=0
            ELSE
              DECAL=IPROC1-1
              IAUX3=IAUX3+1
            ENDIF
          ENDIF
! ATTRIBUTIONS SD/PROC
          DO 95 IDD=IAUX2,IAUX3
            IF (IPROC.EQ.RANG) ZI(ILIST+DECAL+IDD)=1
            ZI(ILIST1+DECAL+IDD-1)=IPROC
   95     CONTINUE
  100   CONTINUE

! MONITORING
        IF (NIV.GE.2) THEN
          CALL UTTCPU('CPU.FETMPI.1','FIN',' ')
          CALL UTTCPR('CPU.FETMPI.1',6,TEMPS)
          ZR(IMON+2*(OPTMPI-1))  =ZR(IMON+2*(OPTMPI-1))  +TEMPS(5)
          ZR(IMON+2*(OPTMPI-1)+1)=ZR(IMON+2*(OPTMPI-1)+1)+TEMPS(6)
          CALL UTIMSD(IFM,2,.FALSE.,.TRUE.,NOMLOG(1:19),1,'V')
          CALL UTIMSD(IFM,2,.FALSE.,.TRUE.,NOMLO1(1:19),1,'V')
          WRITE(IFM,*)'<FETI/FETMPI> REPARTITION SD/PROC RANG/NBPROC ',
     &                RANG,NBPROC
        ENDIF

!---------------------------------------------- OPTION = 2
      ELSE IF (OPTMPI.EQ.2) THEN
        IF (NIV.GE.2) THEN
          CALL UTTCPU('CPU.FETMPI.2','INIT',' ')
          CALL UTTCPU('CPU.FETMPI.2','DEBUT',' ')
        ENDIF
! DETERMINATION DU RANG D'UN PROCESSUS (RANG)
        CALL MPI_COMM_RANK(MPICOU,RANG4,IERMPI)
        CALL MPIERR(IERMPI)
        RANG=RANG4
! MONITORING
        IF (NIV.GE.2) THEN
          CALL UTTCPU('CPU.FETMPI.2','FIN',' ')
          CALL UTTCPR('CPU.FETMPI.2',6,TEMPS)
          ZR(IMON+2*(OPTMPI-1))  =ZR(IMON+2*(OPTMPI-1))  +TEMPS(5)
          ZR(IMON+2*(OPTMPI-1)+1)=ZR(IMON+2*(OPTMPI-1)+1)+TEMPS(6)
          WRITE(IFM,*)'<FETI/FETMPI> RANG ',RANG
        ENDIF

!---------------------------------------------- OPTION = 3
      ELSE IF (OPTMPI.EQ.3) THEN
        IF (NIV.GE.2) THEN
          CALL UTTCPU('CPU.FETMPI.3','INIT',' ')
          CALL UTTCPU('CPU.FETMPI.3','DEBUT',' ')
        ENDIF
! DETERMINATION DU NOMBRE DE PROCESSEURS (NBPROC)
        CALL MPI_COMM_SIZE(MPICOU,NBPRO4,IERMPI)
        CALL MPIERR(IERMPI)
        NBPROC=NBPRO4
! MONITORING
        IF (NIV.GE.2) THEN
          CALL UTTCPU('CPU.FETMPI.3','FIN',' ')
          CALL UTTCPR('CPU.FETMPI.3',6,TEMPS)
          ZR(IMON+2*(OPTMPI-1))  =ZR(IMON+2*(OPTMPI-1))  +TEMPS(5)
          ZR(IMON+2*(OPTMPI-1)+1)=ZR(IMON+2*(OPTMPI-1)+1)+TEMPS(6)
          WRITE(IFM,*)'<FETI/FETMPI> RANG/NBPROC ',RANG,NBPROC
        ENDIF

!---------------------------------------------- OPTION = 4,5,6,7,71
      ELSE IF (((OPTMPI.GE.4).AND.(OPTMPI.LE.7)).OR.
     &          (OPTMPI.EQ.71)) THEN
        IF (NIV.GE.2) THEN
          CALL UTTCPU('CPU.FETMPI.4','INIT',' ')
          CALL UTTCPU('CPU.FETMPI.4','DEBUT',' ')
        ENDIF
! REDUCTION DU VECTEUR ACH24 POUR LE PROCESSEUR MAITRE
! PAR EXEMPLE, L'OBJET JEVEUX MATR_ASSE.FETH
        CALL JEVEUO(ACH24,'E',IACH)
        CALL GCNCON('.',K8BID)
        NOM1='&&REDUCE'//K8BID
        NBSD1=NBSD-1
        IF ((OPTMPI.EQ.4).OR.(OPTMPI.EQ.6)) THEN
          CALL WKVECT(NOM1,'V V I',NBSD,IRED)
          DO 400 I=0,NBSD1
            ZI(IRED+I)=ZI(IACH+I)
  400     CONTINUE
        ELSE IF ((OPTMPI.EQ.5).OR.(OPTMPI.EQ.7).OR.(OPTMPI.EQ.71)) THEN
          CALL WKVECT(NOM1,'V V R',NBSD,IRED)
          DO 402 I=0,NBSD1
            ZR(IRED+I)=ZR(IACH+I)
  402     CONTINUE
        ENDIF
        IF (OPTMPI.EQ.4) THEN
          CALL MPI_REDUCE(ZI(IRED),ZI(IACH),NBSD4,LINT,MPI_SUM,0,
     &                    MPICOU,IERMPI)
        ELSE IF (OPTMPI.EQ.5) THEN
! PROFILER POUR LES OBJETS JEVEUX '&FETI.INFO.CPU' QUI NE DOIVENT PAS
! CONTENIR L'INFO REDONDANTE DU PREMIER INDICE (TEMPS CONCERNANT LA MAT
! RICE GLOBALE COMMUNE A TOUS LES PROCESSEURS)
          NBSD41=NBSD4-1
          CALL MPI_REDUCE(ZR(IRED+1),ZR(IACH+1),NBSD41,LR8,MPI_SUM,0,
     &                    MPICOU,IERMPI)
        ELSE IF (OPTMPI.EQ.6) THEN
          CALL MPI_ALLREDUCE(ZI(IRED),ZI(IACH),NBSD4,LINT,MPI_SUM,
     &                       MPICOU,IERMPI)
        ELSE IF (OPTMPI.EQ.7) THEN
          CALL MPI_REDUCE(ZR(IRED),ZR(IACH),NBSD4,LR8,MPI_SUM,0,
     &                    MPICOU,IERMPI)
        ELSE IF (OPTMPI.EQ.71) THEN
          CALL MPI_ALLREDUCE(ZR(IRED),ZR(IACH),NBSD4,LR8,MPI_SUM,
     &                       MPICOU,IERMPI)
        ENDIF
        CALL MPIERR(IERMPI)
        CALL JEDETR(NOM1)

! MONITORING
        IF (NIV.GE.2) THEN
          CALL UTTCPU('CPU.FETMPI.4','FIN',' ')
          CALL UTTCPR('CPU.FETMPI.4',6,TEMPS)
! GLUTE STUPIDE POUR NE PAS CHANGER LE  EN 11
          IF (OPTMPI.EQ.71) THEN
            OPT=11
          ELSE
            OPT=OPTMPI
          ENDIF
          ZR(IMON+2*(OPT-1))  =ZR(IMON+2*(OPT-1))  +TEMPS(5)
          ZR(IMON+2*(OPT-1)+1)=ZR(IMON+2*(OPT-1)+1)+TEMPS(6)
          IF ((OPTMPI.NE.6).AND.(OPTMPI.NE.71)) THEN
            WRITE(IFM,*)'<FETI/FETMPI> RANG/MPI_REDUCE ENTIER',
     &                 RANG,ACH24
          ELSE
            WRITE(IFM,*)'<FETI/FETMPI> RANG/MPI_ALLREDUCE REEL',
     &                 RANG,ACH24
          ENDIF
        ENDIF

!---------------------------------------------- OPTION = 8
      ELSE IF (OPTMPI.EQ.8) THEN
        IF (NIV.GE.2) THEN
          CALL UTTCPU('CPU.FETMPI.5','INIT',' ')
          CALL UTTCPU('CPU.FETMPI.5','DEBUT',' ')
        ENDIF
! COLLECTE SELECTIVE DU VECTEUR ACH24 POUR LE PROCESSEUR MAITRE
        CALL JEVEUO(ACH241,'E',IACH1)
        CALL JEVEUO(ACH242,'E',IACH2)
        CALL JEVEUO(ACH24,'E',IACH)
        IF (NBSD.NE.0) THEN
          CALL GCNCON('.',K8BID)
          NOM1='&&GATHERV'//K8BID
          CALL WKVECT(NOM1,'V V R',NBSD,IRED)
          DO 500 I=1,NBSD
            ZR(IRED+I-1)=ZR(IACH+I-1)
  500     CONTINUE
        ENDIF
        CALL MPI_GATHERV(ZR(IRED),NBSD4,LR8,ZR(IACH),ZI4(IACH1),
     &                   ZI4(IACH2),LR8,0,MPICOU,IERMPI)
        CALL MPIERR(IERMPI)

        IF (NBSD.NE.0) CALL JEDETR(NOM1)
! MONITORING
        IF (NIV.GE.2) THEN
          CALL UTTCPU('CPU.FETMPI.5','FIN',' ')
          CALL UTTCPR('CPU.FETMPI.5',6,TEMPS)
          ZR(IMON+2*(OPTMPI-1))  =ZR(IMON+2*(OPTMPI-1))  +TEMPS(5)
          ZR(IMON+2*(OPTMPI-1)+1)=ZR(IMON+2*(OPTMPI-1)+1)+TEMPS(6)
          WRITE(IFM,*)'<FETI/FETMPI> RANG/MPI_GATHERV ',RANG,ACH24
!          CALL UTIMSD(IFM,2,.TRUE.,.TRUE.,ACH241(1:19),1,'V')
!          CALL UTIMSD(IFM,2,.TRUE.,.TRUE.,ACH242(1:19),1,'V')
        ENDIF

!---------------------------------------------- OPTION = 9
      ELSE IF (OPTMPI.EQ.9) THEN
        IF (NIV.GE.2) THEN

          CALL UTTCPU('CPU.FETMPI.6','INIT',' ')
          CALL UTTCPU('CPU.FETMPI.6','DEBUT',' ')
        ENDIF
! DISTRIBUTION DU VECTEUR ACH24 PAR LE PROCESSEUR MAITRE A TOUS
! LES AUTRES PROCS
        CALL JEVEUO(ACH24,'E',IACH)
        CALL MPI_BCAST(ZR(IACH),NBSD4,LR8,0,MPICOU,IERMPI)
        CALL MPIERR(IERMPI)

! MONITORING
        IF (NIV.GE.2) THEN
          CALL UTTCPU('CPU.FETMPI.6','FIN',' ')
          CALL UTTCPR('CPU.FETMPI.6',6,TEMPS)
          ZR(IMON+2*(OPTMPI-1))  =ZR(IMON+2*(OPTMPI-1))  +TEMPS(5)
          ZR(IMON+2*(OPTMPI-1)+1)=ZR(IMON+2*(OPTMPI-1)+1)+TEMPS(6)
          WRITE(IFM,*)'<FETI/FETMPI> RANG/MPI_BCAST ',RANG,ACH24
        ENDIF

!---------------------------------------------- OPTION = 10
      ELSE IF (OPTMPI.EQ.10) THEN
        IF (NIV.GE.2) THEN
          CALL UTTCPU('CPU.FETMPI.7','INIT',' ')
          CALL UTTCPU('CPU.FETMPI.7','DEBUT',' ')
        ENDIF
! DISTRIBUTION DU REEL ARGR1 PAR LE PROCESSEUR MAITRE A TOUS
! LES AUTRES PROCS
        CALL MPI_BCAST(ARGR1,1,LR8,0,MPICOU,IERMPI)
        CALL MPIERR(IERMPI)

! MONITORING
        IF (NIV.GE.2) THEN
          CALL UTTCPU('CPU.FETMPI.7','FIN',' ')
          CALL UTTCPR('CPU.FETMPI.7',6,TEMPS)
          ZR(IMON+2*(OPTMPI-1))  =ZR(IMON+2*(OPTMPI-1))  +TEMPS(5)
          ZR(IMON+2*(OPTMPI-1)+1)=ZR(IMON+2*(OPTMPI-1)+1)+TEMPS(6)
          WRITE(IFM,*)'<FETI/FETMPI> RANG/MPI_BCAST ',RANG,ARGR1
        ENDIF

!---------------------------------------------- OPTION
! <1 OU >10 OU DIFFERENT DE 71
      ELSE
        CALL ASSERT(.FALSE.)
      ENDIF
      CALL JEDEMA()


#else
!============================================================

! DECLARATION VARIABLES LOCALES
      INTEGER      NBSD1,ILIST,IDD,IEXIST
      CHARACTER*24 NOMLOG

! CORPS DU PROGRAMME
      CALL JEMARQ()

      IF (OPTMPI.EQ.1) THEN
        NBSD1=NBSD+1
        NOMLOG='&FETI.LISTE.SD.MPI'
        CALL JEEXIN(NOMLOG,IEXIST)
        CALL ASSERT(IEXIST.EQ.0)
        CALL WKVECT(NOMLOG,'V V I',NBSD1,ILIST)
        DO 200 IDD=0,NBSD
          ZI(ILIST+IDD)=1
  200   CONTINUE
        NOMLOG='&FETI.LISTE.SD.MPIB'
        CALL JEEXIN(NOMLOG,IEXIST)
        CALL ASSERT(IEXIST.EQ.0)
        CALL WKVECT(NOMLOG,'V V I',NBSD,ILIST)
        DO 201 IDD=1,NBSD
          ZI(ILIST+IDD-1)=0
  201   CONTINUE
        RANG=0
        NBPROC=1
! MONITORING
        IF (NIV.GE.2) THEN
          CALL UTIMSD(IFM,2,.FALSE.,.TRUE.,NOMLOG(1:19),1,'V')
          WRITE(IFM,*)'<FETI/FETMPI> RANG/NBPROC ',RANG,NBPROC
        ENDIF
      ELSE IF (OPTMPI.EQ.2) THEN
        RANG=0
! MONITORING
        IF (NIV.GE.2) WRITE(IFM,*)'<FETI/FETMPI> RANG ',RANG
      ELSE IF (OPTMPI.EQ.3) THEN
        NBPROC=1
! MONITORING
        IF (NIV.GE.2) WRITE(IFM,*)'<FETI/FETMPI> NBPROC ',NBPROC
      ELSE IF (((OPTMPI.GE.4).AND.(OPTMPI.LE.10)).OR.(OPTMPI.EQ.71))
     &THEN
! MONITORING
        IF (NIV.GE.2) WRITE(IFM,*)'<FETI/FETMPI> OPTMPI=',
     &                 OPTMPI,' VIDE '
      ELSE
        CALL ASSERT(.FALSE.)
      ENDIF
      CALL JEDEMA()
#endif
      END
