      SUBROUTINE  AMUMPH(ACTION,SOLVEZ,MATASZ,RSOLU,CSOLU,VCINEZ,
     &                   NBSOL,IRET,PREPOS)
      IMPLICIT NONE
!           CONFIGURATION MANAGEMENT OF EDF VERSION
!& MODIF AMUMPH MUMPS  DATE 29/03/2011   AUTEUR BOITEAU O.BOITEAU 
! ==================================================================
! COPYRIGHT (C) 1991 - 2011  EDF R&D              WWW.CODE-ASTER.ORG
!
! THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR
! MODIFY IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS
! PUBLISHED BY THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE
! LICENSE, OR (AT YOUR OPTION) ANY LATER VERSION.
! THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
! BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
! MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
! GENERAL PUBLIC LICENSE FOR MORE DETAILS.
!
! YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
! ALONG WITH THIS PROGRAM; IF NOT, WRITE TO : EDF R&D CODE_ASTER,
!    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
! ==================================================================
C--------------------------------------------------------------
C BUT : ROUTINE D'INTERFACE ENTRE LE CODE_ASTER ET LA BIBLIOTHEQUE
C       MUMPS DE RESOLUTION DE SYSTEMES LINEAIRES.
C       A UNE MATRICE ASTER CARACTERISEE PAR SON NOM (MATSZ) PEUT
C       CORRESPONDRE PLUSIEURS INSTANCES MUMPS SUIVANT:
C          - LE NUME_DDL ASSOCIE A LA MATR_ASSE,
C          - SON TYPE (R OU C),
C          - SA TAILLE (NU//'.SMOS.SMDI','LONMAX'),
C          - L'ARITHMETIQUE DE LA RESOLUTION MUMPS (SIMPLE OU DOUBLE)
C
C IN : ACTION :
C     /'PRERES'  : POUR DEMANDER LA FACTORISATION
C     /'RESOUD'  : POUR DEMANDER LA DESCENTE/REMONTEE
C     /'DETR_MAT': POUR DEMANDER LA DESTRUCTION DE L'INSTANCE MUMPS
C                  ASSOCIEE A UNE MATRICE (ON VA AUSSI DETRUIRE LA
C                  MATRICE, DONC PAS BESOIN DE CONNAITRE LE CONTEXTE
C                  DE RESOLUTION, CAD LA SD_SOLVEUR).
C                  EXEMPLE: DETRSD.
C     /'DETR_OCC': IDEM QUE CI DESSUS MAIS ON NE DETRUIT PAS DS
C                  L'IMMEDIAT LA MATRICE. IL FAUT CONNAITRE PRECISEMENT
C                  LA SD SOLVEUR. EXEMPLE: PRERES.
C IN : SOLVEZ   (K19) : NOM DE LA SD SOLVEUR
C             (SI ACTION=PRERES/RESOUD)
C IN : MATAS (K19) : NOM DE LA MATR_ASSE
C             (SI ACTION=PRERES/RESOUD/DETR_MATR)
C VAR: RSOLU (R)   : EN ENTREE : VECTEUR SECOND MEMBRE (REEL)
C                    EN SORTIE : VECTEUR SOLUTION (REEL)
C             (SI ACTION=RESOUD)
C VAR: CSOLU (C)   : EN ENTREE : VECTEUR SECOND MEMBRE (COMPLEXE)
C                    EN SORTIE : VECTEUR SOLUTION (COMPLEXE)
C             (SI ACTION=RESOUD)
C IN : VCINE (K19) : NOM DU CHAM_NO DE CHARGEMENT CINEMATIQUE
C            (SI ACTION=RESOUD)
C IN : NBSOL (I) : NOMRE DE SYSTEMES A RESOUDRE
C OUT : IRET (I) : CODE_RETOUR :
C            0 : OK
C            1 : ERREUR (DANS LE CAS OU MUMPS EST UTILISE EN PRE_COND)
C            2 : MATRICE NUMERIQUEMENT SINGULIERE 
C               (POUR PRERES/TLDLG3 OU OP0014/TLDLGG/TLDLG3)
C IN : PREPOS (LOG) : SI .TRUE. ON FAIT LES PRE ET POSTTRAITEMENTS DE
C           MISE A L'ECHELLE DU RHS ET DE LA SOLUTION (MRCONL) ET DE LA
C           PRISE EN COMPTE DES AFFE_CHAR_CINE (CSMBGG).
C           SI .FALSE. ON NE LES FAIT PAS (PAR EXEMPLE EN MODAL).
C----------------------------------------------------------------------
! RESPONSABLE BOITEAU O.BOITEAU

      CHARACTER*(*) ACTION,MATASZ,VCINEZ,SOLVEZ
      INTEGER       IRET,NBSOL
      REAL*8        RSOLU(*)
      COMPLEX*16    CSOLU(*)
      LOGICAL       PREPOS
      
#ifdef _HAVE_MUMPS

C============================================================
      INCLUDE 'mpif.h'
      INCLUDE 'smumps_struc.h'
      INCLUDE 'cmumps_struc.h'
      INCLUDE 'dmumps_struc.h'
      INCLUDE 'zmumps_struc.h'
C============================================================

      INTEGER NMXINS,IPREM
      PARAMETER (NMXINS=5)
      TYPE (SMUMPS_STRUC) , TARGET  :: SMPS(NMXINS)
      TYPE (CMUMPS_STRUC) , TARGET  :: CMPS(NMXINS)
      TYPE (SMUMPS_STRUC) , POINTER :: SMPSK
      TYPE (CMUMPS_STRUC) , POINTER :: CMPSK
      TYPE (DMUMPS_STRUC) , TARGET  :: DMPS(NMXINS)
      TYPE (ZMUMPS_STRUC) , TARGET  :: ZMPS(NMXINS)
      TYPE (DMUMPS_STRUC) , POINTER :: DMPSK
      TYPE (ZMUMPS_STRUC) , POINTER :: ZMPSK
      INTEGER      K,IERD,IBID,KXMPS,JREFA,N,NSMDI,IFM,NIV,IFMUMP,
     &             IMD,JSLVK,JSLVI,NPREC,IRETZ
      INTEGER*4    K4
      CHARACTER*1  ROUCS(NMXINS),ROUC,PREC,PRECS(NMXINS)
      CHARACTER*4  ETAMAT,KBID,ETAMS(NMXINS),ETAM
      CHARACTER*14 NONUS(NMXINS),NONU,NU,IMPR
      CHARACTER*19 MATAS,NOMATS(NMXINS),VCINE,NOMAT,NOSOLV,SOLVEU,
     &             NOSOLS(NMXINS)
      COMMON /MUMPSS/ SMPS
      COMMON /MUMPSC/ CMPS
      COMMON /MUMPSD/ DMPS
      COMMON /MUMPSZ/ ZMPS
      COMMON /MUMPSH/ NONUS,NOMATS,NOSOLS,ETAMS,ROUCS,PRECS
      
C --- DEBUT DECLARATIONS NORMALISEES JEVEUX ----------------------------
      INTEGER ZI
      COMMON /IVARJE/ZI(1)
      REAL*8 ZR
      COMMON /RVARJE/ZR(1)
      COMPLEX*16 ZC
      COMMON /CVARJE/ZC(1)
      LOGICAL ZL
      COMMON /LVARJE/ZL(1)
      CHARACTER*8 ZK8
      CHARACTER*16 ZK16
      CHARACTER*24 ZK24
      CHARACTER*32 ZK32
      CHARACTER*80 ZK80
      COMMON /KVARJE/ZK8(1),ZK16(1),ZK24(1),ZK32(1),ZK80(1)
C----------------------------------------------------------------
      SAVE IPREM
      DATA  IPREM /0/
C----------------------------------------------------------------
      CALL JEMARQ()
      
      IRETZ=0
      CALL INFNIV(IFM,NIV)
      IF ((ACTION(1:6).NE.'PRERES').AND.(ACTION(1:6).NE.'RESOUD').AND.
     &    (ACTION(1:8).NE.'DETR_OCC').AND.(ACTION(1:8).NE.'DETR_MAT'))
     &  CALL ASSERT(.FALSE.)

C --- ATTENTION: PARAMETRE DEVELOPPEUR 
C --- IMPR : PARAMETRE POUR IMPRIMER LA MATRICE + RHS + EVENTUELLEMENT
C            LA SOLUTION SUR L'UNITE IFMUMP.
C            EN SEQUENTIEL: UN SEUL FICHIER,
C            EN PARALLELE DISTRIBUE, UN FICHIER PAR PROC CONTENANT LA
C               MATRICE LOCALE + RHS (SI PROC 0) +  SOLUTION (SI PROC 0
C               ET SI DEMANDE)
C            EN PARALLELE CENTRALISE, UN FICHIER UNIQUEMENT SUR PROC 0
C --- VALEURS POSSIBLES:
C            = 'NON' RESOLUTION STD SANS ECRITURE FICHIER
C            = 'OUI_SOLVE' ON ECRIT MATRICE/RHS/SOLUTION ET ON RESOUD
C              COMPLETEMENT LE PB COMME EN STD
C            = 'OUI_NOSOLVE' IDEM CI-DESSUS SANS RESOUDRE AFIN
C               DE GAGNER DU TEMPS. LE CALCUL S'ARRETE EN UTMESS_F EN
C              FIN D'ECRITURE DU RHS. ON ECRIT PAS DE SOLUTION
      IMPR='OUI_SOLVE'
      IMPR='OUI_NOSOLVE'
      IMPR='NON'
      IFMUMP=17
C --- FIN BLOC PARAMETRE DEVELOPPEUR
      
      SOLVEU= SOLVEZ
      MATAS=MATASZ
      VCINE=VCINEZ


C      0. PHASE D'INITIALISATION
C      ---------------------------

      IF (IPREM.EQ.0) THEN
        IF (IMPR(1:3).NE.'NON') THEN
          IF (IMPR(1:9).EQ.'OUI_SOLVE') THEN
            CALL U2MESI('A','FACTOR_70',1,IFMUMP)
          ELSE IF (IMPR(1:11).EQ.'OUI_NOSOLVE') THEN
            CALL U2MESI('A','FACTOR_71',1,IFMUMP)
          ELSE
C --- OPTION NON PREVUE
            CALL ASSERT(.FALSE.)
          ENDIF
        ENDIF
        
C INITIALISE LES NMXINS INSTANCES MUMPS POTENTIELLES
C NOMATS (NOM DE LA MATR_ASSE GLOBALE), NONUS (NUM_DDL),
C NOSOLS (SD_SOLVEUR), ETAMS (?), ROUCS (R OU C)
        DO K=1,NMXINS
          NOMATS(K)=' '
          NONUS(K)=' '
          NOSOLS(K)=' '
          ETAMS(K)=' '
          ROUCS(K)=' '
          PRECS(K)=' '
        ENDDO
        IPREM=1
      ENDIF

C      1. RECHERCHE DE KXMPS (NUMERO DE L'INSTANCE XMUMPS) +
C           ROUC (R OU C) :
C      -----------------------------------------------------
      CALL ASSERT(MATAS.NE.' ')

C        Y-A-T-IL DEJA UNE INSTANCE EN MEMOIRE POUR MATAS ?

C     ON TEST LE NOM DE LA MATRICE, CELUI DU NUME_DDL, LE TYPE ET
C     LA TAILLE DU PB ASTER ET DU PB MUMPS ASSOCIE

      CALL DISMOI('F','NOM_NUME_DDL',MATAS,'MATR_ASSE',IBID,NU,IERD)
      CALL JELIRA(MATAS//'.VALM','TYPE',IBID,ROUC)
      CALL JELIRA(NU//'.SMOS.SMDI','LONMAX',NSMDI,KBID)
      
      CALL JEVEUO(MATAS//'.REFA','L',JREFA)
      IF ( ZK24(JREFA-1+11).EQ.'MATR_DISTR' ) THEN
        IMD=1
      ELSE
        IMD=0
      ENDIF


C ---  TESTS DE COMPATIBILITE DE SD_SOLVEUR EN FONCTION DE ACTION
      IF (SOLVEU.EQ.' ') THEN
C    -- ON NE CONNAIT PAS LA SD SOLVEUR. ON VIENT SANS DOUTE VIA TLDLGG.
C       ON PREND CELUI ASSOCIE A LA MATRICE
        CALL DISMOI('F','SOLVEUR',MATAS,'MATR_ASSE',IBID,SOLVEU,IBID)
      ENDIF
      PREC=' '
      IF (ACTION(1:8).EQ.'DETR_OCC') CALL ASSERT(SOLVEU.NE.' ')
      CALL JEEXIN(SOLVEU//'.SLVK',IBID)
      IF (IBID.NE.0) THEN
        CALL JEVEUO(SOLVEU//'.SLVK','L',JSLVK)
        IF (ZK24(JSLVK)(1:5).EQ.'MUMPS') THEN
          IF (ZK24(JSLVK-1+7)(1:3).EQ.'OUI') THEN
            PREC='S'
          ELSE IF (ZK24(JSLVK-1+7)(1:3).EQ.'NON') THEN
            PREC='D'
          ELSE
C --- ON A OUBLIE UNE INITIALISATION AMONT DE MIXPRE DS .SLVK
C     SAUF POUR CMDE ECLATEE
            IF (ACTION(1:5).NE.'DETR_') CALL ASSERT(.FALSE.)
          ENDIF
        ELSE
C --- A PRECISER POUR GCPC AVEC IC SIMPLE PRECISION AVEC MUMPS
          CALL ASSERT(.FALSE.)
        ENDIF
      ELSE
C --- ON DOIT AVOIR UNE SD_SOLVEUR.SLVK POUR CETTE OPTION
        IF (ACTION(1:8).EQ.'DETR_OCC') CALL ASSERT(.FALSE.)
      ENDIF
      
      KXMPS=1
      DO 1, K=1,NMXINS
C ----- ASTUCE POUR DETRUIRE TOUTES LES OCCURENCES (QQES SOIT LEUR
C       ARITHMETIQUE) ASSOCIEES A UNE MATRICE SI 'DETR_MAT'
        IF (ACTION(1:8).EQ.'DETR_MAT') PREC=PRECS(K)
        IF ((NOMATS(K).EQ.MATAS).AND.(NONUS(K).EQ.NU).AND.
     &      (ROUCS(K).EQ.ROUC).AND.(PRECS(K).EQ.PREC)) THEN
          K4=K
          IF (ROUC.EQ.'R') THEN
            IF (PREC.EQ.'S') THEN 
              SMPSK=>SMPS(K4)
              N=SMPSK%N
            ELSE IF (PREC.EQ.'D') THEN
              DMPSK=>DMPS(K4)
              N=DMPSK%N
            ELSE
              CALL ASSERT(.FALSE.)
            ENDIF
          ELSE IF (ROUC.EQ.'C') THEN
            IF (PREC.EQ.'S') THEN 
              CMPSK=>CMPS(K4)
              N=CMPSK%N
            ELSE IF (PREC.EQ.'D') THEN
              ZMPSK=>ZMPS(K4)
              N=ZMPSK%N
            ELSE
              CALL ASSERT(.FALSE.)
            ENDIF         
          ELSE
            CALL ASSERT(.FALSE.)
          ENDIF
          IF ( ((NSMDI.EQ.N).AND.(IMD.EQ.0)).OR.(IMD.EQ.1) ) THEN
            KXMPS=K
            ROUC=ROUCS(K)
            PREC=PRECS(K)
            GOTO 2
          ENDIF
        ENDIF
1     CONTINUE
      IF (ACTION(1:5).EQ.'DETR_') GO TO 9999

C        Y-A-T-IL ENCORE UNE PLACE LIBRE ?
      DO 4, K=1,NMXINS
        IF (NOMATS(K).EQ.' ') THEN
          KXMPS=K
          CALL JELIRA(MATAS//'.VALM','TYPE',IBID,ROUC)
          GOTO 2
        ENDIF
4     CONTINUE
      CALL U2MESS('F','FACTOR_60')
2     CONTINUE

      
C     2. QUELQUES VERIFICATIONS ET PETITES ACTIONS :
C     ----------------------------------------------
      IF (ACTION(1:6).EQ.'PRERES') THEN
         CALL DISMOI('F','NOM_NUME_DDL',MATAS,'MATR_ASSE',IBID,NU,IERD)
         CALL ASSERT(SOLVEU.NE.' ')
         CALL ASSERT(NOMATS(KXMPS).EQ.' ')
         CALL ASSERT(NOSOLS(KXMPS).EQ.' ')
         CALL ASSERT(NONUS(KXMPS).EQ.' ')
         CALL ASSERT(ETAMS(KXMPS).EQ.' ')
         CALL ASSERT(ROUCS(KXMPS).EQ.' ')
         CALL ASSERT(PRECS(KXMPS).EQ.' ')
         ETAM='FNUM'
         NOMAT=MATAS
         NOSOLV=SOLVEU
         NONU=NU
         NOMATS(KXMPS)=NOMAT
         NOSOLS(KXMPS)=NOSOLV
         ETAMS(KXMPS)=ETAM
         NONUS(KXMPS)=NONU
         ROUCS(KXMPS)=ROUC
         PRECS(KXMPS)=PREC

C        -- LA MATRICE EST-ELLE DEJA FACTORISEE ?
C           POUR LDLT ET MF C'EST FAIT DS TLDLR8/MULFR8...
         CALL JEVEUO(NOMAT//'.REFA','E',JREFA)
         ETAMAT=ZK24(JREFA-1+8)
         IF (ETAMAT.EQ.'DECT') THEN
            CALL U2MESS('A','FACTOR_59')
            GOTO 9999
         ELSE
           ZK24(JREFA-1+8)='DECT'
         ENDIF
         
C        --- PARAMETRE NPREC
         CALL JEVEUO(NOSOLV//'.SLVI','L',JSLVI)
         NPREC=ZI(JSLVI)

      ELSE  IF (ACTION(1:6).EQ.'RESOUD') THEN
         CALL ASSERT(NBSOL.GE.1)
         NOMAT=NOMATS(KXMPS)
         NOSOLV=NOSOLS(KXMPS)
         ETAM=ETAMS(KXMPS)
         NONU=NONUS(KXMPS)
         ROUC=ROUCS(KXMPS)
         PREC=PRECS(KXMPS)

         CALL ASSERT(SOLVEU.NE.' ')
         IF ( IMD.EQ.0 ) THEN
           CALL ASSERT(SOLVEU.EQ.NOSOLV)
           CALL ASSERT(ETAM.EQ.'FNUM')
         ENDIF
         CALL DISMOI('F','NOM_NUME_DDL',MATAS,'MATR_ASSE',IBID,NU,IERD)
         CALL ASSERT(NONU.EQ.NU)

      ELSE IF (ACTION(1:5).EQ.'DETR_') THEN
         NOMAT=NOMATS(KXMPS)
         CALL ASSERT(MATAS.NE.' ')

      ELSE
         CALL ASSERT(.FALSE.)
      ENDIF

      IF (ROUC.EQ.'R') THEN
        IF (PREC.EQ.'S') THEN
          CALL AMUMPS(ACTION,KXMPS,RSOLU,VCINE,NBSOL,IRETZ,IMPR,IFMUMP,
     &                PREPOS)
        ELSE IF (PREC.EQ.'D') THEN
          CALL AMUMPD(ACTION,KXMPS,RSOLU,VCINE,NBSOL,IRETZ,IMPR,IFMUMP,
     &                PREPOS)
        ELSE
          CALL ASSERT(.FALSE.)
        ENDIF
      ELSE IF (ROUC.EQ.'C') THEN
        IF (PREC.EQ.'S') THEN
          CALL AMUMPC(ACTION,KXMPS,CSOLU,VCINE,NBSOL,IRETZ,IMPR,IFMUMP,
     &                PREPOS)
        ELSE IF (PREC.EQ.'D') THEN
          CALL AMUMPZ(ACTION,KXMPS,CSOLU,VCINE,NBSOL,IRETZ,IMPR,IFMUMP,
     &                PREPOS)
        ELSE
          CALL ASSERT(.FALSE.)
        ENDIF
      ELSE
        CALL ASSERT(.FALSE.)
      ENDIF

      IF (ACTION(1:6).EQ.'PRERES') THEN
        CALL ASSERT((IRETZ.EQ.0).OR.(IRETZ.EQ.1).OR.(IRETZ.EQ.2))
        IF (IRETZ.EQ.2) THEN
          IF (NPREC.LT.0) THEN
C --- FONCTIONNALITE DE DETECTION DE SINGULARITE NON ACTIVEE: 
C                                               STOP EN UTMESS_F
            CALL U2MESS('F','FACTOR_42')
          ELSE
C --- FONCTIONNALITE DE DETECTION DE SINGULARITE ACTIVEE: 
C                                    ALARME + GESTION DU PB VIA TLDLG3
            CALL U2MESS('A','FACTOR_42')
          ENDIF
        ENDIF
      ENDIF

9999  CONTINUE
      IF ((IRETZ.NE.0).AND.(IRETZ.NE.1).AND.(IRETZ.NE.2)) THEN
C --- VALEUR ILLICITE
        CALL ASSERT(.FALSE.)
      ELSE
C --- ON PEUT FOURNIR L'OUTPUT
        IRET=IRETZ
      ENDIF
      CALL JEDEMA()

#else
      CALL U2MESS('F','FERMETUR_1')

#endif
      END
