      SUBROUTINE  AMUMPH(ACTION,SOLVEZ,MATASZ,RSOLU,CSOLU,VCINEZ,
     &                   NBSOL,IRET,PREPOS)
      IMPLICIT NONE
!           CONFIGURATION MANAGEMENT OF EDF VERSION
!& MODIF AMUMPH MUMPS  DATE 22/04/2013   AUTEUR BOITEAU O.BOITEAU 
! ==================================================================
! COPYRIGHT (C) 1991 - 2013  EDF R&D              WWW.CODE-ASTER.ORG
!
! THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR
! MODIFY IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS
! PUBLISHED BY THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE
! LICENSE, OR (AT YOUR OPTION) ANY LATER VERSION.
! THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL,
! BUT WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
! MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
! GENERAL PUBLIC LICENSE FOR MORE DETAILS.
!
! YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
! ALONG WITH THIS PROGRAM; IF NOT, WRITE TO : EDF R&D CODE_ASTER,
!    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
! ==================================================================
!--------------------------------------------------------------
! BUT : ROUTINE D'INTERFACE ENTRE LE CODE_ASTER ET LA BIBLIOTHEQUE
!       MUMPS DE RESOLUTION DE SYSTEMES LINEAIRES.
!       A UNE MATRICE ASTER CARACTERISEE PAR SON NOM (MATSZ) PEUT
!       CORRESPONDRE PLUSIEURS INSTANCES MUMPS SUIVANT:
!          - LE NUME_DDL ASSOCIE A LA MATR_ASSE,
!          - SON TYPE (R OU C),
!          - SA TAILLE (NU//'.SMOS.SMDI','LONMAX'),
!          - L'ARITHMETIQUE DE LA RESOLUTION MUMPS (SIMPLE OU DOUBLE)
!
! IN : ACTION :
!     /'VERSION' : POUR RECUPERER LE NUMERO DE VERSION (SEULEMENT LA
!              SD_SOLVEUR OU LA MATAS SONT REQUIS). CE NUMERO EST
!              STOCKEE DANS SD_SOLVEUR.SLVK(12). IL DOIT ETRE LICITE
!              (4.9.2 OU 4.10.0) SINON UTMESS_F. PAR DEFAUT ON CHERCHE
!              LE NUMERO DS LA SD_SOLVEUR, SINON ON PREND CELUI LIE
!              AU PACKAGE MUMPS LINKE.
!     /'PRERES'  : POUR DEMANDER LES ETAPES ANALYSE+FACTORISATION
!     /'RESOUD'  : POUR DEMANDER LA DESCENTE/REMONTEE
!     /'DETR_MAT': POUR DEMANDER LA DESTRUCTION DE L'INSTANCE MUMPS
!                  ASSOCIEE A UNE MATRICE (ON VA AUSSI DETRUIRE LA
!                  MATRICE, DONC PAS BESOIN DE CONNAITRE LE CONTEXTE
!                  DE RESOLUTION, CAD LA SD_SOLVEUR).
!                  EXEMPLE: DETRSD.
!     /'DETR_OCC': IDEM QUE CI DESSUS MAIS ON NE DETRUIT PAS DS
!                  L'IMMEDIAT LA MATRICE. IL FAUT CONNAITRE PRECISEMENT
!                  LA SD SOLVEUR. EXEMPLE: PRERES.
! IN : SOLVEZ   (K19) : NOM DE LA SD SOLVEUR
!             (SI ACTION=PRERES/RESOUD)
! IN : MATAS (K19) : NOM DE LA MATR_ASSE
!             (SI ACTION=PRERES/RESOUD/DETR_MATR)
! VAR: RSOLU (R)   : EN ENTREE : VECTEUR SECOND MEMBRE (REEL)
!                    EN SORTIE : VECTEUR SOLUTION (REEL)
!             (SI ACTION=RESOUD)
! VAR: CSOLU (C)   : EN ENTREE : VECTEUR SECOND MEMBRE (COMPLEXE)
!                    EN SORTIE : VECTEUR SOLUTION (COMPLEXE)
!             (SI ACTION=RESOUD)
! IN : VCINE (K19) : NOM DU CHAM_NO DE CHARGEMENT CINEMATIQUE
!            (SI ACTION=RESOUD)
! IN : NBSOL (I) : NOMRE DE SYSTEMES A RESOUDRE
! OUT : IRET (I) : CODE_RETOUR :
!            0 : OK
!            1 : ERREUR (DANS LE CAS OU MUMPS EST UTILISE EN PRE_COND)
!            2 : MATRICE NUMERIQUEMENT SINGULIERE
!               (POUR PRERES/TLDLG3 OU OP0014/TLDLGG/TLDLG3)
! IN : PREPOS (LOG) : SI .TRUE. ON FAIT LES PRE ET POSTTRAITEMENTS DE
!           MISE A L'ECHELLE DU RHS ET DE LA SOLUTION (MRCONL) ET DE LA
!           PRISE EN COMPTE DES AFFE_CHAR_CINE (CSMBGG).
!           SI .FALSE. ON NE LES FAIT PAS (PAR EXEMPLE EN MODAL).
!----------------------------------------------------------------------
! RESPONSABLE BOITEAU O.BOITEAU

      CHARACTER*(*) ACTION,MATASZ,VCINEZ,SOLVEZ
      INTEGER       IRET,NBSOL
      REAL*8        RSOLU(*)
      COMPLEX*16    CSOLU(*)
      LOGICAL       PREPOS

#ifdef _HAVE_MUMPS

!============================================================
      INCLUDE 'mpif.h'
      INCLUDE 'smumps_struc.h'
      INCLUDE 'cmumps_struc.h'
      INCLUDE 'dmumps_struc.h'
      INCLUDE 'zmumps_struc.h'
      INCLUDE 'jeveux.h'
!============================================================

      INTEGER NMXINS,IPREM
      PARAMETER (NMXINS=5)
      TYPE (SMUMPS_STRUC) , TARGET  :: SMPS(NMXINS)
      TYPE (CMUMPS_STRUC) , TARGET  :: CMPS(NMXINS)
      TYPE (SMUMPS_STRUC) , POINTER :: SMPSK
      TYPE (CMUMPS_STRUC) , POINTER :: CMPSK
      TYPE (DMUMPS_STRUC) , TARGET  :: DMPS(NMXINS)
      TYPE (ZMUMPS_STRUC) , TARGET  :: ZMPS(NMXINS)
      TYPE (DMUMPS_STRUC) , POINTER :: DMPSK
      TYPE (ZMUMPS_STRUC) , POINTER :: ZMPSK
      INTEGER      K,IERD,IBID,KXMPS,JREFA,N,NSMDI,IFM,NIV,IFMUMP,
     &             IMD,JSLVK,JSLVI,NPREC,IRETZ,PCENTP(2)
      LOGICAL      LBID,LPRECO
      CHARACTER*1  ROUCS(NMXINS),ROUC,PREC,PRECS(NMXINS)
      CHARACTER*4  ETAMAT,KBID,ETAMS(NMXINS),ETAM
      CHARACTER*12 K12BID
      CHARACTER*14 NONUS(NMXINS),NONU,NU,IMPR
      CHARACTER*19 MATAS,NOMATS(NMXINS),VCINE,NOMAT,NOSOLV,SOLVEU,
     &             NOSOLS(NMXINS)
      CHARACTER*24 KVERS
      COMMON /MUMPSS/ SMPS
      COMMON /MUMPSC/ CMPS
      COMMON /MUMPSD/ DMPS
      COMMON /MUMPSZ/ ZMPS
      COMMON /MUMPSH/ NONUS,NOMATS,NOSOLS,ETAMS,ROUCS,PRECS
!----------------------------------------------------------------
      SAVE IPREM
      DATA  IPREM /0/
!----------------------------------------------------------------
      CALL JEMARQ()

      IRETZ=0
      CALL INFNIV(IFM,NIV)
      IF ((ACTION(1:6).NE.'PRERES').AND.(ACTION(1:6).NE.'RESOUD').AND.
     &    (ACTION(1:8).NE.'DETR_OCC').AND.(ACTION(1:8).NE.'DETR_MAT')
     &    .AND.(ACTION(1:7).NE.'VERSION'))
     &  CALL ASSERT(.FALSE.)

! --- ATTENTION: PARAMETRE DEVELOPPEUR
! --- IMPR : PARAMETRE POUR IMPRIMER LA MATRICE + RHS + EVENTUELLEMENT
!            LA SOLUTION SUR L'UNITE IFMUMP.
!            EN SEQUENTIEL: UN SEUL FICHIER,
!            EN PARALLELE DISTRIBUE, UN FICHIER PAR PROC CONTENANT LA
!               MATRICE LOCALE + RHS (SI PROC 0) +  SOLUTION (SI PROC 0
!               ET SI DEMANDE)
!            EN PARALLELE CENTRALISE, UN FICHIER UNIQUEMENT SUR PROC 0
! --- VALEURS POSSIBLES:
!            = 'NON' RESOLUTION STD SANS ECRITURE FICHIER
!            = 'OUI_SOLVE' ON ECRIT MATRICE/RHS/SOLUTION ET ON RESOUD
!              COMPLETEMENT LE PB COMME EN STD
!            = 'OUI_NOSOLVE' IDEM CI-DESSUS SANS RESOUDRE AFIN
!               DE GAGNER DU TEMPS. LE CALCUL S'ARRETE EN UTMESS_F EN
!              FIN D'ECRITURE DU RHS. ON ECRIT PAS DE SOLUTION
      IMPR='OUI_SOLVE'
      IMPR='OUI_NOSOLVE'
      IMPR='NON'
      IFMUMP=17
! --- FIN BLOC PARAMETRE DEVELOPPEUR

      SOLVEU= SOLVEZ
      MATAS=MATASZ
      VCINE=VCINEZ


!      0. PHASE D'INITIALISATION
!      ---------------------------

      IF (IPREM.EQ.0) THEN
        IF (IMPR(1:3).NE.'NON') THEN
          IF (IMPR(1:9).EQ.'OUI_SOLVE') THEN
            CALL U2MESI('A','FACTOR_70',1,IFMUMP)
          ELSE IF (IMPR(1:11).EQ.'OUI_NOSOLVE') THEN
            CALL U2MESI('A','FACTOR_71',1,IFMUMP)
          ELSE
! --- OPTION NON PREVUE
            CALL ASSERT(.FALSE.)
          ENDIF
        ENDIF

! INITIALISE LES NMXINS INSTANCES MUMPS POTENTIELLES
! NOMATS (NOM DE LA MATR_ASSE GLOBALE), NONUS (NUM_DDL),
! NOSOLS (SD_SOLVEUR), ETAMS (?), ROUCS (R OU C)
        DO K=1,NMXINS
          NOMATS(K)=' '
          NONUS(K)=' '
          NOSOLS(K)=' '
          ETAMS(K)=' '
          ROUCS(K)=' '
          PRECS(K)=' '
        ENDDO
        IPREM=1
      ENDIF

!      1. RECHERCHE DE KXMPS (NUMERO DE L'INSTANCE XMUMPS) +
!           ROUC (R OU C) :
!      -----------------------------------------------------
      CALL ASSERT(MATAS.NE.' ')

!        Y-A-T-IL DEJA UNE INSTANCE EN MEMOIRE POUR MATAS ?

!     ON TEST LE NOM DE LA MATRICE, CELUI DU NUME_DDL, LE TYPE ET
!     LA TAILLE DU PB ASTER ET DU PB MUMPS ASSOCIE

      CALL DISMOI('F','NOM_NUME_DDL',MATAS,'MATR_ASSE',IBID,NU,IERD)
      CALL JELIRA(MATAS//'.VALM','TYPE',IBID,ROUC)
      CALL JELIRA(NU//'.SMOS.SMDI','LONMAX',NSMDI,KBID)

      CALL JEVEUO(MATAS//'.REFA','L',JREFA)
      IF ( ZK24(JREFA-1+11).EQ.'MATR_DISTR' ) THEN
        IMD=1
      ELSE
        IMD=0
      ENDIF


! ---  TESTS DE COMPATIBILITE DE SD_SOLVEUR EN FONCTION DE ACTION
      IF (SOLVEU.EQ.' ') THEN
!    -- ON NE CONNAIT PAS LA SD SOLVEUR. ON VIENT SANS DOUTE VIA TLDLGG.
!       ON PREND CELUI ASSOCIE A LA MATRICE
        CALL DISMOI('F','SOLVEUR',MATAS,'MATR_ASSE',IBID,SOLVEU,IBID)
      ENDIF

      PREC=' '
      LPRECO=.FALSE.
      IF (ACTION(1:8).EQ.'DETR_OCC') CALL ASSERT(SOLVEU.NE.' ')
      CALL JEEXIN(SOLVEU//'.SLVK',IBID)
      IF (IBID.NE.0) THEN
        CALL JEVEUO(SOLVEU//'.SLVK','L',JSLVK)
        IF (ZK24(JSLVK)(1:5).EQ.'MUMPS') THEN
! --- MUMPS EST-IL UTILISE COMME PRECONDITIONNEUR ?
! --- SI OUI, ON DEBRANCHE LES ALARMES ET INFO (PAS LES UTMESS_F)
          LPRECO = ZK24(JSLVK-1+8)(1:3).EQ.'OUI'
! --- ON RECUPERE UNIQUEMENT UN NUMERO DE VERSION LICITE
          IF (ACTION(1:7).EQ.'VERSION') THEN
            IF (ZK24(JSLVK-1+12)(1:4).EQ.'XXXX') THEN
              CALL AMUMPU(31,ROUC,IBID,K12BID,IBID,LBID,KVERS)
              ZK24(JSLVK-1+12)=KVERS
            ELSE
! --- ON TESTE JUSTE LE CARACTERE LICITE DU NUMERO DE VERSION DEJA
! --- STOCKE DANS LA SD_SOLVEUR
              KVERS=TRIM(ADJUSTL(ZK24(JSLVK-1+12)))
              SELECT CASE(KVERS)
              CASE('4.9.2','4.10.0')
              CASE DEFAULT
                CALL U2MESK('F','FACTOR_72',1,KVERS)
              END SELECT
            ENDIF
            GOTO 9999
          ENDIF
          IF (ZK24(JSLVK-1+7)(1:3).EQ.'OUI') THEN
            PREC='S'
          ELSE IF (ZK24(JSLVK-1+7)(1:3).EQ.'NON') THEN
            PREC='D'
          ELSE
! --- ON A OUBLIE UNE INITIALISATION AMONT DE MIXPRE DS .SLVK
!     SAUF POUR CMDE ECLATEE
            IF (ACTION(1:5).NE.'DETR_') CALL ASSERT(.FALSE.)
          ENDIF
        ELSE

! --- A PRECISER POUR GCPC AVEC IC SIMPLE PRECISION AVEC MUMPS
          CALL ASSERT(.FALSE.)
        ENDIF
      ELSE
! --- ON DOIT AVOIR UNE SD_SOLVEUR.SLVK POUR CETTE OPTION
        IF ((ACTION(1:8).EQ.'DETR_OCC').OR.(ACTION(1:7).EQ.'VERSION'))
     &       CALL ASSERT(.FALSE.)
      ENDIF

      KXMPS=1
      DO 1, K=1,NMXINS
! ----- ASTUCE POUR DETRUIRE TOUTES LES OCCURENCES (QQES SOIT LEUR
!       ARITHMETIQUE) ASSOCIEES A UNE MATRICE SI 'DETR_MAT'
        IF (ACTION(1:8).EQ.'DETR_MAT') PREC=PRECS(K)
        IF ((NOMATS(K).EQ.MATAS).AND.(NONUS(K).EQ.NU).AND.
     &      (ROUCS(K).EQ.ROUC).AND.(PRECS(K).EQ.PREC)) THEN
          IF (ROUC.EQ.'R') THEN
            IF (PREC.EQ.'S') THEN
              SMPSK=>SMPS(K)
              N=SMPSK%N
            ELSE IF (PREC.EQ.'D') THEN
              DMPSK=>DMPS(K)
              N=DMPSK%N
            ELSE
              CALL ASSERT(.FALSE.)
            ENDIF
          ELSE IF (ROUC.EQ.'C') THEN
            IF (PREC.EQ.'S') THEN
              CMPSK=>CMPS(K)
              N=CMPSK%N
            ELSE IF (PREC.EQ.'D') THEN
              ZMPSK=>ZMPS(K)
              N=ZMPSK%N
            ELSE
              CALL ASSERT(.FALSE.)
            ENDIF
          ELSE
            CALL ASSERT(.FALSE.)
          ENDIF
          IF ( ((NSMDI.EQ.N).AND.(IMD.EQ.0)).OR.(IMD.EQ.1) ) THEN
            KXMPS=K
            ROUC=ROUCS(K)
            PREC=PRECS(K)
            GOTO 2
          ENDIF
        ENDIF
1     CONTINUE
      IF (ACTION(1:5).EQ.'DETR_') GO TO 9999

!        Y-A-T-IL ENCORE UNE PLACE LIBRE ?
      DO 4, K=1,NMXINS
        IF (NOMATS(K).EQ.' ') THEN
          KXMPS=K
          CALL JELIRA(MATAS//'.VALM','TYPE',IBID,ROUC)
          GOTO 2
        ENDIF
4     CONTINUE
      CALL U2MESS('F','FACTOR_60')
2     CONTINUE


!     2. QUELQUES VERIFICATIONS ET PETITES ACTIONS :
!     ----------------------------------------------
      IF (ACTION(1:6).EQ.'PRERES') THEN
         CALL DISMOI('F','NOM_NUME_DDL',MATAS,'MATR_ASSE',IBID,NU,IERD)
         CALL ASSERT(SOLVEU.NE.' ')
         CALL ASSERT(NOMATS(KXMPS).EQ.' ')
         CALL ASSERT(NOSOLS(KXMPS).EQ.' ')
         CALL ASSERT(NONUS(KXMPS).EQ.' ')
         CALL ASSERT(ETAMS(KXMPS).EQ.' ')
         CALL ASSERT(ROUCS(KXMPS).EQ.' ')
         CALL ASSERT(PRECS(KXMPS).EQ.' ')
         ETAM='FNUM'
         NOMAT=MATAS
         NOSOLV=SOLVEU
         NONU=NU
         NOMATS(KXMPS)=NOMAT
         NOSOLS(KXMPS)=NOSOLV
         ETAMS(KXMPS)=ETAM
         NONUS(KXMPS)=NONU
         ROUCS(KXMPS)=ROUC
         PRECS(KXMPS)=PREC

!        -- LA MATRICE EST-ELLE DEJA FACTORISEE ?
!           POUR LDLT ET MF C'EST FAIT DS TLDLR8/MULFR8...
         CALL JEVEUO(NOMAT//'.REFA','E',JREFA)
         ETAMAT=ZK24(JREFA-1+8)
         IF (ETAMAT.EQ.'DECT') THEN
            IF (.NOT.LPRECO) CALL U2MESS('A','FACTOR_59')
            GOTO 9999
         ELSE
           ZK24(JREFA-1+8)='DECT'
         ENDIF

!        --- PARAMETRE NPREC
         CALL JEVEUO(NOSOLV//'.SLVI','L',JSLVI)
         NPREC=ZI(JSLVI)

      ELSE  IF (ACTION(1:6).EQ.'RESOUD') THEN
         CALL ASSERT(NBSOL.GE.1)
         NOMAT=NOMATS(KXMPS)
         NOSOLV=NOSOLS(KXMPS)
         ETAM=ETAMS(KXMPS)
         NONU=NONUS(KXMPS)
         ROUC=ROUCS(KXMPS)
         PREC=PRECS(KXMPS)

         CALL ASSERT(SOLVEU.NE.' ')
         IF ( IMD.EQ.0 ) THEN
           CALL ASSERT(SOLVEU.EQ.NOSOLV)
           CALL ASSERT(ETAM.EQ.'FNUM')
         ENDIF
         CALL DISMOI('F','NOM_NUME_DDL',MATAS,'MATR_ASSE',IBID,NU,IERD)
         CALL ASSERT(NONU.EQ.NU)

      ELSE IF (ACTION(1:5).EQ.'DETR_') THEN
         NOMAT=NOMATS(KXMPS)
         CALL ASSERT(MATAS.NE.' ')

      ELSE
         CALL ASSERT(.FALSE.)
      ENDIF

!        --- SI GESTION_MEMOIRE='AUTO'
!        --- PARAMETRES POUR LA GESTION DE PCENT_PIVOT/ELIM_LAGR2
!        --- PCENTP(1) --> NBRE TENTATIVES DE FACTO.
!        --- PCENTP(2) --> TERME MULTIPLICATIF DE PCENT_PIVOT ENTRE DEUX
!            TENTATIVES DE FACTO.:
!                    PCENT_PIVOT_NEW=PCENT_PIVOT_OLD*PCENTP(2)
      PCENTP(1)=3
      PCENTP(2)=2
      IF (ROUC.EQ.'R') THEN
        IF (PREC.EQ.'S') THEN
          CALL AMUMPS(ACTION,KXMPS,RSOLU,VCINE,NBSOL,IRETZ,IMPR,IFMUMP,
     &                PREPOS,PCENTP)
        ELSE IF (PREC.EQ.'D') THEN
          CALL AMUMPD(ACTION,KXMPS,RSOLU,VCINE,NBSOL,IRETZ,IMPR,IFMUMP,
     &                PREPOS,PCENTP)
        ELSE
          CALL ASSERT(.FALSE.)
        ENDIF
      ELSE IF (ROUC.EQ.'C') THEN
        IF (PREC.EQ.'S') THEN
          CALL AMUMPC(ACTION,KXMPS,CSOLU,VCINE,NBSOL,IRETZ,IMPR,IFMUMP,
     &                PREPOS,PCENTP)
        ELSE IF (PREC.EQ.'D') THEN
          CALL AMUMPZ(ACTION,KXMPS,CSOLU,VCINE,NBSOL,IRETZ,IMPR,IFMUMP,
     &                PREPOS,PCENTP)
        ELSE
          CALL ASSERT(.FALSE.)
        ENDIF
      ELSE
        CALL ASSERT(.FALSE.)
      ENDIF

! --- NETTOYAGE DES OCCURENCES MUMPS EN MODE GESTION_MEMOIRE='EVAL' POUR
! --- PAR EXEMPLE NE PAS DEPASSER 5 OCCURENCES SIMULTANNEES EN CAS
! --- D'USAGE DU MECANISME TRY_EXCEPT PYTHON
      IF ((ACTION(1:6).EQ.'PRERES').AND.(ZK24(JSLVK+8)(1:4).EQ.'EVAL'))
     &THEN
        IF (ROUC.EQ.'R') THEN
          IF (PREC.EQ.'S') THEN
            CALL AMUMPS('DETR_OCC',KXMPS,RSOLU,VCINE,NBSOL,IRETZ,IMPR,
     &                  IFMUMP,PREPOS,PCENTP)
          ELSE IF (PREC.EQ.'D') THEN
            CALL AMUMPD('DETR_OCC',KXMPS,RSOLU,VCINE,NBSOL,IRETZ,IMPR,
     &                  IFMUMP,PREPOS,PCENTP)
          ENDIF
        ELSE IF (ROUC.EQ.'C') THEN
          IF (PREC.EQ.'S') THEN
            CALL AMUMPC('DETR_OCC',KXMPS,CSOLU,VCINE,NBSOL,IRETZ,IMPR,
     &                  IFMUMP,PREPOS,PCENTP)
          ELSE IF (PREC.EQ.'D') THEN
            CALL AMUMPZ('DETR_OCC',KXMPS,CSOLU,VCINE,NBSOL,IRETZ,IMPR,
     &                  IFMUMP,PREPOS,PCENTP)
          ENDIF
        ENDIF
        CALL U2MESS('F','FACTOR_77')
      ENDIF

! --- GESTION DES CODES RETOUR EN CAS DE DETECTION DE SINGULARITES
      IF (ACTION(1:6).EQ.'PRERES') THEN
        CALL ASSERT((IRETZ.EQ.0).OR.(IRETZ.EQ.1).OR.(IRETZ.EQ.2))
        IF (IRETZ.EQ.2) THEN
          IF (NPREC.LT.0) THEN
! --- FONCTIONNALITE DE DETECTION DE SINGULARITE NON ACTIVEE:
!                                               STOP EN UTMESS_F
            CALL U2MESS('F','FACTOR_42')
          ELSE
! --- FONCTIONNALITE DE DETECTION DE SINGULARITE ACTIVEE:
!                                    ALARME + GESTION DU PB VIA TLDLG3
            IF (.NOT.LPRECO) CALL U2MESS('A','FACTOR_42')
          ENDIF
        ENDIF
      ENDIF

9999  CONTINUE
      IF ((IRETZ.NE.0).AND.(IRETZ.NE.1).AND.(IRETZ.NE.2)) THEN
! --- VALEUR ILLICITE
        CALL ASSERT(.FALSE.)
      ELSE
! --- ON PEUT FOURNIR L'OUTPUT
        IRET=IRETZ
      ENDIF
      CALL JEDEMA()

#else
      CALL U2MESS('F','FERMETUR_1')

#endif
      END
