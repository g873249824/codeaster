# encoding: utf-8

import shlex
from functools import partial

from waflib import Configure, Utils, Logs


def options(self):
    self.load('compiler_c')
    self.load('compiler_fc')

def configure(self):
    from Options import options as opts
    self.add_os_flags('FORFLAGS', 'FCFLAGS')
    self.add_os_flags('FORLINKFLAGS', 'FCLINKFLAGS')
    self.add_os_flags('FORINCLUDES', 'INCLUDES')
    self.add_os_flags('FORDEFINES', 'DEFINES')

    for incpath in ('bibfor/include', 'bibfor/include/fake'):
        paths = self.srcnode.ant_glob(incpath, src=True, dir=True)
        paths = [d.abspath() for d in paths]
        self.env.append_value('INCLUDES', paths)
    if self.env.HAVE_MUMPS:
        ant = 'bibfor/include_mumps-%s%s' \
            % (self.env.MUMPS_version, opts.parallel and '_mpi' or '')
        dirs = [d.abspath() for d in self.srcnode.ant_glob(ant, src=True, dir=True)]
        self.env.append_value('INCLUDES', dirs)

    self.check_fortran()
    self.check_fortran_dummy_main()
    self.check_fortran_compiler_flags()
    self.check_fortran_mangling()
    # insert flags before FCSHLIB_MARKER (and after FCSTLIB_MARKER)
    if self.env.OPTLIB_FLAGS:
        self.start_msg('Checking for OPTLIB_FLAGS')
        self.env.prepend_value('FCSHLIB_MARKER', self.env.OPTLIB_FLAGS)
        self.end_msg(self.env.OPTLIB_FLAGS)

def build(self):
    buildenv = self.all_envs[self.variant]
    get_srcs = self.path.get_src().ant_glob

    self(
        features = 'fc',
            name = 'asterbibfor',
          source = get_srcs('**/*.F90'),
             env = buildenv,
             use = ['MPI', 'OPENMP', 'MED', 'MUMPS', 'SCOTCH', 'PETSC'],
    )

###############################################################################

@Configure.conf
def check_fortran_compiler_flags(self):
    self.start_msg('Getting fortran compiler flags')
    flags = []
    if self.env.FC_NAME == 'GFORTRAN':
        if self.env.DEST_CPU == 'x86_64':
            flags += ['-fdefault-%s-%i' % (name, 8)
                      for name in ('double', 'integer', 'real')]

    if self.env.FC_NAME == 'IFORT':
        flags += ['-fpe0', '-traceback']
        if self.env.DEST_CPU == 'x86_64':
            flags += ['-%s%i' % (name, 8) for name in 'ir']
    self.env.append_unique('FCFLAGS', flags)
    self.end_msg(flags)

@Configure.conf
def check_optimization_fcflags(self):
    """
    loop optimization error using LOC function in gfortran
    Debian bug report: http://gcc.gnu.org/bugzilla/show_bug.cgi?id=51267
    Check if it must be fixed using the 'VOLATILE' statement.
    """
    with_volatile = self.uncompress64('''
eJx9kkFPhDAQhe/+infbFgtaNtnshYOJa7LRxIsHrxUKNtR2A8X48x3YlCVZlFP7Zr43ry3A9J06
33TqC0H3wfry5qzi21sVjNUwQx8144JudJfsR5FJvqILoyrhBBkJ/WNC6Ssdu6xvTKksfHvNBfXB
drOfQ4F8blIVbRnhJaM2jnRaUgIOjjvsY2PlISVMIYWLEqag5HDLTLJN85EokMo/6vL/OrCo0yig
9C4YN8xH9C2Vs9ANOlukyvMp1TZZ5qoxnoYZjszpDOPsM10r2084YdcTRs63HOFTL9ziVRN/f1FP
HV0wEoHN6/MmyprcV0G5Bj49HF8OjxfYVaaOG3pLi8P78Y1FF77ou/qvfgGhoZdy
''')
    without_volatile = self.uncompress64('''
eJx9kkFPhDAQhe/7K95tWwS0bGL2wsHommw08eLBa4WCDbXdQDH+fAfWsiSgnNo38715bQHG79S6
upWf8KrzxhWb+7OML2ek10ZB993mV9PWq1q10X4QmeAreqxlGduYnGL1rX3hShW6jKt1IQ1cs+S8
fGe3k59FjmxqkiVtGeEFozaOZFxSAg6Oa+xDY+kgBHQuYhskjEHJ4YrpaJdkA5EjEX/Uxf91YFan
UUDhrNe2n47oGiqnvu1VOkuVZWOqXTTPVWE4DdMcqVUphtlnupKmG3HClhMGzjUc/kPN3MJVE39z
UU8tXTCiGNuXp22QFbmvgmINfLw7Ph8eLrAtdRU29JYGh7fjKwsufNa3+LF+AEX8l7U=
''')
    self.setenv('debug')
    flags = ['-g']
    self.start_msg('Setting fortran debug flags')
    self.env.append_unique('FCFLAGS', flags)
    self.end_msg(flags)

    self.setenv('release')
    testit = partial(self.check_fc, mandatory=False,
                     compile_filename='testloc.f', execute=True, use=['OPENMP'])
    self.start_msg('Getting fortran optimization flags')
    flags = [f for f in self.env.FCFLAGS
             if (f.startswith('-O') and f[-1].isdigit()) or f == '-g']
    # remove existing optimization flags
    map(self.env.FCFLAGS.remove, flags)
    if not flags:
        flags = ['-O2']
    # different cases to check
    # '-fno-tree-dse' is a workaround that works with gfortran 4.6
    last_ressort = ['-O0']
    cases = [(without_volatile,
              (flags, flags + ['-fno-tree-dse']),),
             (with_volatile,
              (flags, flags + ['-fno-tree-dse'], last_ressort),),]
    optflag = ''
    legend = 'failed'
    for code, all_opts in cases:
        for opts in all_opts:
            if testit(fcflags=opts, fragment=code, 
                      mandatory=opts is last_ressort):
                optflag = opts
                if code is with_volatile:
                    # should be used in jeveux*.h in future
                    DEF = 'USE_VOLATILE_COMMON'
                    legend = 'VOLATILE is required, -D%s' % DEF
                    self.env.append_unique('DEFINES', [DEF])
                else:
                    legend = 'VOLATILE not required'
                break
        if optflag:
            break
    self.env.append_unique('FCFLAGS', optflag)
    self.end_msg('%s (%s)' % (optflag, legend))
