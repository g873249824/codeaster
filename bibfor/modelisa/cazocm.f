      SUBROUTINE CAZOCM(CHAR  ,MOTFAC,IZONE )
C
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF MODELISA  DATE 21/09/2011   AUTEUR COURTOIS M.COURTOIS 
C ======================================================================
C COPYRIGHT (C) 1991 - 2011  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
C (AT YOUR OPTION) ANY LATER VERSION.                                   
C                                                                       
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
C                                                                       
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.         
C ======================================================================
C RESPONSABLE ABBAS M.ABBAS
C
      IMPLICIT NONE
      CHARACTER*8  CHAR
      CHARACTER*16 MOTFAC     
      INTEGER      IZONE
C      
C ----------------------------------------------------------------------
C
C ROUTINE CONTACT (METHODE MAILLEE - LECTURE DONNEES)
C
C LECTURE DES PRINCIPALES CARACTERISTIQUES DU CONTACT 
C CONCERNANT L'APPARIEMENT ET SES OPTIONS
C      
C ----------------------------------------------------------------------
C
C
C IN  CHAR   : NOM UTILISATEUR DU CONCEPT DE CHARGE
C IN  IFORM  : TYPE DE FORMULATION 
C IN  MOTFAC : MOT-CLE FACTEUR (VALANT 'CONTACT')
C IN  IZONE  : INDICE POUR LIRE LES DONNEES
C
C
C -------------- DEBUT DECLARATIONS NORMALISEES JEVEUX -----------------
C
      INTEGER ZI
      COMMON /IVARJE/ ZI(1)
      REAL*8 ZR
      COMMON /RVARJE/ ZR(1)
      COMPLEX*16 ZC
      COMMON /CVARJE/ ZC(1)
      LOGICAL ZL
      COMMON /LVARJE/ ZL(1)
      CHARACTER*8 ZK8
      CHARACTER*16 ZK16
      CHARACTER*24 ZK24
      CHARACTER*32 ZK32
      CHARACTER*80 ZK80
      COMMON /KVARJE/ ZK8(1),ZK16(1),ZK24(1),ZK32(1),ZK80(1)
C
C ---------------- FIN DECLARATIONS NORMALISEES JEVEUX -----------------
C
      INTEGER      CFMMVD,ZMETH,ZDIRN,ZTOLE
      INTEGER      NOC
      CHARACTER*24 DEFICO   
      CHARACTER*24 METHCO,TOLECO
      INTEGER      JMETH ,JTOLE 
      CHARACTER*24 DIRAPP,DIRNOR
      INTEGER      JDIRAP,JDIRNO
      CHARACTER*24 JEUFO1,JEUFO2
      INTEGER      JJFO1,JJFO2     
      CHARACTER*16 APPA,NORM,APTY,TYPNOR,TYPM,VERI
      REAL*8       NOOR,R8PREM
      REAL*8       DIR(3),TOLJ,TOLA,TOLINT
      CHARACTER*8  JEUF1,JEUF2
      LOGICAL      LLISS,CFDISL,LCALC
      INTEGER      IARG
C
C ----------------------------------------------------------------------
C
      CALL JEMARQ
C
C --- INITIALISATIONS
C
      DEFICO = CHAR(1:8)//'.CONTACT' 
      TOLJ   = 0.D0  
      TOLA   = 0.D0  
      JEUF1  = ' '
      JEUF2  = ' ' 
      DIR(1) = 0.D0
      DIR(2) = 0.D0
      DIR(3) = 0.D0
      TOLINT = 0.D0      
      LCALC  = .TRUE.
      LLISS  = CFDISL(DEFICO,'LISSAGE')
C
C --- LECTURE DES STRUCTURES DE DONNEES DE CONTACT
C 
      METHCO = DEFICO(1:16)//'.METHCO' 
      TOLECO = DEFICO(1:16)//'.TOLECO'    
      DIRAPP = DEFICO(1:16)//'.DIRAPP'
      DIRNOR = DEFICO(1:16)//'.DIRNOR'      
      JEUFO1 = DEFICO(1:16)//'.JFO1CO'
      JEUFO2 = DEFICO(1:16)//'.JFO2CO'           
C
      CALL JEVEUO(DIRAPP,'E',JDIRAP)
      CALL JEVEUO(DIRNOR,'E',JDIRNO)
      CALL JEVEUO(METHCO,'E',JMETH )
      CALL JEVEUO(TOLECO,'E',JTOLE )
      CALL JEVEUO(JEUFO1,'E',JJFO1 )
      CALL JEVEUO(JEUFO2,'E',JJFO2 )       
C
      ZMETH = CFMMVD('ZMETH')   
      ZDIRN = CFMMVD('ZDIRN')   
      ZTOLE = CFMMVD('ZTOLE') 
C
C --- RECUPERATION DU TYPE D'APPARIEMENT
C
      CALL GETVTX(MOTFAC,'APPARIEMENT',IZONE,IARG,1,APPA  ,NOC   )
      IF (APPA(1:5) .EQ. 'NODAL') THEN
        ZI(JMETH+ZMETH*(IZONE-1)+1-1) = 0
      ELSEIF (APPA(1:9) .EQ. 'MAIT_ESCL') THEN
        ZI(JMETH+ZMETH*(IZONE-1)+1-1) = 1       
      ELSE
        CALL ASSERT(.FALSE.)
      END IF
C
C --- PRESENCE DE DIST_POUTRE/DIST_COQUE      
C 
      CALL GETVTX(MOTFAC,'DIST_POUTRE',IZONE,IARG,1,TYPM  ,NOC   )
      IF (TYPM(1:3) .EQ. 'OUI') THEN
        ZI(JMETH+ZMETH*(IZONE-1)+2-1) = 1
      ENDIF
      CALL GETVTX(MOTFAC,'DIST_COQUE' ,IZONE,IARG,1,TYPM  ,NOC   )
      IF (TYPM(1:3) .EQ. 'OUI') THEN
        ZI(JMETH+ZMETH*(IZONE-1)+3-1) = 1
      ENDIF
C
C --- TYPE DE NORMALE
C
      CALL GETVTX(MOTFAC,'NORMALE',IZONE,IARG,1,NORM,NOC)
C
      IF (NORM(1:4) .EQ. 'MAIT') THEN
        IF (NORM(5:9).EQ.'_ESCL') THEN
          ZI(JMETH+ZMETH*(IZONE-1)+4-1) = 1
        ELSE 
          ZI(JMETH+ZMETH*(IZONE-1)+4-1) = 0
        ENDIF  
      ELSEIF (NORM(1:4) .EQ. 'ESCL') THEN
        ZI(JMETH+ZMETH*(IZONE-1)+4-1) = 2  
      ELSE
        CALL ASSERT(.FALSE.)
      ENDIF
C 
C --- DEFINITION DU TYPE DE NORMALE - MAITRE
C      
      CALL GETVTX(MOTFAC,'VECT_MAIT',IZONE,IARG,1,TYPNOR,NOC)
C      
      IF (TYPNOR.EQ.'AUTO') THEN
        ZI(JMETH+ZMETH*(IZONE-1)+5-1) = 0
      ELSEIF  (TYPNOR.EQ.'FIXE') THEN 
        IF (ZI(JMETH+ZMETH*(IZONE-1)+4-1).NE.0) THEN
          CALL U2MESS('F','CONTACT3_50')
        ENDIF
        IF (LLISS) THEN
          CALL U2MESS('F','CONTACT3_54')
        ENDIF
        ZI(JMETH+ZMETH*(IZONE-1)+5-1) = 1
        CALL GETVR8(MOTFAC,'MAIT_FIXE',IZONE,IARG,3,DIR,NOC)
        IF (NOC.EQ.0) THEN
          CALL ASSERT(.FALSE.)
        ENDIF
        CALL NORMEV(DIR   ,NOOR  )
        IF (NOOR.LE.R8PREM()) THEN
          CALL U2MESS('F','CONTACT_15')
        ENDIF      
        ZR(JDIRNO+ZDIRN*(IZONE-1))   = DIR(1)
        ZR(JDIRNO+ZDIRN*(IZONE-1)+1) = DIR(2)
        ZR(JDIRNO+ZDIRN*(IZONE-1)+2) = DIR(3)               
      ELSEIF  (TYPNOR.EQ.'VECT_Y') THEN 
        IF (ZI(JMETH+ZMETH*(IZONE-1)+4-1).NE.0) THEN
          CALL U2MESS('F','CONTACT3_51')
        ENDIF    
        IF (LLISS) THEN
          CALL U2MESS('F','CONTACT3_54')
        ENDIF          
        ZI(JMETH+ZMETH*(IZONE-1)+5-1) = 2
        CALL GETVR8(MOTFAC,'MAIT_VECT_Y',IZONE,IARG,3,DIR,NOC)
        IF (NOC.EQ.0) THEN
          CALL ASSERT(.FALSE.)
        ENDIF 
        CALL NORMEV(DIR   ,NOOR  )
        IF (NOOR.LE.R8PREM()) THEN
          CALL U2MESS('F','CONTACT_16')
        ENDIF   
        ZR(JDIRNO+ZDIRN*(IZONE-1))   = DIR(1)
        ZR(JDIRNO+ZDIRN*(IZONE-1)+1) = DIR(2)
        ZR(JDIRNO+ZDIRN*(IZONE-1)+2) = DIR(3)                     
      ELSE
        CALL ASSERT(.FALSE.)
      ENDIF
C 
C --- DEFINITION DU TYPE DE NORMALE - ESCLAVE
C      
      CALL GETVTX(MOTFAC,'VECT_ESCL',IZONE,IARG,1,TYPNOR,NOC)
C      
      IF (TYPNOR.EQ.'AUTO') THEN
        ZI(JMETH+ZMETH*(IZONE-1)+6-1) = 0
      ELSEIF  (TYPNOR.EQ.'FIXE') THEN 
        IF (ZI(JMETH+ZMETH*(IZONE-1)+4-1).NE.2) THEN
          CALL U2MESS('F','CONTACT3_52')
        ENDIF  
        IF (LLISS) THEN
          CALL U2MESS('F','CONTACT3_54')
        ENDIF            
        ZI(JMETH+ZMETH*(IZONE-1)+6-1) = 1
        CALL GETVR8(MOTFAC,'ESCL_FIXE',IZONE,IARG,3,DIR,NOC)
        IF (NOC.EQ.0) THEN
          CALL ASSERT(.FALSE.)
        ENDIF
        CALL NORMEV(DIR   ,NOOR  )
        IF (NOOR.LE.R8PREM()) THEN
          CALL U2MESS('F','CONTACT_15')
        ENDIF      
        ZR(JDIRNO+ZDIRN*(IZONE-1)+3) = DIR(1)
        ZR(JDIRNO+ZDIRN*(IZONE-1)+4) = DIR(2)
        ZR(JDIRNO+ZDIRN*(IZONE-1)+5) = DIR(3)                    
      ELSEIF  (TYPNOR.EQ.'VECT_Y') THEN 
        IF (ZI(JMETH+ZMETH*(IZONE-1)+4-1).NE.2) THEN
          CALL U2MESS('F','CONTACT3_53')
        ENDIF  
        IF (LLISS) THEN
          CALL U2MESS('F','CONTACT3_54')
        ENDIF               
        ZI(JMETH+ZMETH*(IZONE-1)+6-1) = 2
        CALL GETVR8(MOTFAC,'ESCL_VECT_Y',IZONE,IARG,3,DIR,NOC)
        IF (NOC.EQ.0) THEN
          CALL ASSERT(.FALSE.)
        ENDIF
        CALL NORMEV(DIR   ,NOOR  )
        IF (NOOR.LE.R8PREM()) THEN
          CALL U2MESS('F','CONTACT_16')
        ENDIF  
        ZR(JDIRNO+ZDIRN*(IZONE-1)+3) = DIR(1)
        ZR(JDIRNO+ZDIRN*(IZONE-1)+4) = DIR(2)
        ZR(JDIRNO+ZDIRN*(IZONE-1)+5) = DIR(3)                        
      ELSE
        CALL ASSERT(.FALSE.)
      ENDIF
C
C --- RECH. APPARIEMENT DANS UNE DIRECTION FIXE: DIRE_APPA
C     
      CALL GETVTX(MOTFAC,'TYPE_APPA',IZONE,IARG,1,APTY,NOC)
      IF (APTY(1:6) .EQ. 'PROCHE') THEN
        ZI(JMETH+ZMETH*(IZONE-1)+7-1) = 0
      ELSEIF (APTY(1:4) .EQ. 'FIXE') THEN
        ZI(JMETH+ZMETH*(IZONE-1)+7-1) = 1
        CALL GETVR8(MOTFAC,'DIRE_APPA',IZONE,IARG,3,DIR,NOC)
        CALL NORMEV(DIR   ,NOOR  )
        IF (NOOR.LE.R8PREM()) THEN
          CALL U2MESS('F','CONTACT3_15')
        ENDIF
        ZR(JDIRAP+3*(IZONE-1))   = DIR(1)
        ZR(JDIRAP+3*(IZONE-1)+1) = DIR(2)
        ZR(JDIRAP+3*(IZONE-1)+2) = DIR(3)        
      ELSE
        CALL ASSERT(.FALSE.)
      ENDIF        
C
C --- PRESENCE DE VERIF   
C 
      CALL GETVTX(MOTFAC,'RESOLUTION',IZONE,IARG,1,VERI  ,NOC   )
      IF (VERI(1:3) .EQ. 'NON') THEN
        ZI(JMETH+ZMETH*(IZONE-1)+22-1) = 1
        LCALC = .FALSE.
      ENDIF
C
C --- PARAMETRE APPARIEMENT: DIST_MAIT/DIST_ESCL
C
      CALL GETVID(MOTFAC,'DIST_MAIT',IZONE,IARG,1,JEUF1,NOC)
      IF (NOC .NE. 0) ZK8(JJFO1+IZONE-1) = JEUF1
      CALL GETVID(MOTFAC,'DIST_ESCL',IZONE,IARG,1,JEUF2,NOC)
      IF (NOC .NE. 0) ZK8(JJFO2+IZONE-1) = JEUF2
C
C --- PARAMETRE APPARIEMENT: TOLE_PROJ_EXT
C --- TOLE_PROJ_EXT <0: LA PROJECTION HORS DE LA MAILLE EST INTERDITE
C --- TOLE_PROJ_EXT >0: LA PROJECTION HORS DE LA MAILLE EST AUTORISEE
C ---                    MAIS LIMITEE PAR TOLJ
C
      CALL GETVR8(MOTFAC,'TOLE_PROJ_EXT',IZONE,IARG,1,TOLJ,NOC)
      IF (TOLJ .LT. 0.D0) THEN
        ZR(JTOLE+ZTOLE*(IZONE-1)+1-1) = -1.D0
      ELSE
        ZR(JTOLE+ZTOLE*(IZONE-1)+1-1) = TOLJ
      ENDIF       
C
C --- PARAMETRE APPARIEMENT: TOLE_APPA
C --- TOLE_APPA <0: ON APPARIE QUELQUE SOIT LA DISTANCE ESCLAVE/MAITRE
C --- TOLE_APPA >0: ON APPARIE SI DISTANCE ESCLAVE/MAITRE<TOLE
C
      CALL GETVR8(MOTFAC,'TOLE_APPA',IZONE,IARG,1,TOLA,NOC)
      IF (TOLA .LT. 0.D0) THEN
        ZR(JTOLE+ZTOLE*(IZONE-1)+2-1) = -1.D0
      ELSE
        ZR(JTOLE+ZTOLE*(IZONE-1)+2-1) = TOLA
      ENDIF
C
C --- SPECIFIQUE METHODE SANS RESOLUTION
C
      IF (.NOT.LCALC) THEN
        CALL GETVR8(MOTFAC,'TOLE_INTERP',IZONE,IARG,1,TOLINT,NOC)
        ZR(JTOLE+ZTOLE*(IZONE-1)+3-1) = TOLINT
      ENDIF 
C
      CALL JEDEMA()
      END
