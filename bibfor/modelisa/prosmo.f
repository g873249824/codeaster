      SUBROUTINE PROSMO(MATREZ,LIMAT,NBMAT,BASEZ,NUMEDD,LSYM,ROUC)
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF MODELISA  DATE 19/06/2007   AUTEUR PELLET J.PELLET 
C ======================================================================
C COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.

C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.

C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C.======================================================================
      IMPLICIT NONE

C     PROSMO  --  LE BUT DE CETTE ROUTINE EST DE CONSTRUIRE LA MATR_ASSE
C                 DE NOM MATRES QUI VA RESULTER DE LA COMBINAISON
C                 LINEAIRE DES NBMAT MATR_ASSE DE LA LISTE LISMAT
C                 DE NOMS DE MATR_ASSE. LES MATRICES ONT UN STOCKAGE
C                 MORSE


C   ARGUMENT        E/S  TYPE         ROLE
C    MATREZ         OUT    K*     NOM DE LA MATR_ASSE RESULTANT DE LA
C                                 COMBINAISON LINEAIRE DES MATR_ASSE
C                                 DE LA LISTE LISMAT.
C    LIMAT          IN    K24     LISTE DES MATR_ASSE A COMBINER
C                                 DES MATR_ASSE A COMBINER.
C    NBMAT          IN    I       ON FAIT LA COMBINAISON LINEAIRE
C                                 DES NBMAT PREMIERS MATR_ASSE DE LA
C                                 LISTE LIMAT.
C    BASEZ          IN    K*      NOM DE LA BASE SUR LAQUELLE ON
C                                 CONSTRUIT LA MATR_ASSE.
C    NUMEDD         IN    K14    NOM DU NUME_DDL SUR LEQUEL S'APPUIERA
C                                 LA MATR_ASSE MATREZ
C        SI NUMEDD  =' ', LE NOM DU NUME_DDL SERA OBTENU PAR GCNCON
C        SI NUMEDD /=' ', ON PRENDRA NUMEDD COMME NOM DE NUME_DDL

C    LSYM           IN    L      /.TRUE.  : MATRICE SYMETRIQUE
C                                /.FALSE. : MATRICE NON-SYMETRIQUE
C    ROUC           IN    K1     /'R ' : MATRICE REELLE
C                                /'C'  : MATRICE COMPLEXE

C.========================= DEBUT DES DECLARATIONS ====================
C ----- COMMUNS NORMALISES  JEVEUX
      INTEGER ZI
      COMMON /IVARJE/ZI(1)
      REAL*8 ZR,TMAX,JEVTBL
      COMMON /RVARJE/ZR(1)
      COMPLEX*16 ZC
      COMMON /CVARJE/ZC(1)
      LOGICAL ZL
      COMMON /LVARJE/ZL(1)
      CHARACTER*8 ZK8
      CHARACTER*16 ZK16
      CHARACTER*24 ZK24
      CHARACTER*32 ZK32
      CHARACTER*80 ZK80
      COMMON /KVARJE/ZK8(1),ZK16(1),ZK24(1),ZK32(1),ZK80(1)
      CHARACTER*32 JEXNUM
C -----  ARGUMENTS
      INTEGER NBMAT
      LOGICAL LSYM
      CHARACTER*(*) MATREZ,BASEZ,NUMEDD
      CHARACTER*(*) LIMAT(NBMAT)
      CHARACTER*1 ROUC
C -----  VARIABLES LOCALES
      CHARACTER*1 K1BID,BASE
      CHARACTER*14 NUMDDL,NUMDD1,NUMDDI
      CHARACTER*19 MATRES,MAT1,MATI
      CHARACTER*24 KSMHC,KSMDI,KREFA,KCONL,KVALM
      CHARACTER*24 KREFI,KLISTE
      INTEGER LGBL,JHTC,I,IADI,JEQ,NBTER,JIBL,JPBL,IBL1,LCUMU,KBL,JBL1
      INTEGER IBLAV,IDHCOI,ICUM,ISMDI,LSMHC,NTERM,IDSMHC,L,JSMDE
      INTEGER ITBLOC,NBLOC,KBLOC,JREFA,IDREFI,IDCONL,IEQ,IBID
      INTEGER IER,JSMDE1,NEQ,K,HTC

C.========================= DEBUT DU CODE EXECUTABLE ==================

      CALL JEMARQ()

C --- INITIALISATIONS :
C     ---------------
      BASE = BASEZ
      MATRES = MATREZ


C --- NOM DU NUME_DDL A CONSTRUIRE :
C     ----------------------------
      IF (NUMEDD.EQ.' ') THEN
        CALL GCNCON('_',NUMDDL(1:8))
        NUMDDL(9:14) = '.NUDDL'

      ELSE
        NUMDDL = NUMEDD
      END IF

C --- NOM DE LA PREMIERE MATR_ASSE :
C     ----------------------------
      MAT1 = LIMAT(1)

C --- RECUPERATION DU NUME_DDL ATTACHE A LA PREMIERE MATR_ASSE  :
C     --------------------------------------------------------
      CALL DISMOI('F','NOM_NUME_DDL',MAT1,'MATR_ASSE',IBID,NUMDD1,IER)


C --- RECOPIE DU PROF_CHNO DE LA PREMIERE MATRICE SUR LA MATRICE
C --- RESULTANTE :
C     ---------
      CALL JEDUPO(NUMDD1//'.NUME.DEEQ',BASE,NUMDDL//'.NUME.DEEQ',
     &            .FALSE.)
      CALL JEDUPO(NUMDD1//'.NUME.DELG',BASE,NUMDDL//'.NUME.DELG',
     &            .FALSE.)
      CALL JEDUPO(NUMDD1//'.NUME.LILI',BASE,NUMDDL//'.NUME.LILI',
     &            .FALSE.)
      CALL JEDUPO(NUMDD1//'.NUME.LPRN',BASE,NUMDDL//'.NUME.LPRN',
     &            .FALSE.)
      CALL JEDUPO(NUMDD1//'.NUME.NUEQ',BASE,NUMDDL//'.NUME.NUEQ',
     &            .FALSE.)
      CALL JEDUPO(NUMDD1//'.NUME.PRNO',BASE,NUMDDL//'.NUME.PRNO',.TRUE.)
      CALL JEDUPO(NUMDD1//'.NUME.REFN',BASE,NUMDDL//'.NUME.REFN',
     &            .FALSE.)
      CALL JEDUPO(NUMDD1//'.NUME.NEQU',BASE,NUMDDL//'.NUME.NEQU',
     &            .FALSE.)

C --- RECOPIE DU .NSLV DE LA PREMIERE MATRICE SUR LA MATRICE
      CALL JEDUP1(NUMDD1//'.NSLV',BASE,NUMDDL//'.NSLV')

C --- RECUPERATION DU NOMBRE D'EQUATIONS DE LA PREMIERE MATRICE
C --- A COMBINER (C'EST LE MEME POUR TOUTES LES MATRICES) :
C     ---------------------------------------------------
      CALL JEVEUO(NUMDD1//'.SMOS.SMDE','L',JSMDE1)
      NEQ = ZI(JSMDE1-1+1)


C     7) CONSTRUCTION DE L'OBJET KLISTE QUI CONTIENDRA LES DIFFERENTS
C        SMHC(MAT_I) MIS BOUT A BOUT (EQUATION PAR EQUATION) :
C        KLISTE(JEQ)=SMHC(IMAT_1)(JEQ)//SMHC(IMAT_2)(JEQ)//...
C        KLISTE EST ALLOUé PAR "BLOC" POUR EVITER D'UTILISER
C        TROP DE MEMOIRE
C     =========================================================
      KLISTE = '&&PROSMO.KLISTE'
C     RECUPERATION DE LA TAILLE DES BLOCS DONNEE DANS LA COMMANDE DEBUT:
      TMAX = JEVTBL()
      LGBL = INT(TMAX*1024)

C     7-1) HTC : HAUTEUR CUMULEE DE KLISTE(JEQ)
C     --------------------------------------------------------
      CALL WKVECT('&&PROSMO.HTC','V V I',NEQ,JHTC)
      DO 20 I = 1,NBMAT
        MATI = LIMAT(I)
        CALL DISMOI('F','NOM_NUME_DDL',MATI,'MATR_ASSE',IBID,NUMDDI,IER)
        CALL JEVEUO(NUMDDI//'.SMOS.SMDI','L',IADI)
        DO 10,JEQ = 1,NEQ
          IF (JEQ.EQ.1) THEN
            NBTER = 1

          ELSE
            NBTER = ZI(IADI-1+JEQ) - ZI(IADI-1+JEQ-1)
          END IF
          ZI(JHTC-1+JEQ) = ZI(JHTC-1+JEQ) + NBTER
   10   CONTINUE
        CALL JELIBE(NUMDDI//'.SMOS.SMDI')
   20 CONTINUE

C     7-2) IBL : NUMERO DU BLOC DE KLISTE(JEQ) :
C          PBL : POSITION DE L'EQUATION JEQ DANS LE BLOC IBL  :
C     ------------------------------------------------------------
      CALL WKVECT('&&PROSMO.IBL','V V I',NEQ,JIBL)
      CALL WKVECT('&&PROSMO.PBL','V V I',NEQ,JPBL)
      IBL1 = 1
      LCUMU = 0
      DO 30,JEQ = 1,NEQ
        HTC=ZI(JHTC-1+JEQ)
        CALL ASSERT(HTC.LE.LGBL)
C       -- SI ON CHANGE DE BLOC :
        IF (LCUMU + HTC .GT. LGBL) THEN
          IBL1 = IBL1 + 1
          LCUMU = 0
        END IF
        ZI(JIBL-1+JEQ) = IBL1
        ZI(JPBL-1+JEQ) = LCUMU
        LCUMU = LCUMU + HTC
   30 CONTINUE

C     7-3) ALLOCATION DE KLISTE :
C     ------------------------------------------------------------
      IF (IBL1.EQ.1) LGBL = LCUMU
      CALL JECREC(KLISTE,'V V I','NU','DISPERSE','CONSTANT',IBL1)
      CALL JEECRA(KLISTE,'LONMAX',LGBL,K1BID)
      DO 40 KBL = 1,IBL1
        CALL JEVEUO(JEXNUM(KLISTE,KBL),'E',JBL1)
        CALL JELIBE(JEXNUM(KLISTE,KBL))
   40 CONTINUE

C     7-4) REMPLISSAGE DE KLISTE :
C     ------------------------------------------------------------
      CALL JEDETR('&&PROSMO.HTC')
      CALL WKVECT('&&PROSMO.HTC','V V I',NEQ,JHTC)
      IBLAV = 1
      CALL JEVEUO(JEXNUM(KLISTE,IBLAV),'E',JBL1)
      DO 70 I = 1,NBMAT
        MATI = LIMAT(I)
        CALL DISMOI('F','NOM_NUME_DDL',MATI,'MATR_ASSE',IBID,NUMDDI,IER)
        CALL JEVEUO(NUMDDI//'.SMOS.SMDI','L',IADI)
        CALL JEVEUO(NUMDDI//'.SMOS.SMHC','L',IDHCOI)
        ICUM = 0
        DO 60,JEQ = 1,NEQ
          IF (JEQ.EQ.1) THEN
            NBTER = 1

          ELSE
            NBTER = ZI(IADI-1+JEQ) - ZI(IADI-1+JEQ-1)
          END IF

C         LE BLOC CONTENANT J DOIT-IL ETRE RAMENE EN MEMOIRE ?
          IBL1 = ZI(JIBL-1+JEQ)
          IF (IBLAV.NE.IBL1) THEN
            CALL JELIBE(JEXNUM(KLISTE,IBLAV))
            CALL JEVEUO(JEXNUM(KLISTE,IBL1),'E',JBL1)
            IBLAV = IBL1
          END IF
          DO 50,K = 1,NBTER
            ZI(JBL1+ZI(JPBL-1+JEQ)+ZI(JHTC-1+JEQ)+K-1) = ZI(IDHCOI+ICUM+
     &         (K-1))
   50     CONTINUE
          ICUM = ICUM + NBTER
          ZI(JHTC-1+JEQ) = ZI(JHTC-1+JEQ) + NBTER
   60   CONTINUE
        CALL JELIBE(NUMDDI//'.SMOS.SMDI')
        CALL JELIBE(NUMDDI//'.SMOS.SMHC')
   70 CONTINUE
      CALL JELIBE(JEXNUM(KLISTE,IBLAV))


C     7-5) COMPACTAGE DE L'OBJET KLISTE
C     8)   ET CREATION  DU TABLEAU .SMDI
C     ===================================
      KSMDI = NUMDDL//'.SMOS.SMDI'
      CALL WKVECT(KSMDI,BASE//' V I',NEQ,ISMDI)

      LSMHC = 0
      IBLAV = 1
      CALL JEVEUO(JEXNUM(KLISTE,IBLAV),'E',JBL1)
      DO 80 JEQ = 1,NEQ
C       LE BLOC CONTENANT JEQ DOIT-IL ETRE RAMENE EN MEMOIRE ?
        IBL1 = ZI(JIBL-1+JEQ)
        IF (IBLAV.NE.IBL1) THEN
          CALL JELIBE(JEXNUM(KLISTE,IBLAV))
          CALL JEVEUO(JEXNUM(KLISTE,IBL1),'E',JBL1)
          IBLAV = IBL1
        END IF

C       ON TRIE ET ORDONNE LA COLONNE (EN PLACE)
        NTERM = ZI(JHTC-1+JEQ)
        CALL UTTRII(ZI(JBL1+ZI(JPBL-1+JEQ)),NTERM)
        ZI(JHTC-1+JEQ) = NTERM
        IF (JEQ.EQ.1) THEN
          CALL ASSERT(NTERM.EQ.1)
          ZI(ISMDI+1-1) = NTERM

        ELSE
          ZI(ISMDI+JEQ-1) = ZI(ISMDI+ (JEQ-1)-1) + NTERM
        END IF
        LSMHC = LSMHC + NTERM
   80 CONTINUE
      CALL JELIBE(JEXNUM(KLISTE,IBLAV))


C     9) CREATION ET AFFECTATION DU TABLEAU .SMHC
C     ====================================================
      KSMHC = NUMDDL//'.SMOS.SMHC'
      CALL WKVECT(KSMHC,BASE//' V I',LSMHC,IDSMHC)
      IBLAV = 1
      CALL JEVEUO(JEXNUM(KLISTE,IBLAV),'E',JBL1)
      L = 0
      DO 100 JEQ = 1,NEQ
C       LE BLOC CONTENANT JEQ DOIT-IL ETRE RAMENE EN MEMOIRE ?
        IBL1 = ZI(JIBL-1+JEQ)
        IF (IBLAV.NE.IBL1) THEN
          CALL JELIBE(JEXNUM(KLISTE,IBLAV))
          CALL JEVEUO(JEXNUM(KLISTE,IBL1),'E',JBL1)
          IBLAV = IBL1
        END IF

        NTERM = ZI(JHTC-1+JEQ)
        DO 90 K = 1,NTERM
          L = L + 1
          ZI(IDSMHC-1+L) = ZI(JBL1+ZI(JPBL-1+JEQ)-1+K)
   90   CONTINUE
  100 CONTINUE
      CALL JELIBE(JEXNUM(KLISTE,IBLAV))
      CALL JEDETR(KLISTE)
      CALL JEDETR('&&PROSMO.HTC')
      CALL JEDETR('&&PROSMO.IBL')
      CALL JEDETR('&&PROSMO.PBL')


C     10) CREATION ET AFFECTATION DU TABLEAU .IABL
C     ========================================================


C     11) CREATION ET AFFECTATION DU TABLEAU .SMDE
C     =============================================

      CALL WKVECT(NUMDDL//'.SMOS.SMDE',BASE//' V I',6,JSMDE)

C --- RECUPERATION DE LA TAILLE DU BLOC DE LA MATRICE RESULTANTE
C --- (NOMBRE DE TERMES NON NULS DE LA MATRICE)
      ITBLOC = ZI(ISMDI+NEQ-1)

      ZI(JSMDE-1+1) = NEQ
      ZI(JSMDE-1+2) = ITBLOC
      ZI(JSMDE-1+3) = 1


C     12) CREATION ET AFFECTATION DE LA COLLECTION .VALM
C     ===================================================
      KVALM = MATRES//'.VALM'
      CALL JEDETR(KVALM)
      IF (LSYM) THEN
        NBLOC = 1

      ELSE
        NBLOC = 2
      END IF
      CALL JECREC(KVALM,BASE//' V '//ROUC,'NU','DISPERSE',
     &            'CONSTANT',NBLOC)
      CALL JEECRA(KVALM,'LONMAX',ITBLOC,' ')
      DO 110,KBLOC = 1,NBLOC
        CALL JECROC(JEXNUM(KVALM,KBLOC))
  110 CONTINUE


C     13) CREATION ET AFFECTATION DU TABLEAU .REFA
C     ============================================================
      KREFA = MATRES//'.REFA'
      KCONL = MATRES//'.CONL'
      CALL JEEXIN(KREFA,IER)
      IF (IER.EQ.0) THEN
        CALL WKVECT(KREFA,BASE//' V K24',10,JREFA)

      ELSE
        CALL JEVEUO(KREFA,'E',JREFA)
      END IF
      ZK24(JREFA-1+2) = NUMDDL
      IF (LSYM) THEN
        ZK24(JREFA-1+9) = 'MS'

      ELSE
        ZK24(JREFA-1+9) = 'MR'
      END IF
      ZK24(JREFA-1+10) = 'NOEU'

      DO 120 I = 1,NBMAT
        MATI = LIMAT(I)
        KREFI = MATI//'.REFA'
        CALL JEVEUO(KREFI,'L',IDREFI)
        IF (ZK24(IDREFI+1-1).NE.' ') THEN
          ZK24(JREFA-1+1) = ZK24(IDREFI+1-1)
          GO TO 130

        END IF
  120 CONTINUE
  130 CONTINUE


C     15) CREATION ET AFFECTATION DU VECTEUR .CONL
C     =============================================
      CALL WKVECT(KCONL,BASE//' V R',NEQ,IDCONL)
      DO 140 IEQ = 1,NEQ
        ZR(IDCONL+IEQ-1) = 1.D0
  140 CONTINUE

      CALL JEDEMA()

      END
