      SUBROUTINE CAZOCC(CHAR  ,MOTFAC,IZONE )
C
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF MODELISA  DATE 26/03/2013   AUTEUR ABBAS M.ABBAS 
C ======================================================================
C COPYRIGHT (C) 1991 - 2013  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C RESPONSABLE ABBAS M.ABBAS
C
      IMPLICIT NONE
      INCLUDE 'jeveux.h'
      CHARACTER*8  CHAR
      CHARACTER*16 MOTFAC
      INTEGER      IZONE
C
C ----------------------------------------------------------------------
C
C ROUTINE CONTACT (METHODE CONTINUE - LECTURE DONNEES)
C
C LECTURE DES PRINCIPALES CARACTERISTIQUES DU CONTACT (SURFACE IZONE)
C REMPLISSAGE DE LA SD 'DEFICO' (SURFACE IZONE)
C
C ----------------------------------------------------------------------
C
C
C IN  CHAR   : NOM UTILISATEUR DU CONCEPT DE CHARGE
C IN  MOTFAC : MOT-CLE FACTEUR (VALANT 'ZONE')
C IN  IZONE  : INDICE POUR LIRE LES DONNEES DANS AFFE_CHAR_MECA
C
C ----------------------------------------------------------------------
C
      INTEGER      CFMMVD,ZCMCF,ZEXCL
      CHARACTER*24 DEFICO
      INTEGER      NOC,NOCC
      CHARACTER*24 CARACF,EXCLFR,SGRNO
      INTEGER      JCMCF,JEXCLF
      CHARACTER*16 GLIS,INTEG,STACO0,ALGOC,ALGOF
      REAL*8       REXCLF,DIREXF(3)
      REAL*8       COEFFF,SEUILI
      REAL*8       COEFAF,COEFAC
      REAL*8       ALGOCR,ALGOFR
      REAL*8       TYPINT,CTRINI
      INTEGER      PARINT
      LOGICAL      LINTNO,LFROT,LSSCON,LSSFRO,LEXDIR,MMINFL,CFDISL
      LOGICAL      LGLISS,LNEWTG,LNEWTC
      INTEGER      IARG
C
C ----------------------------------------------------------------------
C
      CALL JEMARQ
C
C --- INITIALISATIONS
C
      DEFICO    = CHAR(1:8)//'.CONTACT'
      LFROT     = CFDISL(DEFICO,'FROTTEMENT')
      LNEWTG    = CFDISL(DEFICO,'GEOM_NEWTON')
      LNEWTC    = CFDISL(DEFICO,'CONT_NEWTON')
C
      PARINT    = 0
      TYPINT    = 0.D0
      ALGOCR    = 0.D0
      COEFAC    = 100.D0
      ALGOFR    = 0.D0
      COEFFF    = 0.D0
      COEFAF    = 100.D0
      SEUILI    = 0.D0
      CTRINI    = 0.D0
      LINTNO    = .FALSE.
      LSSCON    = .FALSE.
      LSSFRO    = .FALSE.
      REXCLF    = 0.D0
      DIREXF(1) = 0.D0
      DIREXF(2) = 0.D0
      DIREXF(3) = 0.D0
      LGLISS    = .FALSE.
C
C --- LECTURE DES STRUCTURES DE DONNEES DE CONTACT
C
      CARACF = DEFICO(1:16)//'.CARACF'
      EXCLFR = DEFICO(1:16)//'.EXCLFR'
C
      CALL JEVEUO(CARACF,'E',JCMCF )
      CALL JEVEUO(EXCLFR,'E',JEXCLF)
C
      ZCMCF = CFMMVD('ZCMCF')
      ZEXCL = CFMMVD('ZEXCL')
C
C --- TYPE INTEGRATION
C
      CALL GETVTX(MOTFAC,'INTEGRATION',IZONE,IARG,1,INTEG,NOC)
      IF (INTEG(1:4) .EQ. 'AUTO') THEN
        LINTNO = .TRUE.
        TYPINT = 1.D0
      ELSE IF (INTEG(1:5) .EQ. 'GAUSS') THEN
        CALL GETVIS(MOTFAC,'ORDRE_INT',IZONE,IARG,1,PARINT,NOC)
        TYPINT = 10.D0*PARINT + 2.D0
      ELSE IF (INTEG(1:7) .EQ. 'SIMPSON') THEN
        CALL GETVIS(MOTFAC,'ORDRE_INT',IZONE,IARG,1,PARINT,NOC)
        TYPINT = 10.D0*PARINT + 3.D0
      ELSE IF (INTEG(1:6) .EQ. 'NCOTES') THEN
        CALL GETVIS(MOTFAC,'ORDRE_INT',IZONE,IARG,1,PARINT,NOC)
        TYPINT = 10.D0*PARINT + 4.D0
      ELSE
        CALL ASSERT(.FALSE.)
      ENDIF
C
C --- OPTIONS CONTACT
C
      CALL GETVTX(MOTFAC,'ALGO_CONT',IZONE,IARG,1,ALGOC,NOC)
      IF (ALGOC(1:10) .EQ. 'STANDARD') THEN
        CALL GETVR8(MOTFAC,'COEF_CONT',IZONE,IARG,1,COEFAC,NOC)
        ALGOCR = 1.D0
      ELSEIF (ALGOC(1:14) .EQ. 'PENALISATION') THEN
        CALL GETVR8(MOTFAC,'COEF_PENA_CONT',IZONE,IARG,1,COEFAC,NOC)
        ALGOCR = 3.D0
      ELSE
        CALL ASSERT(.FALSE.)
      ENDIF
C
C --- OPTIONS FROTTEMENT
C
      IF (LFROT) THEN
        CALL GETVTX(MOTFAC,'ALGO_FROT',IZONE,IARG,1,ALGOF,NOC)
        IF (ALGOF(1:10) .EQ. 'STANDARD') THEN
          CALL GETVR8(MOTFAC,'COEF_FROT',IZONE,IARG,1,COEFAF,NOC)
          ALGOFR = 1.D0
        ELSEIF (ALGOF(1:14) .EQ. 'PENALISATION') THEN
          CALL GETVR8(MOTFAC,'COEF_PENA_FROT',IZONE,IARG,1,COEFAF,NOC)
          ALGOFR = 3.D0
        ELSE
          CALL ASSERT(.FALSE.)
        ENDIF
        IF (ALGOC.NE.ALGOF) CALL U2MESS('F','CONTACT_89')
      ELSE
        COEFAF = 0.D0
        ALGOFR = 0.D0
      ENDIF
C
C --- INCOMPATIBILITES
C
      IF (LFROT.AND.(ALGOC.NE.ALGOF)) CALL U2MESS('F','CONTACT_89')
      IF ((ALGOC.EQ.'PENALISATION').AND.LNEWTG)
     &                     CALL U2MESS('F','CONTACT_21')
      IF (LNEWTG.AND.(.NOT.LNEWTC))
     &                     CALL U2MESS('F','CONTACT_20')
C
C --- CARACTERISTIQUES DU FROTTEMENT PAR ZONE
C
      IF (LFROT) THEN
        CALL GETVR8(MOTFAC,'COULOMB'   ,IZONE,IARG,1,COEFFF,NOC)
        CALL GETVR8(MOTFAC,'SEUIL_INIT',IZONE,IARG,1,SEUILI,NOC)
        IF (COEFFF.EQ.0.D0) THEN
          COEFAF = 0.D0
          ALGOFR = 0.D0
        ENDIF
      ENDIF
C
C --- TRAITEMENT EXCLUSION NOEUDS CONTACT
C
      CALL GETVTX(MOTFAC,'SANS_GROUP_NO'   ,IZONE,IARG,1,SGRNO,NOC)
      CALL GETVTX(MOTFAC,'SANS_NOEUD'      ,IZONE,IARG,1,SGRNO,NOCC)
      LSSCON = (NOC.NE.0)  .OR. (NOCC.NE.0)
C
      CALL GETVTX(MOTFAC,'SANS_GROUP_MA'   ,IZONE,IARG,1,SGRNO,NOC)
      CALL GETVTX(MOTFAC,'SANS_MAILLE'     ,IZONE,IARG,1,SGRNO,NOCC)
      LSSCON = LSSCON.OR.((NOC.NE.0).OR.(NOCC.NE.0))
C
C --- TRAITEMENT EXCLUSION NOEUDS FROTTEMENT
C
      CALL GETVTX(MOTFAC,'SANS_GROUP_NO_FR',IZONE,IARG,1,SGRNO,NOC)
      CALL GETVTX(MOTFAC,'SANS_NOEUD_FR'   ,IZONE,IARG,1,SGRNO,NOCC)
      LSSFRO = (NOC.NE.0) .OR. (NOCC.NE.0)
C
C --- SI NOEUD EXCLUS, ON VERIFIE QU'ON A UNE INTEGRATION AUX NOEUDS
C
      IF (.NOT.LINTNO) THEN
        IF (LSSCON .OR. LSSFRO) THEN
          CALL U2MESS('F','CONTACT_97')
        ENDIF
        IF (.NOT.MMINFL(DEFICO,'MAIT',IZONE )) THEN
          CALL U2MESS('F','CONTACT_98')
        ENDIF
      ENDIF
C
C --- NOMBRE DE DIRECTIONS A EXCLURE ET VECTEUR DIRECTEUR
C
      IF (LSSFRO) THEN
        CALL GETVR8(MOTFAC,'DIRE_EXCL_FROT',IZONE,IARG,3,DIREXF,NOC)
        LEXDIR = (NOC .NE. 0)
        IF (.NOT.LEXDIR) THEN
C ------- TOUTES LES DIRECTIONS SONT EXCLUES
          REXCLF    = 2.D0
          DIREXF(1) = 0.D0
          DIREXF(2) = 0.D0
          DIREXF(3) = 0.D0
        ELSE
C ------- UNE SEULE DIRECTION EST EXCLUE
          REXCLF = 1.D0
        ENDIF
      ELSE
        REXCLF    = 0.D0
        DIREXF(1) = 0.D0
        DIREXF(2) = 0.D0
        DIREXF(3) = 0.D0
      ENDIF
C
C --- CONTACT INITIAL
C
      CALL GETVTX(MOTFAC,'CONTACT_INIT',IZONE,IARG,1,STACO0,NOC)
      IF (STACO0 .EQ. 'OUI') THEN
        CTRINI = 1.D0
      ELSEIF (STACO0 .EQ. 'INTERPENETRE') THEN
        CTRINI = 2.D0
      ELSEIF (STACO0 .EQ. 'NON') THEN
        CTRINI = 0.D0
      ELSE
        CALL ASSERT(.FALSE.)
      ENDIF
C
C --- GLISSIERE
C
      CALL GETVTX(MOTFAC,'GLISSIERE',IZONE,IARG,1,GLIS  ,NOC   )
      IF (GLIS(1:3) .EQ. 'OUI') THEN
        LGLISS = .TRUE.
      ELSEIF (GLIS(1:3) .EQ. 'NON') THEN
        LGLISS = .FALSE.
      ELSE
        CALL ASSERT(.FALSE.)
      ENDIF
C
      ZR(JCMCF-1+ZCMCF*(IZONE-1)+1)  = TYPINT
      ZR(JCMCF-1+ZCMCF*(IZONE-1)+2)  = COEFAC
      ZR(JCMCF-1+ZCMCF*(IZONE-1)+3)  = ALGOCR
      ZR(JCMCF-1+ZCMCF*(IZONE-1)+4)  = COEFAF
      ZR(JCMCF-1+ZCMCF*(IZONE-1)+5)  = ALGOFR
      ZR(JCMCF-1+ZCMCF*(IZONE-1)+6)  = COEFFF
      ZR(JCMCF-1+ZCMCF*(IZONE-1)+7)  = SEUILI
      ZR(JCMCF-1+ZCMCF*(IZONE-1)+8)  = CTRINI
      IF (LGLISS) THEN
        ZR(JCMCF-1+ZCMCF*(IZONE-1)+9) = 1.D0
      ELSE
        ZR(JCMCF-1+ZCMCF*(IZONE-1)+9) = 0.D0
      ENDIF
      IF (LSSCON) THEN
        ZR(JCMCF-1+ZCMCF*(IZONE-1)+10) = 1.D0
      ELSE
        ZR(JCMCF-1+ZCMCF*(IZONE-1)+10) = 0.D0
      ENDIF
      IF (LSSFRO) THEN
        ZR(JCMCF-1+ZCMCF*(IZONE-1)+11) = 1.D0
      ELSE
        ZR(JCMCF-1+ZCMCF*(IZONE-1)+11) = 0.D0
      ENDIF
      ZR(JCMCF-1+ZCMCF*(IZONE-1)+12) = REXCLF
      ZR(JEXCLF-1+ZEXCL*(IZONE-1)+1) = DIREXF(1)
      ZR(JEXCLF-1+ZEXCL*(IZONE-1)+2) = DIREXF(2)
      ZR(JEXCLF-1+ZEXCL*(IZONE-1)+3) = DIREXF(3)
C
      CALL JEDEMA()
      END
