subroutine afvarc(chmat, nomail, nomode)
    implicit none
#include "asterf_types.h"
#include "jeveux.h"
#include "asterc/getfac.h"
#include "asterc/r8nnem.h"
#include "asterc/r8vide.h"
#include "asterfort/afva01.h"
#include "asterfort/alcart.h"
#include "asterfort/assert.h"
#include "asterfort/codent.h"
#include "asterfort/dismoi.h"
#include "asterfort/gcncon.h"
#include "asterfort/getvid.h"
#include "asterfort/getvr8.h"
#include "asterfort/getvtx.h"
#include "asterfort/jedema.h"
#include "asterfort/jedetr.h"
#include "asterfort/jelira.h"
#include "asterfort/jemarq.h"
#include "asterfort/jeveuo.h"
#include "asterfort/jexnom.h"
#include "asterfort/juveca.h"
#include "asterfort/mecact.h"
#include "asterfort/nocart.h"
#include "asterfort/reliem.h"
#include "asterfort/utmess.h"
#include "asterfort/wkvect.h"
#include "asterfort/xvarc_temp.h"
    character(len=8) :: chmat, nomail, nomode
! ----------------------------------------------------------------------
! ======================================================================
! COPYRIGHT (C) 1991 - 2013  EDF R&D                  WWW.CODE-ASTER.ORG
! THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
! IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
! THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
! (AT YOUR OPTION) ANY LATER VERSION.
!
! THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
! WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
! MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
! GENERAL PUBLIC LICENSE FOR MORE DETAILS.
!
! YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
! ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
!   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
! ======================================================================
! person_in_charge: jacques.pellet at edf.fr
! ----------------------------------------------------------------------
!     TRAITEMENT DE AFFE_MATERIAU / AFFE_VARC
! ----------------------------------------------------------------------
    integer :: n1, n2, nboccv, nbma, k, ncmp
    integer :: ifac, nbfac, nmxfac, nmxcmp, nbvarc, nbtou, jma
    integer :: iocc, kvarc, nbcvrc
    integer :: jcvnom, jcvvar, jcvcmp, jcvgd, itrou, nbm1, nbgm1
    integer :: nref, nbdetr, nbgdut, nbgdmx, ico, jadetr
!
    character(len=8) :: k8b, typmcl(2), nomgd
    character(len=8) :: nomgd2, chamgd, evol, nocmp1, nocmp2, finst, evouch
    character(len=16) :: motcle(2), nomcha, prolga, proldr, k16a, k16b, k16c
    character(len=24) :: mesmai, cvnom, cvvar, cvgd, cvcmp, valk(3)
    parameter (nmxfac=20,nmxcmp=20)
    character(len=16) :: motfac(nmxfac), limfac(nmxfac), mofac
    character(len=19) :: cart1, cart2, carvid
    character(len=8) :: novarc, novar1, novar2, livarc(nmxfac), knumer
    character(len=8) :: nocvrc
    real(kind=8) :: vrcref(nmxcmp), rcmp(10), vref
    aster_logical :: errgd, ldetr, lautr
    integer, pointer :: desc(:) => null()
    real(kind=8), pointer :: valv1(:) => null()
    character(len=16), pointer :: valv2(:) => null()
    character(len=8), pointer :: ncmp1(:) => null()
    character(len=8), pointer :: ncmp2(:) => null()
    character(len=16), pointer :: vale(:) => null()
! ----------------------------------------------------------------------
!
    call jemarq()
!
    mesmai = '&&AFVARC.MES_MAILLES'
    motcle(1) = 'GROUP_MA'
    motcle(2) = 'MAILLE'
    typmcl(1) = 'GROUP_MA'
    typmcl(2) = 'MAILLE'
    call getfac('AFFE_VARC', nboccv)
!
!
!     1. CALCUL DE NBVARC, NBCVRC, LIVARC ET LIMFAC
!        ALLOCATION DES 5 OBJETS : .CVRCNOM .CVRCVARC ...
!     -------------------------------------------------
    call getvtx(' ', 'LIST_NOM_VARC', nbval=nmxfac, vect=livarc, nbret=n1)
    ASSERT(n1.gt.0)
    nbfac=n1
    do ifac = 1, nbfac
        motfac(ifac)='VARC_'//livarc(ifac)
    end do
!
    nbvarc = 0
    nbcvrc=0
    do ifac = 1, nbfac
        mofac=motfac(ifac)
        ASSERT(mofac(1:5).eq.'VARC_')
        call getvtx(mofac, 'NOM_VARC', iocc=1, scal=novarc, nbret=n1)
        ASSERT(n1.eq.1)
        itrou=0
        do iocc = 1, nboccv
            call getvtx('AFFE_VARC', 'NOM_VARC', iocc=iocc, scal=novar1, nbret=n1)
            ASSERT(n1.eq.1)
            if (novar1 .eq. novarc) itrou=1
        end do
        if (itrou .eq. 0) goto 20
        nbvarc = nbvarc + 1
        livarc(nbvarc) = novarc
        limfac(nbvarc) = mofac
        call getvtx(mofac, 'CMP_GD', iocc=1, nbval=0, nbret=ncmp)
        ASSERT(ncmp.lt.0)
        ncmp=-ncmp
        nbcvrc=nbcvrc+ncmp
 20     continue
    end do
    if (nbvarc .eq. 0) goto 999
!
!
    cvnom = chmat//'.CVRCNOM'
    cvvar = chmat//'.CVRCVARC'
    cvgd = chmat//'.CVRCGD'
    cvcmp = chmat//'.CVRCCMP'
    call wkvect(cvnom, 'G V K8', nbcvrc, jcvnom)
    call wkvect(cvvar, 'G V K8', nbcvrc, jcvvar)
    call wkvect(cvgd, 'G V K8', nbcvrc, jcvgd)
    call wkvect(cvcmp, 'G V K8', nbcvrc, jcvcmp)
!
!
!
!     2. ALLOCATION ET REMPLISSAGE DES CARTES
!        REMPLISSAGE DE .CVRCNOM .CVRCVARC ...
!     --------------------------------------------
    nbcvrc=0
    do kvarc = 1, nbvarc
        mofac = limfac(kvarc)
!
        cart1 = chmat//'.'//livarc(kvarc)//'.1'
        cart2 = chmat//'.'//livarc(kvarc)//'.2'
        call alcart('G', cart1, nomail, 'NEUT_R')
        call alcart('G', cart2, nomail, 'NEUT_K16')
        call jeveuo(cart1//'.NCMP', 'E', vk8=ncmp1)
        call jeveuo(cart1//'.VALV', 'E', vr=valv1)
        call jeveuo(cart2//'.NCMP', 'E', vk8=ncmp2)
        call jeveuo(cart2//'.VALV', 'E', vk16=valv2)
        nocmp1 = 'X'
        do k = 1, nmxcmp
            call codent(k, 'G', nocmp1(2:8))
            ncmp1(k) = nocmp1
        end do
        nocmp2 = 'Z'
        do k = 1, 7
            call codent(k, 'G', nocmp2(2:8))
            ncmp2(k) = nocmp2
        end do
!
!
!       2.1 REPLISSAGE DE .CVRCNOM, .CVRCVARC, ...
!       ------------------------------------------------------------
        call getvtx(mofac, 'NOM_VARC', iocc=1, scal=novarc, nbret=n1)
        call getvtx(mofac, 'GRANDEUR', iocc=1, scal=nomgd, nbret=n1)
        call getvtx(mofac, 'CMP_GD', iocc=1, nbval=nmxcmp, vect=zk8(jcvcmp+nbcvrc),&
                    nbret=ncmp)
        ASSERT(ncmp.ge.1)
        call getvtx(mofac, 'CMP_VARC', iocc=1, nbval=nmxcmp, vect=zk8(jcvnom+nbcvrc),&
                    nbret=n1)
        ASSERT(n1.eq.ncmp)
        do k = 1, ncmp
            zk8(jcvvar+nbcvrc-1+k) = novarc
            zk8(jcvgd +nbcvrc-1+k) = nomgd
        end do
!
        do iocc = 1, nboccv
            call getvtx('AFFE_VARC', 'NOM_VARC', iocc=iocc, scal=novar2, nbret=n1)
            ASSERT(n1.eq.1)
            if (novar2 .ne. novarc) goto 80
!
!         2.2 CALCUL DE  VRCREF(:) :
!         ---------------------------
            call getvr8('AFFE_VARC', 'VALE_REF', iocc=iocc, nbval=nmxcmp, vect=vrcref,&
                        nbret=n1)
!         -- ON NE PEUT DONNER QU'UNE SEULE VALEUR (TEMP OU SECH) :
            nref=n1
            ASSERT(n1.eq.0 .or. n1.eq.1)
            if (n1 .eq. 1) then
                vref=vrcref(1)
            else
                vref=r8vide()
            endif
!         -- IL FAUT RECOPIER VREF POUR TEMP QUI A PLUSIEURS CMPS :
            do k = 1, ncmp
                vrcref(k) = vref
            end do
!
!
!         2.3 CALCUL DE EVOL,CHAMGD,NOMCHA ET VERIFICATIONS :
!         ------------------------------------------------------------
            evol = ' '
            chamgd = ' '
            nomcha = ' '
            errgd = .false.
!
            call getvid('AFFE_VARC', 'CHAM_GD', iocc=iocc, scal=chamgd, nbret=n1)
            call getvid('AFFE_VARC', 'EVOL', iocc=iocc, scal=evol, nbret=n2)
            ASSERT(n1+n2.le.1)
            if (n1 .eq. 1) then
                evouch='CHAMP'
            else if (n2.eq.1) then
                evouch='EVOL'
            else
                evouch='VIDE'
                if (novarc .ne. 'TEMP') then
                    call utmess('F', 'CALCULEL4_11', sk=novarc)
                endif
!           -- POUR LA THM, ON PEUT UTILISER VALE_REF SANS DONNER
!              CHAM_GD NI EVOL :
                ASSERT(nref.eq.1)
            endif
!
!
            if (evouch .eq. 'CHAMP') then
                call dismoi('NOM_GD', chamgd, 'CHAMP', repk=nomgd2)
                if (nomgd2 .ne. nomgd) errgd = .true.
!
            else if (evouch.eq.'EVOL') then
                call getvtx('AFFE_VARC', 'NOM_CHAM', iocc=iocc, scal=nomcha, nbret=n1)
!           -- NOM_CHAMP (VALEUR PAR DEFAUT) :
                if (n1 .eq. 0) then
                    if (novarc .eq. 'SECH') then
                        nomcha='TEMP'
                    else if (novarc.eq.'HYDR') then
                        nomcha='HYDR_ELNO'
                    else if (novarc.eq.'HYDR') then
                        nomcha='EPSA'
                    else if (novarc.eq.'EPSA_ELNO') then
                        nomcha='NEUT'
                    else if (novarc.eq.'M_ACIER') then
                        nomcha='META_ELNO'
                    else if (novarc.eq.'M_ZIRC') then
                        nomcha='META_ELNO'
                    else if (novarc(1:4).eq.'NEUT') then
                        nomcha='NEUT'
                    else
                        nomcha=novarc
                    endif
                endif
                call getvtx('AFFE_VARC', 'PROL_GAUCHE', iocc=iocc, scal=prolga, nbret=n1)
                call getvtx('AFFE_VARC', 'PROL_DROITE', iocc=iocc, scal=proldr, nbret=n1)
                call getvid('AFFE_VARC', 'FONC_INST', iocc=iocc, scal=finst, nbret=n1)
                if (n1 .eq. 0) finst=' '
!               A FAIRE : VERIFIER QUE EVOL+ NOMCHA => LA BONNE GRANDEUR
            endif
!
            if (errgd) then
                valk(1) = novarc
                valk(2) = nomgd
                valk(3) = nomgd2
                call utmess('F', 'MODELISA5_50', nk=3, valk=valk)
            endif
!
!         2.4 ECRITURE DANS LES CARTES :
!         ------------------------------------------------------------
            valv2(1) = livarc(kvarc)
            if (evouch .eq. 'CHAMP') then
                valv2(2) = 'CHAMP'
                valv2(3) = chamgd
                valv2(4) = ' '
                valv2(5) = ' '
                valv2(6) = ' '
                valv2(7) = ' '
            else if (evouch.eq.'EVOL') then
                valv2(2) = 'EVOL'
                valv2(3) = evol
                valv2(4) = nomcha
                valv2(5) = prolga
                valv2(6) = proldr
                valv2(7) = finst
            else if (evouch.eq.'VIDE') then
!           -- ON AFFECTE UNE CARTE CONTENANT DES R8NNEM :
                call gcncon('_', knumer)
                carvid = knumer
                ASSERT(ncmp.le.10)
                do k = 1, ncmp
                    rcmp(k) = r8nnem()
                end do
                call mecact('G', carvid, 'MAILLA', nomail, nomgd,&
                            ncmp=ncmp, lnomcmp=zk8(jcvcmp+nbcvrc), vr=rcmp)
!
                valv2(2) = 'CHAMP'
                valv2(3) = carvid(1:16)
                valv2(4) = ' '
                valv2(5) = ' '
                valv2(6) = ' '
                valv2(7) = ' '
            endif
            do k = 1, ncmp
                valv1(k) = vrcref(k)
            end do
!
!         TOUT='OUI' PAR DEFAUT :
            call getvtx('AFFE_VARC', 'TOUT', iocc=iocc, scal=k8b, nbret=nbtou)
            call getvtx('AFFE_VARC', 'GROUP_MA', iocc=iocc, nbval=0, nbret=nbgm1)
            call getvtx('AFFE_VARC', 'MAILLE', iocc=iocc, nbval=0, nbret=nbm1)
            if (nbgm1+nbm1 .eq. 0) nbtou=1
!
            if (nbtou .ne. 0) then
                call nocart(cart1, 1, ncmp)
                call nocart(cart2, 1, 7)
            else
                call reliem(nomode, nomail, 'NU_MAILLE', 'AFFE_VARC', iocc,&
                            2, motcle, typmcl, mesmai, nbma)
                if (nbma .eq. 0) goto 80
                call jeveuo(mesmai, 'L', jma)
                call nocart(cart1, 3, ncmp, mode='NUM', nma=nbma,&
                            limanu=zi(jma))
                call nocart(cart2, 3, 7, mode='NUM', nma=nbma,&
                            limanu=zi(jma))
                call jedetr(mesmai)
            endif
!
!         2.5 CAS PARTICULIER DU CHAINAGE THERMO-MECANIQUE AVEC XFEM :
!         ------------------------------------------------------------
            call xvarc_temp(novarc, evouch, evol, prolga, proldr,&
                            finst, nboccv, cart2)
!
 80         continue
        end do
!
        nbcvrc=nbcvrc+ncmp
    end do
!
!
!     3. POUR NE PAS PENALISER LES CALCULS N'AYANT QUE LA COMPOSANTE
!        TEMP (POUR NOM_VARC='TEMP'), ON VA TENTER DE REDUIRE NBCVRC :
!     -----------------------------------------------------------------
    call wkvect('&&AFVARC.ADETR', 'V V I', nbcvrc, jadetr)
    nbdetr=0
    do k = 1, nbcvrc
        novarc=zk8(jcvvar-1+k)
        nocvrc=zk8(jcvnom-1+k)
        if (novarc .eq. 'TEMP') then
            if (nocvrc .ne. 'TEMP') then
                nbdetr=nbdetr+1
                zi(jadetr-1+k)=1
            endif
        endif
    end do
    if (nbdetr .eq. 0) goto 999
!
!     3.1 PEUT-ON REELLEMENT SUPPRIMER CES CVRC ?
!     -------------------------------------------
    ldetr=.true.
    cart2 = chmat//'.TEMP    .2'
    call jeveuo(cart2//'.DESC', 'L', vi=desc)
    call jeveuo(cart2//'.VALE', 'L', vk16=vale)
    call jelira(jexnom('&CATA.GD.NOMCMP', 'NEUT_K16'), 'LONMAX', ncmp)
    nbgdmx=desc(2)
    nbgdut=desc(3)
    call jelira(chmat//'.TEMP    .2.VALE', 'LONMAX', n1)
    ASSERT(n1.eq.nbgdmx*ncmp)
!     3.2 ON PARCOURT LES SD STOCKEES DANS LA CARTE ET ON REGARDE S'IL
!         EXISTE D'AUTRES CMPS QUE TEMP ET LAGR :  LAUTR=.TRUE.
!     --------------------------------------------------------------
    do k = 1, nbgdut
        k16a=vale(ncmp*(k-1)+1)
        ASSERT(k16a.eq.'TEMP')
        k16a=vale(ncmp*(k-1)+2)
        k16b=vale(ncmp*(k-1)+3)
        k16c=vale(ncmp*(k-1)+4)
        call afva01(k16a, k16b, k16c, lautr)
        if (lautr) then
            ldetr=.false.
            goto 94
        endif
!
    end do
 94 continue
!
!     3.3 ON SUPPRIME CE QUI NE SERT A RIEN :
!     ----------------------------------------
    if (ldetr) then
        ico=0
        do k = 1, nbcvrc
            if (zi(jadetr-1+k) .eq. 0) then
                ico=ico+1
                zk8(jcvnom-1+ico)=zk8(jcvnom-1+k)
                zk8(jcvvar-1+ico)=zk8(jcvvar-1+k)
                zk8(jcvgd-1+ico)=zk8(jcvgd-1+k)
                zk8(jcvcmp-1+ico)=zk8(jcvcmp-1+k)
            endif
        end do
        ASSERT(ico.eq.nbcvrc-nbdetr)
        call juveca(cvnom, ico)
        call juveca(cvvar, ico)
        call juveca(cvgd, ico)
        call juveca(cvcmp, ico)
    endif
!
!
999 continue
!
    call jedema()
end subroutine
