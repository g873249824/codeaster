      SUBROUTINE CAZOCP(CHAR  )
C
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF MODELISA  DATE 26/03/2013   AUTEUR ABBAS M.ABBAS 
C ======================================================================
C COPYRIGHT (C) 1991 - 2013  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C RESPONSABLE ABBAS M.ABBAS
C
      IMPLICIT NONE
      INCLUDE 'jeveux.h'
      CHARACTER*8  CHAR
C
C ----------------------------------------------------------------------
C
C ROUTINE CONTACT (TOUTES METHODES - LECTURE DONNEES)
C
C LECTURE DES PARAMETRES PRINCIPAUX QUI NE DEPENDENT PAS DE LA ZONE
C DE CONTACT
C
C ----------------------------------------------------------------------
C
C
C IN  CHAR   : NOM UTILISATEUR DU CONCEPT DE CHARGE
C
C ----------------------------------------------------------------------
C
      CHARACTER*24 DEFICO
      CHARACTER*24 PARACR,PARACI
      INTEGER      JPARCR,JPARCI
      INTEGER      NBREAC,LGBLOC,GCPMAX,PREMAX
      INTEGER      REACCA,REACBS,REACBG
      CHARACTER*16 RECH,PREC,REAC,TYPCON,ISTO
      CHARACTER*16 ALGOCO,ALGOFR,ALGOGE
      INTEGER      NOC
      REAL*8       PRECIS,COEFRS
      REAL*8       RESIGE,RESIFR
      LOGICAL      CFDISL,LGCP
      LOGICAL      LCTCD,LCTCC,LXFCM,LFROT,LMAIL
      CHARACTER*16 LISSA
      INTEGER      IARG
C
C ----------------------------------------------------------------------
C
      CALL JEMARQ
C
C --- INITIALISATIONS
C
      DEFICO = CHAR(1:8)//'.CONTACT'
      REAC   = 'AUTOMATIQUE'
      ALGOCO = ' '
      ALGOFR = ' '
      ALGOGE = ' '
      NBREAC = 2
      LGBLOC = 10
      RESIGE = 1.D-2
      RESIFR = 1.D-2
C
C --- LECTURE DES STRUCTURES DE DONNEES DE CONTACT
C
      PARACR = DEFICO(1:16)//'.PARACR'
      PARACI = DEFICO(1:16)//'.PARACI'
      CALL JEVEUO(PARACR,'E',JPARCR)
      CALL JEVEUO(PARACI,'E',JPARCI)
C
C --- DRAPEAUX
C
      LCTCD  = CFDISL(DEFICO,'FORMUL_DISCRETE')
      LCTCC  = CFDISL(DEFICO,'FORMUL_CONTINUE')
      LMAIL  = LCTCD.OR.LCTCC
      LXFCM  = CFDISL(DEFICO,'FORMUL_XFEM')
      LGCP   = CFDISL(DEFICO,'CONT_GCP'  )
      LFROT  = CFDISL(DEFICO,'FROTTEMENT')
C
C --- ALGORITHME GEOMETRIE
C
      IF (LCTCC) THEN
        CALL GETVTX(' ','ALGO_RESO_GEOM',1 ,IARG,1,ALGOGE,NOC)
      ELSEIF (LXFCM) THEN
        ALGOGE = 'POINT_FIXE'
      ELSEIF (LCTCD) THEN
        ALGOGE = 'POINT_FIXE'
      ELSE
        CALL ASSERT(.FALSE.)
      ENDIF
C
      IF (ALGOGE.EQ.'POINT_FIXE') THEN
        ZI(JPARCI+9-1) = 0
      ELSEIF (ALGOGE.EQ.'NEWTON') THEN
        ZI(JPARCI+9-1) = 1
      ELSE
        CALL ASSERT(.FALSE.)
      ENDIF
C
C --- PARAMETRES BOUCLE GEOMETRIQUE
C
      IF (ALGOGE .EQ. 'POINT_FIXE') THEN
        CALL GETVTX(' ','REAC_GEOM',1 ,IARG,1,REAC,NOC)
        IF (REAC .EQ. 'SANS') THEN
          ZI(JPARCI+1-1) = 0
          ZR(JPARCR+1-1) = RESIGE
        ELSEIF (REAC .EQ. 'AUTOMATIQUE') THEN
          ZI(JPARCI+1-1) = -1
          CALL GETVIS(' ','ITER_GEOM_MAXI',1 ,IARG,1,REACBG,NOC)
          ZI(JPARCI+6-1) = REACBG
          CALL GETVR8(' ','RESI_GEOM',1 ,IARG,1,RESIGE,NOC)
          ZR(JPARCR+1-1) = RESIGE
        ELSEIF (REAC .EQ. 'CONTROLE') THEN
          CALL GETVIS(' ','NB_ITER_GEOM',1 ,IARG,1,NBREAC,NOC)
          ZI(JPARCI+1-1) = NBREAC
          ZR(JPARCR+1-1) = RESIGE
        ELSE
          CALL ASSERT(.FALSE.)
        ENDIF
      ELSEIF (ALGOGE .EQ. 'NEWTON') THEN
        CALL GETVR8(' ','RESI_GEOM',1 ,IARG,1,RESIGE,NOC)
        ZI(JPARCI+1-1) = 0
        ZR(JPARCR+1-1) = RESIGE
      ELSE
        CALL ASSERT(.FALSE.)
      ENDIF
C
C --- ALGORITHMES FROTTEMENT
C
      IF (LFROT) THEN
        IF (LCTCC) THEN
          CALL GETVTX(' ','ALGO_RESO_FROT',1 ,IARG,1,ALGOFR,NOC)
        ELSEIF (LXFCM) THEN
          IF (ZI(JPARCI+1-1).EQ.0) THEN
            ALGOFR = 'POINT_FIXE'
          ELSE
            ALGOFR = 'NEWTON'
          ENDIF
        ELSEIF (LCTCD) THEN
          ALGOFR = 'POINT_FIXE'
        ELSE
          CALL ASSERT(.FALSE.)
        ENDIF
      ENDIF
C
      IF (LFROT) THEN
        IF (ALGOFR.EQ.'POINT_FIXE') THEN
          ZI(JPARCI+28-1) = 0
        ELSEIF (ALGOFR.EQ.'NEWTON') THEN
          ZI(JPARCI+28-1) = 1
        ELSE
          CALL ASSERT(.FALSE.)
        ENDIF
      ENDIF
C
C --- PARAMETRES BOUCLE FROTTEMENT
C
      IF (LFROT) THEN
        IF (LCTCC) THEN
          IF (ALGOFR.EQ.'POINT_FIXE') THEN
            CALL GETVIS(' ','ITER_FROT_MAXI',1 ,IARG,1,REACBS,NOC)
            ZI(JPARCI+7-1) = REACBS
            CALL GETVR8(' ','RESI_FROT',1 ,IARG,1,RESIFR,NOC)
            ZR(JPARCR+2-1) = RESIFR
          ELSE
            CALL GETVR8(' ','RESI_FROT',1 ,IARG,1,RESIFR,NOC)
            ZR(JPARCR+2-1) = RESIFR
          ENDIF
        ELSEIF (LXFCM) THEN
          CALL GETVIS(' ','ITER_FROT_MAXI',1 ,IARG,1,REACBS,NOC)
          ZI(JPARCI+7-1) = REACBS
          CALL GETVR8(' ','RESI_FROT',1 ,IARG,1,RESIFR,NOC)
          ZR(JPARCR+2-1) = RESIFR
        ENDIF
      ELSE
        ZI(JPARCI+20-1) = 0
      ENDIF
C
C --- ALGORITHME CONTACT
C
      IF (LCTCC) THEN
        CALL GETVTX(' ','ALGO_RESO_CONT',1 ,IARG,1,ALGOCO,NOC)
      ELSEIF (LXFCM) THEN
        ALGOCO = 'POINT_FIXE'
      ELSEIF (LCTCD) THEN
        ALGOCO = 'POINT_FIXE'
      ELSE
        CALL ASSERT(.FALSE.)
      ENDIF
C
      IF (ALGOCO.EQ.'POINT_FIXE') THEN
        ZI(JPARCI+27-1) = 0
      ELSEIF (ALGOCO.EQ.'NEWTON') THEN
        ZI(JPARCI+27-1) = 1
      ELSE
        CALL ASSERT(.FALSE.)
      ENDIF
C
C --- PARAMETRES BOUCLE CONTACT
C
      IF (ALGOCO.EQ.'POINT_FIXE') THEN
        IF (LXFCM.OR.LCTCC) THEN
          CALL GETVIS(' ','ITER_CONT_MULT',1 ,IARG,1,REACCA,NOC)
          CALL GETVTX(' ','ITER_CONT_TYPE',1 ,IARG,1,TYPCON,NOC)
          IF (TYPCON.EQ.'MULT') THEN
            REACCA = 4
            CALL GETVIS(' ','ITER_CONT_MULT',1 ,IARG,1,REACCA,NOC)
            ZI(JPARCI+5-1)  = REACCA
            ZI(JPARCI+10-1) = -1
          ELSEIF (TYPCON.EQ.'MAXI') THEN
            REACCA = 30
            CALL GETVIS(' ','ITER_CONT_MAXI',1 ,IARG,1,REACCA,NOC)
            ZI(JPARCI+10-1) = REACCA
            ZI(JPARCI+5-1)  = -1
          ELSE
            CALL ASSERT(.FALSE.)
          ENDIF      
        ELSEIF (LCTCD) THEN
          CALL GETVIS(' ','ITER_CONT_MULT',1 ,IARG,1,REACCA,NOC)
          ZI(JPARCI+5-1)  = REACCA
          ZI(JPARCI+10-1) = -1
        ELSE
          CALL ASSERT(.FALSE.)
        ENDIF
      ELSEIF (ALGOCO.EQ.'NEWTON') THEN
C PAS DE PARAMETRES
      ELSE
        CALL ASSERT(.FALSE.)
      ENDIF

C
C --- FORMULATION DISCRETE
C
      IF (LCTCD) THEN
C ---   ARRET OU PAS SI MATRICE DE CONTACT SINGULIERE
        CALL GETVTX(' ','STOP_SINGULIER',1 ,IARG,1,ISTO,NOC)
        IF (ISTO .EQ. 'OUI') THEN
          ZI(JPARCI+2-1) = 0
        ELSEIF (ISTO .EQ. 'NON') THEN
          ZI(JPARCI+2-1) = 1
        ELSE
          CALL ASSERT(.FALSE.)
        END IF
C ---   NOMBRE DE PAQUETS POUR LA RESOLUTION DES SYSTEMES LINEAIRES
        CALL GETVIS(' ','NB_RESOL',1 ,IARG,1,LGBLOC,NOC)
        ZI(JPARCI+3-1) = LGBLOC
C
C --- PARAMETRE GCP
C
        IF (LGCP) THEN
          CALL GETVR8(' ','RESI_ABSO',1 ,IARG,1,PRECIS,NOC)
          IF (NOC.EQ.0) THEN
            CALL U2MESS('F','CONTACT_4')
          ENDIF
          ZR(JPARCR+4-1) = PRECIS

C ---     NON UTILISE
          ZI(JPARCI+11-1) = 0

          CALL GETVIS(' ','ITER_GCP_MAXI',1 ,IARG,1,GCPMAX,NOC)
          ZI(JPARCI+12-1) = GCPMAX

          CALL GETVTX(' ','PRE_COND',1 ,IARG,1,PREC,NOC)
          IF (PREC.EQ.'SANS') THEN
            ZI(JPARCI+13-1) = 0
          ELSE IF (PREC.EQ.'DIRICHLET') THEN
            ZI(JPARCI+13-1) = 1
            CALL GETVR8(' ','COEF_RESI',1 ,IARG,1,COEFRS,NOC)
            ZR(JPARCR+5-1)  = COEFRS
            CALL GETVIS(' ','ITER_PRE_MAXI',1 ,IARG,1,PREMAX,NOC)
            ZI(JPARCI+14-1) = PREMAX
          ELSE
            CALL ASSERT(.FALSE.)
          ENDIF

          CALL GETVTX(' ','RECH_LINEAIRE',1 ,IARG,1,RECH,NOC)
          IF (RECH.EQ.'ADMISSIBLE') THEN
            ZI(JPARCI+15-1) = 0
          ELSE IF (RECH.EQ.'NON_ADMISSIBLE') THEN
            ZI(JPARCI+15-1) = 1
          ELSE
            CALL ASSERT(.FALSE.)
          ENDIF
        ENDIF
      ENDIF
C
C --- LISSAGE
C
      IF (LMAIL) THEN
        CALL GETVTX(' ','LISSAGE',1 ,IARG,1,LISSA,NOC)
        IF (LISSA(1:3) .EQ. 'NON') THEN
          ZI(JPARCI+19-1) = 0
        ELSEIF (LISSA(1:3) .EQ. 'OUI') THEN
          ZI(JPARCI+19-1) = 1
        ELSE
          CALL ASSERT(.FALSE.)
        END IF
      ENDIF
C
C --- METHODE VERIF
C
      IF (LMAIL) THEN
        CALL GETVTX(' ','STOP_INTERP',1 ,IARG,1,ISTO,NOC)
        IF (ISTO.EQ.'OUI') THEN
          ZI(JPARCI+25-1) = 1
        ELSEIF (ISTO.EQ.'NON') THEN
          ZI(JPARCI+25-1) = 0
        ELSE
          CALL ASSERT(.FALSE.)
        ENDIF
      ENDIF
C
      CALL JEDEMA()
      END
