subroutine nmtble(cont_loop  , model         , mesh    , mate  , sdcont_defi,&
                  sdcont_solv, list_func_acti, ds_print, sdstat, sdtime     ,&
                  sddyna     , sderro        , sdconv  , sddisc, nume_inst  ,&
                  hval_incr  , hval_algo)
!
use NonLin_Datastructure_type
!
implicit none
!
#include "asterf_types.h"
#include "asterfort/diinst.h"
#include "asterfort/isfonc.h"
#include "asterfort/mmbouc.h"
#include "asterfort/mm_cycl_erase.h"
#include "asterfort/mm_cycl_init.h"
#include "asterfort/nmaffi.h"
#include "asterfort/nmctcc.h"
#include "asterfort/nmctcf.h"
#include "asterfort/nmctgo.h"
#include "asterfort/nmevcv.h"
#include "asterfort/nmimci.h"
#include "asterfort/nmleeb.h"
#include "asterfort/nmrinc.h"
#include "asterfort/nmtime.h"
!
! ======================================================================
! COPYRIGHT (C) 1991 - 2015  EDF R&D                  WWW.CODE-ASTER.ORG
! THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
! IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
! THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
! (AT YOUR OPTION) ANY LATER VERSION.
!
! THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
! WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
! MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
! GENERAL PUBLIC LICENSE FOR MORE DETAILS.
!
! YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
! ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
!   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
! ======================================================================
! person_in_charge: mickael.abbas at edf.fr
!
    integer, intent(inout) :: cont_loop
    character(len=24), intent(in) :: model
    character(len=8), intent(in) :: mesh
    character(len=24), intent(in) :: mate
    character(len=24), intent(in) :: sdcont_defi
    character(len=24), intent(in) :: sdcont_solv
    integer, intent(in) :: list_func_acti(*)
    type(NL_DS_Print), intent(inout) :: ds_print
    character(len=24), intent(in) :: sdstat
    character(len=24), intent(in) :: sdtime
    character(len=19), intent(in) :: sddyna
    character(len=24), intent(in) :: sderro
    character(len=24), intent(in) :: sdconv
    character(len=19), intent(in) :: sddisc
    integer, intent(in) :: nume_inst
    character(len=19), intent(in) :: hval_incr(*)
    character(len=19), intent(in) :: hval_algo(*)
!
! --------------------------------------------------------------------------------------------------
!
! MECA_NON_LINE - Algo
!
! Contact loop management - END
!
! --------------------------------------------------------------------------------------------------
!
! IO  cont_loop        : level of loop for contact (see nmible.F90)
!                        0 - Not use (not cotnact)
!                        1 - Loop for contact status
!                        2 - Loop for friction triggers
!                        3 - Loop for geometry
! In  model            : name of model
! In  mesh             : name of mesh
! In  mate             : name of material characteristics (field)
! In  sdcont_defi      : name of contact definition datastructure (from DEFI_CONTACT)
! In  sdcont_solv      : name of contact solving datastructure
! In  list_func_acti   : list of active functionnalities
! IO  ds_print         : datastructure for printing parameters
! In  sdstat           : datastructure for statistics
! In  sdtime           : datastructure for timers
! In  sddyna           : dynamic parameters datastructure
! In  sderro           : datastructure for errors during algorithm
! In  sdconv           : datastructure for convergence status
! In  sddisc           : datastructure for time discretization
! In  nume_inst        : index of current step time
! In  hval_incr        : hat-variable for incremental values fields
! In  hval_algo        : hat-variable for algorithms fields
!
! --------------------------------------------------------------------------------------------------
!
    aster_logical :: loop_cont_conv, loop_frot_conv, loop_geom_conv
    aster_logical :: l_loop_frot, l_loop_geom, l_loop_cont
    integer :: i_loop_geom, i_loop_frot, i_loop_cont
    character(len=4) :: state_newt
    real(kind=8) :: time_curr
!
! --------------------------------------------------------------------------------------------------
!
    if (cont_loop.eq.0) then
        goto 999
    endif
!
! - State of Newton loop
!
    call nmleeb(sderro, 'NEWT', state_newt)
!
! - To evaluate contact loops: Newton has covnerged
!
    if (state_newt.ne.'CONV') then
        goto 999
    endif
!
! - Contact loops
!
    l_loop_frot = isfonc(list_func_acti, 'BOUCLE_EXT_FROT')
    l_loop_geom = isfonc(list_func_acti, 'BOUCLE_EXT_GEOM')
    l_loop_cont = isfonc(list_func_acti, 'BOUCLE_EXT_CONT')
!
! - Initializations
!
    loop_cont_conv = .false.
    loop_frot_conv = .false.
    loop_geom_conv = .false.
    time_curr      = diinst(sddisc,nume_inst)
!
! - <1> - Contact loop
!
    if (cont_loop .le. 1) then
        if (l_loop_cont) then
            cont_loop = 1
            call nmtime(sdtime, 'INI', 'CTCC_CONT')
            call nmtime(sdtime, 'RUN', 'CTCC_CONT')
            call nmctcc(mesh          , model      , mate       , sddyna   , sderro   ,&
                        sdstat        , sdcont_defi, sdcont_solv, hval_incr, hval_algo,&
                        loop_cont_conv, time_curr)
            call nmtime(sdtime, 'END', 'CTCC_CONT')
            call nmrinc(sdstat, 'CTCC_CONT')
            if (.not.loop_cont_conv) then
                cont_loop = 1
                goto 500
            endif
        endif
    endif
!
! - <2> - Friction loop
!
    if (cont_loop .le. 2) then
        if (l_loop_frot) then
            cont_loop = 2
            call nmtime(sdtime, 'INI', 'CTCC_FROT')
            call nmtime(sdtime, 'RUN', 'CTCC_FROT')
            call nmctcf(mesh       , model    , ds_print      , sderro, sdcont_defi,&
                        sdcont_solv, hval_incr, loop_frot_conv)
            call nmtime(sdtime, 'END', 'CTCC_FROT')
            call nmrinc(sdstat, 'CTCC_FROT')
            if (.not.loop_frot_conv) then
                cont_loop = 2
                goto 500
            endif
        endif
    endif
!
! - <3> - Geometric loop
!
    if (cont_loop .le. 3) then
        if (l_loop_geom) then
            cont_loop = 3
            call nmctgo(mesh     , ds_print      , sderro, sdcont_defi, sdcont_solv,&
                        hval_incr, loop_geom_conv)
            if (.not.loop_geom_conv) then
                cont_loop = 3
                goto 500
            endif
        endif
    endif
!
500 continue
!
! - Initialization of data structures for cycling detection and treatment
!
    if (loop_cont_conv .or. loop_frot_conv .or. loop_geom_conv) then
        call mm_cycl_erase(sdcont_defi, sdcont_solv, 0, 0)
    endif
!
! - Print line
!
    call nmaffi(list_func_acti, sdconv, ds_print, sderro, sddisc,&
                'FIXE')
!
! - New iteration in loops
!
    if (.not.loop_cont_conv .and. cont_loop .eq. 1) then
        call mmbouc(sdcont_solv, 'CONT', 'INCR')
    endif
    if (.not.loop_frot_conv .and. cont_loop .eq. 2) then 
        call mmbouc(sdcont_solv, 'FROT', 'INCR')
    endif
    if (.not.loop_geom_conv .and. cont_loop .eq. 3) then 
        call mmbouc(sdcont_solv, 'GEOM', 'INCR')
    endif
!
! - Update loops index
!
    call mmbouc(sdcont_solv, 'CONT', 'READ', i_loop_cont)
    call mmbouc(sdcont_solv, 'FROT', 'READ', i_loop_frot)
    call mmbouc(sdcont_solv, 'GEOM', 'READ', i_loop_geom)
!
! - Set values of loops index in convergence table
!
    call nmimci(ds_print, 'BOUC_CONT', i_loop_cont, .true._1)
    call nmimci(ds_print, 'BOUC_FROT', i_loop_frot, .true._1)
    call nmimci(ds_print, 'BOUC_GEOM', i_loop_geom, .true._1)
!
999 continue
!
! - Set loop state
!
    call nmevcv(sderro, list_func_acti, 'FIXE')
!
end subroutine
