      SUBROUTINE CCVRRL(NOMMAI,MODELE,CARAEL,MESMAI,CHAMES,
     &                  CMPERR,CODRET)
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF CALCULEL  DATE 13/06/2012   AUTEUR COURTOIS M.COURTOIS 
C ======================================================================
C COPYRIGHT (C) 1991 - 2012  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
      IMPLICIT NONE
C     --- ARGUMENTS ---
      INCLUDE 'jeveux.h'
      INTEGER      CODRET
      CHARACTER*1  CMPERR
      CHARACTER*8  NOMMAI,MODELE,CARAEL
      CHARACTER*19 CHAMES
      CHARACTER*24 MESMAI
C ----------------------------------------------------------------------
C  CALC_CHAMP - VERIFICATION DES REPERES LOCAUX
C  -    -       - -              -       -
C ----------------------------------------------------------------------
C
C  ROUTINE SERVANT A VERIFIER L'ORIENTATION DES REPERES LOCAUX
C    LORS DU PASSAGE ELNO -> NOEU
C
C IN  :
C   NOMMAI  K8   NOM DU MAILLAGE A VERIFIER
C   MODELE  K8   NOM DU MODELE
C   CARAEL  K8   NOM DU CARAELEM
C   MESMAI  K24  NOM DU VECTEUR CONTENANT LES MAILLES SUR LESQUELLES
C                LE CALCUL EST DEMANDE
C   CHAMES  K19  NOM DU CHAM_ELEM_S POUR LEQUEL ON VERIFIE LES REPERES
C   CMPERR  K1   COMPORTEMENT EN CAS DE PROBLEME
C     'F' : EMISSION D'UNE ERREUR <F>
C     'A' : EMISSION D'UNE ALARME POUR PREVENIR L'UTILISATEUR
C     ' ' : SILENCE => CODE RETOUR
C
C OUT :
C   CODRET  I    CODE RETOUR
C     0 SI OK
C     1 EN CAS DE PROBLEME
C ----------------------------------------------------------------------
C RESPONSABLE SELLENET N.SELLENET
      INTEGER      JMAI,NBMA,IER,NBNO,JCONI1,JCONI2,IMA,NCMAX,I
      INTEGER      POSIT,POSMA,NUMMA,IMA2,NUMMA2,INO,JCESD,JCESL
      INTEGER      JCESV,IEXORI,JREPE,IEPAIS,NBMATO,JDIME,JVECT,IDIR
      INTEGER      JCONX1,JCONX2,JCOORD,JCESDC,INDIK8,IALPHA,IBETA
      INTEGER      JALPHA,JBETA,JGAMMA,JCESC,JCESCC,JCESDD,JCESLC,JCESVC
      INTEGER      ADCAR1(3),ADCAR2(3)
C
      REAL*8       MAXTOL,MAXDIF,TABRES(1),PI,ANGLE1,ANGLE2
      REAL*8       PGL(3,3),VL(3),VG1(3),VG2(3),VG3(3),VG4(3)
C
      CHARACTER*1  CBID
      CHARACTER*16 MODELI
      CHARACTER*19 CNXINV,CARSD,LIGRMO,CARCC,VECSAU
      CHARACTER*24 CARORI,CARCOQ
C
      LOGICAL      LLIMAI,LPROBM
      PARAMETER    (MAXTOL = 8.7266463D-2)
      PARAMETER    (PI = 3.14159265358979D0)
C
      CALL JEMARQ()
      CODRET = 0
      LIGRMO = MODELE//'.MODELE'
      CALL JEVEUO(LIGRMO//'.REPE','L',JREPE)


C     -- OBJETS QUI SERONT EVENTUELLEMNT CREES :
      CARSD  = '&&CCVRRL.CARORIEN'
      CARCC  = '&&CCVRRL.CARCOQUE'
      CNXINV = '&&CCVRRL.CNCINV'
      VECSAU = '&&CCVRRL.VECT'


C
C     DOIT ON REDUIRE LE CALCUL SUR UNE LISTE DE MAILLES
      CALL JEEXIN(MESMAI,IER)
      IF ( IER.NE.0 ) THEN
        CALL JEVEUO(MESMAI,'L',JMAI)
        CALL JELIRA(MESMAI,'LONMAX',NBMA,CBID)
        LLIMAI = .TRUE.
      ELSE
        NBMA = 0
        LLIMAI = .FALSE.
      ENDIF
      CALL JEVEUO(CHAMES//'.CESD','L',JCESDD)
C
C     CONVERSION DE LA CARTE D'ORIENTATION EN UN CHAM_ELEM_S
      CARORI = CARAEL//'.CARORIEN  .VALE'
      CALL JEEXIN(CARORI,IEXORI)
      IF ( IEXORI.NE.0 ) THEN
        CALL CARCES(CARAEL//'.CARORIEN','ELEM',' ','V',CARSD,' ',IER)
        CALL JEVEUO(CARSD//'.CESD','L',JCESD)
        CALL JEVEUO(CARSD//'.CESL','L',JCESL)
        CALL JEVEUO(CARSD//'.CESV','L',JCESV)
        CALL JEVEUO(CARSD//'.CESC','L',JCESC)
        CALL JELIRA(CARSD//'.CESC','LONMAX',NCMAX,CBID)
        JALPHA = INDIK8(ZK8(JCESC),'ALPHA   ',1,NCMAX)
        JBETA  = INDIK8(ZK8(JCESC),'BETA    ',1,NCMAX)
        JGAMMA = INDIK8(ZK8(JCESC),'GAMMA   ',1,NCMAX)
      ELSE
        JCESD=0
        JCESL=0
        JCESV=0
        JCESC=0
      ENDIF
C
C     CONVERSION DE LA CARTE CARACTERISTIQUE DES COQUES
C     EN UN CHAM_ELEM_S
      CARCOQ = CARAEL//'.CARCOQUE  .VALE'
      CALL JEEXIN(CARCOQ,IEXORI)
      IF ( IEXORI.NE.0 ) THEN
        CALL CARCES(CARAEL//'.CARCOQUE','ELEM',' ','V',CARCC,' ',IER)
        CALL JEVEUO(CARCC//'.CESD','L',JCESDC)
        CALL JEVEUO(CARCC//'.CESL','L',JCESLC)
        CALL JEVEUO(CARCC//'.CESV','L',JCESVC)
        CALL JEVEUO(CARCC//'.CESC','L',JCESCC)
        CALL JELIRA(CARCC//'.CESC','LONMAX',NCMAX,CBID)
        IEPAIS = INDIK8(ZK8(JCESCC),'EP      ',1,NCMAX)
        IALPHA = INDIK8(ZK8(JCESCC),'ALPHA   ',1,NCMAX)
        IBETA  = INDIK8(ZK8(JCESCC),'BETA    ',1,NCMAX)
      ELSE
        JCESDC=0
        JCESLC=0
        JCESVC=0
        JCESCC=0
      ENDIF
C
C     CREATION DE LA CONNECTIVITE INVERSE
      CALL CNCINV(NOMMAI,ZI(JMAI),NBMA,'V',CNXINV)
C
      CALL JEVEUO(NOMMAI//'.DIME','L',JDIME)
      NBMATO = ZI(JDIME+2)
      CALL WKVECT(VECSAU,'V V R',6*NBMATO,JVECT)
      DO 80 I = 1,6*NBMATO
        ZR(JVECT+I-1) = 0.D0
  80  CONTINUE
C
      CALL JELIRA(CNXINV,'NUTIOC',NBNO,CBID)
C
      CALL JEVEUO(JEXNUM(CNXINV,1),'L',JCONI1)
      CALL JEVEUO(JEXATR(CNXINV,'LONCUM'),'L',JCONI2)
C
      CALL JEVEUO(JEXNUM(NOMMAI//'.CONNEX',1),'L',JCONX1)
      CALL JEVEUO(JEXATR(NOMMAI//'.CONNEX','LONCUM'),'L',JCONX2)
      CALL JEVEUO(NOMMAI//'.COORDO    .VALE','L',JCOORD)
C
      ADCAR1(1) = JCESD
      ADCAR1(2) = JCESL
      ADCAR1(3) = JCESV
      ADCAR2(1) = JCESDC
      ADCAR2(2) = JCESLC
      ADCAR2(3) = JCESVC
      LPROBM = .FALSE.
C
C     BOUCLE SUR TOUS LES NOEUDS DU MAILLAGE
      MAXDIF = 0.D0
      DO 10 INO = 1,NBNO
        NBMA = ZI(JCONI2+INO)-ZI(JCONI2+INO-1)
        POSIT = ZI(JCONI2+INO-1)
C
C       GRACE A LA CONNECTIVITE INVERSE, ON TROUVE
C       LES MAILLES LIEES
        DO 20 IMA = 1,NBMA
          POSMA = ZI(JCONI1+POSIT+IMA-2)
C
C         LE COMPORTEMENT DE CNCINV N'EST PAS LE MEME SUIVANT
C         QU'ON DONNE OU NON MESMAI
          IF ( LLIMAI ) THEN
            NUMMA = ZI(JMAI+POSMA-1)
          ELSE
            NUMMA = POSMA
          ENDIF
          IF ( NUMMA.EQ.0 ) GOTO 20
C
          IF ( (ZR(JVECT+6*(NUMMA-1)).EQ.0.D0).AND.
     &         (ZR(JVECT+6*(NUMMA-1)+1).EQ.0.D0).AND.
     &         (ZR(JVECT+6*(NUMMA-1)+2).EQ.0.D0).AND.
     &         (ZR(JVECT+6*(NUMMA-1)+3).EQ.0.D0).AND.
     &         (ZR(JVECT+6*(NUMMA-1)+4).EQ.0.D0).AND.
     &         (ZR(JVECT+6*(NUMMA-1)+5).EQ.0.D0) ) THEN
C
            CALL CCCMCR(JCESDD,NUMMA,JREPE,JCONX2,JCONX1,
     &                  JCOORD,ADCAR1,ADCAR2,IALPHA,IBETA,
     &                  IEPAIS,JALPHA,JBETA,JGAMMA,LIGRMO,
     &                  INO,PGL,MODELI,IER)
            IF ( IER.EQ.1 ) GOTO 20
C
            VL(1) = 1.D0
            VL(2) = 0.D0
            VL(3) = 0.D0
            CALL UTPVLG(1,3,PGL,VL,VG1)
            VL(1) = 0.D0
            VL(2) = 1.D0
            VL(3) = 0.D0
            CALL UTPVLG(1,3,PGL,VL,VG2)
C
C           SAUVEGARDE DE LA VALEUR TROUVEE SAUF POUR LES COQUES 3D
            IF ( MODELI.NE.'COQUE_3D' ) THEN
              DO 40 IDIR = 1,3
                ZR(JVECT+6*(NUMMA-1)+IDIR-1) = VG1(IDIR)
 40           CONTINUE
              DO 45 IDIR = 1,3
                ZR(JVECT+3+6*(NUMMA-1)+IDIR-1) = VG2(IDIR)
 45           CONTINUE
            ENDIF
C
          ELSE
            DO 60 IDIR = 1,3
              VG1(IDIR) = ZR(JVECT+6*(NUMMA-1)+IDIR-1)
 60         CONTINUE
            DO 65 IDIR = 1,3
              VG2(IDIR) = ZR(JVECT+3+6*(NUMMA-1)+IDIR-1)
 65         CONTINUE
          ENDIF
C
C         ON COMPARE LES REPERES DES AUTRES MAILLES
C         LIEES AU NOEUD INO
          DO 30 IMA2 = IMA+1,NBMA
            POSMA = ZI(JCONI1+POSIT+IMA2-2)
C
            IF ( LLIMAI ) THEN
              NUMMA2 = ZI(JMAI+POSMA-1)
            ELSE
              NUMMA2 = POSMA
            ENDIF
            IF ( NUMMA2.EQ.0 ) GOTO 30
C
            IF ( (ZR(JVECT+6*(NUMMA2-1)).EQ.0.D0).AND.
     &           (ZR(JVECT+6*(NUMMA2-1)+1).EQ.0.D0).AND.
     &           (ZR(JVECT+6*(NUMMA2-1)+2).EQ.0.D0).AND.
     &           (ZR(JVECT+6*(NUMMA2-1)+3).EQ.0.D0).AND.
     &           (ZR(JVECT+6*(NUMMA2-1)+4).EQ.0.D0).AND.
     &           (ZR(JVECT+6*(NUMMA2-1)+5).EQ.0.D0) ) THEN
C
              CALL CCCMCR(JCESDD,NUMMA2,JREPE,JCONX2,JCONX1,
     &                    JCOORD,ADCAR1,ADCAR2,IALPHA,IBETA,
     &                    IEPAIS,JALPHA,JBETA,JGAMMA,LIGRMO,
     &                    INO,PGL,MODELI,IER)
              IF ( IER.EQ.1 ) GOTO 30
C
              VL(1) = 1.D0
              VL(2) = 0.D0
              VL(3) = 0.D0
              CALL UTPVLG(1,3,PGL,VL,VG3)
              VL(1) = 0.D0
              VL(2) = 1.D0
              VL(3) = 0.D0
              CALL UTPVLG(1,3,PGL,VL,VG4)
C
C             SAUVEGARDE DE LA VALEUR TROUVEE SAUF POUR LES COQUES3D
              IF ( MODELI.NE.'COQUE_3D' ) THEN
                DO 50 IDIR = 1,3
                  ZR(JVECT+6*(NUMMA2-1)+IDIR-1) = VG3(IDIR)
 50             CONTINUE
                DO 55 IDIR = 1,3
                  ZR(JVECT+3+6*(NUMMA2-1)+IDIR-1) = VG4(IDIR)
 55             CONTINUE
              ENDIF
C
            ELSE
              DO 70 IDIR = 1,3
                VG3(IDIR) = ZR(JVECT+6*(NUMMA2-1)+IDIR-1)
 70           CONTINUE
              DO 75 IDIR = 1,3
                VG4(IDIR) = ZR(JVECT+3+6*(NUMMA2-1)+IDIR-1)
 75           CONTINUE
            ENDIF
C
            CALL ANGVEC(VG1,VG3,ANGLE1)
            CALL ANGVEC(VG2,VG4,ANGLE2)
            IF ( ANGLE1.GT.MAXTOL.OR.ANGLE2.GT.MAXTOL ) THEN
              MAXDIF = MAX(ANGLE1,MAXDIF)
              MAXDIF = MAX(ANGLE2,MAXDIF)
              LPROBM = .TRUE.
            ENDIF
C
  30      CONTINUE
  20    CONTINUE
  10  CONTINUE
C
      IF ( LPROBM ) THEN
        IF ( CMPERR.NE.' ' ) THEN
          TABRES(1) = 180.D0*MAXDIF/PI
          CALL U2MESR(CMPERR,'UTILITAI_4',1,TABRES)
        ENDIF
        CODRET = 1
      ENDIF
C
      CALL JEDETR(CNXINV)
      CALL JEDETR(VECSAU)
      CALL DETRSD('CHAM_ELEM_S',CARSD)
      CALL DETRSD('CHAM_ELEM_S',CARCC)
C
      CALL JEDEMA()
C
      END
