      SUBROUTINE XPOCO2(MALINI,DIRNO,NBNO,DIRMA,NBMA,
     &                  CNS1,CNS2,CES1,CES2,CESVI1,CESVI2,RESUCO,
     &                  COMPS1,COMPS2)

C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF PREPOST  DATE 26/02/2013   AUTEUR CUVILLIE M.CUVILLIEZ 
C ======================================================================
C COPYRIGHT (C) 1991 - 2013  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C RESPONSABLE GENIAUT S.GENIAUT

      IMPLICIT NONE

      INCLUDE 'jeveux.h'

      CHARACTER*8   MALINI,RESUCO
      CHARACTER*19  CNS1,CNS2,CES1,CES2,CESVI1,CESVI2
      CHARACTER*19  COMPS1,COMPS2
      INTEGER       NBNO,DIRNO(NBNO),NBMA,DIRMA(NBMA)
C
C   COPIE DES DEPLACMENTS DES NOEUDS DU MAILLAGE MA1
C   CONTENUS DANS LES TABLEAUX D'INDIRECTION DIRMA ET DIRNO
C
C   IN
C       MALINI : NOM DU MAILLAGE SAIN
C       DIRNO : TABLEAU DE CORRESPONDANCE DES NUMEROS DE NOEUDS
C       NBNO  : LONGUEUR DE DIRNO
C       DIRMA : TABLEAU DE CORRESPONDANCE DES NUMEROS DE MAILLES
C       NBMA  : LONGUEUR DE DIRMA
C       CNS1   : CHAMP_NO_S DU DEPLACEMENT EN ENTREE
C       CES1   : CHAMP_ELEM_S DE CONTRAINTES EN ENTREE
C       RESUCO : NOM DU CONCEPT RESULTAT D'ORIGINE
C       COMPS1 : CHAM_ELEM_S DU COMPORTEMENT EN ENTREE
C   OUT
C       CNS2   : CHAMP_NO_S DU DEPLACEMENT EN SORTIE
C       CES2   : CHAMP_ELEM_S DE CONTRAINTES EN SORTIE
C       COMPS2 : CHAM_ELEM_S DU COMPORTEMENT EN SORTIE



      INTEGER      IER,I,J,NDIM,NBCMP,JCNSD1,JCNSC1,JCNSV1,JCNSV2,JCNSL2
      INTEGER      JCESV1,JCESD1,JCESL1,JCESV2,JCESD2,JCESL2,IAD1,IAD2
      INTEGER      JCVIV1,JCVID1,JCVIL1,JCVIV2,JCVID2,JCVIL2
      INTEGER      IMA,NPG1,NCMP1,NPG2,NCMP2,IPG,ICMP,IMA2,NPGV1,NPGV2
      INTEGER      NCMV1,NCMV2,NDIMC,IDECV2,IDECL2
      LOGICAL      XISMEC,LMECA
      CHARACTER*8  K8B
      CHARACTER*16  TYSD
      INTEGER      IVIEX,IRET

      INTEGER       JRESD1,JRESV1,JRESL1,IADR1
      INTEGER       JRESD2,JRESV2,JRESL2,IADR2


      CALL JEMARQ()
      CALL DISMOI('F','DIM_GEOM',MALINI,'MAILLAGE',NDIM,K8B,IER)

C     ------------------------------------------------------------------
C                    1.     DEPLACEMENT
C     ------------------------------------------------------------------
      CALL JEVEUO(CNS1//'.CNSV','L',JCNSV1)
      CALL JEVEUO(CNS1//'.CNSD','L',JCNSD1)
      CALL JEVEUO(CNS1//'.CNSC','L',JCNSC1)
      CALL JEVEUO(CNS2//'.CNSV','E',JCNSV2)
      CALL JEVEUO(CNS2//'.CNSL','E',JCNSL2)

C     NBCMP : NBRE DE CMP MAX PAR NOEUDS DU CHAM_NO_S CNS1
      NBCMP = ZI(JCNSD1-1+2)

C     VERIF QUE LES 2 PREMIERES COMPOSANTES DU CHAMP DEP1 SONT DX DY
C     OU QUE LA PREMIERE COMPOSANTES DE CE CHAMP EST TEMP
      CALL ASSERT((ZK8(JCNSC1-1+1).EQ.'DX'.AND.ZK8(JCNSC1-1+2).EQ.'DY')
     &        .OR.(ZK8(JCNSC1-1+1).EQ.'TEMP'))

      LMECA = XISMEC()
C     RQ : "NDIMC" CORRESPOND AU NOMBRE DE COMPOSANTE VECTORIELLE DU 
C     CHAMP PRIMAL (DEPL EN MECA -> NDIM CMP / TEMP EN THERMIQUE
C     -> 1 CMP)
      IF (LMECA) THEN
        NDIMC = NDIM
      ELSE
        NDIMC = 1
      END IF      

      DO 100 I=1,NBNO
        IF (DIRNO(I).NE.0) THEN
          IF (LMECA) THEN
            IDECV2 = JCNSV2-1+2*NDIMC*(DIRNO(I)-1)
            IDECL2 = JCNSL2-1+2*NDIMC*(DIRNO(I)-1)
          ELSE
            IDECV2 = JCNSV2-1+NDIMC*(DIRNO(I)-1)
            IDECL2 = JCNSL2-1+NDIMC*(DIRNO(I)-1)
          END IF
          DO 110 J=1,NDIMC
            ZR(IDECV2+J)= ZR(JCNSV1-1+NBCMP*(I-1)+J)
            ZL(IDECL2+J)=.TRUE.
 110      CONTINUE
        ENDIF
 100  CONTINUE
C
      CALL GETTCO(RESUCO,TYSD)

      IF (TYSD(1:9).NE.'MODE_MECA'.AND.TYSD(1:9).NE.'EVOL_THER') THEN
C     ------------------------------------------------------------------
C                    2.      CONTRAINTES
C     ------------------------------------------------------------------
        CALL JEVEUO(CES1//'.CESV','L',JCESV1)
        CALL JEVEUO(CES1//'.CESD','L',JCESD1)
        CALL JEVEUO(CES1//'.CESL','L',JCESL1)
        CALL JEVEUO(CES2//'.CESV','E',JCESV2)
        CALL JEVEUO(CES2//'.CESD','L',JCESD2)
        CALL JEVEUO(CES2//'.CESL','E',JCESL2)

        CALL JEEXIN(CESVI1//'.CESV',IRET)
        IF(IRET .NE. 0) THEN
          CALL JEVEUO(CESVI1//'.CESV','L',JCVIV1)
          CALL JEVEUO(CESVI1//'.CESD','L',JCVID1)
          CALL JEVEUO(CESVI1//'.CESL','L',JCVIL1)
        ENDIF
        IVIEX = IRET

        CALL JEEXIN(CESVI2//'.CESV',IRET)
        IF(IRET .NE. 0) THEN
          CALL JEVEUO(CESVI2//'.CESV','E',JCVIV2)
          CALL JEVEUO(CESVI2//'.CESD','L',JCVID2)
          CALL JEVEUO(CESVI2//'.CESL','E',JCVIL2)
        ENDIF
        IVIEX = IVIEX*IRET


        DO 10 IMA = 1,NBMA
          IMA2 = DIRMA(IMA)

          IF (IMA2.EQ.0) GOTO 10
          NPG1  = ZI(JCESD1-1+5+4* (IMA-1)+1)
          NCMP1 = ZI(JCESD1-1+5+4* (IMA-1)+3)

          NPG2  = ZI(JCESD2-1+5+4* (IMA2-1)+1)
          NCMP2 = ZI(JCESD2-1+5+4* (IMA2-1)+3)
          CALL ASSERT(NPG1.EQ.NPG2)
          CALL ASSERT(NCMP1.EQ.NCMP2)

          IF(IVIEX .NE. 0) THEN
            NPGV1  = ZI(JCVID1-1+5+4* (IMA-1)+1)
            NCMV1 = ZI(JCVID1-1+5+4* (IMA-1)+3)
            NPGV2  = ZI(JCVID2-1+5+4* (IMA2-1)+1)
            NCMV2 = ZI(JCVID2-1+5+4* (IMA2-1)+3)
            CALL ASSERT(NPG2.EQ.NPGV2)
            CALL ASSERT(NPGV1.EQ.NPG2)
            CALL ASSERT(NCMV1.LE.NCMV2)
          ENDIF

          DO 20 IPG = 1,NPG1
            DO 30 ICMP = 1,NCMP1
              CALL CESEXI('C',JCESD1,JCESL1,IMA,IPG,1,ICMP,IAD1)
              CALL ASSERT(IAD1.GT.0)
              CALL CESEXI('C',JCESD2,JCESL2,DIRMA(IMA),IPG,1,ICMP,IAD2)
              CALL ASSERT(IAD2.GT.0)
              ZL(JCESL2-1+IAD2) = .TRUE.
              ZR(JCESV2-1+IAD2) = ZR(JCESV1-1+IAD1)
 30         CONTINUE
            IF(IVIEX .NE. 0) THEN
              DO 40 ICMP = 1,NCMV1
                CALL CESEXI('C',JCVID1,JCVIL1,IMA,IPG,1,ICMP,IAD1)
                CALL ASSERT(IAD1.GT.0)
                CALL CESEXI('C',JCVID2,JCVIL2,DIRMA(IMA),IPG,1,
     &                      ICMP,IAD2)
                CALL ASSERT(IAD2.LT.0)
                IAD2 = -IAD2
                ZL(JCVIL2-1+IAD2) = .TRUE.
                ZR(JCVIV2-1+IAD2) = ZR(JCVIV1-1+IAD1)
 40           CONTINUE
            ENDIF
 20       CONTINUE
 10     CONTINUE
      ENDIF


C     ------------------------------------------------------------------
C                      3.  COMPORTEMENT
C     ------------------------------------------------------------------

C     RECUPERATION DU CHAM_ELEM_S DU COMPORTEMENT EN ENTREE
      CALL EXISD('CHAM_ELEM_S',COMPS1,IRET)

C     SI CE CHAMP N'EXISTE PAS ON N'A RIEN A FAIRE
      IF (IRET.NE.0) THEN

C       RECUP DES INFOS SUR LE CHAM_ELEM_S DU COMPORTEMENT EN ENTREE
        CALL JEVEUO(COMPS1//'.CESD','L',JRESD1)
        CALL JEVEUO(COMPS1//'.CESV','L',JRESV1)
        CALL JEVEUO(COMPS1//'.CESL','L',JRESL1)

C       NB CMP
        NBCMP = ZI(JRESD1-1+2)

C       VERIF QUE LE CHAMP DE SORTIE A BIEN ETE CREE
        CALL EXISD('CHAM_ELEM_S',COMPS2,IRET)
        CALL ASSERT(IRET.NE.0)

C       RECUP DES INFOS SUR LE CHAM_ELEM_S DU COMPORTEMENT EN SORTIE
        CALL JEVEUO(COMPS2//'.CESD','L',JRESD2)
        CALL JEVEUO(COMPS2//'.CESV','E',JRESV2)
        CALL JEVEUO(COMPS2//'.CESL','E',JRESL2)

        DO 300 IMA = 1,NBMA

          IMA2 = DIRMA(IMA)

C         ON ZAPPE LES MAILLES NON CLASSIQUES
          IF (IMA2.EQ.0) GOTO 300

          DO 310 ICMP = 1,NBCMP

            CALL CESEXI('C',JRESD1,JRESL1,IMA ,1,1,ICMP,IADR1)
            CALL CESEXI('C',JRESD2,JRESL2,IMA2,1,1,ICMP,IADR2)

            IF (IADR1.GT.0 ) THEN
              CALL ASSERT(IADR2.LT.0)
              ZK16(JRESV2-1-IADR2) = ZK16(JRESV1-1+IADR1)
              ZL(JRESL2-1-IADR2) = .TRUE.
           ENDIF

 310      CONTINUE
 300    CONTINUE

      ENDIF

C     ------------------------------------------------------------------

      CALL JEDEMA()
      END
