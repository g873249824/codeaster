      SUBROUTINE AVGRMA(VWORK, TDISP, VNBPG, NBPGT, NBORDR, NMAINI,
     &                  NBMAP, NUMPAQ, TSPAQ, NOMCRI, PROAXE,
     &                  CESR)
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF PREPOST  DATE 05/07/2004   AUTEUR F1BHHAJ J.ANGLES 
C ======================================================================
C COPYRIGHT (C) 1991 - 2003  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
C (AT YOUR OPTION) ANY LATER VERSION.                                   
C                                                                       
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
C                                                                       
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.         
C ======================================================================
C RESPONSABLE F1BHHAJ J.ANGLES
C TOLE  CRP_20
      IMPLICIT     NONE
      INTEGER      TDISP, NBMAP, VNBPG(NBMAP), NBPGT, NBORDR, NMAINI
      INTEGER      NUMPAQ, TSPAQ
      REAL*8       VWORK(TDISP)
      CHARACTER*16 NOMCRI, PROAXE
      CHARACTER*19 CESR
C ---------------------------------------------------------------------
C BUT: DETERMINER LE PLAN DANS LEQUEL LE DOMMAGE EST MAXIMAL
C ---------------------------------------------------------------------
C ARGUMENTS:
C VWORK     IN    R  : VECTEUR DE TRAVAIL CONTENANT
C                      L'HISTORIQUE DES TENSEURS DES CONTRAINTES
C                      ATTACHES A CHAQUE POINT DE GAUSS DES MAILLES
C                      DU <<PAQUET>> DE MAILLES.
C TDISP     IN    I  : DIMENSION DU VECTEUR VWORK
C VNBPG     IN    I  : VECTEUR CONTENANT LE NOMBRE DE
C                      POINT DE GAUSS DE CHAQUE MAILLE DU MAILLAGE.
C NBPGT     IN    I  : NOMBRE TOTAL DE POINTS DE GAUSS A TRAITER.
C NBORDR    IN    I  : NOMBRE DE NUMERO D'ORDRE STOCKE DANS LA
C                      STRUCTURE DE DONNEES RESULTAT.
C NMAINI    IN    I  : NUMERO DE LA 1ERE MAILLE DU <<PAQUET>> DE
C                      MAILLES COURANT.
C NBMAP     IN    I  : NOMBRE DE MAILLES DANS LE <<PAQUET>> DE
C                      MAILLES COURANT.
C NUMPAQ    IN    I  : NUMERO DU PAQUET DE MAILLES COURANT.
C TSPAQ     IN    I  : TAILLE DU SOUS-PAQUET DU <<PAQUET>> DE MAILLES
C                      COURANT.
C NOMCRI    IN    K16: NOM DU CRITERE AVEC PLANS CRITIQUES.
C PROAXE    IN    K16: TYPE DE PROJECTION (UN OU DEUX AXES).
C CESR      IN    K19: NOM DU CHAMP SIMPLE DESTINE A RECEVOIR LES
C                      RESULTATS.
C
C REMARQUE :
C  - LA TAILLE DU SOUS-PAQUET EST EGALE A LA TAILLE DU <<PAQUET>> DE
C    MAILLES DIVISEE PAR LE NOMBRE DE NUMERO D'ORDRE (NBORDR).
C-----------------------------------------------------------------------
C---- COMMUNS NORMALISES  JEVEUX
      INTEGER ZI
      COMMON /IVARJE/ZI(1)
      REAL*8 ZR
      COMMON /RVARJE/ZR(1)
      COMPLEX*16 ZC
      COMMON /CVARJE/ZC(1)
      LOGICAL ZL
      COMMON /LVARJE/ZL(1)
      CHARACTER*8 ZK8
      CHARACTER*16 ZK16
      CHARACTER*24 ZK24
      CHARACTER*32 ZK32,JEXNOM,JEXNUM,JEXATR
      CHARACTER*80 ZK80
      COMMON /KVARJE/ZK8(1),ZK16(1),ZK24(1),ZK32(1),ZK80(1)
C-----------------------------------------------------------------------
      INTEGER       I, JVECTN, JVECTU, JVECTV
      INTEGER       JVECN1, JVECU1, JVECV1, JVECN2, JVECU2, JVECV2
      INTEGER       JVPG1, JVPG2, JAXE, JFLAG, JMIMA
      INTEGER       JNPOIN, JVPOIN, JVORDR
      INTEGER       IVTRAV, INTRAV, INPIC, IVPIC, IORPIC
      INTEGER       INCYC, IVMIN, IVMAX, IOMIN, IOMAX
      INTEGER       JSIGN, JPHYD, JSIEQ, JNRUP, JDOEL, JDOTO
      INTEGER       JCERD, JCERL, JCERV, IRET, ICESD, ICESL, ICESV, IBID
      INTEGER       TNECES, TDISP2, LOR8EM, LOISEM, JVECPG, N, K
      INTEGER       IDEB, DIM, J, NGAM, TAB2(18), IFIN
      INTEGER       L, NBPG, NBPGP, KWORK, SOMPGW, IMAP 
      INTEGER       IPG, NBVEC, NVAL, VNORMX
      INTEGER       ICMP, JAD
C
      REAL*8        DGAM, GAMMA, PI, R8PI, DPHI, TAB1(18), PHI0
      REAL*8        VALA, VALB, COEFPA, PSEUIL, CUDOMX
      REAL*8        NXM, NYM, NZM, GAMMAM, EPSILO, PHIM, DPHI2, DGAM2
      REAL*8        VRESU(22)
C
      CHARACTER*2  CODRET, CODWO
      CHARACTER*8  CHMAT1, NOMPAR, NOMRES, NOMMAT, METHOD
      CHARACTER*16 PHENOM
      CHARACTER*19 CHMAT, CESMAT
      LOGICAL      ENDUR, LSIG0
C
      COMPLEX*16    C16B
C
C-----------------------------------------------------------------------
C234567                                                              012
C-----------------------------------------------------------------------
      DATA  TAB1/ 180.0D0, 60.0D0, 30.0D0, 20.0D0, 15.0D0, 12.857D0,
     &             11.25D0, 10.588D0, 10.0D0, 10.0D0, 10.0D0, 10.588D0,
     &             11.25D0, 12.857D0, 15.0D0, 20.0D0, 30.0D0, 60.0D0 /
C
      DATA  TAB2/ 1, 3, 6, 9, 12, 14, 16, 17, 18, 18, 18, 17, 16, 14,
     &           12, 9, 6, 3 /
C
      EPSILO = 1.0D-7
      PI = R8PI()
C-----------------------------------------------------------------------
C
      CALL JEMARQ()
C
C CONSTRUCTION DU VECTEUR NORMAL SUR UNE DEMI SPHERE
C CONSTRUCTION DU VECTEUR U DANS LE PLAN TANGENT, SUR UNE DEMI SPHERE
C CONSTRUCTION DU VECTEUR V DANS LE PLAN TANGENT, SUR UNE DEMI SPHERE
C
      CALL WKVECT('&&AVGRMA.VECT_NORMA', 'V V R', 627, JVECTN)
      CALL WKVECT('&&AVGRMA.VECT_TANGU', 'V V R', 627, JVECTU)
      CALL WKVECT('&&AVGRMA.VECT_TANGV', 'V V R', 627, JVECTV)
C
      CALL WKVECT('&&AVGRMA.VECT_NORMA1', 'V V R', 27, JVECN1)
      CALL WKVECT('&&AVGRMA.VECT_TANGU1', 'V V R', 27, JVECU1)
      CALL WKVECT('&&AVGRMA.VECT_TANGV1', 'V V R', 27, JVECV1)
      CALL WKVECT('&&AVGRMA.VECT_NORMA2', 'V V R', 27, JVECN2)
      CALL WKVECT('&&AVGRMA.VECT_TANGU2', 'V V R', 27, JVECU2)
      CALL WKVECT('&&AVGRMA.VECT_TANGV2', 'V V R', 27, JVECV2)
C
      CALL WKVECT('&&AVGRMA.VECTPG1', 'V V R', 18*NBORDR, JVPG1)
      CALL WKVECT('&&AVGRMA.VECTPG2', 'V V R', 18*NBORDR, JVPG2)
C
      CALL WKVECT('&&AVGRMA.AXE', 'V V R', 209*NBORDR, JAXE)
      CALL WKVECT('&&AVGRMA.FLAG', 'V V I', 209, JFLAG)
      CALL WKVECT('&&AVGRMA.MINMAX', 'V V R', 4*209, JMIMA)
C
      CALL WKVECT('&&AVGRMA.NB_POIN', 'V V I', 209, JNPOIN)
      CALL WKVECT('&&AVGRMA.VAL_POIN', 'V V R', 209*NBORDR, JVPOIN)
      CALL WKVECT('&&AVGRMA.NUME_ORDR', 'V V I', 209*NBORDR, JVORDR)
C
      CALL WKVECT('&&AVGRMA.POIN_TRAV','V V R',NBORDR+2,IVTRAV)
      CALL WKVECT('&&AVGRMA.ORDR_TRAV','V V I',2*(NBORDR+2),INTRAV)
      CALL WKVECT('&&AVGRMA.NB_PIC', 'V V I',209, INPIC)
      CALL WKVECT('&&AVGRMA.VAL_PICS','V V R',209*(NBORDR+2),IVPIC)
      CALL WKVECT('&&AVGRMA.NORD_PIC','V V I',209*(NBORDR+2),IORPIC)
C
      CALL WKVECT('&&AVGRMA.NB_CYCL','V V I', 209, INCYC)
      CALL WKVECT('&&AVGRMA.VAL_MIN','V V R',209*(NBORDR+2),IVMIN)
      CALL WKVECT('&&AVGRMA.VAL_MAX','V V R',209*(NBORDR+2),IVMAX)
      CALL WKVECT('&&AVGRMA.NORD_MIN','V V I',209*(NBORDR+2),IOMIN)
      CALL WKVECT('&&AVGRMA.NORD_MAX','V V I',209*(NBORDR+2),IOMAX)
C
      CALL WKVECT('&&AVGRMA.SIG_NORM','V V R',209*NBORDR,JSIGN)
      CALL WKVECT('&&AVGRMA.PRES_HYDR','V V R',NBORDR,JPHYD)
      CALL WKVECT('&&AVGRMA.SIG_EQUI','V V R',209*NBORDR,JSIEQ)
C
      CALL WKVECT('&&AVGRMA.NCYC_RUPT','V V R',209*NBORDR,JNRUP)
      CALL WKVECT('&&AVGRMA.DOMM_ELEM','V V R',209*NBORDR,JDOEL)
      CALL WKVECT('&&AVGRMA.DOMM_TOT','V V R',209,JDOTO)
C
C OBTENTION DES ADRESSES '.CESD', '.CESL' ET '.CESV' DU CHAMP SIMPLE
C DESTINE A RECEVOIR LES RESULTATS : DOMMAGE_MAX, COORDONNEES VECTEUR
C NORMAL CORRESPONDANT
C
      CALL JEVEUO(CESR//'.CESD','L',JCERD)
      CALL JEVEUO(CESR//'.CESL','E',JCERL)
      CALL JEVEUO(CESR//'.CESV','E',JCERV)
C
C RECUPERATION MAILLE PAR MAILLE DU MATERIAU DONNE PAR L'UTILISATEUR
C
      CALL GETVID(' ','CHAM_MATER',1,1,1,CHMAT1,IRET)
      CHMAT = CHMAT1//'.CHAMP_MAT'
      CESMAT = '&&AVGRMA.CESMAT'
      CALL CARCES(CHMAT,'ELEM',' ','V',CESMAT,IRET)
      CALL JEVEUO(CESMAT//'.CESD','L',ICESD)
      CALL JEVEUO(CESMAT//'.CESL','L',ICESL)
      CALL JEVEUO(CESMAT//'.CESV','L',ICESV)
C
      TNECES = 209*NBORDR*2
      CALL JEDISP(1, TDISP2)
      TDISP2 =  (TDISP2 * LOISEM()) / LOR8EM()
      IF (TDISP2 .LT. TNECES ) THEN
         CALL UTDEBM('F', 'AVGRMA.1', 'LA TAILLE MEMOIRE '//
     &       ' NECESSAIRE AU VECTEUR DE TRAVAIL DANS '//
     &       ' LEQUEL NOUS STOCKONS LES COMPOSANTES '//
     &       ' u ET v DU VECTEUR TAU EST TROP IMPORTANTE '//
     &       ' PAR RAPPORT A LA PLACE DISPONIBLE.')
         CALL UTIMPI('L', 'TAILLE DISPONIBLE : ', 1, TDISP2)
         CALL UTIMPI('L', 'TAILLE NECESSAIRE : ', 1, TNECES)
         CALL UTFINM( )
      ELSE
         CALL WKVECT( '&&AVGRMA.VECTPG', 'V V R', TNECES, JVECPG )
      ENDIF
C
      DGAM = 10.0D0
C
      N = 0
      K = 1
      IDEB = 1
      DIM = 627
      DO 300 J=1, 18
         GAMMA=(J-1)*DGAM*(PI/180.0D0)
         DPHI=TAB1(J)*(PI/180.0D0)
         NGAM=TAB2(J)
         IFIN = NGAM
         PHI0 = DPHI/2.0D0
C
         CALL VECNUV(IDEB, IFIN, GAMMA, PHI0, DPHI, N, K, DIM,
     &               ZR(JVECTN), ZR(JVECTU), ZR(JVECTV))
C
 300  CONTINUE
C
C CONSTRUCTION DU VECTEUR : CONTRAINTE = F(NUMERO D'ORDRE) EN CHAQUE
C POINT DE GAUSS DU PAQUET DE MAILLES.
      L = 1
      NBPG = 0
      NBPGP = 0
      KWORK = 0
      SOMPGW = 0
C
      DO 400 IMAP=NMAINI, NMAINI+(NBMAP-1)
         IF ( IMAP .GT. NMAINI ) THEN
           KWORK = 1
           SOMPGW = SOMPGW + VNBPG(IMAP-1)
         ENDIF
         NBPG = VNBPG(IMAP)
C SI LA MAILLE COURANTE N'A PAS DE POINTS DE GAUSS, LE PROGRAMME
C PASSE DIRECTEMENT A LA MAILLE SUIVANTE.
         IF (NBPG .EQ. 0) THEN
           GOTO 400
         ENDIF
C
         NBPGP = NBPGP + NBPG
         IF ( (L*INT(NBPGT/10.0D0)) .LT. NBPGP ) THEN
           WRITE(6,*)NUMPAQ,'   ',(NBPGP-NBPG)
           L = L + 1
         ENDIF
C
C RECUPERATION DU NOM DU MATERIAU AFFECTE A LA MAILLE COURANTE
C ET DES PARAMETRES ASSOCIES AU CRITERE DOMM_MAXI POUR LA MAILLE
C COURANTE
C
         CALL RNOMAT (ICESD, ICESL, ICESV, IMAP, NOMCRI, IBID, IBID,
     &                IBID, VALA, VALB, COEFPA, NOMMAT)
C
         DO 420 IPG=1, NBPG
C
C  PROJECTION DE L'HISTORIQUE DU CISAILLEMENT DANS UN PLAN
C
            CALL JERAZO('&&AVGRMA.VECTPG', TNECES, 1)
C
            NBVEC = 209
            CALL PROPLA(NBVEC, ZR(JVECTN), ZR(JVECTU), ZR(JVECTV),
     &                  NBORDR, KWORK, SOMPGW, VWORK, TDISP, TSPAQ,
     &                  IPG, ZR(JVECPG))
C
C
C CALCUL DU DOMMAGE MAX ET DU VECTEUR NORMAL ASSOCIE POUR
C LE POINT DE GAUSS COURANT DE LA MAILLE COURANTE.
C
C 1. REMISE A ZERO DU VECTEUR DE TRAVAIL CONTENANT LES VALEURS DE
C    DELTA_TAU POUR UN POINT DE GAUSS ET DU VECTEUR DE TRAVAIL
C    PERMETTANT DE POINTER SUR LE VECTEUR NORMAL ASSOCIE.
C
            CALL JERAZO('&&AVGRMA.AXE', NBVEC*NBORDR, 1)
            CALL JERAZO('&&AVGRMA.FLAG', NBVEC, 1)
            CALL JERAZO('&&AVGRMA.MINMAX', 4*NBVEC, 1)
C
C 2. ENCADREMENT DES POINTS DANS LE PLAN
C
            LSIG0 = .FALSE.
            CALL AVENCA(ZR(JVECPG), NBVEC, NBORDR, LSIG0, ZI(JFLAG),
     &                  ZR(JMIMA))
            IF (LSIG0) THEN
               CUDOMX = 0.0D0
               NXM = 0.0D0
               NYM = 0.0D0
               NZM = 1.0D0
               GOTO 555
            ENDIF
C
C 3. PROJECTION DE L'HISTORIQUE DE CHARGEMENT SUR UN OU DEUX AXES
C
            CALL PROJAX(ZR(JVECPG), NBVEC, NBORDR, PROAXE, ZI(JFLAG),
     &                   ZR(JMIMA), ZR(JAXE))
C
C 4. COMPTAGE RAINFLOW (NORME AFNOR + POSTDAM)
C
C 4.1 PREMIER FILTRAGE DES PICS DE LA FONCTION
C
            CALL JERAZO('&&AVGRMA.NB_POIN', NBVEC, 1)
            CALL JERAZO('&&AVGRMA.VAL_POIN', NBVEC*NBORDR, 1)
            CALL JERAZO('&&AVGRMA.NUME_ORDR', NBVEC*NBORDR, 1)
C
            CALL GETVR8(' ','DELTA_OSCI',1,1,1,PSEUIL,NVAL)
C
            CALL AVPEAK(ZR(JAXE), NBVEC, NBORDR, PSEUIL, ZI(JFLAG),
     &                  ZI(JNPOIN), ZR(JVPOIN), ZI(JVORDR))
C
C 4.2 REARANGEMENT ET EXTRACTION DES PICS
C
            CALL JERAZO('&&AVGRMA.POIN_TRAV', NBORDR+2, 1)
            CALL JERAZO('&&AVGRMA.ORDR_TRAV', 2*(NBORDR+2), 1)
C
            CALL JERAZO('&&AVGRMA.NB_PIC', NBVEC, 1)
            CALL JERAZO('&&AVGRMA.VAL_PICS', NBVEC*(NBORDR+2), 1)
            CALL JERAZO('&&AVGRMA.NORD_PIC', NBVEC*(NBORDR+2), 1)
C
            METHOD = 'RAINFLOW'
            CALL AVPIC2(METHOD, NBVEC, NBORDR, ZR(IVTRAV), ZI(INTRAV),
     &                  ZI(JNPOIN), ZR(JVPOIN), ZI(JVORDR), ZI(INPIC),
     &                  ZR(IVPIC), ZI(IORPIC))
C
C 4.3 COMPTAGE RAINFLOW
C
            CALL JERAZO('&&AVGRMA.NB_CYCL', NBVEC, 1)
            CALL JERAZO('&&AVGRMA.VAL_MIN', NBVEC*(NBORDR+2), 1)
            CALL JERAZO('&&AVGRMA.VAL_MAX', NBVEC*(NBORDR+2), 1)
            CALL JERAZO('&&AVGRMA.NORD_MIN', NBVEC*(NBORDR+2), 1)
            CALL JERAZO('&&AVGRMA.NORD_MAX', NBVEC*(NBORDR+2), 1)
C
            CALL AVRAIN(NBVEC, NBORDR, ZI(INTRAV), ZI(INPIC),
     &                  ZR(IVPIC), ZI(IORPIC), ZI(INCYC), ZR(IVMIN),
     &                  ZR(IVMAX), ZI(IOMIN), ZI(IOMAX))
C
C 5. CALCUL DE LA CONTRAINTE EQUIVALENTE AU SENS DES CRITERES
C
            CALL JERAZO('&&AVGRMA.SIG_NORM', NBVEC*NBORDR, 1)
            CALL JERAZO('&&AVGRMA.PRES_HYDR', NBORDR, 1)
C
            IF ( NOMCRI(1:9) .EQ. 'DOMM_MAXI' ) THEN
C
C 5.1.1 CALCUL DE LA CONTRAINTE NORMALE
C
               CALL JXVERI('MESSAGE','VERI18')
C
               CALL AVSIGN(NBVEC, NBORDR, ZR(JVECTN),
     &                     VWORK, TDISP, KWORK, 
     &                     SOMPGW, TSPAQ, IPG, ZR(JSIGN))            
C
C 5.1.2 CALCUL DE LA CONTRAINTE EQUIVALENTE AU SENS DU CRITERE DOMM_MAXI
C
               CALL JERAZO('&&AVGRMA.SIG_EQUI', NBVEC*NBORDR, 1)
C
               CALL AVCRIT(NBVEC, NBORDR, VALA, COEFPA, ZI(INCYC),
     &                     ZR(IVMIN), ZR(IVMAX), ZI(IOMIN), ZI(IOMAX),
     &                     NOMCRI, ZR(JSIGN), ZR(JPHYD), ZR(JSIEQ))
C
            ELSEIF ( NOMCRI(1:16) .EQ. 'DANG_VAN_MODI_AV' ) THEN
C
C 5.2.1 CALCUL DE LA PRESSION HYDROSTATIQUE
C
               CALL JXVERI('MESSAGE','VERI18')
C
               CALL AVPHYD(NBORDR, VWORK, TDISP, KWORK, SOMPGW,
     &                     TSPAQ, IPG, ZR(JPHYD))            
C
C 5.2.2 CALCUL DE LA CONTRAINTE EQUIVALENTE AU SENS DU CRITERE DE
C       DANG VAN
C
               CALL JERAZO('&&AVGRMA.SIG_EQUI', NBVEC*NBORDR, 1)
C
               CALL AVCRIT(NBVEC, NBORDR, VALA, COEFPA, ZI(INCYC),
     &                     ZR(IVMIN), ZR(IVMAX), ZI(IOMIN), ZI(IOMAX),
     &                     NOMCRI, ZR(JSIGN), ZR(JPHYD), ZR(JSIEQ))
C
            ENDIF
C
C 6. CALCUL DU DOMMAGE ELEMENTAIRE DE WOHLER
C
            CALL JERAZO('&&AVGRMA.NCYC_RUPT', NBVEC*NBORDR, 1)
            CALL JERAZO('&&AVGRMA.DOMM_ELEM', NBVEC*NBORDR, 1)
C
            CALL AVDOWH(NBVEC, NBORDR, NOMMAT, ZI(INCYC), ZR(JSIEQ),
     &                  ZR(JDOEL), ZR(JNRUP))
C
C 7. CALCUL DU DOMMAGE TOTAL (CUMUL)
C
            CALL JERAZO('&&AVGRMA.DOMM_TOT', NBVEC, 1)
C
            CALL AVDOMT(NBVEC, NBORDR, ZI(INCYC), ZR(JDOEL), ZR(JDOTO))
C
C 8. CALCUL DU CUMUL DE DOMMAGE MAXIMAL ET VECTEUR NORMAL ASSOCIE
C
            CALL AVCDMX(NBVEC, ZR(JDOTO), CUDOMX, VNORMX)
C
C 9. PREMIER RAFFINEMENT CONCERNANT LA DETERMINATION DU VECTEUR NORMAL
C    CORRESPONDANT AU MAX DES CUMULS DE DOMMAGE.
C
            NXM = ZR(JVECTN + (VNORMX-1)*3)
            NYM = ZR(JVECTN + (VNORMX-1)*3 + 1)
            NZM = ZR(JVECTN + (VNORMX-1)*3 + 2)
            GAMMAM = ATAN2(SQRT(ABS(1.0D0-NZM**2)),NZM)
            IF (GAMMAM .LT. 0.0D0) THEN
               GAMMAM = GAMMAM + PI
            ENDIF
C
            IF ((ABS(NYM) .LT. EPSILO) .AND.
     &          (ABS(NXM) .LT. EPSILO)) THEN
              PHIM = 0.0D0
            ELSE
              PHIM = ATAN2(ABS(NYM),NXM)
            ENDIF
            IF (PHIM .LT. 0.0D0) THEN
              PHIM = PHIM + PI
            ENDIF
C
            IF (ABS(GAMMAM) .LT. EPSILO) THEN
               GAMMA = 5.0D0*(PI/180.0D0)
               DPHI2 = 60.0D0*(PI/180.0D0)
               IDEB = 1
               IFIN = 6
               N = 0
               K = 1
               DIM = 27
               PHI0 = 0.0D0
C
               CALL VECNUV(IDEB, IFIN, GAMMA, PHI0, DPHI2, N, K, DIM,
     &                     ZR(JVECN2), ZR(JVECU2), ZR(JVECV2))
               GAMMA = 0.0D0
               PHI0 = PI
               IDEB = 1
               IFIN = 1
               K = 1
C
               CALL VECNUV(IDEB, IFIN, GAMMA, PHI0, DPHI2, N, K, DIM,
     &                     ZR(JVECN2), ZR(JVECU2), ZR(JVECV2))
C
C 9.1 PROJECTION DE L'HISTORIQUE DU CISAILLEMENT SUR UN PLAN
C
               NBVEC = 7
               CALL JERAZO('&&AVGRMA.VECTPG2', 18*NBORDR, 1)
               CALL PROPLA(NBVEC, ZR(JVECN2), ZR(JVECU2), ZR(JVECV2),
     &                     NBORDR, KWORK, SOMPGW, VWORK, TDISP, TSPAQ,
     &                     IPG, ZR(JVPG2))
            ELSE
               DGAM2 = 2.0D0*(PI/180.0D0)
               DPHI2 = DGAM2/SIN(GAMMAM)
               N = 0
               K = 2
               DIM = 27
               IDEB = 1
               IFIN = 3
               DO 430 J=1, 3
                  GAMMA = GAMMAM + (J-K)*DGAM2
                  CALL VECNUV(IDEB, IFIN, GAMMA, PHIM, DPHI2, N, K, DIM,
     &                        ZR(JVECN2), ZR(JVECU2), ZR(JVECV2))
 430           CONTINUE
C
               NBVEC = 9
               CALL JERAZO('&&AVGRMA.VECTPG2', 18*NBORDR, 1)
               CALL PROPLA(NBVEC, ZR(JVECN2), ZR(JVECU2), ZR(JVECV2),
     &                     NBORDR, KWORK, SOMPGW, VWORK, TDISP, TSPAQ,
     &                     IPG, ZR(JVPG2))
            ENDIF
C
            CALL JERAZO('&&AVGRMA.AXE', NBVEC*NBORDR, 1)
            CALL JERAZO('&&AVGRMA.FLAG', NBVEC, 1)
            CALL JERAZO('&&AVGRMA.MINMAX', 4*NBVEC, 1)
C
C 9.2 ENCADREMENT DES POINTS DANS LE PLAN
C
            CALL AVENCA(ZR(JVPG2), NBVEC, NBORDR, LSIG0, ZI(JFLAG),
     &                  ZR(JMIMA))
C
C 9.3 PROJECTION DE L'HISTORIQUE DE CHARGEMENT SUR UN OU DEUX AXES
C
            CALL PROJAX(ZR(JVPG2), NBVEC, NBORDR, PROAXE, ZI(JFLAG),
     &                  ZR(JMIMA), ZR(JAXE))
C
C 9.4 COMPTAGE RAINFLOW (NORME AFNOR + POSTDAM)
C
C 9.4.1 PREMIER FILTRAGE DES PICS DE LA FONCTION
C
            CALL JERAZO('&&AVGRMA.NB_POIN', NBVEC, 1)
            CALL JERAZO('&&AVGRMA.VAL_POIN', NBVEC*NBORDR, 1)
            CALL JERAZO('&&AVGRMA.NUME_ORDR', NBVEC*NBORDR, 1)
C
            CALL AVPEAK(ZR(JAXE), NBVEC, NBORDR, PSEUIL, ZI(JFLAG),
     &                  ZI(JNPOIN), ZR(JVPOIN), ZI(JVORDR))
C
C 9.4.2 REARANGEMENT ET EXTRACTION DES PICS
C
            CALL JERAZO('&&AVGRMA.POIN_TRAV', NBORDR+2, 1)
            CALL JERAZO('&&AVGRMA.ORDR_TRAV', 2*(NBORDR+2), 1)
C
            CALL JERAZO('&&AVGRMA.NB_PIC', NBVEC, 1)
            CALL JERAZO('&&AVGRMA.VAL_PICS', NBVEC*(NBORDR+2), 1)
            CALL JERAZO('&&AVGRMA.NORD_PIC', NBVEC*(NBORDR+2), 1)
C
            CALL AVPIC2(METHOD, NBVEC, NBORDR, ZR(IVTRAV),
     &                  ZI(INTRAV), ZI(JNPOIN), ZR(JVPOIN),
     &                  ZI(JVORDR), ZI(INPIC), ZR(IVPIC), ZI(IORPIC))
C
C 9.4.3 COMPTAGE RAINFLOW
C
            CALL JERAZO('&&AVGRMA.NB_CYCL', NBVEC, 1)
            CALL JERAZO('&&AVGRMA.VAL_MIN', NBVEC*(NBORDR+2), 1)
            CALL JERAZO('&&AVGRMA.VAL_MAX', NBVEC*(NBORDR+2), 1)
            CALL JERAZO('&&AVGRMA.NORD_MIN', NBVEC*(NBORDR+2), 1)
            CALL JERAZO('&&AVGRMA.NORD_MAX', NBVEC*(NBORDR+2), 1)
C
            CALL AVRAIN(NBVEC, NBORDR, ZI(INTRAV), ZI(INPIC),
     &                  ZR(IVPIC), ZI(IORPIC), ZI(INCYC), ZR(IVMIN),
     &                  ZR(IVMAX), ZI(IOMIN), ZI(IOMAX))
C
C 9.5 CALCUL DE LA CONTRAINTE EQUIVALENTE AU SENS DES CRITERES
C
            CALL JERAZO('&&AVGRMA.SIG_NORM', NBVEC*NBORDR, 1)
            CALL JERAZO('&&AVGRMA.PRES_HYDR', NBORDR, 1)
C
            IF ( NOMCRI(1:9) .EQ. 'DOMM_MAXI' ) THEN
C
C 9.5.1.1 CALCUL DE LA CONTRAINTE NORMALE
C
               CALL JXVERI('MESSAGE','VERI18')
C
               CALL AVSIGN(NBVEC, NBORDR, ZR(JVECN2),
     &                     VWORK, TDISP, KWORK, 
     &                     SOMPGW, TSPAQ, IPG, ZR(JSIGN))            
C
C 9.5.1.2 CALCUL DE LA CONTRAINTE EQUIVALENTE AU SENS DU CRITERE
C         DOMM_MAXI
C
               CALL JERAZO('&&AVGRMA.SIG_EQUI', NBVEC*NBORDR, 1)
C
               CALL AVCRIT(NBVEC, NBORDR, VALA, COEFPA, ZI(INCYC),
     &                     ZR(IVMIN), ZR(IVMAX), ZI(IOMIN), ZI(IOMAX),
     &                     NOMCRI, ZR(JSIGN), ZR(JPHYD), ZR(JSIEQ))
C
            ELSEIF ( NOMCRI(1:16) .EQ. 'DANG_VAN_MODI_AV' ) THEN
C
C 9.5.2.1 CALCUL DE LA PRESSION HYDROSTATIQUE
C
               CALL JXVERI('MESSAGE','VERI18')
C
               CALL AVPHYD(NBORDR, VWORK, TDISP, KWORK, SOMPGW,
     &                     TSPAQ, IPG, ZR(JPHYD))            
C
C 9.5.2.2 CALCUL DE LA CONTRAINTE EQUIVALENTE AU SENS DU CRITERE DE
C         DANG VAN
C
               CALL JERAZO('&&AVGRMA.SIG_EQUI', NBVEC*NBORDR, 1)
C
               CALL AVCRIT(NBVEC, NBORDR, VALA, COEFPA, ZI(INCYC),
     &                     ZR(IVMIN), ZR(IVMAX), ZI(IOMIN), ZI(IOMAX),
     &                     NOMCRI, ZR(JSIGN), ZR(JPHYD), ZR(JSIEQ))
C
            ENDIF
C
C 9.6 CALCUL DU DOMMAGE ELEMENTAIRE DE WOHLER
C
            CALL JERAZO('&&AVGRMA.NCYC_RUPT', NBVEC*NBORDR, 1)
            CALL JERAZO('&&AVGRMA.DOMM_ELEM', NBVEC*NBORDR, 1)
C
            CALL AVDOWH(NBVEC, NBORDR, NOMMAT, ZI(INCYC), ZR(JSIEQ),
     &                  ZR(JDOEL), ZR(JNRUP))
C
C 9.7 CALCUL DU DOMMAGE TOTAL (CUMUL)
C
            CALL JERAZO('&&AVGRMA.DOMM_TOT', NBVEC, 1)
C
            CALL AVDOMT(NBVEC, NBORDR, ZI(INCYC), ZR(JDOEL),
     &                  ZR(JDOTO))
C
C 9.8 CALCUL DU CUMUL DOMMAGE MAXIMAL ET VECTEUR NORMAL ASSOCIE
C
            CALL AVCDMX(NBVEC, ZR(JDOTO), CUDOMX, VNORMX)
C
C 10. SECOND RAFFINEMENT CONCERNANT LA DETERMINATION DU VECTEUR NORMAL
C     CORRESPONDANT AU MAX DES CUMULS DE DOMMAGE.
C
            NXM = ZR(JVECN2 + (VNORMX-1)*3)
            NYM = ZR(JVECN2 + (VNORMX-1)*3 + 1)
            NZM = ZR(JVECN2 + (VNORMX-1)*3 + 2)
            GAMMAM = ATAN2(SQRT(ABS(1.0D0-NZM**2)),NZM)
            IF (GAMMAM .LT. 0.0D0) THEN
               GAMMAM = GAMMAM + PI
            ENDIF
C
            IF ((ABS(NYM) .LT. EPSILO) .AND.
     &          (ABS(NXM) .LT. EPSILO)) THEN
              PHIM = 0.0D0
            ELSE
              PHIM = ATAN2(ABS(NYM),NXM)
            ENDIF
            IF (PHIM .LT. 0.0D0) THEN
              PHIM = PHIM + PI
            ENDIF
C
            IF (ABS(GAMMAM) .LT. EPSILO) THEN
               GAMMA = 5.0D0*(PI/180.0D0)
               DPHI2 = 60.0D0*(PI/180.0D0)
               IDEB = 1
               IFIN = 6
               N = 0
               K = 1
               DIM = 27
               PHI0 = 0.0D0
               CALL VECNUV(IDEB, IFIN, GAMMA, PHI0, DPHI2, N, K, DIM,
     &                     ZR(JVECN1), ZR(JVECU1), ZR(JVECV1))
C
               GAMMA = 0.0D0
               PHI0 = PI
               IDEB = 1
               IFIN = 1
               K = 1
               CALL VECNUV(IDEB, IFIN, GAMMA, PHI0, DPHI2, N, K, DIM,
     &                     ZR(JVECN1), ZR(JVECU1), ZR(JVECV1))
C
C 10.1 PROJECTION DE L'HISTORIQUE DU CISAILLEMENT SUR UN PLAN
C
               NBVEC = 7
               CALL JERAZO('&&AVGRMA.VECTPG1', 18*NBORDR, 1)
               CALL PROPLA(NBVEC, ZR(JVECN1), ZR(JVECU1), ZR(JVECV1),
     &                     NBORDR, KWORK, SOMPGW, VWORK, TDISP, TSPAQ,
     &                     IPG, ZR(JVPG1))
            ELSE
               DGAM2 = 1.0D0*(PI/180.0D0)
               DPHI2 = DGAM2/SIN(GAMMAM)
               N = 0
               K = 2
               DIM = 27
               IDEB = 1
               IFIN = 3
               DO 440 J=1, 3
                  GAMMA = GAMMAM + (J-K)*DGAM2
                  CALL VECNUV(IDEB, IFIN, GAMMA, PHIM, DPHI2, N, K, DIM,
     &                        ZR(JVECN1), ZR(JVECU1), ZR(JVECV1))
 440           CONTINUE
C
               NBVEC = 9
               CALL JERAZO('&&AVGRMA.VECTPG1', 18*NBORDR, 1)
               CALL PROPLA(NBVEC, ZR(JVECN1), ZR(JVECU1), ZR(JVECV1),
     &                     NBORDR, KWORK, SOMPGW, VWORK, TDISP, TSPAQ,
     &                     IPG, ZR(JVPG1))
            ENDIF
C
            CALL JERAZO('&&AVGRMA.AXE', NBVEC*NBORDR, 1)
            CALL JERAZO('&&AVGRMA.FLAG', NBVEC, 1)
            CALL JERAZO('&&AVGRMA.MINMAX', 4*NBVEC, 1)
C
C 10.2 ENCADREMENT DES POINTS DANS LE PLAN
C
            CALL AVENCA(ZR(JVPG1), NBVEC, NBORDR, LSIG0, ZI(JFLAG),
     &                  ZR(JMIMA))
C
C 10.3 PROJECTION DE L'HISTORIQUE DE CHARGEMENT SUR UN OU DEUX AXES
C
            CALL PROJAX(ZR(JVPG1), NBVEC, NBORDR, PROAXE, ZI(JFLAG),
     &                  ZR(JMIMA), ZR(JAXE))
C
C 10.4 COMPTAGE RAINFLOW (NORME AFNOR + POSTDAM)
C
C 10.4.1 PREMIER FILTRAGE DES PICS DE LA FONCTION
C
            CALL JERAZO('&&AVGRMA.NB_POIN', NBVEC, 1)
            CALL JERAZO('&&AVGRMA.VAL_POIN', NBVEC*NBORDR, 1)
            CALL JERAZO('&&AVGRMA.NUME_ORDR', NBVEC*NBORDR, 1)
C
            CALL AVPEAK(ZR(JAXE), NBVEC, NBORDR, PSEUIL, ZI(JFLAG),
     &                  ZI(JNPOIN), ZR(JVPOIN), ZI(JVORDR))
C
C 10.4.2 REARANGEMENT ET EXTRACTION DES PICS
C
            CALL JERAZO('&&AVGRMA.POIN_TRAV', NBORDR+2, 1)
            CALL JERAZO('&&AVGRMA.ORDR_TRAV', 2*(NBORDR+2), 1)
C
            CALL JERAZO('&&AVGRMA.NB_PIC', NBVEC, 1)
            CALL JERAZO('&&AVGRMA.VAL_PICS', NBVEC*(NBORDR+2), 1)
            CALL JERAZO('&&AVGRMA.NORD_PIC', NBVEC*(NBORDR+2), 1)
C
            CALL AVPIC2(METHOD, NBVEC, NBORDR, ZR(IVTRAV),
     &                  ZI(INTRAV), ZI(JNPOIN), ZR(JVPOIN),
     &                  ZI(JVORDR), ZI(INPIC), ZR(IVPIC), ZI(IORPIC))
C
C 10.4.3 COMPTAGE RAINFLOW
C
            CALL JERAZO('&&AVGRMA.NB_CYCL', NBVEC, 1)
            CALL JERAZO('&&AVGRMA.VAL_MIN', NBVEC*(NBORDR+2), 1)
            CALL JERAZO('&&AVGRMA.VAL_MAX', NBVEC*(NBORDR+2), 1)
            CALL JERAZO('&&AVGRMA.NORD_MIN', NBVEC*(NBORDR+2), 1)
            CALL JERAZO('&&AVGRMA.NORD_MAX', NBVEC*(NBORDR+2), 1)
C
            CALL AVRAIN(NBVEC, NBORDR, ZI(INTRAV), ZI(INPIC),
     &                  ZR(IVPIC), ZI(IORPIC), ZI(INCYC), ZR(IVMIN),
     &                  ZR(IVMAX), ZI(IOMIN), ZI(IOMAX))
C
C 10.5 CALCUL DE LA CONTRAINTE EQUIVALENTE AU SENS DES CRITERES
C
            CALL JERAZO('&&AVGRMA.SIG_NORM', NBVEC*NBORDR, 1)
            CALL JERAZO('&&AVGRMA.PRES_HYDR', NBORDR, 1)
C
            IF ( NOMCRI(1:9) .EQ. 'DOMM_MAXI' ) THEN
C
C 10.5.1.1 CALCUL DE LA CONTRAINTE NORMALE
C
               CALL JXVERI('MESSAGE','VERI18')
C
               CALL AVSIGN(NBVEC, NBORDR, ZR(JVECN1),
     &                     VWORK, TDISP, KWORK, 
     &                     SOMPGW, TSPAQ, IPG, ZR(JSIGN))            
C
C 10.5.1.2 CALCUL DE LA CONTRAINTE EQUIVALENTE AU SENS DU CRITERE
C         DOMM_MAXI
C
               CALL JERAZO('&&AVGRMA.SIG_EQUI', NBVEC*NBORDR, 1)
C
               CALL AVCRIT(NBVEC, NBORDR, VALA, COEFPA, ZI(INCYC),
     &                     ZR(IVMIN), ZR(IVMAX), ZI(IOMIN), ZI(IOMAX),
     &                     NOMCRI, ZR(JSIGN), ZR(JPHYD), ZR(JSIEQ))
C
            ELSEIF ( NOMCRI(1:16) .EQ. 'DANG_VAN_MODI_AV' ) THEN
C
C 10.5.2.1 CALCUL DE LA PRESSION HYDROSTATIQUE
C
               CALL JXVERI('MESSAGE','VERI18')
C
               CALL AVPHYD(NBORDR, VWORK, TDISP, KWORK, SOMPGW,
     &                     TSPAQ, IPG, ZR(JPHYD))            
C
C 10.5.2.2 CALCUL DE LA CONTRAINTE EQUIVALENTE AU SENS DU CRITERE DE
C         DANG VAN
C
               CALL JERAZO('&&AVGRMA.SIG_EQUI', NBVEC*NBORDR, 1)
C
               CALL AVCRIT(NBVEC, NBORDR, VALA, COEFPA, ZI(INCYC),
     &                     ZR(IVMIN), ZR(IVMAX), ZI(IOMIN), ZI(IOMAX),
     &                     NOMCRI, ZR(JSIGN), ZR(JPHYD), ZR(JSIEQ))
C
            ENDIF
C
C 10.6 CALCUL DU DOMMAGE ELEMENTAIRE DE WOHLER
C
            CALL JERAZO('&&AVGRMA.NCYC_RUPT', NBVEC*NBORDR, 1)
            CALL JERAZO('&&AVGRMA.DOMM_ELEM', NBVEC*NBORDR, 1)
C
            CALL AVDOWH(NBVEC, NBORDR, NOMMAT, ZI(INCYC), ZR(JSIEQ),
     &                  ZR(JDOEL), ZR(JNRUP))
C
C 10.7 CALCUL DU DOMMAGE TOTAL (CUMUL)
C
            CALL JERAZO('&&AVGRMA.DOMM_TOT', NBVEC, 1)
C
            CALL AVDOMT(NBVEC, NBORDR, ZI(INCYC), ZR(JDOEL),
     &                  ZR(JDOTO))
C
C 10.8 CALCUL DU CUMUL DOMMAGE MAXIMAL ET VECTEUR NORMAL ASSOCIE
C
            CALL AVCDMX(NBVEC, ZR(JDOTO), CUDOMX, VNORMX)
C
            NXM = ZR(JVECN1 + (VNORMX-1)*3)
            NYM = ZR(JVECN1 + (VNORMX-1)*3 + 1)
            NZM = ZR(JVECN1 + (VNORMX-1)*3 + 2)
C
C 11. CONSTRUCTION D'UN CHAM_ELEM SIMPLE PUIS D'UN CHAM_ELEM CONTENANT
C     POUR CHAQUE POINT DE GAUSS DE CHAQUE MAILLE LE DOMMAGE_MAX ET LE
C     VECTEUR NORMAL ASSOCIE.
C
 555        CONTINUE
C
            DO 600 ICMP=1, 22
               VRESU(ICMP) = 0.0D0
 600        CONTINUE
            VRESU(2) = NXM
            VRESU(3) = NYM
            VRESU(4) = NZM
            VRESU(11) = CUDOMX
C
C 12. AFFECTATION DES RESULTATS DANS UN CHAM_ELEM SIMPLE
C
            DO 610 ICMP=1, 22
               CALL CESEXI('C',JCERD,JCERL,IMAP,IPG,1,ICMP,JAD)
C
               IF (JAD .EQ. 0) THEN
                  CALL UTMESS('F', 'AVGRMA.2', 'HORS BORNES '//
     &                             ' DEFINIES DANS CESCRE.')
               ELSE
                  JAD = ABS(JAD)
                  ZL(JCERL - 1 + JAD) = .TRUE.
                  ZR(JCERV - 1 + JAD) = VRESU(ICMP)
               ENDIF
C
 610        CONTINUE
C
 420     CONTINUE
 400  CONTINUE
C
C MENAGE
C
      CALL DETRSD('CHAM_ELEM_S',CESMAT)
C
      CALL JEDETR('&&AVGRMA.VECT_NORMA')
      CALL JEDETR('&&AVGRMA.VECT_TANGU')
      CALL JEDETR('&&AVGRMA.VECT_TANGV')
      CALL JEDETR('&&AVGRMA.VECT_NORMA1')
      CALL JEDETR('&&AVGRMA.VECT_TANGU1')
      CALL JEDETR('&&AVGRMA.VECT_TANGV1')
      CALL JEDETR('&&AVGRMA.VECT_NORMA2')
      CALL JEDETR('&&AVGRMA.VECT_TANGU2')
      CALL JEDETR('&&AVGRMA.VECT_TANGV2')
      CALL JEDETR('&&AVGRMA.VECTPG1')
      CALL JEDETR('&&AVGRMA.VECTPG2')
      CALL JEDETR('&&AVGRMA.AXE')
      CALL JEDETR('&&AVGRMA.FLAG')
      CALL JEDETR('&&AVGRMA.MINMAX')
      CALL JEDETR('&&AVGRMA.NB_POIN')
      CALL JEDETR('&&AVGRMA.VAL_POIN')
      CALL JEDETR('&&AVGRMA.NUME_ORDR')
      CALL JEDETR('&&AVGRMA.POIN_TRAV')
      CALL JEDETR('&&AVGRMA.ORDR_TRAV')
      CALL JEDETR('&&AVGRMA.NB_PIC')
      CALL JEDETR('&&AVGRMA.VAL_PICS')
      CALL JEDETR('&&AVGRMA.NORD_PIC')
      CALL JEDETR('&&AVGRMA.NB_CYCL')
      CALL JEDETR('&&AVGRMA.VAL_MIN')
      CALL JEDETR('&&AVGRMA.VAL_MAX')
      CALL JEDETR('&&AVGRMA.NORD_MIN')
      CALL JEDETR('&&AVGRMA.NORD_MAX')
      CALL JEDETR('&&AVGRMA.SIG_NORM')
      CALL JEDETR('&&AVGRMA.PRES_HYDR')
      CALL JEDETR('&&AVGRMA.SIG_EQUI')
      CALL JEDETR('&&AVGRMA.NCYC_RUPT')
      CALL JEDETR('&&AVGRMA.DOMM_ELEM')
      CALL JEDETR('&&AVGRMA.DOMM_TOT')
      CALL JEDETR('&&AVGRMA.VECTPG')
C
      CALL JEDEMA()
      END
