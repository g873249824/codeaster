      INTEGER FUNCTION VERIOB(OBLIG,OBZ,VERIF,IARG,KARG)
      IMPLICIT NONE
      CHARACTER*1 OBLIG
      CHARACTER*(*) OBZ,VERIF,KARG
      INTEGER IARG
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF UTILITAI  DATE 10/10/2006   AUTEUR VABHHTS J.PELLET 
C ======================================================================
C COPYRIGHT (C) 1991 - 2006  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C ======================================================================
C RESPONSABLE VABHHTS J.PELLET
C ----------------------------------------------------------------------
C  BUT : VERIFIER UN OBJET JEVEUX
C        => ERREUR <F> SI FAUX
C  IN   OBLIG : / 'O' : OBLIGATOIRE
C               / 'F' : FACULTATIF
C  IN   OBZ   : NOM D'UN OBJET JEVEUX
C  IN   VERIF  :   /'EXIS_XD'     : OBZ EXISTE COLL. DISPERSEE
C                  /'EXIS_XC'     : OBZ EXISTE COLL. CONTIGUE
C                  /'EXIS_V'      : OBZ EXISTE VECTEUR
C                  /'EXIS_N'      : OBZ EXISTE POINTEUR DE NOMS
C                  /'EXIS_OC'     : OBZ EXISTE OBJET DE COLLECTION

C                  /'LONMAX'      : LONMAX(VEC) = IARG
C                  /'NUTIOC'      : NUTIOC(COLL)= IARG
C                  /'NOMUTI'      : NOMUTI(PNOM) = IARG

C                  /'TYPE_I'      : TYPE ENTIER
C                  /'TYPE_R'      : TYPE REEL
C                  /'TYPE_C'      : TYPE COMPLEXE
C                  /'TYPE_K8/K16/...'      : TYPE K8,K16, ...

C                  /'DOCU '       : DOCU(OBZ)=KARG

C  IN   IARG  :   ARGUMENT ENTIER (SI VERIF LE NECESSITE)
C  IN   KARG  :   ARGUMENT CHAINE (SI VERIF LE NECESSITE)
C  OUT  VERIOB : 1 : L'OBJET EXISTE
C                0 : L'OBJET N'EXISTE PAS
C
C  REMARQUE : SI L'OBJET EST UN OBJET DE COLLECTION :
C             CALL VERIOB(JEXNUM(COLL,NUM),...)
C             ALORS LES 2 VERIFS AUTORISEES SONT :
C                   'VERIF_OC' ET 'LONMAX'
C ----------------------------------------------------------------------
      CHARACTER*32 OB
      CHARACTER*1  XOUS, GENR, KBID,TMES
      CHARACTER*8  TYSCA ,STOCK ,DOCU
      CHARACTER*12  VERIF2
      CHARACTER*24 VALK(2)
      INTEGER I1,I2,IBID,I3, I4,LTYP
      LOGICAL CONTIG,OC

C -DEB------------------------------------------------------------------

      OB=OBZ
      VERIF2=VERIF

      CALL ASSERT(OBLIG.EQ.'O'.OR.OBLIG.EQ.'F')
      CALL JEEXIN(OB,I1)
      IF (I1.GT.0) THEN
        VERIOB=1
      ELSE
        VERIOB=0
        IF (OBLIG.EQ.'O') CALL U2MESK('F','SDVERI_26',1,OB)
        GOTO 9999
      ENDIF


C ---POUR LES OBJETS DE COLLECTION, ON N'ACCEPTE QUE EXIS_OC ET LONMAX:
      OC=.FALSE.
      IF(OB(25:26).EQ.'$$') THEN
        OC=.TRUE.
        CALL ASSERT(VERIF.EQ.'EXIS_OC'.OR.VERIF.EQ.'LONMAX')
      ENDIF


C ---VERIFICATION DE L'EXISTENCE ET DU GENRE DE L'OBJET :
      IF (VERIF(1:4).EQ.'EXIS') THEN

        CALL JELIRA(OB,'XOUS',IBID,XOUS)
        IF (OC) XOUS='S'
        CALL JELIRA(OB,'GENR',IBID,GENR)
        STOCK=' '
        IF (XOUS.EQ.'X') CALL JELIRA(OB,'STOCKAGE',IBID,STOCK)
        CONTIG=STOCK.EQ.'CONTIG'

        IF (VERIF.EQ.'EXIS_XD') THEN
          CALL ASSERT(XOUS.EQ.'X'.AND.(.NOT.CONTIG))
        ELSEIF (VERIF.EQ.'EXIS_XC') THEN
          CALL ASSERT(XOUS.EQ.'X'.AND.CONTIG)
        ELSEIF (VERIF.EQ.'EXIS_V') THEN
          CALL ASSERT(XOUS.EQ.'S'.AND.(GENR.EQ.'V'.OR.GENR.EQ.'E'))
        ELSEIF (VERIF.EQ.'EXIS_N') THEN
          CALL ASSERT(XOUS.EQ.'S'.AND.GENR.EQ.'N')
        ELSEIF (VERIF.EQ.'EXIS_OC') THEN
          CALL ASSERT(XOUS.EQ.'S'.AND.GENR.EQ.'V'.OR.GENR.EQ.'E')
        ELSE
          CALL ASSERT(.FALSE.)
        ENDIF



C ---VERIFICATION DU LONMAX D'UN VECTEUR
      ELSE IF (VERIF.EQ.'LONMAX') THEN
        CALL JELIRA(OB,'LONMAX',I2,KBID)
        IF (I2.NE.IARG)
     &     CALL U2MESK('F','SDVERI_17',1,OB)


C ---VERIFICATION DU NUTIOC D'UNE COLLECTION
      ELSE IF (VERIF.EQ.'NUTIOC') THEN
        CALL JELIRA(OB,'NUTIOC',I3,KBID)
        IF (I3.NE.IARG)
     &    CALL U2MESK('F','SDVERI_18',1,OB)


C ---VERIFICATION DU NOMUTI D'UN POINTEUR DE NOMS
      ELSE IF (VERIF.EQ.'NOMUTI') THEN
       CALL JELIRA(OB,'NOMUTI',I4,KBID)
       IF (I4.NE.IARG)
     &   CALL U2MESK('F','SDVERI_19',1,OB)


C ---VERIFICATION DE TYPE_I
      ELSE IF (VERIF.EQ.'TYPE_I') THEN
       CALL JELIRA(OB,'TYPE',IBID,TMES)
       IF (TMES(1:1).NE.'I')
     &   CALL U2MESK('F','SDVERI_20',1,OB)


C ---VERIFICATION DE TYPE_R
      ELSE IF (VERIF.EQ.'TYPE_R') THEN
       CALL JELIRA(OB,'TYPE',IBID,TMES)
        IF(TMES.NE.'R')
     &   CALL U2MESK('F','SDVERI_21',1,OB)


C ---VERIFICATION DE TYPE_C
      ELSE IF (VERIF.EQ.'TYPE_C') THEN
       CALL JELIRA(OB,'TYPE',IBID,TMES)
        IF(TMES.NE.'C')
     &    CALL U2MESK('F','SDVERI_22',1,OB)


C ---VERIFICATION DE TYPE_K*
      ELSE IF (VERIF(1:6).EQ.'TYPE_K') THEN
       CALL JELIRA(OB,'TYPE',IBID,TYSCA(1:1))
       CALL JELIRA(OB,'LTYP',LTYP,KBID)
       CALL CODENT(LTYP,'G',TYSCA(2:8))
       IF(TYSCA.NE.VERIF2(6:9)) THEN
         VALK(1)=OB
         VALK(2)=VERIF(6:9)
         CALL U2MESK('F','SDVERI_24',2,VALK)
       ENDIF


C ---VERIFICATION DE DOCU
      ELSE IF (VERIF.EQ.'DOCU') THEN
       CALL JELIRA(OB,'DOCU',IBID,DOCU)
       IF(DOCU.NE.KARG) THEN
         VALK(1)=KARG
         VALK(2)=DOCU
         CALL U2MESK('F','SDVERI_27',2,VALK)
       ENDIF


C ---RETOUR CODE ERREUR
      ELSE
        CALL U2MESK('F','SDVERI_25',1,VERIF2)
      ENDIF

9999  CONTINUE
      END
