      SUBROUTINE OP0045()
C-----------------------------------------------------------------------
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGELINE  DATE 26/02/2013   AUTEUR BOITEAU O.BOITEAU 
C ======================================================================
C COPYRIGHT (C) 1991 - 2013  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C TOLE CRP_20
C        MODE_ITER_SIMULT
C        RECHERCHE DE MODES PAR ITERATION SIMULTANEE EN SOUS-ESPACE
C        (LANCZOS, JACOBI OU IRA-ARPACK) OU METHODE DE TYPE QR (LAPACK)
C-----------------------------------------------------------------------
C        - POUR LE PROBLEME GENERALISE AUX VALEURS PROPRES :
C                         2
C                        L (M) Y  + (K) Y = 0
C
C          LES MATRICES (C) ET (M) SONT REELLES SYMETRIQUES
C          LA MATRICE (K) EST REELLE OU COMPLEXE SYMETRIQUE
C          LES VALEURS PROPRES ET DES VECTEURS PROPRES SONT REELS
C
C        - POUR LE PROBLEME QUADRATIQUE AUX VALEURS PROPRES :
C                         2
C                        L (M) Y  + L (C) Y + (K) Y = 0
C
C          LES MATRICES (C) ET (M) SONT REELLES SYMETRIQUES
C          LA MATRICE (K) EST REELLE OU COMPLEXE SYMETRIQUE
C          LES VALEURS PROPRES ET DES VECTEURS PROPRES SONT REELS OU
C          COMPLEXES CONJUGUEES OU NON
C-----------------------------------------------------------------------
C RESPONSABLE BOITEAU O.BOITEAU
      IMPLICIT NONE

C VARIABLES LOCALES
      INCLUDE 'jeveux.h'
      INTEGER       NBPARI, NBPARR, NBPARK, NBPARA, MXDDL
      PARAMETER    ( NBPARI=8 , NBPARR=16 , NBPARK=3, NBPARA=27 )
      PARAMETER    ( MXDDL=1 )
      INTEGER      IADX,IMET,I,IADY,IERX,IRET,
     &             IADRB,IADZ,IER1,IFM,ITEMAX,IADRH,IBID,IERD,IFREQ
      INTEGER      LMAT(3),LSELEC,LRESID,LDSOR,LAMOR,LBRSS,LMASSE,IAUXK,
     &             LMTPSC,LRESUR,LTYPRI,LWORKD,LAUX,LRAIDE,LSIGN,LVALPR,
     &             LWORKL,LDIAGR,LRESUI,LSURDR,LVEC,LWORKV,IAUXI,IAUXR,
     &             LBORVP,LMF,LPROD,LRESUK,LTYPRE,LXRIG,KQRNR,
     &             LDDL,LMATRA,LONWL,LMET,NBVEC2,ICOEF,NPIV2(2)
      INTEGER      NPIVOT,NBVECT,PRIRAM(8),MAXITR,NEQACT,MFREQ,IDET(2),
     &             NBORTO,NFREQ,NITV,NPARR,NBCINE,NEQ,NITQRM,IZERO,
     &             NBRSS,NITBAT,NIV,MXRESF,NBLAGR,NPERM,
     &             NITJAC,N1,NSTOC,NCONV,IEXIN,LWORKR,LAUR,MPICOU,
     &             QRN,QRLWOR,IQRN,LQRN,QRAR,QRAI,QRBA,QRVL,KQRN,
     &             QRN2,ILSCAL,IRSCAL,LAUC,LAUL,ICSCAL,IVSCAL,IISCAL,
     &             IBSCAL,JREFA,ISLVI,NPREC,ISLVK,KREFA,NNVALP,IARG,
     &             MPICOW,RANG,NBPROC,TYPECO,VALI(5),NBVECG,NFREQG,
     &             RANGL,ICOM1,ICOM2,L,L1,L2,L3,ISNNEM,INDF
C     &             ,IETFIN,IETDEB,IETRAT,IETMAX
      INTEGER*4    COMCOU
      REAL*8       PRORTO,OMEGA2,FMIN,FMAX,ALPHA,TOLSOR,DET(2),RZERO,
     &             FREQOM,R8PREM,OMEMIN,OMEMAX,OMESHI,R8VIDE,UNDF,
     &             OMECOR,FCORIG,PRECDC,SEUIL,VPINF,PRECSH,TOL,VPMAX,
     &             PRSUDG,RBID,TOLDYN,EFFMIN,EFFMAX,EPS,R8DEPI,QUAPI2
C     &             RETFIN
      COMPLEX*16   SIGMA,CBID,CZERO,DCMPLX
      CHARACTER*1  CTYP,APPR,KTYP
      CHARACTER*8  MODES,KNEGA,METHOD,ARRET
      CHARACTER*9  TYPEVP
      CHARACTER*14 MATRA,MATRB,MATRC
      CHARACTER*16 MODRIG,TYPCON,NOMCMD,OPTIOF,OPTIOV,TYPRES,TYPEQZ,
     &             K16BID
      CHARACTER*19 MASSE0,MASSE,RAIDE0,RAIDE,AMOR,MATPSC,MATOPA,VECRIG,
     &             NUMEDD,SOLVEU,TABMOD
      CHARACTER*24 CBORVP,VALK(5),NOPARA(NBPARA),METRES,KZERO
      LOGICAL      FLAGE,LQZ,LKR,LC,LNS,LNSC,LNSK,LNSM,LTABMO,LPG,
     &             LCOMOD,LBID
C    &             ,LCPU
C     ------------------------------------------------------------------
      DATA CBORVP / '&&OP0045.BORNE.VALP.USR ' /
      DATA  NOPARA /
     &  'NUME_MODE'       , 'ITER_QR'         , 'ITER_BATHE'      ,
     &  'ITER_ARNO'       , 'ITER_JACOBI'     , 'ITER_SEPARE'     ,
     &  'ITER_AJUSTE'     , 'ITER_INVERSE'    ,
     &  'NORME'           , 'METHODE'         , 'TYPE_MODE'       ,
     &  'FREQ'            ,
     &  'OMEGA2'          , 'AMOR_REDUIT'     , 'ERREUR'          ,
     &  'MASS_GENE'       , 'RIGI_GENE'       , 'AMOR_GENE'       ,
     &  'MASS_EFFE_DX'    , 'MASS_EFFE_DY'    , 'MASS_EFFE_DZ'    ,
     &  'FACT_PARTICI_DX' , 'FACT_PARTICI_DY' , 'FACT_PARTICI_DZ' ,
     &  'MASS_EFFE_UN_DX' , 'MASS_EFFE_UN_DY' , 'MASS_EFFE_UN_DZ' /
C     ------------------------------------------------------------------

C     ------------------------------------------------------------------
C     -------  LECTURE DES DONNEES  ET PREMIERES VERIFICATION   --------
C     ------------------------------------------------------------------

      CALL JEMARQ()
C     --- POUR MESURER LE TEMPS CONSOMMEE DS LES ETAPES DE OP0045
C     --- IL FAUT AUSSI DECOMMENTER LES APPELS A SYSTEM_CLOCK (UTILES
C     --- MAIS REFUSES PAR L'AGLA).
C      LCPU=.TRUE.
C      LCPU=.FALSE.
C      IF (LCPU) CALL SYSTEM_CLOCK(IETDEB,IETRAT,IETMAX)
      UNDF=R8VIDE()
      INDF=ISNNEM()   
      RZERO=0.D0
      IZERO=0
      KZERO=' '
      CZERO=DCMPLX(0.D0,0.D0)
      FLAGE = .FALSE.
      NCONV = 0
      ICOEF = 0
      LKR = .TRUE.
      LPG = .FALSE.
      CALL INFMAJ
      CALL INFNIV(IFM,NIV)
      IF (NIV.EQ.2) THEN
        PRIRAM(1) = 2
        PRIRAM(2) = 2
        PRIRAM(3) = 2
        PRIRAM(4) = 2
        PRIRAM(5) = 0
        PRIRAM(6) = 0
        PRIRAM(7) = 0
        PRIRAM(8) = 2
      ELSE
        CALL VECINT(8,IZERO,PRIRAM)
      ENDIF
      EPS=100.D0*R8PREM()
      QUAPI2 = R8DEPI() * R8DEPI()


C     --- RECUPERATION DU RESULTAT  ---
      CALL GETRES(MODES,TYPCON,NOMCMD)

C     ------------------------------------------------------------------
C     --------------------MACRO_MODE_MECA PARALLELE (PART I)------------
C     ------------------------------------------------------------------
C     --- RECUPERATION ET TEST DE VALIDITE DES PARAMETRES DEDIES 
C     ------------------------------------------------------------------
      ICOM1=-999
      ICOM2=-999
      MPICOW=COMCOU(0)
      MPICOU=COMCOU(1)
C     --- ON EST CENSE FONCTIONNER EN COMM_WORLD
      IF (MPICOW.NE.MPICOU) CALL ASSERT(.FALSE.)
      CALL MPIEXE('MPI_RANG_SIZE',MPICOW,IBID,RANG,NBPROC)
      CALL GETVIS('PARALLELISME_MACRO','TYPE_COM',1,IARG,1,TYPECO,L1)
      CALL GETVIS('PARALLELISME_MACRO','IPARA1_COM',1,IARG,1,ICOM1,L2)
      CALL GETVIS('PARALLELISME_MACRO','IPARA2_COM',1,IARG,1,ICOM2,L3)
      VALK(1)='TYPE_COM'
      VALK(2)='IPARA1_COM'
      VALK(3)='IPARA2_COM'
      VALK(4)='RANG'
      VALK(5)='NBPROC'
      VALI(1)=TYPECO
      VALI(2)=ICOM1
      VALI(3)=ICOM2
      VALI(4)=RANG
      VALI(5)=NBPROC
      IF (L1*L2*L3.NE.1)
     &  CALL U2MESG('F','APPELMPI_6',3,VALK,3,VALI,0,RBID)

      IF ((((TYPECO.NE.1).AND.(TYPECO.NE.-999))
     & .OR.((ICOM1.NE.-999).AND.((ICOM1.LT.1).OR.(ICOM1.GT.NBPROC)))
     & .OR.((ICOM2.NE.-999).AND.((ICOM2.LT.1).OR.(ICOM2.GT.NBPROC)))
     & .OR.(ICOM1.GT.ICOM2)
     & .OR.(NBPROC.LT.1).OR.(RANG.LT.0)))
     &  CALL U2MESG('F','APPELMPI_8',5,VALK,5,VALI,0,RBID)

      IF ((TYPECO.EQ.1).AND.(NBPROC.GT.1)) THEN
        LCOMOD=.TRUE.
C       --- DECOMPOSE LE COM GLOBAL MPICOW EN COM LOCAL MPICOU
C       --- PLUS AFFECTATION DE CE NOUVEAU COM AFIN DE NE PAS PERTURBER 
C       --- LA FACTO DE LA DEMI-BANDE
        CALL MPIEXE('MPI_COMM_SPLIT',MPICOW,MPICOU,ICOM1,0)
        IF (MPICOW.EQ.MPICOU) CALL ASSERT(.FALSE.)
        CALL MPIEXE('AFFE_COMM_REFE',MPICOU,IBID,1,IBID)
C       --- RANG DANS LE SOUS-COMM MPICOU LIE A CHAQUE OCCURENCE
C       --- MUMPS: RANGL
        CALL MPIEXE('MPI_RANG_SIZE',MPICOU,IBID,RANGL,IBID)
C       --- TAILLE MAXIMUM DU BUFFER MPI
      ELSE
        RANGL=-9999
        MPICOU=-9999
        LCOMOD=.FALSE.
      ENDIF
C     ------------------------------------------------------------------

C     --- TYPE DE CALCUL : DYNAMIQUE OU FLAMBEMENT OU GENERAL  ---
C     TYPE_RESU : 'DYNAMIQUE' OU 'MODE_FLAMB' OU 'GENERAL'
      CALL GETVTX(' ','TYPE_RESU',1,IARG,1,TYPRES,LTYPRE)


C     --- CATALOGUE DE COMMANDE, DIFFERENT SELON LE TYPE_RESU
C     -> ON STOCKE DANS DES VARIABLES POUR EVITER DE FAIRE DES GETXXX
C     POUR CHAQUE TYPE_RESU. 
C     POUR L'INSTANT TYPE_RESU='GENERAL' REVIENT A 'MODE_FLAMB'
C     SAUF LE NOM DES MATRICES
      IF (TYPRES .EQ. 'DYNAMIQUE') THEN
        MATRA = 'MATR_RIGI'
        MATRB = 'MATR_MASS'
        MATRC = 'MATR_AMOR'
        TYPEVP= 'FREQ'
      ELSEIF (TYPRES .EQ. 'MODE_FLAMB') THEN
        MATRA = 'MATR_RIGI'
        MATRB = 'MATR_RIGI_GEOM'
        TYPEVP= 'CHAR_CRIT'
      ELSEIF (TYPRES .EQ. 'GENERAL') THEN
        MATRA = 'MATR_A'
        MATRB = 'MATR_B'
        MATRC = 'MATR_C'
        TYPEVP= 'CHAR_CRIT'
        TYPRES= 'MODE_FLAMB'
      ENDIF


C     --- OPTION DEMANDEE : BANDE OU PLUS_PETITE OU PLUS_GRANDE OU
C         CENTRE OU TOUT ---
C     OPTIOF : 'BANDE' OU 'CENTRE' OU 'PLUS_PETITE' OU 'TOUT'
      CALL GETVTX('CALC_'//TYPEVP,'OPTION',1,IARG,1,OPTIOF,LMF)


C     --- RECUPERATION DES ARGUMENTS MATRICIELS ---
      IF (OPTIOF .EQ. 'PLUS_GRANDE') THEN
        OPTIOF = 'PLUS_PETITE'
        LPG = .TRUE.
        CALL GETVID(' ',MATRA,1,IARG,1,MASSE0,L)
        CALL GETVID(' ',MATRB,1,IARG,1,RAIDE0,L)
        RAIDE = 'MATR'
        MASSE = 'MATM'
C       - TRANSMISSION DES LAGRANGES DE LA RAIDEUR VERS LA MASSE
        CALL AJLAGR(MASSE0, RAIDE0, RAIDE)
C       - SUPPRESSION DES LAGRANGES DE LA RAIDEUR
        CALL MTDEFS(MASSE,MASSE0,'V',' ')
        CALL MTCMBL(1, 'R', 1.D0, MASSE0, MASSE, 'LAGR',' ','ELIM=')
      ELSE
        CALL GETVID(' ',MATRA,1,IARG,1,RAIDE,L)
        CALL GETVID(' ',MATRB,1,IARG,1,MASSE,L)
      ENDIF
      AMOR = ' '
      LAMOR = 0
      IF (TYPRES .NE. 'MODE_FLAMB')
     &   CALL GETVID(' ',MATRC,1,IARG,1,AMOR,LAMOR)
      IF (LAMOR.EQ.0) THEN
        LC=.FALSE.
      ELSE
        LC=.TRUE.
      ENDIF

C     --- TEST DU TYPE (COMPLEXE OU REELLE) DE LA MATRICE DE RAIDEUR ---
      CALL JELIRA(RAIDE//'.VALM','TYPE',IBID,KTYP)
      IF (KTYP.EQ.'R') THEN
        LKR=.TRUE.
      ELSE IF (KTYP.EQ.'C') THEN
        LKR=.FALSE.
      ELSE
        CALL ASSERT(.FALSE.)
      ENDIF

C     --- METHODE DE RESOLUTION CHOISIE ---
C     METHOD : 'TRI_DIAG','JACOBI' OU 'SORENSEN' OU 'QZ'
      CALL GETVTX(' ','METHODE',1,IARG,1,METHOD,LMET)
      IF (METHOD(1:2).EQ.'QZ') THEN
        LQZ=.TRUE.
      ELSE
        LQZ=.FALSE.
      ENDIF

C     --- DETECTION DES MODES DE CORPS RIGIDE ---
C     MODRIG : 'MODE_RIGIDE' OU 'SANS'
      CALL GETVTX(' ','OPTION',1,IARG,1,MODRIG,LTYPRI)

C     --- RECUPERATION DES ARGUMENTS CONCERNANT LE NOMBRE DE SHIFT ---
      CALL GETVIS('CALC_'//TYPEVP,'NMAX_ITER_SHIFT',1,IARG,
     &  1,NBRSS,LBRSS)

C     --- RECUPERATION NFREQ ---
C     NFREQ : NOMBRE DE MODES DEMANDES
      CALL GETVIS('CALC_'//TYPEVP,'NMAX_'//TYPEVP,
     &                                      1,IARG,1,NFREQ,L)

C     --- RECUPERATION PARAM ESPACE REDUIT ---
C     NBVECT, NBVEC2 : DIMENSION/COEF MULTIPLICATEUR DE L'ESPACE REDUIT
      NBVECT = 0
      CALL GETVIS('CALC_'//TYPEVP,'DIM_SOUS_ESPACE',1,IARG,1,NBVECT,L)
      NBVEC2 = 0
      CALL GETVIS('CALC_'//TYPEVP,'COEF_DIM_ESPACE',1,IARG,1,NBVEC2,L)

C     --- RECUPERATION DECALAGE POUR DETERMINER LE SHIFT ---
C     PRECSH : POUR PRE TRAITEMENT
      CALL GETVR8('CALC_'//TYPEVP,'PREC_SHIFT',1,IARG,1,PRECSH,L)
C     PRECDC : POUR POST TRAITEMENT
      CALL GETVR8('VERI_MODE','PREC_SHIFT',1,IARG,1,PRECDC,LMF)

C     --- RECUPERATION PARAM LANCZOS ---
      IF (METHOD .EQ. 'TRI_DIAG') THEN
         CALL GETVIS(' ','NMAX_ITER_ORTHO' ,1,IARG,1,NBORTO,L)
         CALL GETVR8(' ','PREC_ORTHO'      ,1,IARG,1,PRORTO,L)
         CALL GETVR8(' ','PREC_LANCZOS'    ,1,IARG,1,PRSUDG,L)
         CALL GETVIS(' ','NMAX_ITER_QR'    ,1,IARG,1,NITV,L)

C     --- RECUPERATION PARAM JACOBI ---
      ELSE  IF (METHOD .EQ. 'JACOBI') THEN
         CALL GETVIS(' ','NMAX_ITER_BATHE ',1,IARG,1,ITEMAX,L)
         CALL GETVR8(' ','PREC_BATHE'      ,1,IARG,1,TOL,L)
         CALL GETVIS(' ','NMAX_ITER_JACOBI',1,IARG,1,NPERM,L)
         CALL GETVR8(' ','PREC_JACOBI'     ,1,IARG,1,TOLDYN,L)

C     --- RECUPERATION PARAM SORENSEN ---
       ELSE IF (METHOD .EQ. 'SORENSEN') THEN
         CALL GETVR8(' ','PREC_SOREN',1,IARG,1,TOLSOR,L)
         CALL GETVIS(' ','NMAX_ITER_SOREN'  ,1,IARG,1,MAXITR,L)
         CALL GETVR8(' ','PARA_ORTHO_SOREN' ,1,IARG,1,ALPHA,L)
         IF ((ALPHA.LT.1.2D0*EPS).OR.(ALPHA.GT.0.83D0-EPS))
     &     CALL U2MESS('E','ALGELINE2_64')
C     --- RECUPERATION PARAM QZ ---
      ELSE IF (LQZ) THEN
        CALL GETVTX(' ','TYPE_QZ',1,IARG,1,TYPEQZ,L)
      ENDIF

C     --- RECUPERATION PARAM MODES RIGIDES ---
C     FCORIG : SEUIL DE FREQUENCE CORPS RIGIDE
      CALL GETVR8('CALC_'//TYPEVP,'SEUIL_'//TYPEVP,1,IARG,1,FCORIG,L)
      OMECOR = RZERO
      IF (TYPRES.EQ.'DYNAMIQUE') OMECOR = OMEGA2(FCORIG)

C     --- LISTES DES FREQUENCES/CHARGES CRITIQUES ---
      NNVALP = 0
      CALL GETVR8('CALC_'//TYPEVP,TYPEVP,1,IARG,0,RBID,NNVALP)
      IF (NNVALP.LT.0) THEN
         NNVALP = -NNVALP
         CALL WKVECT(CBORVP,' V V R',NNVALP,LBORVP)
         CALL GETVR8('CALC_'//TYPEVP,TYPEVP,1,IARG,NNVALP,ZR(LBORVP),L)
      ELSE
         CALL WKVECT(CBORVP,' V V R',1,LBORVP)
         ZR(LBORVP)=RZERO
      ENDIF

C     --- APPROCHE (CAS AVEC AMORTISSEMENT) ---
C     UTILISE SI LMAMOR.NE.0 ET SI METHODE.NE.QZ
      CALL GETVTX('CALC_'//TYPEVP,'APPROCHE',1,IARG,1,APPR,IBID)

C     ------------------------------------------------------------------
C     --------------------  REGLES D'EXCLUSION   -----------------------
C     ------------------------------------------------------------------
C     --- MODES RIGIDES---
      IF ((MODRIG.EQ.'MODE_RIGIDE').AND.(METHOD.NE.'TRI_DIAG'))
     &  CALL U2MESS('F','ALGELINE2_65')

      IF (LC) THEN
         VALK(1) = MATRA
         VALK(2) = MATRC
         IF (LPG) CALL U2MESS('F','ALGELINE5_82')
         IF (OPTIOF.EQ.'BANDE') CALL U2MESK('F','ALGELINE2_66',2,VALK)
         IF (((APPR.EQ.'I').OR.(APPR.EQ.'C')).AND.(ZR(LBORVP).EQ.0.D0))
     &      CALL U2MESS('F','ALGELINE2_67')
         IF (MODRIG.EQ.'MODE_RIGIDE')
     &      CALL U2MESK('F','ALGELINE2_68',2,VALK)
         IF ((METHOD.EQ.'SORENSEN').AND.(ZR(LBORVP).EQ.0.D0))
     &      CALL U2MESS('F','ALGELINE2_71')
         IF (METHOD(1:6).EQ.'JACOBI')
     &      CALL U2MESK('F','ALGELINE5_64',1,MATRC)
      ENDIF

C     --- MATRICE K COMPLEXE ---
      IF (.NOT.LKR) THEN
         VALK(1) = MATRA
         VALK(2) = MATRC
         IF (LPG) CALL U2MESS('F','ALGELINE5_82')
         IF ((METHOD.NE.'SORENSEN').AND.(.NOT.LQZ))
     &     CALL U2MESS('F','ALGELINE2_69')
         IF (OPTIOF.EQ.'BANDE') CALL U2MESK('F','ALGELINE2_66',2,VALK)
         IF (ZR(LBORVP).EQ.0.D0) CALL U2MESS('F','ALGELINE2_70')
         IF (MODRIG.EQ.'MODE_RIGIDE')
     &      CALL U2MESK('F','ALGELINE2_68',2,VALK)
         IF (TYPRES.EQ.'MODE_FLAMB')
     &      CALL U2MESK('F','ALGELINE2_46',1,MATRA)
      ENDIF

C     --- METHODE QZ ---
      IF (LQZ) THEN
        IF ((TYPEQZ(1:5).EQ.'QZ_QR').AND.((TYPRES(1:10).EQ.'FLAMBEMENT')
     &       .OR.LC.OR.(.NOT.LKR))) THEN
           VALK(1) = MATRA
           VALK(2) = MATRC
           CALL U2MESK('F','ALGELINE5_60',2,VALK)
        ENDIF
      ENDIF
      IF ((OPTIOF.EQ.'TOUT').AND.(.NOT.LQZ))
     &  CALL U2MESK('F','ALGELINE5_65',1,'CALC_'//TYPEVP)

C     --- COMPATIBILITE DES MODES (DONNEES ALTEREES) ---
      CALL EXISD('MATR_ASSE',RAIDE,IBID)
      IF (IBID.NE.0) THEN
        CALL DISMOI('F','NOM_NUME_DDL',RAIDE,'MATR_ASSE',IBID,
     &              NUMEDD,IRET)
      ELSE
        NUMEDD=' '
      ENDIF

      IF (LPG) THEN
        CALL VPCREA(0,MODES,RAIDE0,AMOR,MASSE0,NUMEDD,IER1)
      ELSE
        CALL VPCREA(0,MODES,MASSE,AMOR,RAIDE,NUMEDD,IER1)
      ENDIF


C     --- VERIFICATION DES "REFE" ---
      CALL VRREFE(MASSE,RAIDE,IRET)
      IF (IRET.GT.0) THEN
        VALK(1) = RAIDE
        VALK(2) = MASSE
        CALL U2MESK('F','ALGELINE2_58', 2 ,VALK)
      ENDIF
      IF (LC) THEN
        CALL VRREFE(RAIDE,AMOR,IRET)
        IF (IRET.GT.0) THEN
          VALK(1) = RAIDE
          VALK(2) = AMOR
          CALL U2MESK('F','ALGELINE2_58', 2 ,VALK)
        ENDIF
      ENDIF

C     --- DESCRIPTEUR DES MATRICES ---
      LNSK=.FALSE.
      LNSM=.FALSE.
      LNSC=.FALSE.
      CALL MTDSCR(MASSE)
      CALL JEVEUO(MASSE(1:19)//'.&INT','E',LMASSE)
      IF (ZI(LMASSE+4).EQ.0) LNSM=.TRUE.
      CALL MTDSCR(RAIDE)
      CALL JEVEUO(RAIDE(1:19)//'.&INT','E',LRAIDE)
      IF (ZI(LRAIDE+4).EQ.0) LNSK=.TRUE.
      IF (LC) THEN
        CALL MTDSCR(AMOR)
        CALL JEVEUO(AMOR(1:19)//'.&INT','E',LAMOR)
        IF (ZI(LAMOR+4).EQ.0) LNSC=.TRUE.
      ELSE
        LAMOR=0
      ENDIF

C     --- MATRICE K ET/OU M ET OU C NON SYMETRIQUE(S)
      IF (LNSC.OR.LNSK.OR.LNSM) THEN
        LNS=.TRUE.
        IF (LPG) CALL U2MESS('F','ALGELINE5_82')
        IF ((.NOT.LQZ).AND.(METHOD.NE.'SORENSEN'))
     &    CALL U2MESS('F','ALGELINE5_69')
        IF (.NOT.LKR) CALL U2MESK('F','ALGELINE5_70',1,MATRA)
        IF (OPTIOF.EQ.'BANDE') CALL U2MESS('F','ALGELINE4_39')
        IF (MODRIG.EQ.'MODE_RIGIDE') CALL U2MESS('F','ALGELINE4_40')
        IF (TYPRES.EQ.'MODE_FLAMB') CALL U2MESS('F','ALGELINE4_41')
      ELSE
        LNS=.FALSE.
      ENDIF

C     ------------------------------------------------------------------
C     ----------- DDL : LAGRANGE, BLOQUE PAR AFFE_CHAR_CINE  -----------
C     ------------------------------------------------------------------

C     --- NOMBRE D'EQUATIONS ---
      NEQ = ZI(LRAIDE+2)
      CALL WKVECT('&&OP0045.POSITION.DDL','V V I',NEQ*MXDDL,LDDL)
      CALL WKVECT('&&OP0045.DDL.BLOQ.CINE','V V I',NEQ,LPROD)
      CALL VPDDL(RAIDE, MASSE, NEQ, NBLAGR, NBCINE, NEQACT, ZI(LDDL),
     &           ZI(LPROD), IERD)
      IF (IERD .NE. 0) GOTO 9999

C       -- TRAITEMENTS PARTICULIERS PROPRES A QZ
      IF (LQZ) THEN
        IF (OPTIOF(1:4).EQ.'TOUT') NFREQ = NEQACT
        IF ((TYPEQZ(1:5).EQ.'QZ_QR').AND.((NBLAGR.NE.0).OR.LNS)) THEN
           VALK(1) = MATRA
           VALK(2) = MATRC
           CALL U2MESK('F','ALGELINE5_60',2,VALK)
        ENDIF
      ENDIF

C     ------------------------------------------------------------------
C     ----------- LECTURE/TRAITEMENT SD SOLVEUR LINEAIRE  -----------
C     ------------------------------------------------------------------
C     -- LECTURE DES PARAMETRES SOLVEURS LINEAIRES ET CREATION DE
C        LA SD SOLVEUR ASSOCIEE. CETTE SD SOLVEUR EST LOCALE A L'OPERA
C        TEUR. POUR CE CALCUL, C'EST ELLE QUI EST UTILISEE POUR PARAME
C        TREE LE SOLVEUR LINEAIRE, ET NON PAS LA SD SOLVEUR CREE PAR LA
C        CMDE ECLATEE NUME_DDL LORS DE LA CONSTITUTION DES MATRICES.
      CALL JEVEUO(RAIDE//'.REFA','L',JREFA)
      SOLVEU='&&OP0045.SOLVEUR'
      CALL CRESOL(SOLVEU)
      CALL JEVEUO(SOLVEU//'.SLVK','L',ISLVK)
      CALL JEVEUO(SOLVEU//'.SLVI','L',ISLVI)
      NPREC=ZI(ISLVI)
      METRES=ZK24(ISLVK)
      IF((METRES(1:4).NE.'LDLT').AND.(METRES(1:10).NE.'MULT_FRONT').AND.
     &   (METRES(1:5).NE.'MUMPS')) CALL U2MESS('F','ALGELINE5_71')

      NPREC=ZI(ISLVI)
      METRES=ZK24(ISLVK)

C     ------------------------------------------------------------------
C     ------------  CONSTRUCTION DE LA MATRICE SHIFTEE   ---------------
C     ------------------------------------------------------------------

C     --- VERIFICATION DES FREQUENCES MIN ET MAX, PASSAGE EN OMEGA2
      IF (TYPRES.EQ.'DYNAMIQUE') THEN
        FMIN = RZERO
        FMAX = RZERO
        IF (NNVALP.GT.0) FMIN = ZR(LBORVP)
        IF (NNVALP.GT.1) FMAX = ZR(LBORVP+1)
        IF (LC.AND.(FMIN.LT.0.D0)) THEN
          FMIN = -FMIN
          IF (NIV .GE. 1) THEN
             WRITE(IFM,*)'PROBLEME QUADRATIQUE'
             WRITE(IFM,*)'FREQUENCE DE DECALAGE EST NEGATIVE',
     &               'LES VALEURS PROPRES ETANT CONJUGUEES 2 A 2 '//
     &               'ON PEUT LA PRENDRE POSITIVE. ON LE FAIT !!!'
             WRITE(IFM,*)
           ENDIF
        ENDIF
        OMEMIN = OMEGA2(FMIN)
        OMEMAX = OMEGA2(FMAX)
      ELSE
        OMEMIN = RZERO
        OMEMAX = RZERO
        IF (NNVALP.GT.0) OMEMIN = ZR(LBORVP)
        IF (NNVALP.GT.1) OMEMAX = ZR(LBORVP+1)
        FMIN=OMEMIN
        FMAX=OMEMAX
      ENDIF

C     --- ARRET SI PAS DE FREQUENCE DANS L'INTERVALLE DONNE  ---
      CALL GETVTX ( ' ', 'STOP_BANDE_VIDE', 1,IARG,1, ARRET, N1 )

C     ------------------------------------------------------------------
C     ----  DETETECTION DES MODES DE CORPS RIGIDE                 ------
C     ------------------------------------------------------------------

      LXRIG = 0
      NSTOC = 0
      IF (MODRIG .EQ. 'MODE_RIGIDE') THEN
        VECRIG = '&&OP0045.MODE.RIGID'
        CALL UTTCPU('CPU.RESO.1','DEBUT',' ')
        CALL UTTCPU('CPU.RESO.4','DEBUT',' ')
        CALL TLDLG2(LRAIDE,NPREC,NSTOC,VECRIG,' ',' ')
        CALL UTTCPU('CPU.RESO.1','FIN',' ')
        CALL UTTCPU('CPU.RESO.4','FIN',' ')
        IF (NSTOC.NE.0) CALL JEVEUO(VECRIG,'E',LXRIG)
      ENDIF
C      IF (LCPU) THEN
C        CALL SYSTEM_CLOCK(IETFIN)
C        RETFIN=REAL(IETFIN-IETDEB)/REAL(IETRAT)
C        WRITE(IFM,*)'<OP0045> COUT LECTURE PARAMETRES: ',RETFIN
C        CALL SYSTEM_CLOCK(IETDEB,IETRAT,IETMAX)
C      ENDIF
C     ------------------------------------------------------------------
C     ----  CREATION DE LA MATRICE DYNAMIQUE ET DE SA FACTORISEE  ------
C     ------------------------------------------------------------------
      MATPSC = '&&OP0045.DYN_FAC_R '
      MATOPA = '&&OP0045.DYN_FAC_C '
      OMESHI=RZERO
      SIGMA=CZERO
      NPIVOT=0
      LMTPSC= 0
      LMATRA=0
C     --- SI AVEC L'OPTION 'BANDE', ON FOURNIT UNE TABLE, CONTROLE ET
C     --- LECTURE DES PARAMETRES DE LA TABLE (AU FORMAT INFO_MODE)
C     --- GAIN DE TEMPS, ON NE RECALCULE PAS TOUT DS LE VPFOPR SUIVANT
      LTABMO=.FALSE.
      EFFMIN=-9999.D0
      EFFMAX=-9999.D0
      IF (OPTIOF.EQ.'BANDE') THEN
        CALL GETVID('CALC_'//TYPEVP,'TABLE_'//TYPEVP,1,IBID,1,TABMOD,L)
        IF (L.EQ.1) THEN
          LTABMO=.TRUE.
          CALL VPTABL(TABMOD,TYPEVP,FMIN,FMAX,PRECDC,NFREQ,
     &                EFFMIN,EFFMAX)
C     --- RECUPERATION DES BORNES EFFECTIVES ET CHANGEMENT DES BORNES
C     --- DE LA BANDE SI NECESSAIRE
          IF (ABS(FMAX-EFFMAX)+ABS(FMIN-EFFMIN).GT.EPS) THEN
            VALK(1)=TABMOD
            CALL U2MESK('A','ALGELINE2_26',1,VALK)
            FMIN=EFFMIN
            FMAX=EFFMAX
            IF (TYPRES.EQ.'DYNAMIQUE') THEN
              OMEMIN=OMEGA2(FMIN)
              OMEMAX=OMEGA2(FMAX)
            ELSE
              OMEMIN=FMIN
              OMEMAX=FMAX
            ENDIF
          ENDIF
        ENDIF
      ENDIF

C --- DETERMINATION D'INFO POUR LE TEST DE STURM ET LES POSITIONS
C     MODALES + CONSTRUCTION DE LA MATRICE DYNAMIQUE/ SA FACTORISEE
C     (STOCKEE DS MATOPA). CAS PARTICULIER DU QEP APPROCHE REEL, POUR
C     LEQUEL ON UTILISE AUSSI UNE MATRICE MATPSC DISTINCTE DE MATOPA.
C     DANS TOUS LES AUTRES CAS, MATPSC=MATOPA.
C --- AVEC QZ, UTILE QUE POUR GENERALISE REEL SYMETRIQUE
C     DANS LES AUTRES CAS (VPFOPC,WPFOPR,WPFOPC) ON SORT DES LE CALCUL
C     DU SHIFT SIGMA
      IF (.NOT.LC) THEN
C     --- PROBLEME GENERALISE REEL SYMETRIQUE ---
        IF (LKR.AND.(.NOT.LNS)) THEN
          CALL MTDEFS(MATOPA,RAIDE,'V','R')
          CALL MTDSCR(MATOPA)
          CALL JEVEUO(MATOPA(1:19)//'.&INT','E',LMATRA)
C     --- POUR EVITER DE REFAIRE LE TEST DE STURM DE PRETTRAITEMENT AVEC
C     --- L'OPTION 'BANDE'
          IF (LTABMO) THEN
            OPTIOV='BANDEA'
          ELSE
            OPTIOV=OPTIOF
          ENDIF
          CALL VPFOPR(OPTIOV,TYPRES,LMASSE,LRAIDE,LMATRA,OMEMIN,OMEMAX,
     &            OMESHI,NFREQ,NPIV2,OMECOR,PRECSH,NBRSS,NBLAGR,SOLVEU,
     &            DET,IDET)
          NPIVOT=NPIV2(1)
          IF (NFREQ.LE.0) THEN
            IF ( ARRET(1:3) .EQ. 'OUI' ) THEN
              CALL UTEXCP(24,'MODAL_1')
            ELSE
              NFREQ = 1
              CALL RSCRSD('G', MODES , TYPCON , NFREQ )
              GOTO 999
            ENDIF
          ENDIF
          LMTPSC=LMATRA
          MATPSC=MATOPA
        ELSE
C     --- PROBLEME GENERALISE COMPLEXE OU REEL NON SYM ---
          CALL VPFOPC(LMASSE,LRAIDE,FMIN,SIGMA,MATOPA,RAIDE,LQZ,SOLVEU)
          IF (.NOT.LQZ)
     &      CALL JEVEUO(MATOPA(1:19)//'.&INT','L',LMATRA)
        ENDIF

      ELSE

C     --- PROBLEME QUADRATIQUE REEL SYM OU NON SYM---
        IF (LKR) THEN
          CALL WPFOPR(LMASSE,LAMOR,LRAIDE,APPR,FMIN,SIGMA,
     &                MATOPA,MATPSC,RAIDE,LQZ,SOLVEU)
          IF (.NOT.LQZ) THEN
            CALL JEVEUO(MATOPA(1:19)//'.&INT','L',LMATRA)
            CALL JEEXIN(MATPSC(1:19)//'.&INT',IEXIN)
            IF (IEXIN.NE.0)
     &        CALL JEVEUO(MATPSC(1:19)//'.&INT','L',LMTPSC)
          ENDIF
        ELSE
C     --- PROBLEME QUADRATIQUE COMPLEXE SYM ---
          CALL WPFOPC(LMASSE,LAMOR,LRAIDE,FMIN,SIGMA,
     &                MATOPA,RAIDE,LQZ,SOLVEU)
          IF (.NOT.LQZ)
     &      CALL JEVEUO(MATOPA(1:19)//'.&INT','L',LMATRA)
        ENDIF
      ENDIF

C      IF (LCPU) THEN
C        CALL SYSTEM_CLOCK(IETFIN)
C        RETFIN=REAL(IETFIN-IETDEB)/REAL(IETRAT)
C        WRITE(IFM,*)'<OP0045> COUT MATRICE DYNAMIQUE + FACTO: ',RETFIN
C        CALL SYSTEM_CLOCK(IETDEB,IETRAT,IETMAX)
C      ENDIF
C    --- ON BLINDE LES STRUCTURES DE DONNEES DE TYPE MATR_ASSE
C    --- ON NE MANIPULE PAR LA SUITE QUE LEUR DESCRIPTEUR
C    --- MATOPA --> LMATRA ET MATPSC --> LMTPSC
C    --- ON TOUCHE A LEUR .REFA POUR DETRUIRE CORRECTEMENT LES
C    --- EVENTUELLES OCCURENCES EXTERNES
      IF (LMATRA.EQ.0) MATOPA=' '
      IF (LMTPSC.EQ.0) MATPSC=' '
      IF (LMATRA.NE.0) THEN
        CALL JEEXIN(MATOPA(1:19)//'.REFA',IRET)
        IF (IRET.NE.0) THEN
          CALL JEVEUO(MATOPA(1:19)//'.REFA','E',KREFA)
          ZK24(KREFA-1+7)=SOLVEU
        ENDIF
      ENDIF
      IF ((LMTPSC.NE.0).AND.(LMTPSC.NE.LMATRA)) THEN
        CALL JEEXIN(MATPSC(1:19)//'.REFA',IRET)
        IF (IRET.NE.0) THEN
          CALL JEVEUO(MATPSC(1:19)//'.REFA','E',KREFA)
          ZK24(KREFA-1+7)=SOLVEU
        ENDIF
      ENDIF

C     ------------------------------------------------------------------
C     ----  CORRECTION EVENTUELLE DU NBRE DE MODES DEMANDES NFREQ ------
C     ----  DETERMINATION DE LA DIMENSION DU SOUS ESPACE NBVECT   ------
C     ------------------------------------------------------------------


      IF (NIV.GE.1) THEN
        WRITE(IFM,*)'INFORMATIONS SUR LE CALCUL DEMANDE:'
        WRITE(IFM,*)'NOMBRE DE MODES RECHERCHES     : ',NFREQ
        WRITE(IFM,*)
      ENDIF

C     --- CORRECTION DU NOMBRE DE FREQUENCES DEMANDEES
      IF (NFREQ.GT.NEQACT) THEN
        NFREQ = NEQACT
        IF (NIV .GE. 1) THEN
          WRITE(IFM,*)'INFORMATIONS SUR LE CALCUL DEMANDE:'
          WRITE(IFM,*)'TROP DE MODES DEMANDES POUR LE NOMBRE '//
     &               'DE DDL ACTIFS, ON EN CALCULERA LE MAXIMUM '//
     &               'A SAVOIR: ',NFREQ
        ENDIF
      ENDIF

C     --- DETERMINATION DE NBVECT (DIMENSION DU SOUS ESPACE) ---
      IF (.NOT.LQZ) THEN
        IF (NIV.GE.1)
     &    WRITE(IFM,*)'LA DIMENSION DE L''ESPACE REDUIT EST : ',NBVECT
        IF (NBVEC2.NE.0) THEN
          ICOEF = NBVEC2
        ELSE
          IF (METHOD.EQ.'JACOBI') THEN
            ICOEF = 2
          ELSE IF (METHOD.EQ.'TRI_DIAG') THEN
            ICOEF = 4
          ELSE IF (METHOD.EQ.'SORENSEN') THEN
            ICOEF = 2
          ENDIF
        ENDIF
        IF (NBVECT.LT.NFREQ) THEN
          IF (METHOD.EQ.'JACOBI') THEN
            NBVECT = MIN(MIN(7+NFREQ,ICOEF*NFREQ),NEQACT)
          ELSE IF (METHOD.EQ.'TRI_DIAG') THEN
            NBVECT = MIN(MAX(7+NFREQ,ICOEF*NFREQ),NEQACT)
          ELSE IF (METHOD.EQ.'SORENSEN') THEN
            NBVECT = MIN(MAX(3+NFREQ,ICOEF*NFREQ),NEQACT)
          ENDIF
          IF (NIV .GE. 1) THEN
            WRITE(IFM,*)'ELLE EST INFERIEURE AU NOMBRE '//
     &                      'DE MODES, ON LA PREND EGALE A ',NBVECT
            WRITE(IFM,*)
          ENDIF
        ELSE
          IF (NBVECT.GT.NEQACT) THEN
            NBVECT = NEQACT
            IF (NIV .GE. 1) THEN
              WRITE(IFM,*) 'ELLE EST SUPERIEURE AU'//
     &       ' NOMBRE DE DDL ACTIFS, ON LA RAMENE A CE NOMBRE ',NBVECT
              WRITE(IFM,*)
            ENDIF
          ENDIF
        ENDIF
      ENDIF

C     --- TRAITEMENT SPECIFIQUE A SORENSEN ---
      IF ((METHOD.EQ.'SORENSEN').AND.(NBVECT-NFREQ.LE.2)) THEN
        IF (NFREQ.GT.(NEQACT+2)) THEN
CC        DIMINUTION FORCEE DE NFREQ
          NFREQ=NEQACT-2
        ENDIF
CC      AUGMENTATION FORCEE DE NBVECT
        NBVECT = NFREQ + 2
      ENDIF

C     --- TRAITEMENT SPECIFIQUE A QZ ---
C     AVEC QZ ON A PAS D'ESPACE DE PROJECTION, IL FAUT DONC AFFECTER
C     NBVECT EN DUR
      IF (LQZ) NBVECT=NEQ

C     --- CORRECTION DE NBVECT DANS LE CAS QUADRATIQUE
      IF (LC) THEN
        NBVECT = 2*NBVECT
        NFREQ = 2*NFREQ
        CALL U2MESS('I','ALGELINE2_75')
      ENDIF


C     ------------------------------------------------------------------
C     --------------  ALLOCATION DES ZONES DE TRAVAIL   ----------------
C     ------------------------------------------------------------------
C     ------------------------------------------------------------------
C     --------------------MACRO_MODE_MECA PARALLELE (PART II)-----------
C     ------------------------------------------------------------------
C     --- REDIMENSIONNEMENT DES BUFFERS DE COM
C     ------------------------------------------------------------------
      NBVECG=-9999
      NFREQG=-9999
      IF (LCOMOD) THEN
C       --- ON REMET LE COM WORLD POUR COMMUNIQUER NBVECT/NBFREQ
        CALL MPIEXE('AFFE_COMM_REFE',MPICOW,IBID,1,IBID)
C       --- EST-ON LE PROCESSUS MAITRE DU COM LOCAL: RANGL=0 ?
C       --- SI OUI, ON ENVOI LES BONNES VALEURS DE NBVECT/NFREQ
C       --- SUR LE COM GLOBAL MPICOW, SINON ON RENVOI ZERO POUR NE PAS
C       --- COMPTER PLUSIEURS FOIS L'INFO.
        IF (RANGL.EQ.0) THEN        
          NBVECG=NBVECT
          NFREQG=NFREQ
        ELSE
          NBVECG=0
          NFREQG=0
        ENDIF
        CALL MPICM1('MPI_SUM','I',1,IBID,NBVECG,RBID,CBID)
        CALL MPICM1('MPI_SUM','I',1,IBID,NFREQG,RBID,CBID)
C         --- ON REMET LE COM LOCAL POUR LES FACTO ET SOLVES A SUIVRE
        CALL MPIEXE('AFFE_COMM_REFE',MPICOU,IBID,1,IBID)
      ENDIF
C     ------------------------------------------------------------------

C     --- CREATION ET INITIALISATION DES SD
      IF (LCOMOD) THEN
        MXRESF = NFREQG
        IAUXR=NBPARR*NBVECG
        IAUXI=NBPARI*NBVECG
        IAUXK=NBPARK*NBVECG
      ELSE
        MXRESF = NFREQ
        IAUXR=NBPARR*NBVECT
        IAUXI=NBPARI*NBVECT
        IAUXK=NBPARK*NBVECT
      ENDIF
      CALL WKVECT('&&OP0045.RESU_I','V V I'  ,IAUXI,LRESUI)
      CALL WKVECT('&&OP0045.RESU_','V V R'   ,IAUXR,LRESUR)
      CALL WKVECT('&&OP0045.RESU_K','V V K24',IAUXK,LRESUK)
      CALL VECINT(IAUXI,INDF,ZI(LRESUI))
      CALL VECINI(IAUXR,UNDF,ZR(LRESUR))
      CALL VECINK(IAUXK,KZERO,ZK24(LRESUK))

C     --- CAS GENERALISE REEL ---
      IF (LKR.AND.(.NOT.LC).AND.(.NOT.LNS)) THEN
        IF (LCOMOD) THEN
          CALL WKVECT('&&OP0045.VECTEUR_PROPRE','V V R',NEQ*NBVECG,LVEC)
        ELSE
          CALL WKVECT('&&OP0045.VECTEUR_PROPRE','V V R',NEQ*NBVECT,LVEC)
        ENDIF
      ELSE
C     --- CAS GENERALISE COMPLEXE OU QUADRATIQUE REEL ET COMPLEXE ---
        IF (LCOMOD) CALL ASSERT(.FALSE.)
        CALL WKVECT('&&OP0045.VECTEUR_PROPRE','V V C',NEQ*NBVECT,LVEC)
      ENDIF

      IF (METHOD .EQ. 'TRI_DIAG') THEN
        CALL WKVECT('&&OP0045.MAT.DIAG'    ,'V V R',NBVECT,LDIAGR)
        CALL WKVECT('&&OP0045.MAT.SUR.DIAG','V V R',NBVECT,LSURDR)
        CALL WKVECT('&&OP0045.SIGNES'      ,'V V R',NBVECT,LSIGN)
        IF (.NOT.LC) THEN
          CALL WKVECT('&&OP0045.MAT.MOD.REDUITE','V V R',
     &                NBVECT*NBVECT,IADZ)
        ELSE
          CALL WKVECT('&&OP0045.VECT.LANCZOS','V V R',NEQ*NBVECT,IADX)
          CALL WKVECT('&&OP0045.VECTY   ','V V R',NEQ*NBVECT,IADY)
          CALL WKVECT('&&OP0045.MAT.MOD.REDUITE','V V R',
     &                2*NBVECT*NBVECT,IADZ)
          CALL WKVECT('&&OP0045.VECT_DEP.H','V V R',NEQ,IADRH)
          CALL WKVECT('&&OP0045.VECT_DEP.B','V V R',NEQ,IADRB)
        ENDIF
      ELSE IF (METHOD .EQ. 'JACOBI') THEN
         CALL WKVECT('&&OP0045.VALPRO','V V R',NBVECT,LVALPR)
      ELSE IF (LQZ) THEN
        QRN = NBVECT
        QRLWOR=8*QRN
        QRN2=QRN*QRN
        IF (TYPEQZ(1:7).EQ.'QZ_EQUI') THEN
          CALL WKVECT('&&OP0045.QRLSCALE.WORK','V V R',QRN,ILSCAL)
          CALL WKVECT('&&OP0045.QRRSCALE.WORK','V V R',QRN,IRSCAL)
          CALL WKVECT('&&OP0045.QRRCONDE.WORK','V V R',QRN,ICSCAL)
          CALL WKVECT('&&OP0045.QRRCONDV.WORK','V V R',QRN,IVSCAL)
          CALL WKVECT('&&OP0045.QRI.WORK','V V I',QRN+6,IISCAL)
          CALL WKVECT('&&OP0045.QRB.WORK','V V L',QRN,IBSCAL)
        ENDIF
        IF (LKR.AND.(.NOT.LC).AND.(.NOT.LNS)) THEN
          CALL WKVECT('&&OP0045.QZ.VALPRO','V V R',QRN,LVALPR)
          CALL WKVECT('&&OP0045.QZ.MATRICEK','V V R',QRN2,IQRN)
          CALL WKVECT('&&OP0045.QZ.MATRICEM','V V R',QRN2,LQRN)
          CALL WKVECT('&&OP0045.QZ.ALPHAR','V V R',QRN,QRAR)
          CALL WKVECT('&&OP0045.QZ.ALPHAI','V V R',QRN,QRAI)
          CALL WKVECT('&&OP0045.QZ.BETA','V V R',QRN,QRBA)
          CALL WKVECT('&&OP0045.QZ.VL','V V R',QRN,QRVL)
          CALL WKVECT('&&OP0045.QZ.WORK','V V R',QRLWOR,KQRN)
        ELSE
          IF (LC)
     &      CALL WKVECT('&&OP0045.VECT.AUC','V V C',QRN2,LAUC)
          CALL WKVECT('&&OP0045.QZ.VALPRO','V V C',QRN,LVALPR)
          CALL WKVECT('&&OP0045.QZ.MATRICEK','V V C',QRN2,IQRN)
          CALL WKVECT('&&OP0045.QZ.MATRICEM','V V C',QRN2,LQRN)
          CALL WKVECT('&&OP0045.QZ.ALPHA','V V C',QRN,QRAR)
          CALL WKVECT('&&OP0045.QZ.BETA','V V C',QRN,QRBA)
          CALL WKVECT('&&OP0045.QZ.VL','V V C',QRN,QRVL)
          CALL WKVECT('&&OP0045.QZ.WORK','V V C',QRLWOR,KQRN)
          CALL WKVECT('&&OP0045.QZ.WORKR','V V R',QRLWOR,KQRNR)
        ENDIF
        CALL JERAZO('&&OP0045.QZ.MATRICEK',QRN2,1)
        CALL JERAZO('&&OP0045.QZ.MATRICEM',QRN2,1)
      ELSE IF (METHOD .EQ. 'SORENSEN') THEN
        LONWL = 3*NBVECT**2+6*NBVECT
        CALL WKVECT('&&OP0045.SELECT','V V L',NBVECT,LSELEC)
C     --- CAS REEL GENERALISE ---
        IF (LKR.AND.(.NOT.LC).AND.(.NOT.LNS)) THEN
          CALL WKVECT('&&OP0045.RESID','V V R',NEQ,LRESID)
          CALL WKVECT('&&OP0045.VECT.WORKD','V V R',3*NEQ,LWORKD)
          CALL WKVECT('&&OP0045.VECT.WORKL','V V R',LONWL,LWORKL)
          CALL WKVECT('&&OP0045.VECT.WORKV','V V R',3*NBVECT,LWORKV)
          CALL WKVECT('&&OP0045.VAL.PRO','V V R',2*(NFREQ+1),LDSOR)
          CALL WKVECT('&&OP0045.VECT.AUX','V V R',NEQ,LAUX)
C     --- CAS COMPLEXE GENERALISE ---
        ELSE IF ((.NOT.LC).AND.(LNS.OR..NOT.LKR)) THEN
          CALL WKVECT('&&OP0045.RESID','V V C',NEQ,LRESID)
          CALL WKVECT('&&OP0045.VECT.WORKD','V V C',3*NEQ,LWORKD)
          CALL WKVECT('&&OP0045.VECT.WORKL','V V C',LONWL,LWORKL)
          CALL WKVECT('&&OP0045.VECT.WORKV','V V C',3*NBVECT,LWORKV)
          CALL WKVECT('&&OP0045.VAL.PRO','V V C',(NFREQ+1),LDSOR)
          CALL WKVECT('&&OP0045.VECT.AUX','V V C',NEQ,LAUX)
          CALL WKVECT('&&OP0045.VECT.AUR','V V R',NBVECT,LWORKR)
C     --- CAS REEL QUADRATIQUE APPROCHE REELLE OU IMAGINAIRE ---
        ELSE IF ((LKR.AND.LC).AND.(APPR.NE.'C')) THEN
          CALL WKVECT('&&OP0045.RESID','V V R',2*NEQ,LRESID)
          CALL WKVECT('&&OP0045.VECT.WORKD','V V R',6*NEQ,LWORKD)
          CALL WKVECT('&&OP0045.VECT.AUX','V V R',2*NEQ,LAUX)
          CALL WKVECT('&&OP0045.VECT.AUC','V V C',2*NEQ*(NBVECT+1),
     &     LAUC)
          CALL WKVECT('&&OP0045.VECT.AUR','V V R',2*NEQ*(NBVECT+1),
     &     LAUR)
          CALL WKVECT('&&OP0045.VECT.AUL','V V C',NEQ*(NBVECT+1),
     &     LAUL)
          CALL WKVECT('&&OP0045.VAL.PR','V V R',NBVECT+1,LDIAGR)
          CALL WKVECT('&&OP0045.VAL.PI','V V R',NBVECT+1,LSURDR)
          CALL WKVECT('&&OP0045.VAL.PRO','V V R',2*(NFREQ+1),LDSOR)
          CALL WKVECT('&&OP0045.VECT.WORKL','V V R',LONWL,LWORKL)
          CALL WKVECT('&&OP0045.VECT.WORKV','V V R',3*NBVECT,LWORKV)
C     --- CAS REEL QUADRATIQUE APPROCHE COMPLEXE ---
        ELSE IF ((LKR.AND.LC).AND.(APPR.EQ.'C')) THEN
          CALL WKVECT('&&OP0045.RESID','V V C',2*NEQ,LRESID)
          CALL WKVECT('&&OP0045.VECT.WORKD','V V C',6*NEQ,LWORKD)
          CALL WKVECT('&&OP0045.VECT.AUX','V V C',2*NEQ,LAUX)
          CALL WKVECT('&&OP0045.VECT.AUC','V V C',2*NEQ*(NBVECT+1),
     &     LAUC)
          CALL WKVECT('&&OP0045.VECT.AUR','V V R',2*NEQ*(NBVECT+1),
     &     LAUR)
          CALL WKVECT('&&OP0045.VECT.WORKL','V V C',LONWL,LWORKL)
          CALL WKVECT('&&OP0045.VECT.WORKV','V V C',3*NBVECT,LWORKV)
          CALL WKVECT('&&OP0045.VAL.PRO','V V C',2*(NFREQ+1),LDSOR)
C     --- CAS COMPLEXE QUADRATIQUE  ---
        ELSEIF ((.NOT.LKR).AND.LC) THEN
          CALL WKVECT('&&OP0045.RESID','V V C',2*NEQ,LRESID)
          CALL WKVECT('&&OP0045.VECT.WORKD','V V C',6*NEQ,LWORKD)
          CALL WKVECT('&&OP0045.VECT.WORKL','V V C',LONWL,LWORKL)
          CALL WKVECT('&&OP0045.VECT.WORKV','V V C',3*NBVECT,LWORKV)
          CALL WKVECT('&&OP0045.VAL.PRO','V V C',2*(NFREQ+1),LDSOR)
          CALL WKVECT('&&OP0045.VECT.AUX','V V C',2*NEQ,LAUX)
          CALL WKVECT('&&OP0045.VECT.AUC','V V C',2*NEQ*(NBVECT+1),
     &     LAUC)
          CALL WKVECT('&&OP0045.VECT.AUR','V V R',2*NEQ*(NBVECT+1),
     &     LAUR)
        ELSE
C ---- OPTION ILLICITE
          CALL ASSERT(.FALSE.)
        ENDIF
      ENDIF


C ---- TEST POUR VALIDER LE QUADRATIQUE INFORMATIQUEMENT
C TEST POUR SIMULER LE PB GENERALISE KU=LAMBDA*MU VIA LES CHEMINS
C INFORMATIQUE DU PB QUADRATIQUE. ON POSE C=-M ET M=0
C OBJECTIF: VALIDER LE QUADRATIQUE INFORMATIQUEMENT
C PERIMETRE: UNIQUEMENT EN SYMETRIQUE
C
C ATTENTION: CETTE PROGRAMMATION MODIFIE AMOR ET MASSE
C            ELLE NE PEUT DONC SERVIR QU'A TESTER MODE_ITER_SIMULT
C
C     LTESTQ=.FALSE.
C     IF ((LTESTQ).AND.(LC)) THEN
C       CALL JEVEUO(JEXNUM(AMOR(1:19)//'.VALM',1),'E',JVALMA)
C       CALL JEVEUO(JEXNUM(MASSE(1:19)//'.VALM',1),'E',JVALMM)
C       CALL JEVEUO(NUMEDD(1:14)//'.SMOS.SMHC','L',IHCOL)
C       CALL JEVEUO(NUMEDD(1:14)//'.SMOS.SMDI','L',IADIA)
C       IDEB=1
C       DO 35 J = 1,NEQ
C         IFIN = ZI(IADIA-1+J)
C         DO 34 I = IDEB,IFIN
C           ZR(JVALMA-1+I)=-ZR(JVALMM-1+I)
C           ZR(JVALMM-1+I)=0.D0
C  34     CONTINUE
C         IDEB = IFIN+1
C  35   CONTINUE
C     ENDIF
C     ------------------------------------------------------------------
C     ------------------------------------------------------------------
C     -------  CALCUL DES VALEURS PROPRES ET VECTEURS PROPRES   --------
C     ------------------------------------------------------------------
C     ------------------------------------------------------------------

C      IF (LCPU) THEN
C        CALL SYSTEM_CLOCK(IETFIN)
C        RETFIN=REAL(IETFIN-IETDEB)/REAL(IETRAT)
C        WRITE(IFM,*)'<OP0045> COUT PRETRAITEMENTS: ',RETFIN
C        CALL SYSTEM_CLOCK(IETDEB,IETRAT,IETMAX)
C      ENDIF
      IF (.NOT.LC) THEN

C     ------------------------------------------------------------------
C     ------------------------------------------------------------------
C     ---------------------  PROBLEME GENERALISE   ---------------------
C     ------------------------------------------------------------------
C     ------------------------------------------------------------------

        IF ((METHOD(1:8).EQ.'SORENSEN').AND.LKR.AND.(.NOT.LNS)) THEN
C     ------------------------------------------------------------------
C     -------  SORENSEN PB GENERALISE REEL SYMETRIQUE  --------
C     ------------------------------------------------------------------
          CALL VPSORN (LMASSE, LMATRA, NEQ, NBVECT, NFREQ, TOLSOR,
     &         ZR(LVEC), ZR(LRESID), ZR(LWORKD), ZR(LWORKL), LONWL,
     &         ZL(LSELEC), ZR(LDSOR), OMESHI, ZR(LAUX), ZR(LWORKV),
     &         ZI(LPROD), ZI(LDDL), NEQACT, MAXITR, IFM, NIV, PRIRAM,
     &         ALPHA,OMECOR,NCONV,FLAGE,SOLVEU)
          CALL RECTFR(NCONV,NCONV,OMESHI,NPIVOT,NBLAGR,
     &         ZR(LDSOR),NFREQ+1,ZI(LRESUI),ZR(LRESUR),MXRESF)
          CALL VPBOST (TYPRES, NCONV, NCONV, OMESHI, ZR(LDSOR),
     &         NFREQ+1, VPINF, VPMAX, PRECDC, METHOD, OMECOR)
          IF (TYPRES .EQ. 'DYNAMIQUE')
     &      CALL VPORDI(1,0,NCONV,ZR(LRESUR+MXRESF),ZR(LVEC),NEQ,
     &                  ZI(LRESUI))
          DO 37 IMET = 1,NCONV
            ZI(LRESUI-1+  MXRESF+IMET) = IZERO
            ZR(LRESUR-1+IMET) = FREQOM(ZR(LRESUR-1+MXRESF+IMET))
C           SI OPTION 'PLUS_GRANDE' : CONVERSION EN VALEUR PHYSIQUE
            IF (LPG)
     &         ZR(LRESUR-1+IMET) = +1.D0 / (QUAPI2 * ZR(LRESUR-1+IMET))
            ZR(LRESUR-1+2*MXRESF+IMET) = RZERO
            ZK24(LRESUK-1+  MXRESF+IMET) = 'SORENSEN'
 37       CONTINUE
          IF (TYPRES .NE. 'DYNAMIQUE') THEN
            CALL VPORDO(0,0,NCONV,ZR(LRESUR+MXRESF),ZR(LVEC),NEQ)
            DO 38 IMET = 1,NCONV
              ZR(LRESUR-1+IMET) = FREQOM(ZR(LRESUR-1+MXRESF+IMET))
              ZI(LRESUI-1+IMET) = IMET
 38         CONTINUE
          ENDIF
        ELSE IF ((METHOD(1:8).EQ.'SORENSEN').AND.(LNS.OR..NOT.LKR)) THEN
C     ------------------------------------------------------------------
C     -------  SORENSEN PB GENERALISE COMPLEXE OU REEL NON SYM  --------
C     ------------------------------------------------------------------
          IF (LCOMOD) CALL ASSERT(.FALSE.)
          CALL VPSORC (LMASSE, LMATRA, NEQ, NBVECT, NFREQ, TOLSOR,
     &       ZC(LVEC), ZC(LRESID), ZC(LWORKD), ZC(LWORKL), LONWL,
     &       ZL(LSELEC), ZC(LDSOR), SIGMA,
     &       ZC(LAUX), ZC(LWORKV), ZR(LWORKR),
     &       ZI(LPROD), ZI(LDDL), NEQACT, MAXITR, IFM, NIV, PRIRAM,
     &       ALPHA, NCONV, FLAGE, SOLVEU)
          NPIVOT = NBLAGR
          CALL RECTFC(NCONV, NCONV, SIGMA, NPIVOT, NBLAGR,
     &       ZC(LDSOR), NFREQ+1, ZI(LRESUI), ZR(LRESUR), NFREQ)
          CALL VPBOSC (TYPRES, NCONV, NCONV, SIGMA, ZC(LDSOR),
     &       NFREQ+1, VPINF, VPMAX, PRECDC, METHOD, OMECOR)
          DO 377 IMET = 1,NCONV
            ZI(LRESUI-1+  MXRESF+IMET) = IZERO
            ZR(LRESUR-1+IMET) = FREQOM(ZR(LRESUR-1+MXRESF+IMET))
            ZK24(LRESUK-1+  MXRESF+IMET) = 'SORENSEN'
 377      CONTINUE

        ELSE IF (LQZ.AND.LKR.AND.(.NOT.LNS)) THEN
C     ------------------------------------------------------------------
C     -------  QZ PB GENERALISE REEL SYMETRIQUE  --------
C     ------------------------------------------------------------------
          CALL VPQZLA(TYPEQZ, QRN, IQRN, LQRN, QRAR, QRAI, QRBA,
     &         QRVL, LVEC, KQRN, LVALPR, NCONV,
     &         OMECOR, KTYP, KQRNR, NEQACT, ILSCAL, IRSCAL,
     &         OPTIOF, TYPRES, OMEMIN, OMEMAX, OMESHI, ZI(LPROD), NFREQ,
     &         LMASSE, LRAIDE, LAMOR, NUMEDD, SIGMA, ICSCAL, IVSCAL,
     &         IISCAL, IBSCAL, FLAGE)
          CALL RECTFR(NCONV,NCONV,OMESHI,NPIVOT,NBLAGR,
     &         ZR(LVALPR),NFREQ,ZI(LRESUI),ZR(LRESUR),MXRESF)
          CALL VPBOST(TYPRES, NCONV, NCONV, OMESHI, ZR(LVALPR),
     &         NFREQ, VPINF, VPMAX, PRECDC, METHOD, OMECOR)
          IF (TYPRES .EQ. 'DYNAMIQUE')
     &      CALL VPORDI(1,0,NCONV,ZR(LRESUR+MXRESF),ZR(LVEC),NEQ,
     &                    ZI(LRESUI))
          DO 125 IMET = 1,NCONV
            ZI(LRESUI-1+  MXRESF+IMET) = IZERO
            ZR(LRESUR-1+IMET) = FREQOM(ZR(LRESUR-1+MXRESF+IMET))
C           SI OPTION 'PLUS_GRANDE' : CONVERSION EN VALEUR PHYSIQUE
            IF (LPG)
     &         ZR(LRESUR-1+IMET) = +1.D0 / (QUAPI2 * ZR(LRESUR-1+IMET))
            ZR(LRESUR-1+2*MXRESF+IMET) = RZERO
            ZK24(LRESUK-1+  MXRESF+IMET) = TYPEQZ
  125     CONTINUE
          IF (TYPRES .NE. 'DYNAMIQUE') THEN
            CALL VPORDO(0,0,NCONV,ZR(LRESUR+MXRESF),ZR(LVEC),NEQ)
              DO 126 IMET = 1,NCONV
                ZR(LRESUR-1+IMET) = FREQOM(ZR(LRESUR-1+MXRESF+IMET))
                ZI(LRESUI-1+IMET) = IMET
  126         CONTINUE
          ENDIF

        ELSE IF (LQZ.AND.((.NOT.LKR).OR.LNS)) THEN
C     ------------------------------------------------------------------
C     -------  QZ PB GENERALISE COMPLEXE OU REEL NON SYM  --------
C     ------------------------------------------------------------------
          IF (LCOMOD) CALL ASSERT(.FALSE.)
          CALL VPQZLA(TYPEQZ, QRN, IQRN, LQRN, QRAR, QRAI, QRBA,
     &         QRVL, LVEC, KQRN, LVALPR, NCONV,
     &         OMECOR, KTYP, KQRNR, NEQACT, ILSCAL, IRSCAL,
     &         OPTIOF, TYPRES, OMEMIN, OMEMAX, OMESHI, ZI(LPROD), NFREQ,
     &         LMASSE, LRAIDE, LAMOR, NUMEDD, SIGMA, ICSCAL, IVSCAL,
     &         IISCAL, IBSCAL, FLAGE)
          NPIVOT = NBLAGR

          CALL RECTFC(NCONV, NCONV, SIGMA, NPIVOT, NBLAGR,
     &         ZC(LVALPR), NFREQ, ZI(LRESUI), ZR(LRESUR), NFREQ)

          CALL VPBOSC(TYPRES, NCONV, NCONV, SIGMA, ZC(LVALPR),
     &         NFREQ, VPINF, VPMAX, PRECDC, METHOD, OMECOR)

          DO 127 IMET = 1,NCONV
            ZI(LRESUI-1+  MXRESF+IMET) = IZERO
            ZR(LRESUR-1+IMET) = FREQOM(ZR(LRESUR-1+MXRESF+IMET))
            ZK24(LRESUK-1+  MXRESF+IMET) = TYPEQZ
  127     CONTINUE

        ELSE IF (METHOD(1:6).EQ.'JACOBI') THEN
C     ------------------------------------------------------------------
C     -------  JACOBI PB GENERALISE REEL   --------
C     ------------------------------------------------------------------
          IF ((.NOT.LKR).OR.LNS) CALL ASSERT(.FALSE.)
          CALL SSPACE(LMTPSC,LMATRA,LMASSE,NEQ,NBVECT,NFREQ,ZI(LPROD),
     &             ITEMAX,NPERM,TOL,TOLDYN,ZR(LVEC),ZR(LVALPR),
     &             NITJAC,NITBAT,SOLVEU)
          CALL RECTFR(NFREQ,NBVECT,OMESHI,NPIVOT,NBLAGR,
     &             ZR(LVALPR),NBVECT,ZI(LRESUI),ZR(LRESUR),MXRESF)
          CALL VPBOST(TYPRES,NFREQ,NBVECT,OMESHI,ZR(LVALPR),NBVECT,
     &                  VPINF, VPMAX,PRECDC,METHOD,OMECOR)
          IF (TYPRES .EQ. 'DYNAMIQUE')
     &      CALL VPORDI (1,0,NFREQ,ZR(LRESUR+MXRESF),ZR(LVEC),NEQ,
     &                  ZI(LRESUI))

          DO 30 IMET = 1,NFREQ
            ZI(LRESUI-1+2*MXRESF+IMET) = NITBAT
            ZI(LRESUI-1+4*MXRESF+IMET) = NITJAC
            ZR(LRESUR-1+IMET) = FREQOM(ZR(LRESUR-1+MXRESF+IMET))
C           SI OPTION 'PLUS_GRANDE' : CONVERSION EN VALEUR PHYSIQUE
            IF (LPG)
     &         ZR(LRESUR-1+IMET) = +1.D0 / (QUAPI2 * ZR(LRESUR-1+IMET))
            ZR(LRESUR-1+2*MXRESF+IMET) = RZERO
            ZK24(LRESUK-1+  MXRESF+IMET) = 'BATHE_WILSON'
 30       CONTINUE
          IF (TYPRES .NE. 'DYNAMIQUE') THEN
            CALL VPORDO(0,0,NFREQ,ZR(LRESUR+MXRESF),ZR(LVEC),NEQ)
            DO 31 IMET = 1,NFREQ
              ZR(LRESUR-1+IMET) = FREQOM(ZR(LRESUR-1+MXRESF+IMET))
              ZI(LRESUI-1+IMET) = IMET
 31         CONTINUE
          ENDIF

        ELSE IF (METHOD(1:8).EQ.'TRI_DIAG') THEN
C     ------------------------------------------------------------------
C     -------  LANCZOS PB GENERALISE REEL   --------
C     ------------------------------------------------------------------
          IF ((.NOT.LKR).OR.LNS) CALL ASSERT(.FALSE.)
          IF (NSTOC .GE. NBVECT) CALL U2MESS('A','ALGELINE2_72')
          IF (NSTOC .NE. 0) THEN
            DO 26 I =1, NEQ * NSTOC
              ZR(LVEC + I - 1) = ZR(LXRIG + I -1)
 26         CONTINUE
          ENDIF
          CALL VP2INI(LMTPSC,LMASSE,LMATRA,NEQ,NBVECT,NBORTO,PRORTO,
     &                  ZI(LPROD),ZI(LDDL),ZR(LDIAGR),ZR(LSURDR),
     &                  ZR(LSIGN),ZR(LVEC),PRSUDG,NSTOC,OMESHI,SOLVEU)
          CALL VP2TRD('G',NBVECT,ZR(LDIAGR),ZR(LSURDR),ZR(LSIGN),
     &                  ZR(IADZ),NITV,NITQRM)
          CALL VPRECO(NBVECT,NEQ,ZR(IADZ),ZR(LVEC))
          CALL RECTFR(NFREQ,NBVECT,OMESHI,NPIVOT,NBLAGR,
     &             ZR(LDIAGR),NBVECT,ZI(LRESUI),ZR(LRESUR),MXRESF)
          CALL VPBOST(TYPRES,NFREQ,NBVECT,OMESHI,ZR(LDIAGR),NBVECT,
     &                  VPINF, VPMAX,PRECDC,METHOD,OMECOR)
          IF (TYPRES .EQ. 'DYNAMIQUE')
     &      CALL VPORDI (1,0,NFREQ,ZR(LRESUR+MXRESF),ZR(LVEC),NEQ,
     &                  ZI(LRESUI))
          DO 32 IMET = 1,NFREQ
            ZI(LRESUI-1+  MXRESF+IMET) = NITQRM
            ZR(LRESUR-1+IMET) = FREQOM(ZR(LRESUR-1+MXRESF+IMET))
C           SI OPTION 'PLUS_GRANDE' : CONVERSION EN VALEUR PHYSIQUE
            IF (LPG)
     &         ZR(LRESUR-1+IMET) = +1.D0 / (QUAPI2 * ZR(LRESUR-1+IMET))
            ZR(LRESUR-1+2*MXRESF+IMET) = RZERO
            ZK24(LRESUK-1+  MXRESF+IMET) = 'LANCZOS'
 32       CONTINUE
          IF (TYPRES .NE. 'DYNAMIQUE') THEN
            CALL VPORDO(0,0,NFREQ,ZR(LRESUR+MXRESF),ZR(LVEC),NEQ)
            DO 33 IMET = 1,NFREQ
              ZR(LRESUR-1+IMET) = FREQOM(ZR(LRESUR-1+MXRESF+IMET))
              ZI(LRESUI-1+IMET) = IMET
 33         CONTINUE
          ENDIF
        ENDIF

      ELSE
      
        IF (LCOMOD) CALL ASSERT(.FALSE.)

C     ------------------------------------------------------------------
C     ------------------------------------------------------------------
C     ---------------------  PROBLEME QUADRATIQUE   --------------------
C     ------------------------------------------------------------------
C     ------------------------------------------------------------------

        IF (METHOD(1:8).EQ.'TRI_DIAG') THEN
C     ------------------------------------------------------------------
C     -------  LANCZOS PB QUADRATIQUE   --------
C     ------------------------------------------------------------------
          CALL WP2INI(APPR,LMASSE,LAMOR,LRAIDE,LMATRA,LMTPSC,SIGMA,
     &                  ZR(IADRH),ZR(IADRB),OPTIOF,PRORTO,NBORTO,NBVECT,
     &                  NEQ,ZI(LPROD),ZI(LDDL),ZR(LDIAGR),ZR(LSURDR),
     &                  ZR(LSIGN),ZR(IADX),ZR(IADY),SOLVEU)
          CALL VP2TRD('Q',NBVECT,ZR(LDIAGR),ZR(LSURDR),ZR(LSIGN),
     &                  ZR(IADZ),NITV,NITQRM)
          NPIVOT = NBLAGR
          NFREQ  = NFREQ / 2
          CALL WP2VEC(APPR,OPTIOF,NFREQ,NBVECT,NEQ,SIGMA,ZR(IADX),
     &                  ZR(IADY),ZR(IADZ),2*NBVECT,ZR(LSURDR),
     &                  ZR(LDIAGR),ZC(LVEC),MXRESF,
     &                  ZI(LRESUI),ZR(LRESUR),ZI(LPROD),OMECOR)
          DO 36 IMET = 1,NFREQ
            ZI(LRESUI-1+MXRESF+IMET) = NITQRM
            ZR(LRESUR-1+IMET) = FREQOM(ZR(LRESUR-1+MXRESF+IMET))
            ZK24(LRESUK-1+MXRESF+IMET) = 'LANCZOS'
 36       CONTINUE

        ELSE IF (LQZ) THEN
C     ------------------------------------------------------------------
C     -------  QZ PB QUADRATIQUE REEL ET COMPLEXE, SYM OU NON  --------
C     ------------------------------------------------------------------
          CALL VPQZLA(TYPEQZ, QRN, IQRN, LQRN, QRAR, QRAI, QRBA,
     &         QRVL, LVEC, KQRN, LVALPR,
     &         NCONV, OMECOR, KTYP, KQRNR, NEQACT, ILSCAL, IRSCAL,
     &         OPTIOF, TYPRES, OMEMIN, OMEMAX, OMESHI, ZI(LPROD), NFREQ,
     &         LMASSE, LRAIDE, LAMOR, NUMEDD, SIGMA, ICSCAL, IVSCAL,
     &         IISCAL, IBSCAL, FLAGE)
          NFREQ=NFREQ/2
          CALL WP4VEC(NFREQ,NCONV,NEQ,SIGMA,
     &           ZC(LVALPR),ZC(LVEC),MXRESF,
     &           ZI(LRESUI),ZR(LRESUR),ZI(LPROD),ZC(LAUC),OMECOR)
          DO 578 IMET = 1,NFREQ
            ZI(LRESUI-1+MXRESF+IMET) = IZERO
            ZR(LRESUR-1+IMET) = FREQOM(ZR(LRESUR-1+MXRESF+IMET))
            ZK24(LRESUK-1+MXRESF+IMET) = TYPEQZ
 578      CONTINUE
        ELSE IF (METHOD(1:8).EQ.'SORENSEN') THEN
          IF (LKR) THEN
            IF ((APPR.EQ.'R').OR.(APPR.EQ.'I')) THEN
C     ------------------------------------------------------------------
C     -------  SORENSEN PB QUADRATIQUE REEL  SYM  --------
C     -------  APPROCHE REELLE OU IMAGINAIRE      --------
C     ------------------------------------------------------------------
              CALL WPSORN (APPR, LMASSE, LAMOR, LMATRA,
     &           NEQ, NBVECT, NFREQ, TOLSOR, ZC(LVEC), ZR(LRESID),
     &           ZR(LWORKD), ZR(LWORKL), LONWL, ZL(LSELEC), ZR(LDSOR),
     &           ZR(LSURDR),ZR(LDIAGR),
     &           SIGMA, ZR(LAUX), ZR(LWORKV), ZI(LPROD), ZI(LDDL),
     &           NEQACT,MAXITR, IFM, NIV, PRIRAM, ALPHA, NCONV, FLAGE,
     &           ZR(LAUR), ZC(LAUC), ZC(LAUL),SOLVEU)
              NFREQ = NCONV / 2
              CALL WP3VEC(APPR,OPTIOF,NFREQ,NCONV,NEQ,SIGMA,
     &          ZR(LSURDR),ZR(LDIAGR),ZC(LVEC),MXRESF,
     &          ZI(LRESUI),ZR(LRESUR),ZI(LPROD),ZC(LAUC),OMECOR)
            ELSE
C     ------------------------------------------------------------------
C     -------  SORENSEN PB QUADRATIQUE REEL,SYM OU NON   --------
C     -------  APPROCHE COMPLEXE                         --------
C     ------------------------------------------------------------------
              CALL WPSORC (LMASSE, LAMOR, LMATRA,
     &           NEQ, NBVECT, NFREQ, TOLSOR, ZC(LVEC), ZC(LRESID),
     &           ZC(LWORKD), ZC(LWORKL), LONWL, ZL(LSELEC), ZC(LDSOR),
     &           SIGMA, ZC(LAUX), ZC(LWORKV), ZI(LPROD), ZI(LDDL),
     &           NEQACT,MAXITR, IFM, NIV, PRIRAM, ALPHA, NCONV, FLAGE,
     &           ZC(LAUC),ZR(LAUR),SOLVEU)
              NFREQ = NCONV / 2
              CALL WP4VEC(NFREQ,NCONV,NEQ,SIGMA,
     &           ZC(LDSOR),ZC(LVEC),MXRESF,
     &           ZI(LRESUI),ZR(LRESUR),ZI(LPROD),ZC(LAUC),OMECOR)
            ENDIF
            DO 378 IMET = 1,NFREQ
              ZI(LRESUI-1+MXRESF+IMET) = IZERO
              ZR(LRESUR-1+IMET) = FREQOM(ZR(LRESUR-1+MXRESF+IMET))
              ZK24(LRESUK-1+MXRESF+IMET) = 'SORENSEN'
 378        CONTINUE
          ELSE
C     ------------------------------------------------------------------
C     -------  SORENSEN PB QUADRATIQUE COMPLEXE SYM  --------
C     -------  APPROCHE COMPLEXE                     --------
C     ------------------------------------------------------------------
            IF (LNS) CALL ASSERT(.FALSE.)
            CALL WPSORC (LMASSE, LAMOR, LMATRA,
     &         NEQ, NBVECT, NFREQ, TOLSOR, ZC(LVEC), ZC(LRESID),
     &         ZC(LWORKD), ZC(LWORKL), LONWL, ZL(LSELEC), ZC(LDSOR),
     &         SIGMA, ZC(LAUX), ZC(LWORKV), ZI(LPROD), ZI(LDDL),
     &         NEQACT,MAXITR, IFM, NIV, PRIRAM, ALPHA, NCONV, FLAGE,
     &         ZC(LAUC),ZR(LAUR),SOLVEU)
            NFREQ = NCONV / 2
            CALL WP5VEC(OPTIOF,NFREQ,NCONV,NEQ,ZC(LDSOR),ZC(LVEC),
     &         MXRESF,ZI(LRESUI),ZR(LRESUR),ZC(LAUC))
            DO 379 IMET = 1,NFREQ
              ZI(LRESUI-1+MXRESF+IMET) = IZERO
              ZR(LRESUR-1+IMET) = FREQOM(ZR(LRESUR-1+MXRESF+IMET))
              ZK24(LRESUK-1+MXRESF+IMET) = 'SORENSEN'
 379        CONTINUE
          ENDIF
        ENDIF
      ENDIF
C ---- NOMBRE DE MODES CONVERGES
C ---- SI LE SOLVEUR MODAL A BIEN ACHEVE SON TRAVAIL ON FAIT CETTE AFFEC
C ---- TATION SINON ON NE TIENT COMPTE QUE DES NCONV MODES REELLEMENT CV
      IF (.NOT.FLAGE) NCONV = NFREQ

C     ------------------------------------------------------------------
C     -------------------- CORRECTION : OPTION BANDE -------------------
C     ------------------------------------------------------------------

C     --- SI OPTION BANDE ON NE GARDE QUE LES FREQUENCES DANS LA BANDE
      MFREQ = NCONV
      IF (OPTIOF.EQ.'BANDE') THEN
        IF (LC.OR.LNS.OR..NOT.LKR) CALL ASSERT(.FALSE.)
        DO 110 IFREQ = MFREQ - 1,0
          IF (ZR(LRESUR+MXRESF+IFREQ).GT.OMEMAX .OR.
     &      ZR(LRESUR+MXRESF+IFREQ).LT.OMEMIN )
     &      NCONV = NCONV - 1
110     CONTINUE
        IF (MFREQ.NE.NCONV) CALL U2MESS('I','ALGELINE2_17')
      ENDIF


C      IF (LCPU) THEN
C        CALL SYSTEM_CLOCK(IETFIN)
C        RETFIN=REAL(IETFIN-IETDEB)/REAL(IETRAT)
C        WRITE(IFM,*)'<OP0045> COUT SOLVEUR MODAL + POST 1: ',RETFIN
C        CALL SYSTEM_CLOCK(IETDEB,IETRAT,IETMAX)
C      ENDIF
       
C     ------------------------------------------------------------------
C     -------------- CALCUL DES PARAMETRES GENERALISES  ----------------
C     ----------- CALCUL DE LA NORME D'ERREUR SUR LE MODE  -------------
C     ---------------- STOCKAGE DES VECTEURS PROPRES  ------------------
C     ------------------------------------------------------------------

C     --- POSITION MODALE NEGATIVE DES MODES INTERDITE
      KNEGA = 'NON'
      NPARR = NBPARR
      IF (TYPCON.EQ.'MODE_ACOU') NPARR = 7

C     ------------------------------------------------------------------
C     --------------------MACRO_MODE_MECA PARALLELE (PART III)----------
C     ------------------------------------------------------------------
      IF ((.NOT.LC).AND.LKR.AND.(.NOT.LNS)) THEN
        CALL VPPARA(MODES,TYPCON,KNEGA,LRAIDE,LMASSE,LAMOR,
     &              MXRESF,NEQ,NCONV,OMECOR,ZI(LDDL),ZI(LPROD),
     &              ZR(LVEC),CBID,NBPARI,NPARR,NBPARK,NOPARA,'    ',
     &              ZI(LRESUI),ZR(LRESUR),ZK24(LRESUK),KTYP,
     &              LCOMOD,ICOM1,ICOM2,TYPRES,NFREQG)
      ELSE
        IF (LCOMOD) CALL ASSERT(.FALSE.)
        CALL VPPARA(MODES,TYPCON,KNEGA,LRAIDE,LMASSE,LAMOR,
     &              MXRESF,NEQ,NCONV,OMECOR,ZI(LDDL),ZI(LPROD),
     &              RBID,ZC(LVEC), NBPARI, NPARR, NBPARK, NOPARA,'    ',
     &              ZI(LRESUI),ZR(LRESUR),ZK24(LRESUK),KTYP,
     &              LCOMOD,IBID,IBID,K16BID,IBID)
      ENDIF
C      IF (LCPU) THEN
C        CALL SYSTEM_CLOCK(IETFIN)
C        RETFIN=REAL(IETFIN-IETDEB)/REAL(IETRAT)
C        WRITE(IFM,*)'<OP0045> COUT VPPARA HORS COM: ',RETFIN
C        CALL SYSTEM_CLOCK(IETDEB,IETRAT,IETMAX)
C      ENDIF

C     --- IMPRESSIONS LIEES A LA METHODE ---
      CALL VPWECF (' ', TYPRES, NCONV, MXRESF, ZI(LRESUI), ZR(LRESUR),
     &  ZK24(LRESUK), LAMOR,KTYP,LNS)
      CALL TITRE

C     ------------------------------------------------------------------
C     ----------- CONTROLE DE VALIDITE DES MODES CALCULES  -------------
C     ------------------------------------------------------------------

      CALL GETVTX('VERI_MODE','STOP_ERREUR',1,IARG,1,OPTIOV,LMF)
      IF (OPTIOV.EQ.'OUI') THEN
        CTYP = 'E'
      ELSE
        CTYP = 'A'
      ENDIF

      CALL GETVR8('VERI_MODE','SEUIL',1,IARG,1,SEUIL,LMF)
      CALL GETVTX('VERI_MODE','STURM',1,IARG,1,OPTIOV,LMF)
      IF (OPTIOV.EQ.'NON') THEN
        OPTIOV = ' '
      ELSE
        OPTIOV = OPTIOF
        IF (LC.OR.(.NOT.LKR).OR.LNS) THEN
C --- POUR DEBRANCHER LE TEST DE STURM DANS VPCNTL
          OPTIOV = ' '
          VALK(1) = MATRA
          VALK(2) = MATRC
          CALL U2MESK('I','ALGELINE2_73',2,VALK)
         ENDIF
      ENDIF

      LMAT(1) = LRAIDE
      LMAT(2) = LMASSE
      LMAT(3) = LMTPSC
C --- SI ON MANIPULE DEUX MATRICES DYNAMIQUES (MATOPA/MATPSC), ON SE
C     DEBARASSE DE CELLE INUTILE (MATRICE + FACTORISEE EVENTUELLE)
C     ET DE SON EVENTUELLE OCCURENCE EXTERNE (MUMPS)
      IF ((LMTPSC.NE.LMATRA).AND.(LMATRA.NE.0))
     &  CALL DETRSD('MATR_ASSE',MATOPA)

C     ------------------------------------------------------------------
C     --------------------MACRO_MODE_MECA PARALLELE (PART IV)-----------
C     ------------------------------------------------------------------
C     --- EN CAS DE TEST DE STURM LOCAL A CHAQUE SOUS-BANDE, REMISE A
C     --- JOUR DES BORNES VIA LE COM WORLD.
C     --- PUIS ON REMET LE COMCOU POUR NE PAS GENER LES FACTOS EVENTUEL
C     --- LES DE VPCNTL.
C     ------------------------------------------------------------------
      IF (LCOMOD) THEN
        CALL MPIEXE('AFFE_COMM_REFE',MPICOW,IBID,1,IBID)
        CALL MPICM1('MPI_MIN','R',1,IBID,IBID,OMEMIN,CBID)
        CALL MPICM1('MPI_MIN','R',1,IBID,IBID,VPINF,CBID)
        CALL MPICM1('MPI_MAX','R',1,IBID,IBID,OMEMAX,CBID)
        CALL MPICM1('MPI_MAX','R',1,IBID,IBID,VPMAX,CBID)
        CALL MPIEXE('AFFE_COMM_REFE',MPICOU,IBID,1,IBID)
      ENDIF
      CALL VPCNTL
     &  (CTYP,MODES,OPTIOV,OMEMIN,OMEMAX,SEUIL,NCONV,ZI(LRESUI),
     &   LMAT,OMECOR,PRECDC,IERX,VPINF,VPMAX,ZR(LRESUR),
     &   ZR(LRESUR+3*MXRESF),ZR(LRESUR+MXRESF),TYPRES,NBLAGR,
     &   SOLVEU,NBRSS,PRECSH)
      CALL GETVTX('VERI_MODE','STOP_ERREUR',1,IARG,1,OPTIOV,LMF)

      IF ((OPTIOV.EQ.'OUI').AND.(IERX.NE.0))
     &  CALL U2MESS('F','ALGELINE2_74')

      IF (FLAGE) CALL U2MESS('F','ALGELINE5_75')
 999  CONTINUE


C     ------------------------------------------------------------------

 9999 CONTINUE
C     --- DESTRUCTION DE LA MATRICE DYNAMIQUE RESTANTE (VRAI MATPSC DIS
C     SOSSIEE DE MATOPA OU MATPSC POINTANT SUR MATOPA D'OU LA RECONSTRUC
C     TION DE NOM CI-DESSOUS
      IF (LMTPSC.NE.0) THEN
        MATPSC=ZK24(ZI(LMTPSC+1))(1:19)
        CALL DETRSD('MATR_ASSE',MATPSC)
      ENDIF

C     ------------------------------------------------------------------
C     -----------------------MACRO_MODE_MECA PARALLELE (PART V) -------
C     ------------------------------------------------------------------
C     --- AVANT DE QUITTER L'OP. ON REMET LE COM WORLD (AU CAS OU)
C     --- DESTRUCTION DES SOUS-COMMUNICATEURS EVENTUELLEMENT ASSOCIES A
C     --- UNE OCCURENCE MUMPS (APRES CELLE DE LADITE OCCURENCE)
C     ------------------------------------------------------------------
      IF (LCOMOD) THEN
        CALL MPIEXE('AFFE_COMM_REFE',MPICOW,IBID,1,IBID)
        CALL MPIEXE('MPI_COMM_FREE',MPICOU,IBID,IBID,IBID)
      ENDIF
C      IF (LCPU) THEN
C        CALL SYSTEM_CLOCK(IETFIN)
C        RETFIN=REAL(IETFIN-IETDEB)/REAL(IETRAT)
C        WRITE(IFM,*)'<OP0045> COUT POST 3: ',RETFIN
C        CALL SYSTEM_CLOCK(IETDEB,IETRAT,IETMAX)
C      ENDIF
      CALL JEDEMA()

C     FIN DE OP0045

      END
