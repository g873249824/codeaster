      SUBROUTINE TLDLG2(LMAT,NPREC,NMRIG,VEMRIG,FETI,VEINPN)
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGELINE  DATE 19/12/2012   AUTEUR PELLET J.PELLET 
C ======================================================================
C COPYRIGHT (C) 1991 - 2012  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C RESPONSABLE PELLET J.PELLET
C
      IMPLICIT NONE
      INCLUDE 'jeveux.h'
      INTEGER LMAT,NPREC,NMRIG
      CHARACTER*(*) VEMRIG,FETI,VEINPN

C
C ----------------------------------------------------------------------
C
C  RECHERCHE DE MODES DE CORPS RIGIDE PAR DECOMPOSITION DE GAUSS
C
C ----------------------------------------------------------------------
C
C
C          POUR LE PROBLEME AUX VALEURS PROPRES :
C                        (K) X = 0
C          LA MATRICE (K) EST REELLE SYMETRIQUE
C          LES VALEURS PROPRES ET LES VECTEURS PROPRES SONT REELS
C          ON DECOMPOSE (K) SOUS LA FORME
C                        (  KEE   KER  )
C                        (  TKER  KRR  )
C          AVEC DIM DE KRR = NOMBRE DE MODES DE CORPS RIGIDE DE (K)
C          ET KEE INVERSIBLE
C          LES MODES DE CORPS RIGIDE SONT LES VECTEURS DE LA MATRICE
C                   (  KEE(-1)KER  )
C                   (     -ID(R)    )
C          ET OBTENUS AVEC DES ROUTINES DEVELOPPPEES POUR TRAITER LES
C          BLOCAGES CINEMATIQUES
C
C IN  LMAT : DESCRIPTEUR DE LA MATRICE DONT ON CHERCHE LES MODES RIGIDES
C IN  NPREC: SI DIFFERENT DE 0,NIVEAU DE PERTE DE DECIMALES A PARTIR
C            DUQUEL ON CONSIDERE QU'UN PIVOT EST NUL.SI 0, CE SERA 8
C OUT NMRIG: NOMBRE DE MODES DE CORPS RIGIDE
C IN/JXOUT : VEMRIG : NOM DE L'OBJET CONTENANT LES MODES DE CORPS RIGIDE
C
C IN       : FETI : /' '    : ON CALCULE NMRIG ET VEMRIG
C                   /'FETI' : ON CALCULE EN PLUS :
C                             * LE VECTEUR VEINPN
C                             * LA MATRICE LMAT EST FACTORISEE APRES
C                               AVOIR "BLOQUE" LES PIVOTS NULS
C IN/JXOUT : VEINPN : VECTEUR DES INDICES DE PIVOTS NULS
C
C
      CHARACTER*8 NOMNO,NOMCMP,TYDDL,RENUM
      CHARACTER*16 METRES
      CHARACTER*14 NU
      CHARACTER*19 NOMA19,NOMB19,LIGREL,CHSOLU
      CHARACTER*24 INFOFE
      CHARACTER*40 INFOBL
      COMPLEX*16 CBID
      INTEGER NDECI,ISINGU,NOM,NEQ,TYPVAR,TYPSYM,NAUX,MADR
      INTEGER LMATB,NDIGI2,NPIVOT,JDELG,KSING,NMRAV,JKSING
      INTEGER IFM,NIV,IEXI
      INTEGER PASS,I,IEQ,J,JEQ,KRIG,JPOMR,NADR,IBID,LXSOL
      INTEGER LCINE,IDEC1,K,IDECI,IDECJ,COMPT,IINF,LADR1,LADR2
      INTEGER JDIGS,JREFAB,JCCID,JVALE,INPN
      REAL*8 EPSB,D1,ANORM,MOYDIA
      LOGICAL LFETI
C
C ----------------------------------------------------------------------
      CALL JEMARQ()
      CALL INFNIV(IFM,NIV)

      NOM=ZI(LMAT+1)
      NEQ=ZI(LMAT+2)
      TYPVAR=ZI(LMAT+3)
      TYPSYM=ZI(LMAT+4)
      NOMA19=ZK24(NOM)(1:19)
      CALL DISMOI('F','NOM_NUME_DDL',NOMA19,'MATR_ASSE',IBID,NU,IBID)
      CALL JEVEUO(NU//'.NUME.DELG','L',JDELG)
      CALL ASSERT(NU.NE.' ')
      METRES='MULT_FRONT'
      RENUM='METIS'


C     -- FETI OR NOT FETI ?
      IF (FETI.EQ.'FETI') THEN
        LFETI=.TRUE.
        CALL WKVECT(VEINPN,'V V I',NEQ,INPN)
        CALL JEEXIN('&FETI.FINF',IEXI)
        IF (IEXI.GT.0) THEN
C         -- CAS : FETI INTERNE :
          CALL JEVEUO('&FETI.FINF','L',IINF)
          INFOFE=ZK24(IINF)
        ELSE
C         -- CAS : CAAY :
          INFOFE='FFFFFFFFFFFFFFFFFFFF'
        ENDIF
        CALL INFMUE()
        CALL INFNIV(IFM,NIV)
      ELSE
        CALL ASSERT(FETI.EQ.' ')
        LFETI=.FALSE.
        INFOFE='FFFFFFFFFFFFFFFFFFFF'
      ENDIF


C     -- MONITORING ET VERIFICATIONS :
      IF (NIV.GE.2) THEN
        WRITE (IFM,*)
     &    '<TLDLG2> RECHERCHE DE MODES RIGIDES DE LA MATRICE :',NOMA19
        WRITE (IFM,*)'<TLDLG2> DESCRIPTION DE LA MATRICE ',NOMA19,':'
      ENDIF

      IF (TYPSYM.EQ.1) THEN
        IF (NIV.GE.2)WRITE (IFM,*)'<TLDLG2> MATRICE SYMETRIQUE'
      ELSE
        IF (NIV.GE.2)WRITE (IFM,*)'<TLDLG2> MATRICE NON-SYMETRIQUE'
        CALL U2MESS('F','ALGELINE3_46')
      ENDIF
      CALL ASSERT(TYPSYM.EQ.1)

      IF (TYPVAR.EQ.1) THEN
        IF (NIV.GE.2)WRITE (IFM,*)'<TLDLG2> MATRICE REELLE'
      ELSE
        IF (NIV.GE.2)WRITE (IFM,*)'<TLDLG2> MATRICE COMPLEXE'
        CALL U2MESS('F','ALGELINE3_47')
      ENDIF
      CALL ASSERT(TYPVAR.EQ.1)

      IF (NIV.GE.2)WRITE (IFM,*)'<TLDLG2> METHODE MULT_FRONT'



C     -- PERTE DE DECIMALES POUR LAQUELLE ON CONSIDERE LE PIVOT NUL.
C        DEFAUT: 8
      IF (NPREC.EQ.0) THEN
        NDIGI2=8
      ELSE
        NDIGI2=NPREC
      ENDIF


C     -- CE VECTEUR CONTIENDRA DES 0,ET LE NUMERO,LA OU ON A BLOQUE
      CALL WKVECT('&&TLDLG2.POSMODRI','V V I ',NEQ,JPOMR)

C     -- CREATION DE LA MATRICE DE TRAVAIL (COPIE DE NOMA19)
      NOMB19='&&TLDLG2.COPIEMATA'
      CALL COPISD('MATR_ASSE','V',NOMA19,NOMB19)
      CALL MTDSCR(NOMB19)
      CALL JEVEUO(NOMB19//'.REFA','E',JREFAB)
      CALL JEVEUO(NOMB19//'.&INT','E',LMATB)

C     -- PRISE EN COMPTE DES CHARGES CINEMATIQUES :
      CALL ASSERT(ZK24(JREFAB-1+3).NE.'ELIMF')
      IF (ZK24(JREFAB-1+3).EQ.'ELIML') CALL MTMCHC(NOMB19,'ELIMF')
      CALL ASSERT(ZK24(JREFAB-1+3).NE.'ELIML')



C     -- CREATION DE L'OBJET .DIGS: DIAGONALE AVANT ET APRES
      CALL DIAGAV(NOMB19,NEQ,NEQ,TYPVAR,EPSB)
      CALL JEVEUO(NOMB19//'.DIGS','L',JDIGS)

C     -- VALEUR ABSOLUE MOYENNE DE LA DIAGONALE
      MOYDIA=0.D0
      DO 10 IEQ=1,NEQ
        MOYDIA=MOYDIA+ABS(ZR(JDIGS-1+IEQ))
   10 CONTINUE


C     -- 1. RECHERCHE DES PIVOTS NULS DE LA MATRICE :
C     ----------------------------------------------------------------
      CALL WKVECT('&&TLDLG2.KSINGU','V V I ',NEQ,JKSING)
      NMRIG=0

C     -- DEBUT BOUCLE: TANT QU'IL EXISTE DES PIVOTS NULS
   20 CONTINUE
      PASS=0
      NMRAV=NMRIG
C     -- FACTORISATION : SI NPIVOT.NE.0 ALORS KI SINGULIERE ET
C        NPIVOT CONTIENT LE NUMERO DE LIGNE DU PREMIER PIVOT .LT. EPSB
      CALL MULFR8(NOMB19,NPIVOT,NEQ,TYPSYM,EPSB,RENUM)

      IF (NPIVOT.GE.1) THEN
C       -- 1.1 LA FACT. S'EST ARRETEE SUR UN PIVOT VRAIMENT NUL
        NMRIG=NMRIG+1
        ZI(JKSING-1+NMRIG)=NPIVOT
      ELSE
C       -- 1.2 LA FACT. A PEUT ETRE CALCULE DES PIVOTS QUASI-NULS
C          POUR EVITER DE FACTORISER PLUSIEURS FOIS (COUT), ON RELEVE
C          TOUS LES PETITS PIVOTS OBTENUS.
        DO 30 IEQ=1,NEQ
          D1=ABS(ZR(JDIGS-1+IEQ)/ZR(JDIGS+NEQ-1+IEQ))
          IF (D1.GT.0.D0) THEN
            NDECI=INT(LOG10(D1))
          ELSE
            NDECI=0
          ENDIF
          IF (NDECI.GE.NDIGI2) THEN
            NMRIG=NMRIG+1
            ZI(JKSING-1+NMRIG)=IEQ
          ENDIF
   30   CONTINUE
      ENDIF

C     -- 1.3 SI ON A RENCONTRE DE NOUVEAUX PIVOTS NULS :
      DO 31, KSING=NMRAV+1,NMRIG
        PASS=1
        ISINGU=ZI(JKSING-1+KSING)
        CALL ASSERT(ISINGU.GT.0 .AND. ISINGU.LE.NEQ)
C       -- CE SERAIT BIZARRE QUE ISINGU SOIT UN DDL DE LAGRANGE :
        CALL ASSERT(ZI(JDELG-1+ISINGU).EQ.0)
        IF (LFETI) ZI(INPN-1+KSING)=ISINGU
        ZI(JPOMR-1+ISINGU)=KSING
        IF (NIV.GE.2) THEN
          WRITE (IFM,*)'<TLDLG2> PIVOT NUL A LA LIGNE ',ISINGU
          CALL RGNDAS(NU,ISINGU,NOMNO,NOMCMP,TYDDL,
     &              LIGREL,INFOBL)
          CALL ASSERT(TYDDL.EQ.'A'.OR.TYDDL.EQ.'D')
          WRITE (IFM,*)'<TLDLG2> NOEUD ',NOMNO,' CMP ',NOMCMP
        ENDIF
  31  CONTINUE

      IF (PASS.NE.0) THEN
        GOTO 40
      ELSE
        GOTO 60
      ENDIF

   40 CONTINUE

C     -- 1.3 REINITIALISATION DE B
      CALL DETRSD('MATR_ASSE',NOMB19)
      NOMB19='&&TLDLG2.COPIEMATA '
      CALL COPISD('MATR_ASSE','V',NOMA19,NOMB19)
      CALL MTDSCR(NOMB19)
C     -- BLOCAGE 'CINEMATIQUE' DU/DES DDL A PIVOT NUL
      CALL JEVEUO(NOMB19//'.REFA','E',JREFAB)
      IF (ZK24(JREFAB-1+3).EQ.'ELIMF') CALL MTMCHC(NOMB19,'ELIML')
      CALL ASSERT(ZK24(JREFAB-1+3).NE.'ELIMF')
      IF (ZK24(JREFAB-1+3).EQ.'ELIML') THEN
        CALL JEVEUO(NOMB19//'.CCID','E',JCCID)
      ELSE
        CALL WKVECT(NOMB19//'.CCID','V V I',NEQ+1,JCCID)
      ENDIF
      DO 50,IEQ=1,NEQ
        IF (ZI(JPOMR-1+IEQ).GT.0)ZI(JCCID-1+IEQ)=1
   50 CONTINUE
      ZI(JCCID-1+NEQ+1)=NMRIG
      ZK24(JREFAB-1+3)='ELIML'
      CALL MTMCHC(NOMB19,'ELIMF')
      CALL DIAGAV(NOMB19,NEQ,NEQ,TYPVAR,EPSB)
      CALL JEVEUO(NOMB19//'.DIGS','L',JDIGS)
      GOTO 20

C     -- FIN RECHERCHE DES PIVOTS NULS :
   60 CONTINUE


C     -- 1.4 : FIN DE BOUCLE RECHERCHE NMRIG :
      CALL JEDETR('&&TLDLG2.KSINGU')
      IF (NIV.GE.1) THEN
        WRITE (IFM,9000)
        WRITE (IFM,*)'<TLDLG2> NB DE MODES DE CORPS RIGIDES'//
     &    ' DETECTES: ',NMRIG
      ENDIF
      IF (NMRIG.GE.7) CALL U2MESS('A','ALGELINE3_49')

      IF (LFETI) THEN
C       SI FETI: COPIE DE LA FACTORISEE TEMPORAIRE NOMB19.VALF
C       DANS LA MATRICE INITIALE (NOMA19.VALF)
C       ATTENTION : IL Y A UNE FORME D'INCOHERENCE :
C                   A.VALF N'EST PAS VRAIMENT LA FACTORISEE DE A
        CALL JEEXIN(NOMA19//'.VALF',IBID)
        IF (IBID.GT.0) THEN
          CALL U2MESK('F','ALGELINE3_50',1,NOMA19)
        ELSE
          CALL JEDUPO(NOMB19//'.VALF','V',NOMA19//'.VALF',.FALSE.)
        ENDIF
      ENDIF



C     -- 2. CALCUL DES MODES DE CORPS RIGIDE :
C     -----------------------------------------------------------------
      IF (NMRIG.NE.0) THEN
        CALL MTDSCR(NOMB19)
        CALL JEVEUO(NOMB19//'.&INT','E',LMATB)

C       CONSTRUCTION DES SECONDS MEMBRES DU TYPE (KER -ID(R)) DANS
C       ZR(LXSOL, LXSOL+NEQ .... LXSOL+(NMRIG-1)*NEQ) POUR R VARIANT
C       DE 1 A NMRIG

        CALL WKVECT(VEMRIG,'V V R ',NEQ*NMRIG,LXSOL)
        CALL WKVECT('&&TLDLG2.TLSECCIN','V V R ',NEQ*NMRIG,LCINE)

C       -- REMPLISSAGE POUR AVOIR FI=0 ET U0=-1 (NOTATION CSMBGG)
        KRIG=1
        DO 70 JEQ=1,NEQ
          IF (ZI(JPOMR+JEQ-1).NE.0) THEN
            ZR(LCINE+(KRIG-1)*NEQ+JEQ-1)=-1.D0
            KRIG=KRIG+1
          ENDIF
   70   CONTINUE

        DO 80 KRIG=1,NMRIG
C       -----------------------------------------------------------
C         CSMBGG : CALCUL DE LA CONTRIBUTION AU SECOND MEMBRE DES
C         DDLS IMPOSES LORSQU'ILS SONT TRAITEES PAR ELIMINATION :
C                ! K    K   ! (ON VEUT ELIMINER LES DDLS R)
C         K  =   !  EE   ER !
C                !  T       !
C                ! K    K   !
C                !  RE   RR !
C
C         LE TRAITEMENT PAR ELIMINATION CONSISTE A RESOUDRE :
C           ! K    0 !   ! X  !   ! FI  -K  U0!
C           !  EE    !   !  E !   !      ER   !
C           !        ! * !    ! = !           !
C           ! 0    1 !   ! X  !   ! 0     U0  !
C           !        !   !  R !   !           !

          CALL CSMBGG(LMATB,ZR(LXSOL+(KRIG-1)*NEQ),
     &                ZR(LCINE+(KRIG-1)*NEQ),CBID,CBID,'R')
   80   CONTINUE

C       -- REMARQUE : ON N'A PAS BESOIN D'UTILISER MRCONL CAR
C          LES DDLS DUALISES SONT MIS A 0. (ALPHA*0=0 !)
        CALL RLDLG3(METRES,LMATB,ZR(LXSOL),CBID,NMRIG)
      ENDIF
      CALL DETRSD('MATR_ASSE',NOMB19)



C       -- 3. IMPRESSION EVENTUELLE DES MODES DE CORPS RIGIDES :
C       ----------------------------------------------------------
      IF (LFETI .AND. (INFOFE(6:6).EQ.'X')) THEN
        CHSOLU='&&TLDLG2.CHSOLU'
        CALL VTCREM(CHSOLU,NOMA19,'V','R')
        CALL JEVEUO(CHSOLU//'.VALE','E',JVALE)
        DO 81,KRIG=1,NMRIG
          DO 91 J=1,NEQ
            ZR(JVALE-1+J)=ZR(LXSOL+(KRIG-1)*NEQ-1+J)
 91       CONTINUE
          WRITE (IFM,*)'<TLDLG2> MODE RIGIDE NUMERO : ',KRIG
          CALL IMPRSD('CHAMP',CHSOLU,IFM,'TLDLG2 MODE_RIG')
 81     CONTINUE
        CALL DETRSD('CHAM_NO',CHSOLU)
      ENDIF



C       -- 4. VERIFICATION EVENTUELLE DES MODES DE CORPS RIGIDES :
C       ----------------------------------------------------------
      IF (LFETI .AND. (INFOFE(6:6).EQ.'X')) THEN
        IF (NMRIG.NE.0) THEN
          WRITE (IFM,*)'<TLDLG2> MOYENNE DES TERMES DIAGONAUX ',
     &      MOYDIA/NEQ
C         NORME L1(K*UI) / NORME L1(KII)
          NAUX=NEQ*NMRIG
          CALL WKVECT('&&TLDLG2.VERIFMCR','V V R',NAUX,LADR1)
          CALL MRMULT('ZERO',LMAT,ZR(LXSOL),ZR(LADR1),NMRIG,.FALSE.)
          DO 100 I=1,NMRIG
            ANORM=0.D0
            DO 90 J=1,NEQ
              ANORM=ANORM+ABS(ZR(LADR1+(I-1)*NMRIG+J-1))
   90       CONTINUE
            ANORM=100.D0*ANORM/MOYDIA
            WRITE (IFM,*)'<TLDLG2> TEST K*MCR(J)/K (EN %) ',I,ANORM
  100     CONTINUE
          CALL JEDETR('&&TLDLG2.VERIFMCR')
        ENDIF
      ENDIF



C     -- 5. VERIFICATION EVENTUELLE DE MOORE-PENROSE :
C     -------------------------------------------------
      IF (LFETI .AND. (INFOFE(6:6).EQ.'T')) THEN
        INFOFE(9:9)='F'
        IF (INFOFE(9:9).EQ.'T') THEN
C         VERIF CONDITION DE MOORE-PENROSE
C         CALCUL DE (KIDD)- * FIDD PAR MULT_FRONT
C         A RESERVER AU DEVELOPPEUR POUR LA MISE AU POINT
C         CAR TRES COUTEUX EN MEMOIRE ET CPU
C         2 OBJETS SONT DE TAILLE NEQ * NEQ !!
          NAUX=NEQ*NEQ
          CALL WKVECT('&&TLDLG2.VERIFPSI1','V V R',NAUX,LADR2)
          CALL WKVECT('&&TLDLG2.VERIFPSI2','V V R',NAUX,MADR)
          NAUX=NEQ*(NEQ+1)/2
          CALL WKVECT('&&TLDLG2.VERIFPSI3','V V R',NAUX,NADR)
          CALL COPMA2(NOMA19,ZR(LADR2),ZR(MADR))
          CALL RLTFR8(NOMA19,NEQ,ZR(MADR),NEQ,TYPSYM)
          IF (NMRIG.NE.0) THEN
            DO 120 I=1,NMRIG
              IDEC1=ZI(INPN-1+I)
              DO 110 J=1,NEQ
                ZR(MADR-1+(J-1)*NEQ+IDEC1)=0.D0
  110         CONTINUE
  120       CONTINUE
          ENDIF

          IDEC1=NADR
          ANORM=0.D0
          COMPT=0
          DO 150 J=1,NEQ
            IDECJ=(J-1)*NEQ+MADR-1
            DO 140 I=J,NEQ
              IDECI=LADR2-1+I
              MOYDIA=ZR(IDECI+(J-1)*NEQ)
              ZR(IDEC1)=-MOYDIA
              DO 130 K=1,NEQ
                ZR(IDEC1)=ZR(IDEC1)+ZR(IDECI+(K-1)*NEQ)*ZR(IDECJ+K)
  130         CONTINUE
              IF (ABS(MOYDIA).NE.0.D0) THEN
                ANORM=ANORM+ABS(ZR(IDEC1)/MOYDIA)
                COMPT=COMPT+1
              ENDIF

              IDEC1=IDEC1+1
  140       CONTINUE
  150     CONTINUE
          ANORM=100.D0*ANORM/COMPT
          WRITE (IFM,*)'<TLDLG2> TEST K*(K)+*K-K/K (EN %) ',ANORM
          WRITE (IFM,*)'<TLDLG2> NBRE TERMES TOTAUX/NEGLIGES ',NAUX,
     &      NAUX-COMPT
          CALL JEDETR('&&TLDLG2.VERIFPSI1')
          CALL JEDETR('&&TLDLG2.VERIFPSI2')
          CALL JEDETR('&&TLDLG2.VERIFPSI3')
        ENDIF
      ENDIF


C     -- NETTOYAGE ET SORTIE :
C     -------------------------
      IF (NIV.GE.1)WRITE (IFM,9010)
      CALL JEDETR('&&TLDLG2.POSMODRI')
      CALL JEDETR('&&TLDLG2.TLSECCIN')
      IF (LFETI) CALL INFBAV()
      CALL JEDEMA()

 9000 FORMAT (72X,/)
 9010 FORMAT (72('-'),/)
      END
