      SUBROUTINE CBVAL2(NBCOMB,TYPCST,CONST,LMAT,TYPRES,LRES,DDLEXC)
      IMPLICIT NONE
      INCLUDE 'jeveux.h'

      CHARACTER*32 JEXNUM
      INTEGER NBCOMB,LMAT(*),LRES
      CHARACTER*(*) TYPRES,DDLEXC,TYPCST(*)
      REAL*8 CONST(*)
C     ------------------------------------------------------------------
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGELINE  DATE 09/11/2012   AUTEUR DELMAS J.DELMAS 
C ======================================================================
C COPYRIGHT (C) 1991 - 2012  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.

C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.

C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C     COMBINAISON LINEAIRE DES .VALM DES MATRICES
C       *  LES MATRICES SONT SUPPOSEES AVOIR LE MEME TYPE DE STOCKAGE
C          (MORSE) MAIS ELLES ONT DES PROFILS DIFFERENTS
C       *  POUR L'INSTANT ON NE TRAITE QUE LE CAS DE MATRICES
C          SYMETRIQUES, REELLES.
C       *  LES SCALAIRES SONT PRIS REELS POUR L'INSTANT
C     -----------------------------------------------------------------
C IN  I  NBCOMB = NOMBRE DE MATRICES A COMBINER
C IN  R  CONST  = TABLEAU DE R*8    DES COEFICIENTS
C IN  I  LMAT = TABLEAU DES POINTEURS DES MATRICES
C IN  K* TYPRES = TYPE DES MATRICES   (R)
C IN  I  LRES = POINTEUR DE MATRICE RESULTAT
C IN  K* DDLEXC = NOM DES DDLS A EXCLURE (CONCRETEMENT IL S'AGIT
C                                         DES LAGRANGE)

C     -----------------------------------------------------------------

      LOGICAL SYMR,SYMI

C     -----------------------------------------------------------------
      INTEGER LGBLOC
      CHARACTER*1 CLAS,TYPMAT
      CHARACTER*8 NOMDDL
      CHARACTER*14 NUMR,NUMI
      CHARACTER*19 MATRES,MATI
      CHARACTER*24 VALMI,VALMR
      INTEGER NEQ,IBID,MXDDL,IERD,LDDL,JREFAI,JREFAR,JSMHCR,JSMDIR
      INTEGER ICONST,IMAT,IER,JSMHCI,JSMDII,JVLMI1,JVLMR1,K
      INTEGER JVLMI2,JVLMR2
      REAL*8 ZERO
C     -----------------------------------------------------------------
      CALL JEMARQ()
      ZERO = 0.D0

      NOMDDL = DDLEXC
      MATRES = ZK24(ZI(LRES+1))
      CALL ASSERT(TYPRES.EQ.'R' .OR. TYPRES.EQ.'C')
      NEQ = ZI(LRES+2)
      VALMR = MATRES//'.VALM'
      LGBLOC = ZI(LRES+14)
      CALL JELIRA(MATRES//'.REFA','CLAS',IBID,CLAS)
      CALL JEVEUO(MATRES//'.REFA','L',JREFAR)
      CALL ASSERT(ZK24(JREFAR-1+9) (1:1).EQ.'M')
      SYMR = ZK24(JREFAR-1+9) .EQ. 'MS'

      MXDDL = 1
      CALL DISMOI('F','NOM_NUME_DDL',MATRES,'MATR_ASSE',IBID,NUMR,IERD)
      CALL WKVECT('&&CBVAL2','V V I',NEQ*MXDDL,LDDL)
      CALL PTEDDL('NUME_DDL',NUMR,MXDDL,NOMDDL,NEQ,ZI(LDDL))


      CALL JEVEUO(NUMR//'.SMOS.SMHC','L',JSMHCR)
      CALL JEVEUO(NUMR//'.SMOS.SMDI','L',JSMDIR)
      CALL JEVEUO(JEXNUM(VALMR,1),'E',JVLMR1)
      IF (TYPRES(1:1).EQ.'R') THEN
        DO 10 K = 1,LGBLOC
          ZR(JVLMR1-1+K) = ZERO
   10   CONTINUE
        IF (.NOT.SYMR) THEN
          CALL JEVEUO(JEXNUM(VALMR,2),'E',JVLMR2)
          DO 20 K = 1,LGBLOC
            ZR(JVLMR2-1+K) = ZERO
   20     CONTINUE
        END IF

      ELSE
        CALL U2MESS('F','ALGELINE_5')
      END IF


C --- BOUCLE SUR LES MATRICES A COMBINER :
C     ----------------------------------
      ICONST = 1
      DO 30 IMAT = 1,NBCOMB
        CALL ASSERT(TYPCST(IMAT).EQ.'R')
        MATI = ZK24(ZI(LMAT(IMAT)+1))
        CALL DISMOI('F','NOM_NUME_DDL',MATI,'MATR_ASSE',IBID,NUMI,IER)
        CALL JEVEUO(NUMI//'.SMOS.SMHC','L',JSMHCI)
        CALL JEVEUO(NUMI//'.SMOS.SMDI','L',JSMDII)
        CALL JEVEUO(MATI//'.REFA','L',JREFAI)
        VALMI = MATI//'.VALM'
        SYMI = ZK24(JREFAI-1+9) .EQ. 'MS'
        IF (.NOT.SYMI) CALL ASSERT(.NOT.SYMR)
        CALL JELIRA(VALMI,'TYPE',IBID,TYPMAT)
        CALL JEVEUO(JEXNUM(VALMI,1),'L',JVLMI1)
        CALL ASSERT(TYPMAT.EQ.'R')
        IF (.NOT.SYMI) CALL JEVEUO(JEXNUM(VALMI,2),'L',JVLMI2)

        IF (TYPRES(1:1).EQ.'R') THEN
          IF (TYPMAT.EQ.'R') THEN
            CALL RRSSM2(NEQ,ZI4(JSMHCR),ZI4(JSMHCI),ZI(JSMDIR),
     &         ZI(JSMDII),ZI(LDDL),CONST(ICONST),ZR(JVLMI1),ZR(JVLMR1))
            IF (.NOT.SYMR) THEN
              IF (.NOT.SYMI) THEN
                CALL RRSSM2(NEQ,ZI4(JSMHCR),ZI4(JSMHCI),ZI(JSMDIR),
     &                      ZI(JSMDII),ZI(LDDL),CONST(ICONST),
     &                      ZR(JVLMI2),ZR(JVLMR2))

              ELSE
                CALL RRSSM2(NEQ,ZI4(JSMHCR),ZI4(JSMHCI),ZI(JSMDIR),
     &                      ZI(JSMDII),ZI(LDDL),CONST(ICONST),
     &                      ZR(JVLMI1),ZR(JVLMR2))
              END IF
            END IF
          END IF
        END IF
        ICONST = ICONST + 1
        CALL JELIBE(JEXNUM(VALMI,1))
        IF (.NOT.SYMI) CALL JELIBE(JEXNUM(VALMI,2))
   30 CONTINUE

      CALL JEDETR('&&CBVAL2')

      CALL JEDEMA()

      END
