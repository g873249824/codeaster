      SUBROUTINE XPRCNU(NOMA,CNXINV,BASE,VCN,GRLR,LCMIN)
      IMPLICIT NONE

      CHARACTER*8    NOMA
      CHARACTER*19   CNXINV
      CHARACTER*24   VCN,GRLR
      CHARACTER*1    BASE
      REAL*8         LCMIN

C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 08/03/2011   AUTEUR MASSIN P.MASSIN 
C ======================================================================
C COPYRIGHT (C) 1991 - 2011  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C RESPONSABLE GENIAUT S.GENIAUT
C TOLE CRP_20

C     ------------------------------------------------------------------
C
C       XPRCNU   : X-FEM PROPAGATION : CREATION DE LA TABLE DE CONNEXION
C       ------     -     --                                    -
C                                       DES NODES POUR LA METHODE UPWIND
C                                           -                     -
C
C    DANS LE CADRE DE LA PROPAGATION DE FISSURE XFEM AVEC LA METHODE
C    UPWIND, ON CALCULE LA BASE LOCALE DE LA GRILLE UTILISEE ET ON
C    ARRANGE LES NOEUDS SELON LA DIRECTION DES AXES DE CETTE BASE
C
C    ENTREE
C            NOMA   = NOM DU MAILLAGE SUR LEQUEL LES LEVEL SETS SONT
C                     STOCKES
C            CNXINV = CONNECTIVITE INVERSEE DU MAILLAGE NOMA
C            BASE   = 'V' OU 'G'. BASE JEVEUX SUR LAQUELLE LES OBJETS
C                     VCN, VCND ET REFJEV (VOIR CI-DESSOUS) SERONT
C                     CREES. DANS LE CAS OU LE MAILLAGE NOMA EST UNE
C                     GRILLE AUXILIAIRE, C'EST BIEN DE UTILISER LA BASE
C                     GLOBALE POUR LES ATTACHER A LA SD DU MODELE DE
C                     LA GRILLE.
C            VCN    = NOM DE L'OBJET JEVEUX OU STOCKER LA TABLE (VOIR
C                     CI-DESSOUS DANS LE CODE POUR LA DESCRIPTION DE LA
C                     TABLE)
C            GRLR   = NOM DE L'OBJET JEVEUX OU STOCKER LA TABLE VCND,
C                     LA BASE LOCALE DE LA GRILLE ET LA LONGUEUER DE
C                     LA PLUS PETITE ARETE DE LA GRILLE (VOIR SD_GRILLE
C                     ET CI-DESSOUS DANS LE CODE POUR UNE DESCRIPTION DE
C                     CES OBJETS)
C
C    SORTIE
C            VCN    = OBJET CREE
C            GRLR   = OBJET CREE
C
C     ------------------------------------------------------------------

C     ----- DEBUT COMMUNS NORMALISES  JEVEUX  --------------------------
      INTEGER          ZI
      COMMON  /IVARJE/ ZI(1)
      REAL*8           ZR
      COMMON  /RVARJE/ ZR(1)
      COMPLEX*16       ZC
      COMMON  /CVARJE/ ZC(1)
      LOGICAL          ZL
      COMMON  /LVARJE/ ZL(1)
      CHARACTER*8      ZK8
      CHARACTER*16             ZK16
      CHARACTER*24                      ZK24
      CHARACTER*32                               ZK32
      CHARACTER*80                                        ZK80
      COMMON  /KVARJE/ ZK8(1), ZK16(1), ZK24(1), ZK32(1), ZK80(1)
      CHARACTER*32    JEXNUM,JEXATR,JEXNOM
C     -----  FIN  COMMUNS NORMALISES  JEVEUX  --------------------------

C     MESH INFORMATION RETREIVING AND GENERAL PURPOSE VARIABLES
      INTEGER          NBNO,NBMA,JCOOR,JCONX1,JCONX2,JMAI,ITYPMA
      INTEGER          IFM,NIV,IRET,NDIM,NDIME,DIMUNS,JTMDIM
      CHARACTER*8      TYPMA,K8B
      INTEGER          I,J

C     LOCAL REFERENCE SYSTEM
      REAL*8           LOCREF(3,3),NODREF(4,3),MODVEC,PARTOL
      PARAMETER        (PARTOL=1.D-2)
      INTEGER          ELMORI,NOTPAR,JREF

C     CREATION OF THE CONNECTION TABLE OF THE NODES
      INTEGER          JGRLR,JVCN,JVCND,IBID
      INTEGER          NODE,NODEPS,NODEDG,NBELNO,ELNO,JELNO,ELNOL
      REAL*8           NODXYZ(2,3), ABSXYZ(3), LOCXYZ(3),R8PREM,R8MAEM
      INTEGER          NODCON(3),ELDEF(8),NOCUR,ORPH,UNSUPP,AR(12,3),
     &                 NBAR,MAXEDG(3),NUMNOD(3)

C-----------------------------------------------------------------------
C     DEBUT
C-----------------------------------------------------------------------
      CALL JEMARQ()
      CALL INFMAJ()
      CALL INFNIV(IFM,NIV)

C SET THE NUMBER OF EDGES OF THE ELEMENT SHARING ONE NODE FOR 2D MODELS
      MAXEDG(2) = 2
C SET THE NUMBER OF EDGES OF THE ELEMENT SHARING ONE NODE FOR 3D MODELS
      MAXEDG(3) = 3

C SET THE NUMBER OF NODES IN THE SUPPORTED 2D ELEMENTS
      NUMNOD(2) = 4
C SET THE NUMBER OF NODES IN THE SUPPORTED 3D ELEMENTS
      NUMNOD(3) = 8

C SET THE MAXIMUM DIMENSION OF THE UNSUPPORTED ELEMENTS
      DIMUNS = 0

C RETRIEVE THE NUMBER OF NODES AND ELEMENTS IN THE MESH
      CALL DISMOI('F','NB_NO_MAILLA',NOMA,'MAILLAGE',NBNO,K8B,IRET)
      CALL DISMOI('F','NB_MA_MAILLA',NOMA,'MAILLAGE',NBMA,K8B,IRET)
C RETRIEVE THE COORDINATES OF THE NODES
C                12345678901234567890
      CALL JEVEUO(NOMA//'.COORDO    .VALE','L',JCOOR)
C RETRIEVE THE DEFINITION OF THE ELEMENTS IN TERMS OF NODES
      CALL JEVEUO(NOMA//'.CONNEX','L',JCONX1)
      CALL JEVEUO(JEXATR(NOMA//'.CONNEX','LONCUM'),'L',JCONX2)
C RETRIEVE THE TYPE OF EACH ELEMENT IN THE MESH
      CALL JEVEUO(NOMA//'.TYPMAIL','L',JMAI)
C RETRIEVE THE DIMENSIONS OF THE EXISTING ELEMENTS
      CALL JEVEUO('&CATA.TM.TMDIM','L',JTMDIM)
C RETRIEVE THE DIMENSION OF THE PROBLEM (2D AND 3D ARE SUPPORTED)
      CALL DISMOI('F','DIM_GEOM',NOMA,'MAILLAGE',NDIM,K8B,IRET)

C     CREATE THE JEVEUX OBJECTS WHERE THE RESULTS WILL BE STORED
      CALL WKVECT(VCN,BASE//' V I',6*NBNO,JVCN)
      CALL WKVECT(GRLR,BASE//' V R',10+6*NBNO,JGRLR)

C     SET THE POINTERS FOR THE DIFFERENT PARTS OF THE GRLR OBJECT
      JREF  = JGRLR+1
      JVCND = JGRLR+10

C ----------------------------------------------------------------------
C FIRST OF ALL, THE LOCAL REFERENCE SYSTEM FOR THE GRID MUST BE
C CALCULATED. IT WILL BE USED BELOW FOR THE NODE ORDERING TASK.
C ----------------------------------------------------------------------

      ELMORI = 0

C     SEARCH THE FIRST SUPPORTED ELEMENT IN THE MESH
      DO 1010 I=1,NBMA
         ITYPMA=ZI(JMAI-1+I)
         CALL JENUNO(JEXNUM('&CATA.TM.NOMTM',ITYPMA),TYPMA)
         IF (((NDIM.EQ.2).AND.(TYPMA(1:5).EQ.'QUAD4')).OR.
     &       ((NDIM.EQ.3).AND.(TYPMA(1:5).EQ.'HEXA8'))) THEN
             ELMORI = I
             GOTO 1000
         ENDIF
1010  CONTINUE

1000  CONTINUE

C     CHECK IF A SUPPORTED ELEMENT HAS BEEN FOUND
      IF (ELMORI.EQ.0) THEN
         CALL U2MESS('F','XFEM2_54')
      ENDIF

C     RETRIEVE THE NODE CONNECTION OF ALL THE EDGES OF THE FIRST
C     SUPPORTED ELEMENT
      CALL CONARE(TYPMA,AR,NBAR)

C     RETRIEVE THE TWO (2D CASE) OR THREE (3D CASE) EDGES THAT SHARE THE
C     NODE AT THE ORIGIN OF THE LOCAL REFERENCE SYSTEM
      J=0
      DO 1100 I=1,NBAR
         IF (AR(I,1).EQ.1) THEN
            J=J+1
C           THE NUMBER OF EDGES SHARING THE NODE SHOULD ALWAYS BE
C           LOWER OR EQUAL TO THE MAXIMUM VALUE EXPECTED
            CALL ASSERT(J.LE.MAXEDG(NDIM))
            NODCON(J) = AR(I,2)
         ENDIF

         IF(AR(I,2).EQ.1) THEN
            J = J+1
C           THE NUMBER OF EDGES SHARING THE NODE SHOULD ALWAYS BE
C           LOWER OR EQUAL TO THE MAXIMUM VALUE EXPECTED
            CALL ASSERT(J.LE.MAXEDG(NDIM))
            NODCON(J) = AR(I,1)
         ENDIF
1100  CONTINUE

C     THE NUMBER OF EDGES RETRIEVED SHOULD ALWAYS BE EQUAL TO
C     THE NUMBER OF THE EXPECTED EDGES
      CALL ASSERT(J.EQ.MAXEDG(NDIM))

C     RETRIEVE THE COORDINATES OF THE ORIGIN
      J = ZI(JCONX1-1+ZI(JCONX2-1+ELMORI)+1-1)
      NODREF(1,1) = ZR(JCOOR-1+3*(J-1)+1)
      NODREF(1,2) = ZR(JCOOR-1+3*(J-1)+2)
      NODREF(1,3) = ZR(JCOOR-1+3*(J-1)+3)

C     RETRIEVE THE COORDINATES OF THE OTHER NODES DEFINING THE LOCAL
C     AXES (Xl,Yl,Zl)
      DO 1200 I=1,NDIM
         J = ZI(JCONX1-1+ZI(JCONX2-1+ELMORI)+NODCON(I)-1)
         NODREF(I+1,1) = ZR(JCOOR-1+3*(J-1)+1)
         NODREF(I+1,2) = ZR(JCOOR-1+3*(J-1)+2)
         NODREF(I+1,3) = ZR(JCOOR-1+3*(J-1)+3)
1200  CONTINUE

C     EVALUATE THE UNIT VECTORS DEFINING THE THREE LOCAL AXES
      DO 1300 I=1,NDIM
C        VECTOR...
         LOCREF(I,1) = NODREF(I+1,1) - NODREF(1,1)
         LOCREF(I,2) = NODREF(I+1,2) - NODREF(1,2)
         LOCREF(I,3) = NODREF(I+1,3) - NODREF(1,3)
C        ...MODULE OF THE VECTOR...
         MODVEC = (LOCREF(I,1)**2+LOCREF(I,2)**2+LOCREF(I,3)**2)**0.5D0
C        ...UNIT VECTOR!
         LOCREF(I,1) = LOCREF(I,1)/MODVEC
         LOCREF(I,2) = LOCREF(I,2)/MODVEC
         LOCREF(I,3) = LOCREF(I,3)/MODVEC
1300  CONTINUE

C     FOR THE 2D CASE, THE Zl AXIS DIRECTION IS KNOWN IN ADVANCE BECAUSE
C     IT'S COINCIDENT WITH THE GLOBAL Z AXIS
      IF (NDIM.EQ.2) THEN
         LOCREF(3,1) = 0
         LOCREF(3,2) = 0
         LOCREF(3,3) = 1
      ENDIF

C     CHECK IF THE LOCAL AXES ARE ORTHOGONAL EACH OTHER
C     Xl - Yl
      MODVEC = LOCREF(1,1)*LOCREF(2,1)+LOCREF(1,2)*LOCREF(2,2)+
     &         LOCREF(1,3)*LOCREF(2,3)
      IF(ABS(MODVEC).GT.PARTOL) CALL U2MESS('F','XFEM2_55')
C     Xl - Zl
      MODVEC = LOCREF(1,1)*LOCREF(3,1)+LOCREF(1,2)*LOCREF(3,2)+
     &         LOCREF(1,3)*LOCREF(3,3)
      IF(ABS(MODVEC).GT.PARTOL) CALL U2MESS('F','XFEM2_55')
C     Yl - Zl
      MODVEC = LOCREF(2,1)*LOCREF(3,1)+LOCREF(2,2)*LOCREF(3,2)+
     &         LOCREF(2,3)*LOCREF(3,3)
      IF(ABS(MODVEC).GT.PARTOL) CALL U2MESS('F','XFEM2_55')

C     THE DIRECTIONS OF THE THREE AXES ARE CORRECT (ORTHOGONAL TO EACH
C     OTHER) BUT THE SENSE COULD BE WRONG. THEREFORE THE Z-AXIS IS
C     RECALCULATED IN SUCH A WAY THAT ITS SENSE IS COHERENT WITH THE
C     SENSE OF X AND Y AXES. IT IS CALCULATED AS THE VECTORIAL PRODUCT
C     OF X AND Y AXES.
      LOCREF(3,1) = LOCREF(1,2)*LOCREF(2,3)-LOCREF(1,3)*LOCREF(2,2)
      LOCREF(3,2) = LOCREF(1,3)*LOCREF(2,1)-LOCREF(1,1)*LOCREF(2,3)
      LOCREF(3,3) = LOCREF(1,1)*LOCREF(2,2)-LOCREF(1,2)*LOCREF(2,1)

C     STORE THE LOCAL REFERENCE SYSTEM IN THE JEVEUO OBJECT. THIS WILL
C     BE USED LATER BY XPRUPW.F
C     THIS BASE IS STORED IN A 9 ELEMENTS VECTOR. ELEMENTS 1 TO 3
C     ARE X-AXIS COMPONENTS, ELEMENTS 4 TO 6 ARE Y-AXIS COMPONENTS AND
C     ELEMENTS 7 TO 9 ARE Z-AXIS COMPONENT.
      DO 1400 I=1,3
         ZR(JREF-1+3*(I-1)+1) = LOCREF(I,1)
         ZR(JREF-1+3*(I-1)+2) = LOCREF(I,2)
         ZR(JREF-1+3*(I-1)+3) = LOCREF(I,3)
1400  CONTINUE

C-----------------------------------------------------------------------
C CREATION OF THE TWO VECTORS DESCRIBING THE CONNECTION OF THE NODES.
C FOR EACH NODE IN THE MESH, THE DATA CONTAINED IN THE TWO VECTORS
C ARE AS FOLLOWS:
C
C VECTOR 1, INTEGERS, 6 ELEMENTS: N+X,N-X,N+Y,N-Y,N+Z,N-Z
C VECTOR 2, REALS, 6 ELEMENTS: DX+,DX-,DY+,DY-,DZ+,DZ-
C
C WHERE
C   N+i  = NEAREST NODE IN POSITIVE i-DIRECTION
C   Di+  = DISTANCE BETWEEN THE CURRENT NODE AND N+i (IN i-DIRECTION,
C          OF COURSE!)
C   N-i  = NEAREST NODE IN NEGATIVE i-DIRECTION
C   Di-  = DISTANCE BETWEEN THE CURRENT NODE AND N-i (OPPOSITE TO
C          i-DIRECTION, OF COURSE!)
C-----------------------------------------------------------------------

C     CHECK THE NUMBER OF UNSUPPORTED ELEMENTS IN THE MESH
      UNSUPP = 0

C     CHECK THE NUMBER OF EDGES IN THE MESH THAT ARE NOT PARALLEL TO
C     THE LOCAL REFERENCE SYSTEM
      NOTPAR = 0

C     SHORTEST EDGE IN THE GRID
      LCMIN=R8MAEM()

C     ANALYSE EACH NODE IN THE MESH
      DO 100 NODE=1,NBNO

C        RETRIEVE THE COORDINATES OF THE NODE
         NODXYZ(1,1) = ZR(JCOOR-1+3*(NODE-1)+1)
         NODXYZ(1,2) = ZR(JCOOR-1+3*(NODE-1)+2)
         NODXYZ(1,3) = ZR(JCOOR-1+3*(NODE-1)+3)

C        RETRIEVE THE ELEMENTS CONTAINING THE NODE
         CALL JELIRA(JEXNUM(CNXINV,NODE),'LONMAX',NBELNO,K8B)
         CALL JEVEUO(JEXNUM(CNXINV,NODE),'L',JELNO)

C        FOR EACH OF THESE ELEMENTS, RETRIEVE THE THREE EDGES CONTAINING
C        THE ACTUAL NODE AND DETERMINE THEIR ORIENTATION AND LENGTH
         DO 200 ELNOL=1,NBELNO

C           GET THE ELEMENT NUMBER
            ELNO = ZI(JELNO-1+ELNOL)

C           ONLY THE SUPPORTED ELEMENTS ARE CONSIDERED
            ITYPMA=ZI(JMAI-1+ELNO)
            CALL JENUNO(JEXNUM('&CATA.TM.NOMTM',ITYPMA),TYPMA)

            IF (((TYPMA(1:5).EQ.'HEXA8').AND.(NDIM.EQ.3)).OR.
     &          ((TYPMA(1:5).EQ.'QUAD4').AND.(NDIM.EQ.2))) THEN

C              GET THE ELEMENT DEFINITION AND THE NODE POSITION INTO THE
C              ELEMENT DEFINITION
               NODEPS = 0
               DO 300 NOCUR=1,NUMNOD(NDIM)
                  ELDEF(NOCUR) = ZI(JCONX1-1+ZI(JCONX2-1+ELNO)+NOCUR-1)
                  IF (ELDEF(NOCUR).EQ.NODE) NODEPS=NOCUR
300            CONTINUE

C              THE NODE SHOULD ALWAYS BE PRESENT INTO THE ELEMENT
C              DEFINITION. HOWEVER IT IS BETTER TO CHECK IT, JUST IN THE
C              CASE SOMETHING IS WRONG IN THE MESH DEFINITION
               CALL ASSERT(NODEPS.GT.0)

C              RETRIEVE ALL THE EDGES OF THE ELEMENT
               CALL CONARE(TYPMA,AR,NBAR)

C              RETRIEVE THE THREE EDGES CONTAINING THE ACTUAL NODE. ONLY
C              THE POSITION INTO THE ELEMENT DEFINITION OF THE EDGE
C              NODES DIFFERENT FROM THE CURRENT ONE IS STORED.
               J=0
               DO 350 I=1,NBAR
C                 IF THE CURRENT NODE IS THE FIRST IN THE EDGE
C                 DEFINITION, THE SECOND NODE IN THE EDGE DEFINITION IS
C                 STORED
                  IF(AR(I,1).EQ.NODEPS) THEN
                    J = J+1
C                   THE NUMBER OF EDGES SHARING THE NODE SHOULD ALWAYS
C                   BE LOWER OR EQUAL TO THE MAXIMUM VALUE EXPECTED
                    CALL ASSERT(J.LE.MAXEDG(NDIM))
                    NODCON(J) = AR(I,2)
                  ENDIF

C                 IF THE CURRENT NODE IS THE SECOND IN THE EDGE
C                 DEFINITION, THE FIRST NODE IN THE EDGE DEFINITION IS
C                 STORED
                  IF(AR(I,2).EQ.NODEPS) THEN
                    J = J+1
C                   THE NUMBER OF EDGES SHARING THE NODE SHOULD ALWAYS
C                   BE LOWER OR EQUAL TO THE MAXIMUM VALUE EXPECTED
                    CALL ASSERT(J.LE.MAXEDG(NDIM))
                    NODCON(J) = AR(I,1)
                  ENDIF
350            CONTINUE

C              THE NUMBER OF EDGES RETRIEVED SHOULD ALWAYS BE EQUAL TO
C              THE NUMBER OF THE EXPECTED EDGES
               CALL ASSERT(J.EQ.MAXEDG(NDIM))

C              BUILD EACH EDGE SHARING THE CURRENT NODE AND EVALUATE ITS
C              DIRECTION
               DO 400 I=1,MAXEDG(NDIM)
                  NODEDG = ELDEF(NODCON(I))
                  NODXYZ(2,1) = ZR(JCOOR-1+3*(NODEDG-1)+1)
                  NODXYZ(2,2) = ZR(JCOOR-1+3*(NODEDG-1)+2)
                  NODXYZ(2,3) = ZR(JCOOR-1+3*(NODEDG-1)+3)

                  NODXYZ(2,1) = NODXYZ(2,1) - NODXYZ(1,1)
                  NODXYZ(2,2) = NODXYZ(2,2) - NODXYZ(1,2)
                  NODXYZ(2,3) = NODXYZ(2,3) - NODXYZ(1,3)

C                 EXPRESSS THE EDGE VECTOR (EXPRESSED IN THE GLOBAL
C                 REFERENCE SYSTEM) IN THE LOCAL REFERENCE SYSTEM
                  DO 450 J=1,3
                     LOCXYZ(J) = (NODXYZ(2,1)*LOCREF(J,1)+
     &                            NODXYZ(2,2)*LOCREF(J,2)+
     &                            NODXYZ(2,3)*LOCREF(J,3))
450               CONTINUE

C                 EVALUATE THE ABSOLUTE VALUE OF THE COMPONENTS OF THE
C                 EDGE VECTOR EXPRESSED IN THE LOCAL REFERENCE SYSTEM
                  ABSXYZ(1) = ABS(LOCXYZ(1))
                  ABSXYZ(2) = ABS(LOCXYZ(2))
                  ABSXYZ(3) = ABS(LOCXYZ(3))

C                 TOLERANCE ON THE LOCAL COMPONENTS OF THE EDGE VECTOR
C                 USED TO CHECK IF THE EDGE IS PARALLEL TO ONE LOCAL
C                 AXIS
                  MODVEC = ((ABSXYZ(1)**2+ABSXYZ(2)**2+ABSXYZ(3)**2)
     &                     **0.5D0)*PARTOL

                  IF ((ABSXYZ(1).GT.ABSXYZ(2)) .AND.
     &               (ABSXYZ(1).GT.ABSXYZ(3))) THEN

C                    CHECK IF THE EDGE IS REALLY PARALLEL TO Xl AXIS
                     IF(.NOT.((ABSXYZ(1).GT.MODVEC).AND.
     &                        (ABSXYZ(2).LT.MODVEC).AND.
     &                        (ABSXYZ(3).LT.MODVEC))) THEN
                         NOTPAR = NOTPAR+1
                     ENDIF

C                    CHECK THAT THE VALUE OF DELTAX IS GREATER THAN ZERO
                     IF (.NOT.(ABSXYZ(1).GT.R8PREM())) THEN
                        CALL U2MESS('F','XFEM2_57')
                     ENDIF

C                    CALCULATE THE SHORTEST EDGE IN THE GRID
                     IF(ABSXYZ(1).LT.LCMIN) LCMIN=ABSXYZ(1)

                     IF (LOCXYZ(1).GT.0) THEN
C                       EDGE PARALLEL TO Xl-AXIS, DELTAX POSITIVE
                        ZI(JVCN-1+6*(NODE-1)+1) = NODEDG
                        ZR(JVCND-1+6*(NODE-1)+1) = ABSXYZ(1)
                     ELSE
C                       EDGE PARALLEL TO Xl-AXIS, DELTAX NEGATIVE
                        ZI(JVCN-1+6*(NODE-1)+2) = NODEDG
                        ZR(JVCND-1+6*(NODE-1)+2) = ABSXYZ(1)
                     ENDIF

                  ELSE
                        IF (ABSXYZ(2).GT.ABSXYZ(3)) THEN

C                           CHECK IF THE EDGE IS REALLY PARALLEL TO Yl
C                           AXIS
                            IF(.NOT.((ABSXYZ(2).GT.MODVEC).AND.
     &                               (ABSXYZ(1).LT.MODVEC).AND.
     &                               (ABSXYZ(3).LT.MODVEC))) THEN
                                NOTPAR = NOTPAR+1
                            ENDIF

C                           CHECK THAT THE VALUE OF DELTAY IS GREATER
C                           THAN ZERO
                            IF (.NOT.(ABSXYZ(2).GT.R8PREM())) THEN
                               CALL U2MESS('F','XFEM2_57')
                            ENDIF

C                           CALCULATE THE SHORTEST EDGE IN THE GRID
                            IF(ABSXYZ(2).LT.LCMIN) LCMIN=ABSXYZ(2)

                            IF (LOCXYZ(2).GT.0) THEN
C                              EDGE PARALLEL TO Yl-AXIS, DELTAY POSITIVE
                               ZI(JVCN-1+6*(NODE-1)+3) = NODEDG
                               ZR(JVCND-1+6*(NODE-1)+3) = ABSXYZ(2)
                            ELSE
C                              EDGE PARALLEL TO Yl-AXIS, DELTAY NEGATIVE
                               ZI(JVCN-1+6*(NODE-1)+4) = NODEDG
                               ZR(JVCND-1+6*(NODE-1)+4) = ABSXYZ(2)
                            ENDIF

                        ELSE

C                           CHECK IF THE EDGE IS REALLY PARALLEL TO Zl
C                           AXIS
                            IF(.NOT.((ABSXYZ(3).GT.MODVEC).AND.
     &                               (ABSXYZ(1).LT.MODVEC).AND.
     &                               (ABSXYZ(2).LT.MODVEC))) THEN
                                NOTPAR = NOTPAR+1
                            ENDIF
C                           CHECK THAT THE VALUE OF DELTAZ IS GREATER
C                           THAN ZERO
                            IF (.NOT.(ABSXYZ(3).GT.R8PREM())) THEN
                               CALL U2MESS('F','XFEM2_57')
                            ENDIF

C                           CALCULATE THE SHORTEST EDGE IN THE GRID
                            IF(ABSXYZ(3).LT.LCMIN) LCMIN=ABSXYZ(3)

                            IF (LOCXYZ(3).GT.0) THEN
C                              EDGE PARALLEL TO Zl-AXIS, DELTAZ POSITIVE
                               ZI(JVCN-1+6*(NODE-1)+5) = NODEDG
                               ZR(JVCND-1+6*(NODE-1)+5) = ABSXYZ(3)
                            ELSE
C                              EDGE PARALLEL TO Zl-AXIS, DELTAZ NEGATIVE
                               ZI(JVCN-1+6*(NODE-1)+6) = NODEDG
                               ZR(JVCND-1+6*(NODE-1)+6) = ABSXYZ(3)
                            ENDIF

                        ENDIF

                  ENDIF

400            CONTINUE

            ELSE

C               THE ELEMENT IS NOT SUPPORTED
                UNSUPP = UNSUPP + 1

C               CHECK THE DIMENSION OF THE UNSUPPORTED ELEMENT
                NDIME=ZI(JTMDIM-1+ITYPMA)

C               STORE THE MAXIMUM DIMENSION OF THE UNSUPPORTED ELEMENTS
                IF (NDIME.GT.DIMUNS) DIMUNS=NDIME

            ENDIF

200      CONTINUE

100   CONTINUE

C     IF EDGES NOT PARALLEL TO THE LOCAL REFERENCE SYSTEM HAVE BEEN
C     DETECTED, A FATAL ERROR IS ISSUED
      IF (NOTPAR.GT.0) CALL U2MESS('F','XFEM2_55')

C     ANALYSE EACH NODE IN THE MESH TO CHECK IF THERE ARE SOME NODES
C     THAT DO NOT BELONG TO THE TYPE OF ELEMENT CONSIDERED FOR THE
C     UPWIND SCHEME

      ORPH = 0
      DO 500 NODE=1,NBNO

         I = 0

C        CHECK THE NEIGHBORING NODES IN Xl AND Yl DIRECTIONS
         DO 600 NOCUR=1,4
            IF (ZI(JVCN-1+6*(NODE-1)+NOCUR).EQ.0) I = I+1
600      CONTINUE

C        CHECK THE NEIGHBORING NODES IN Zl DIRECTION ONLY FOR THE 3D
C        CASE
         IF (NDIM.EQ.3) THEN
            DO 601 NOCUR=5,6
               IF (ZI(JVCN-1+6*(NODE-1)+NOCUR).EQ.0) I = I+1
601         CONTINUE
         ENDIF

C        THE NODE DOES NOT BELONG TO ANY ALLOWED ELEMENT FOR THE UPWIND
C        SCHEME. HERE I LABEL THIS NODE AS "ORPHAN NODE".
         IF (((I.EQ.6).AND.(NDIM.EQ.3)).OR.((I.EQ.4).AND.(NDIM.EQ.2)))
     &           ORPH=ORPH+1

500   CONTINUE

C     MANAGE THE UNSUPPORTED ELEMENTS
      IF (UNSUPP.GT.0) THEN

C        CASE 1: ALL THE UNSUPPORTED ELEMENTS ARE OF LOWER DIMENSION
C                THEN THE DIMENSION OF THE PROBLEM AND THERE ARE SOME
C                ORPHAN NODES
         IF((DIMUNS.LT.NDIM).AND.(ORPH.GT.0)) THEN
            IF(NDIM.EQ.3) THEN
               CALL U2MESS('F','XFEM2_52')
            ELSE
               CALL U2MESS('F','XFEM2_50')
            ENDIF
         ENDIF

C        CASE 2: AT LEAST ONE OF THE UNSUPPORTED ELEMENTS HAS THE SAME
C                DIMENSION OF THE PROBLEM
         IF(DIMUNS.GE.NDIM) CALL U2MESS('F','XFEM2_53')

      ENDIF

C     STORE THE LCMIN VALUE IN THE GRLR OBJECT
      ZR(JGRLR-1+1) = LCMIN

      IF (NIV.GT.1) THEN
      WRITE(IFM,900)
      WRITE(IFM,905)
      DO 50 I=1,NBNO
         WRITE(IFM,901)I,ZI(JVCN-1+6*(I-1)+1),ZI(JVCN-1+6*(I-1)+2),
     &  ZI(JVCN-1+6*(I-1)+3),ZI(JVCN-1+6*(I-1)+4),ZI(JVCN-1+6*(I-1)+5),
     &  ZI(JVCN-1+6*(I-1)+6)
         WRITE(IFM,904)ZR(JVCND-1+6*(I-1)+1),ZR(JVCND-1+6*(I-1)+2),
     &ZR(JVCND-1+6*(I-1)+3),ZR(JVCND-1+6*(I-1)+4),ZR(JVCND-1+6*(I-1)+5),
     &  ZR(JVCND-1+6*(I-1)+6)
50    CONTINUE
      ENDIF

900   FORMAT('NODE  | NX+  | NX-  | NY+  | NY-  | NZ+  | NZ-  |')
901   FORMAT(I6,6('|',I6),'|')
904   FORMAT('      ',6('|',F6.3),'|')
905   FORMAT('      | DX+  | DX-  | DY+  | DY-  | DZ+  | DZ-  |')

C-----------------------------------------------------------------------
C     FIN
C-----------------------------------------------------------------------
      CALL JEDEMA()
      END
