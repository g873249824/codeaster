      SUBROUTINE NMCONV(CNFINT,CNDIRI,CNFEXT,CNVCFO,PARCRI,
     &                  ITERAT,ETA   ,CONV  ,LICCVG,ITEMAX,
     &                  CONVER,ECHLDC,ECHEQU,ECHCON,ECHPIL,
     &                  FINPAS,SDCRIT,NUMINS,SDDISC,PARMET,
     &                  CNVFRE,MAILLA,INST  ,VALMOI,VALPLU,
     &                  DEPALG,MEASSE,SDDYNA,CNVCF1,NUMEDD,
     &                  DEFICO,RESOCO,MATASS,SDIMPR,FONACT,
     &                  MAXREL,MATE  ,COMREF)

C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 22/01/2008   AUTEUR FLEJOU J-L.FLEJOU 
C ======================================================================
C COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C TOLE CRP_21
C TOLE CRP_20
C RESPONSABLE MABBAS M.ABBAS
C
      IMPLICIT     NONE
      LOGICAL      FONACT(*)
      LOGICAL      ITEMAX, CONVER, ECHLDC, FINPAS, ECHCON(2), ECHEQU
      LOGICAL      MAXREL,ECHPIL
      INTEGER      ITERAT, LICCVG(*), NUMINS
      REAL*8       ETA, CONV(*), PARCRI(*), PARMET(*),INST(*)
      CHARACTER*19 SDCRIT,CNFINT,CNDIRI,CNFEXT,CNVCFO,CNVFRE
      CHARACTER*19 SDDISC,CNVCF1,MATASS
      CHARACTER*19 SDDYNA
      CHARACTER*24 VALMOI(8),VALPLU(8),DEPALG(8)
      CHARACTER*19 MEASSE(8)
      CHARACTER*24 COMREF,MATE
      CHARACTER*8  MAILLA
      CHARACTER*24 NUMEDD
      CHARACTER*24 DEFICO,RESOCO
      CHARACTER*24 SDIMPR
C
C ----------------------------------------------------------------------
C
C ROUTINE MECA_NON_LINE (ALGORITHME)
C
C VERIFICATION DES CRITERES D'ARRET
C
C ----------------------------------------------------------------------
C
C
C IN  CNFINT : FORCES INTERNES   - FINT
C IN  CNDIRI : REACTIONS D'APPUI - BT.LAMBDA
C IN  CNFEXT : RESULTANTE DES EFFORTS EXTERIEURS
C IN  CNVCFO : FORCE DE REFERENCE DES VARI_COM
C IN  PARCRI : CRITERES DE CONVERGENCE
C               1 : ITER_GLOB_MAXI
C               2 : RESI_GLOB_RELA
C               3 : RESI_GLOB_MAXI
C               4 : ARRET
C               5 : ITER_GLOB_ELAS
C               6 : RESI_REFE_RELA
C IN  ITERAT : NUMERO D'ITERATION
C IN  ETA    : COEFFICIENT DE PILOTAGE
C IN  CONV   : INFORMATIONS SUR LA CONVERGENCE DU CALCUL
C               1 - RESI_DUAL_ABSO      (LAGRANGIEN AUGMENTE)
C               2 - RESI_PRIM_ABSO      (LAGRANGIEN AUGMENTE)
C               3 - NOMBRE D'ITERATIONS DUAL (LAGRANGIEN AUGMENTE)
C               4 - NUMERO ITERATION BFGS (LAGRANGIEN AUGMENTE)
C              10 - NOMBRE D'ITERATIONS (RECHERCHE LINEAIRE)
C              11 - RHO                 (RECHERCHE LINEAIRE)
C              20 - RESI_GLOB_RELA
C              21 - RESI_GLOB_MAXI
C IN  LICCVG : CODES RETOURS
C              (1) : PILOTAGE
C                  =  0 CONVERGENCE
C                  =  1 PAS DE CONVERGENCE
C                  = -1 BORNE ATTEINTE
C              (2) : INTEGRATION DE LA LOI DE COMPORTEMENT
C                  = 0 OK
C                  = 1 ECHEC DANS L'INTEGRATION : PAS DE RESULTATS
C                  = 3 SIZZ NON NUL (DEBORST) ON CONTINUE A ITERER
C              (3) : TRAITEMENT DU CONTACT UNILATERAL EN GD. DEPL.
C                  = 0 OK
C                  = 1 ECHEC DANS LE TRAITEMENT DU CONTACT
C              (4) : TRAITEMENT DU CONTACT UNILATERAL EN GD. DEPL.
C                  = 0 OK
C                  = 1 MATRICE DE CONTACT SINGULIERE
C              (5) : MATRICE DU SYSTEME (MATASS)
C                  = 0 OK
C                  = 1 MATRICE SINGULIERE
C                  = 3 ON NE SAIT PAS SI SINGULIERE
C IN  SDDISC : LISTE D'INSTANT
C IN  PARMET : PARAMETRES DE LA METHODE DE RESOLUTION
C                       3 - PAS_MINI_ELAS
C IN  FONACT : FONCTIONNALITES ACTIVEES (VOIR NMFONC)
C OUT ITEMAX : .TRUE. SI ITERATION MAXIMUM ATTEINTE
C OUT CONVER : .TRUE. SI CONVERGENCE REALISEE
C OUT ECHLDC : .TRUE. SI ECHEC INTEGRATION LOI DE COMPORTEMENT
C OUT ECHCON : .TRUE. SI ECHEC TRAITEMENT DU CONTACT UNILATERAL
C OUT ECHEQU : .TRUE. SI MATASS SINGULIERE
C OUT ECHPIL : .TRUE. SI ECHEC PILOTAGE
C OUT FINPAS : .TRUE. SI ON NE FAIT PLUS D'AUTRES PAS DE TEMPS
C OUT MAXREL : .TRUE. SI CRITERE RESI_GLOB_RELA ET CHARGEMENT = 0,
C                             ON UTILISE RESI_GLOB_MAXI
C IN  MAILLA : NOM DU MAILLAGE
C IN  DEFICO : SD POUR LA DEFINITION DU CONTACT
C IN  RESOCO : SD POUR LA RESOLUTION DU CONTACT
C IN  MATASS : MATRICE DU PREMIER MEMBRE ASSEMBLEE
C IN  SDIMPR : SD AFFICHAGE
C IN  NUMEDD : NUMEROTATION NUME_DDL
C IN  SDCRIT : SYNTHESE DES RESULTATS DE CONVERGENCE POUR
C                   ARCHIVAGE
C IN  COMREF : VARI_COM REFE
C
C --- DEBUT DECLARATIONS NORMALISEES JEVEUX ----------------------------
C
      INTEGER            ZI
      COMMON  / IVARJE / ZI(1)
      REAL*8             ZR
      COMMON  / RVARJE / ZR(1)
      COMPLEX*16         ZC
      COMMON  / CVARJE / ZC(1)
      LOGICAL            ZL
      COMMON  / LVARJE / ZL(1)
      CHARACTER*8        ZK8
      CHARACTER*16                ZK16
      CHARACTER*24                          ZK24
      CHARACTER*32                                    ZK32
      CHARACTER*80                                              ZK80
      COMMON  / KVARJE / ZK8(1) , ZK16(1) , ZK24(1) , ZK32(1) , ZK80(1)
C
C --- FIN DECLARATIONS NORMALISEES JEVEUX ------------------------------
C
      LOGICAL      ERROR
      LOGICAL      ISFONC,LREFE,CINIT
      INTEGER      NOCC,NEQ
      INTEGER      JCRR
      INTEGER      IBID,IRET
      INTEGER      TYPALC
      REAL*8       R8VIDE,R8BID,VCMAX
      REAL*8       INSTAM,INSTAP,DIINST,PASMIN
      CHARACTER*16 GEONOE
      REAL*8       GEOVAL
      LOGICAL      GEOERR
      CHARACTER*16 K16BID
      INTEGER      JCRI
      CHARACTER*24 IMPCNT,IMPCNL,IMPCNV,IMPCNA,CRITER
      INTEGER      JIMPCT,JIMPCL,JIMPCV,JIMPCA
      REAL*8       VRELA,VMAXI,VREFE,VRESI,VCHAR,VINIT
      INTEGER      IRELA,IMAXI,IREFE,IRESI,ICHAR,IINIT
      CHARACTER*24 CLREAC
      INTEGER      JCLREA
      CHARACTER*8  K8BID
      CHARACTER*24 K24BID,COMMOI,DEPDEL
      LOGICAL      CTCFIX,CTCGEO,CTCCVG
      INTEGER      CTCITE
      LOGICAL      CBORST,BORCVG
      INTEGER      CTCINT(2)
      INTEGER      IFM,NIV
C
C ----------------------------------------------------------------------
C
      CALL JEMARQ()
      CALL INFDBG('MECA_NON_LINE',IFM,NIV)
C
C --- AFFICHAGE
C
      IF (NIV.GE.2) THEN
        WRITE (IFM,*) '<MECANONLINE> EVALUATION DE LA CONVERGENCE'
      ENDIF
C
C --- INITIALISATIONS
C
      FINPAS = .FALSE.
      ITEMAX = .FALSE.
      ERROR  = .FALSE.
      CBORST = LICCVG(2).EQ.3
      BORCVG = .TRUE.
      CTCCVG = .FALSE.
      IMPCNT = SDIMPR(1:14)//'CONV.TYPE'
      IMPCNL = SDIMPR(1:14)//'CONV.LIEU'
      IMPCNV = SDIMPR(1:14)//'CONV.VAL'
      IMPCNA = SDIMPR(1:14)//'CONV.ACT'
      CALL JEVEUO(IMPCNT,'E',JIMPCT)
      CALL JEVEUO(IMPCNL,'E',JIMPCL)
      CALL JEVEUO(IMPCNV,'E',JIMPCV)
      CALL JEVEUO(IMPCNA,'E',JIMPCA)
      CALL DISMOI('F','NB_EQUA',NUMEDD,'NUME_DDL',NEQ,K8BID,IRET)
C
C --- DECOMPACTION DES VARIABLES CHAPEAUX
C
      CALL DESAGG(VALMOI,K24BID,K24BID,K24BID,COMMOI,
     &            K24BID,K24BID,K24BID,K24BID)
      CALL DESAGG(DEPALG,K24BID,DEPDEL,K24BID,K24BID,
     &            K24BID,K24BID,K24BID,K24BID)
C
C --- NOUVEL INSTANT
C
      INSTAM = DIINST(SDDISC, NUMINS-1)
      INSTAP = DIINST(SDDISC, NUMINS  )
C
C ======================================================================
C
C    TRAITEMENT DES CODES RETOUR D'ERREUR
C
C ======================================================================
C
C --- LOI DE COMPORTEMENT
C
      ECHLDC = (LICCVG(2).EQ.1)
      IF (ECHLDC) THEN
        ERROR  = .TRUE.
        CALL NMIMPR('IMPR','ERREUR','ECHEC_LDC',0.D0,1)
      END IF
C
C --- PILOTAGE
C
      ECHPIL = LICCVG(1) .EQ. 1
      IF (ECHPIL) THEN
        ERROR  = .TRUE.
        CALL NMIMPR('IMPR','ERREUR','ECHEC_PIL',0.D0,1)
      END IF
C
C --- MATRICE DU SYSTEME
C
      ECHEQU = .NOT. (LICCVG(5).EQ.0 .OR. LICCVG(5).EQ.3)
      IF (ECHEQU) THEN
        ERROR  = .TRUE.
        CALL NMIMPR('IMPR','ERREUR','MATR_SING',0.D0,0)
      END IF
C
C --- CONTACT DISCRET
C
      ECHCON(1) = LICCVG(3) .NE. 0
      IF (ECHCON(1)) THEN
        ERROR  = .TRUE.
        CALL NMIMPR('IMPR','ERREUR','CONT_ERR',0.D0,1)
      END IF

      ECHCON(2) = LICCVG(4) .NE. 0
      IF (ECHCON(2)) THEN
        ERROR  = .TRUE.
        CALL NMIMPR('IMPR','ERREUR','CONT_SING',0.D0,0)
      END IF

      IF (ERROR) THEN
        CONVER = .FALSE.
        GOTO 9999
      ENDIF
C
C ======================================================================
C
C    CALCUL DES RESIDUS
C
C ======================================================================
C
C --- DOIT-ON VERIFIER UN RESI_GLOB_REFE ?
C
      LREFE = ISFONC(FONACT,'RESI_REFE')
C
C --- DOIT-ON VERIFIER LES VARIABLES DE COMMANDE INITIALES ?
C
      CALL GETFAC('ETAT_INIT',NOCC)
      CINIT = (NUMINS.EQ.1).AND.(NOCC.EQ.0)
C
C --- CALCUL DES RESIDUS ET DES CHARGEMENTS
C
      CALL NMRESI(NUMEDD,INST  ,SDDYNA,NEQ   ,VALPLU,
     &            MEASSE,MATASS,CNFINT,CNDIRI,CNFEXT,
     &            CNVCFO,CNVFRE,CNVCF1,LREFE ,CINIT ,
     &            VRELA ,VMAXI ,VCHAR ,VRESI ,VREFE ,
     &            VINIT ,IRELA ,IMAXI ,ICHAR ,IRESI ,
     &            IREFE ,IINIT)
C
C --- ECRITURE DES INFOS SUR LES RESIDUS POUR AFFICHAGE
C
      CALL IMPCMP(IRELA,NUMEDD,ZK16(JIMPCL-1+1))
      ZK16(JIMPCT-1+1) = 'RESI_GLOB_RELA'
      ZR(JIMPCV-1+1)   = VRELA

      CALL IMPCMP(IMAXI,NUMEDD,ZK16(JIMPCL-1+2))
      ZK16(JIMPCT-1+2) = 'RESI_GLOB_MAXI'
      ZR(JIMPCV-1+2)   = VMAXI

      CALL IMPCMP(IREFE,NUMEDD,ZK16(JIMPCL-1+3))
      ZK16(JIMPCT-1+3) = 'RESI_GLOB_REFE'
      ZR(JIMPCV-1+3)   = VREFE
C
C --- SAUVEGARDES RESIDUS
C
      CONV(20) = VRELA
      CONV(21) = VMAXI
C
C --- VERIFICATION QUE LES VARIABLES DE COMMANDE INITIALES CONDUISENT
C --- A DES FORCES NODALES NULLES
C
      IF (CINIT) THEN
        IF (VCHAR.GT.PARCRI(2)) THEN
          VINIT = VINIT/VCHAR
        ENDIF
        IF (VINIT.GT.PARCRI(2)) THEN
          CALL NMVCMX(MATE,MAILLA,COMREF,COMMOI,VCMAX)
        ENDIF
      ENDIF
C
C ======================================================================
C
C    AFFICHAGES DANS LE TABLEAU DE CONVERGENCE
C
C ======================================================================
C
C --- INSTANT
C
      CALL IMPSDR(SDIMPR(1:14),
     &            'INCR_TPS ',K16BID,INSTAP,IBID)
C
C --- NUMERO ITERATION NEWTON
C
      CALL IMPSDR(SDIMPR(1:14),
     &            'ITER_NEWT',K16BID,R8BID,ITERAT)
C
C --- RESIDUS
C
      CALL IMPSDR(SDIMPR(1:14),
     &            'RESI_RELA',K16BID,VRELA,IBID)
      CALL IMPSDR(SDIMPR(1:14),
     &            'RELA_NOEU',ZK16(JIMPCL-1+1),R8BID,IBID)
      CALL IMPSDR(SDIMPR(1:14),
     &            'RESI_MAXI',K16BID,VMAXI,IBID)
      CALL IMPSDR(SDIMPR(1:14),
     &            'MAXI_NOEU',ZK16(JIMPCL-1+2),R8BID,IBID)
      CALL IMPSDR(SDIMPR(1:14),
     &            'RESI_REFE',K16BID,VREFE,IBID)
      CALL IMPSDR(SDIMPR(1:14),
     &            'REFE_NOEU',ZK16(JIMPCL-1+3),R8BID,IBID)
C
C --- CRITERES RECHERCHE LINEAIRE
C
      IF (ITERAT.EQ.0) THEN
        CONV(10) = 0
      ENDIF
      CALL IMPSDR(SDIMPR(1:14),
     &            'RELI_ITER',K16BID,R8BID,INT(CONV(10)))
C
      IF (NINT(CONV(10)).EQ.0) THEN
        CALL IMPSDR(SDIMPR(1:14),
     &              'RELI_COEF',K16BID,1.D0,IBID)
      ELSE
        CALL IMPSDR(SDIMPR(1:14),
     &              'RELI_COEF',K16BID,CONV(11),IBID)
      ENDIF
C
C --- CRITERES PILOTAGE
C
      CALL IMPSDR(SDIMPR(1:14),
     &            'PILO_PARA',K16BID,ETA,IBID)
C
C --- NUMERO ITERATION FETI
C
C     NOM DE LA SD CRITER EN DUR CONFORMEMENT A NMRESO
      CRITER = '&FETI.CRITER.CRTI'
      CALL JEEXIN(CRITER,IRET)
      IF (IRET.GT.0) THEN
        CALL JEVEUO(CRITER,'L',JCRI)
        CALL IMPSDR(SDIMPR(1:14),'ITER_FETI',K16BID,R8BID,ZI(JCRI))
        CALL JEDETR(CRITER)
      ENDIF
C
C ======================================================================
C
C    EXAMEN DE LA CONVERGENCE
C
C ======================================================================
C
C --- LE PILOTAGE A ATTEINT LES BORNES
C
      IF (LICCVG(1) .EQ. -1) THEN
        CALL IMPSDM(SDIMPR(1:14),'PILO_PARA','B')
        FINPAS  = .TRUE.
      ELSE
        CALL IMPSDM(SDIMPR(1:14),'PILO_PARA',' ')
      END IF
C
C --- EXAMEN DU NOMBRE D'ITERATIONS
C
      PASMIN = PARMET(3)
      IF (ABS(INSTAP-INSTAM) .LT. PASMIN) THEN
        ITEMAX = ITERAT .GE. PARCRI(5)
      ELSE
        ITEMAX = ITERAT .GE. PARCRI(1)
      ENDIF
C
C --- COLONNES A TESTER POUR LE CRITERE D'ARRET
C
C     CVGTST(1): TEST SUR RESI_GLOB_RELA
C     CVGTST(2): TEST SUR RESI_GLOB_MAXI
C     CVGTST(3): TEST SUR RESI_REFE_RELA
C
      ZL(JIMPCA-1+1) = (PARCRI(2)  .NE. R8VIDE())
      ZL(JIMPCA-1+2) = (PARCRI(3)  .NE. R8VIDE())
      ZL(JIMPCA-1+3) = (PARCRI(6)  .NE. R8VIDE())
C
C --- CRITERES D'ARRET
C
      CONVER = .TRUE.
      IF (ZL(JIMPCA-1+1)) THEN
        IF ((VRELA.GT.PARCRI(2)).OR.(VRELA.LT.0.D0)) THEN
           CONVER = .FALSE.
           CALL IMPSDM(SDIMPR(1:14),'RESI_RELA','X')
        ELSE
           CALL IMPSDM(SDIMPR(1:14),'RESI_RELA',' ')
        ENDIF
      ENDIF
      IF (ZL(JIMPCA-1+2)) THEN
        IF ((VMAXI.GT.PARCRI(3)).OR.(VMAXI.LT.0.D0)) THEN
           CONVER = .FALSE.
           CALL IMPSDM(SDIMPR(1:14),'RESI_MAXI','X')
        ELSE
           CALL IMPSDM(SDIMPR(1:14),'RESI_MAXI',' ')
        ENDIF
      ENDIF
      IF (ZL(JIMPCA-1+3)) THEN
        IF ((VREFE.GT.PARCRI(6)).OR.(VREFE.LT.0.D0)) THEN
           CONVER = .FALSE.
           CALL IMPSDM(SDIMPR(1:14),'RESI_REFE','X')
        ELSE
           CALL IMPSDM(SDIMPR(1:14),'RESI_REFE',' ')
        ENDIF
      ENDIF
C
C --- SI CRITERE RESI_GLOB_RELA ET CHARGEMENT = 0,
C --- ON UTILISE RESI_GLOB_MAXI
C
      MAXREL = .FALSE.
      IF (ZL(JIMPCA-1+1)) THEN
         CALL JEVEUO(SDCRIT //'.CRTR','L',JCRR)
         IF (VCHAR .LT. (1.D-6 * ZR(JCRR+5))) THEN
           IF (NUMINS.GT.1) THEN
             CALL IMPSDM(SDIMPR(1:14),'RESI_RELA',' ')
             CALL IMPSDM(SDIMPR(1:14),'RESI_MAXI','X')
             IF (VRESI .LT. ZR(JCRR+6)) THEN
               CALL IMPSDM(SDIMPR(1:14),'RESI_RELA',' ')
               CALL IMPSDM(SDIMPR(1:14),'RESI_MAXI',' ')
               CONVER = .TRUE.
               MAXREL = .TRUE.
               CALL U2MESS('I','MECANONLINE2_98')
             ENDIF
           ENDIF
         ENDIF
      ENDIF
C
C ======================================================================
C --- CONVERGENCE ADAPTEE AU CONTACT DISCRET
C ======================================================================
C
C
C --- TYPE DE CONTACT
C
      CALL CFDISC(DEFICO,' ',TYPALC,IBID,IBID,IBID)

      IF (FONACT(4).AND.(TYPALC.NE.5)) THEN
C
C --- ACCES OBJETS
C
         CLREAC = RESOCO(1:14)//'.REAL'
         CALL JEVEUO(CLREAC,'E',JCLREA)
         CTCFIX = ZL(JCLREA+2-1)
C
C --- NOMBRE ITERATIONS INTERNES DE CONTACT POUR L'ITERATION COURANTE
C
         CALL CFITER(RESOCO,'L','ITER',CTCITE,R8BID)

         CALL IMPSDR(SDIMPR(1:14),
     &               'CTCD_ITER',K16BID,R8BID,CTCITE)
C
C --- TRAITEMENT DE LA REACTUALISATION GEOMETRIQUE POUR LE CONTACT
C
         IF (CONVER) THEN

           CALL CFCONV(MAILLA,NEQ   ,DEPDEL,RESOCO,CTCFIX,
     &                 CTCITE,CTCGEO,CTCINT,GEONOE,GEOVAL,
     &                 GEOERR)

           IF (CTCGEO) THEN
C
C --- REACTUALISATION GEOMETRIQUE A FAIRE (-> NON CVG DU CONTACT)
C
             CTCCVG = .FALSE.
             CALL IMPSDR(SDIMPR(1:14),
     &                   'CTCD_INFO',' ALGO/REAC_GEOM  ',R8BID,IBID)
             CALL IMPSDR(SDIMPR(1:14),
     &                   'CTCD_NOEU',GEONOE,R8BID,IBID)
             CALL IMPSDR(SDIMPR(1:14),
     &                   'CTCD_GEOM',' ',GEOVAL,IBID)
           ELSE
C
C --- PAS DE REACTUALISATION GEOMETRIQUE A FAIRE
C
             IF (CTCFIX) THEN
C
C --- MAIS ATTENTE POINT FIXE (-> NON CVG DU CONTACT)
C
               CTCCVG = .FALSE.
               CALL IMPSDR(SDIMPR(1:14),
     &               'CTCD_INFO',' ATT_PT_FIXE    ',R8BID,IBID)
             ELSE
               CTCCVG = .TRUE.
               IF (ITERAT.EQ.0) THEN
                 CALL IMPSDR(SDIMPR(1:14),
     &                       'CTCD_INFO',' INIT_GEOM/ALGO  ',R8BID,IBID)
               ELSE
                 CALL IMPSDR(SDIMPR(1:14),
     &                       'CTCD_INFO',' ALGO.          ',R8BID,IBID)
               ENDIF


             ENDIF
             IF (GEOERR) THEN
               CALL U2MESS('A','MECANONLINE2_96')

               CALL IMPSDR(SDIMPR(1:14),
     &                     'CTCD_NOEU',GEONOE,R8BID,IBID)
               CALL IMPSDR(SDIMPR(1:14),
     &                     'CTCD_GEOM',' ',GEOVAL,IBID)
               CALL IMPSDR(SDIMPR(1:14),
     &                     'CTCD_INFO',' ALGO/ALARM_GEOM',R8BID,IBID)
             ELSE
               CALL IMPSDR(SDIMPR(1:14),
     &                     'CTCD_NOEU','                ',R8BID,IBID)
               CALL IMPSDR(SDIMPR(1:14),
     &                     'CTCD_GEOM',' ',R8VIDE(),IBID)
             ENDIF
           ENDIF
         ELSE
           CTCCVG = .FALSE.
           CTCGEO = .FALSE.
           CTCFIX = .FALSE.
           IF (ITERAT.EQ.0) THEN
             CALL IMPSDR(SDIMPR(1:14),
     &                   'CTCD_INFO',' INIT_GEOM/ALGO  ',R8BID,IBID)
           ELSE
             CALL IMPSDR(SDIMPR(1:14),
     &                   'CTCD_INFO',' ALGO.          ',R8BID,IBID)
           ENDIF
         ENDIF

         IF (CTCCVG) THEN
            CALL IMPSDM(SDIMPR(1:14),'CTCD_ITER',' ')
         ELSE
            CALL IMPSDM(SDIMPR(1:14),'CTCD_ITER','X')
         ENDIF

         ZL(JCLREA+1-1) = CTCGEO
         ZL(JCLREA+2-1) = CTCFIX

      ELSE
        CTCCVG = .TRUE.
      ENDIF
C
C --- CONVERGENCE ADAPTEE A LA METHODE DE DE BORST
C
      IF (CBORST) THEN
         IF (CONVER) THEN
           CALL IMPSDR(SDIMPR(1:14),
     &                 'ITER_DEBO',' DE BORST...    ',R8BID,IBID)
           CALL U2MESS('I','MECANONLINE2_3')
           BORCVG = .FALSE.
         ELSE
           CALL IMPSDR(SDIMPR(1:14),
     &                 'ITER_DEBO','                ',R8BID,IBID)
         ENDIF
      ENDIF
C
C --- CONVERGENCE FINALE
C
      CONVER = CONVER.AND.CTCCVG.AND.BORCVG
      IF (CONVER) THEN
         CALL IMPSDM(SDIMPR(1:14),'ITER_NEWT',' ')
      ELSE
         CALL IMPSDM(SDIMPR(1:14),'ITER_NEWT','X')
      ENDIF
C
C --- AFFICHAGE TABLEAU CONVERGENCE
C --- SAUF POUR METHODE CONTINUE: VOIR NMTBLE
C
      IF (.NOT.FONACT(5)) THEN
        CALL NMIMPR('IMPR','ETAT_CONV',' ',0.D0,0)
      ENDIF
      IF (FONACT(5).AND.(.NOT.(CONVER))) THEN
        CALL NMIMPR('IMPR','ETAT_CONV',' ',0.D0,0)
      ENDIF
C
C --- AFFICHAGE INFORMATIONS FINALES DE CONVERGENCE
C --- SAUF POUR METHODE CONTINUE: VOIR NMTBLE
C
      IF (CONVER) THEN
         IF (.NOT.FONACT(5)) THEN
C
C --- TYPE DE CONVERGENCE
C
           IF (MAXREL) THEN
             CALL NMIMPR('IMPR','MAXI_RELA',' ',0.D0,0)
           ELSE
             CALL NMIMPR('IMPR','CONV_OK',' ',0.D0,0)
           ENDIF
C
C --- RECAPITULATIF CRITERES CONVERGENCE - AFFICHAGE RESIDUS
C
           CALL NMIMPR('IMPR','CONV_RECA',' ',0.D0,0)
C
C --- INFOS DE CONVERGENCE CONTACT DISCRET
C
           IF (FONACT(4).AND.(TYPALC.NE.5)) THEN
             CALL NMIMPR('IMPR','CONV_CONT',' ',0.D0,CTCINT)
           ENDIF

         ENDIF
      ELSE
         IF (ITEMAX) THEN
            CALL NMIMPR('IMPR','ERREUR','ITER_MAXI',0.D0,0)
         ENDIF
      ENDIF
C
C --- SAUVEGARDES INFOS CONVERGENCE
C
      CALL JEVEUO(SDCRIT //'.CRTR','E',JCRR)
      ZR(JCRR+1-1) = ITERAT
      ZR(JCRR+2-1) = CONV(10)
      ZR(JCRR+3-1) = VRELA
      ZR(JCRR+4-1) = VMAXI
      ZR(JCRR+5-1) = ETA
      IF ((NUMINS.EQ.1) .AND. (ITERAT.EQ.0)) THEN
        ZR(JCRR+6-1) = VCHAR
      ELSE
        IF ((CONVER).AND.(.NOT.MAXREL)) THEN
          ZR(JCRR+6-1) = MIN(VCHAR, ZR(JCRR+6-1))
        ENDIF
      ENDIF
      IF (CONVER) THEN
        ZR(JCRR+7-1) = VRESI
      ENDIF
      ZR(JCRR+8-1) = VREFE
C
 9999 CONTINUE
      CALL JEDEMA()
      END
