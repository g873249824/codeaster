      SUBROUTINE MODEXP(MODGEN,SST1,INDIN1,LINO1,NBMOD,NUMLIA,
     &                  TRAMOD,MODET)
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 19/12/2012   AUTEUR PELLET J.PELLET 
C ======================================================================
C COPYRIGHT (C) 1991 - 2012  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C-------------------------------------------------------------C
C--                                                         --C
C--  ROUTINE QUI REALISE L'EXPANSION DES MODES D'INTERFACE  --C
C--    DE L'INTERFACE ESCLAVE VERS L'INTERFACE MAITRESSE    --C
C--                                                         --C
C-------------------------------------------------------------C
C--   VARIABLES E/S  :
C--   MODGEN   /IN/  : NOM DU MODELE GENERALISE
C--   SST1     /IN/  : NOM DE LA SOUS STRUCTURE
C--   INDIN1   /IN/  : NOM DU VECTEUR CONTENANT LES DDL D'INTERFACE
C--   LINO1    /IN/  : NOM DU VECTEUR CONTENANT LES NOEUDS D'INTERFACE
C--   NBMOD    /IN/  : NOMBRE DE MODE A ETENDRE
C--   NUMLIA   /IN/  : NUMERO DE LA LIAISON ASSOCIEE A L'INTERFACE
C--   TRAMOD   /IN/  : TRACE DES MODES SUR L'INTERFACE ESCLAVE
C--   MODET    /OUT/ : MODES ETENDUS SUR L'INTERFACE MAITRE

      IMPLICIT NONE
C
C

      INCLUDE 'jeveux.h'

      CHARACTER*32 JEXNUM,JEXNOM
C
C

      INTEGER       NBMOD,LBID,I1,J1,K1,ISST1,IBID,LCLEF,LNUM,
     &              NBEQ1,NL,NC,LMAST,NUMLIA,NBNO,LNRES,LMODET,
     &              SIZECO,CONNEC,LCONNC,NBEC,LPRNO,IPOS1,LCPHI,
     &              NBDDL,LNOINT,LINDIN,LLINO,LINDNO,LIPOS,IK,
     &              LDDLD,LINLAG,LINTRF,LINDDL,NDDLIN,NBVECT,LTRAMO,
     &              LMATMO,LCLIN,RANK,LWORK,JWORK,INFO,LPHIEX,LCPET
      REAL*8        SHIFT,SWORK(1)
      COMPLEX*16    CBID
      CHARACTER*1   K1BID
      CHARACTER*4   K4BID
      CHARACTER*8   MODGEN,SST1,KB
      CHARACTER*14  NUME,NUME91
      CHARACTER*19  RAIDE,MASSE, SOLVEU,PRNO, SSAMI,RAIINT
      CHARACTER*24  COINT,NODDLI,MATMOD,VEFREQ,INDIN1,LINO1,TRAMOD,
     &              MODET
      INTEGER       IARG,IRET

C---------------------------------------------------C
C--                                               --C
C-- CALCUL DES MODES D'INTERFACE POUR L'EXPANSION --C
C--                                               --C
C---------------------------------------------------C

C-- RECUPERATION DES MATRICES DE MASSE ET RAIDEUR
      CALL JENONU(JEXNOM(MODGEN//'      .MODG.SSNO',SST1),ISST1)
      CALL JEVEUO(JEXNUM(MODGEN//'      .MODG.SSME',ISST1),'L',
     &                IBID)
      CALL JEVEUO(ZK8(IBID)//'.MAEL_RAID_REFE','L',LBID)
      RAIDE=ZK24(LBID+1)(1:19)
      CALL JEVEUO(ZK8(IBID)//'.MAEL_MASS_REFE','L',LBID)
      MASSE=ZK24(LBID+1)(1:19)

C-- RECUPERATION DU NUME_DDL
      CALL DISMOI('F','NOM_NUME_DDL',MASSE(1:8),'MATR_ASSE',IBID,
     &              NUME,IBID)
      CALL DISMOI('F','PROF_CHNO',NUME,'NUME_DDL',IBID,PRNO,IBID)
      CALL JEVEUO(JEXNUM(PRNO//'.PRNO',1),'L',LPRNO)

      CALL DISMOI('F','NB_EQUA',RAIDE,'MATR_ASSE',NBEQ1,KB,IBID)
      CALL DISMOI('F','NB_EC','DEPL_R','GRANDEUR',NBEC,KB,IBID)

C-- REMPLISSAGE DES VECTEURS D'INDICES ASSOCIES AUX DDL D'INTERFACE
C--      POUR LA CREATION DES MATRICES
      CALL JELIRA(INDIN1,'LONMAX',NBDDL,K1BID)
      CALL JEVEUO(INDIN1,'L',LINDIN)
      NODDLI='&&MOIN93.NOEUDS_DDL_INT'
      CALL JELIRA(LINO1,'LONMAX',NBNO,K1BID)
      CALL JEVEUO(LINO1,'L',LLINO)

      CALL WKVECT(NODDLI,'V V I',9*NBNO,LNOINT)
      CALL WKVECT('&&MOIN93.V_IND_LAG','V V I',2*NBDDL,LINLAG)
      CALL WKVECT('&&MOIN93.DDL_ACTIF_INT','V V I',NBDDL,LINTRF)
      CALL WKVECT('&&MOIN93.V_IND_DDL_INT','V V I',NBDDL,LINDDL)

C-- LA LISTE DES NOEUDS D'INTERFACE DOIT ETRE ORDONNEE
      CALL WKVECT('&&MODEXP.VECT_CLEFS','V V I',NBNO,LCLEF)
      CALL WKVECT('&&MODEXP.VECT_NUM','V V I',NBNO,LNUM)

      DO 10 K1=1,NBNO
        ZI(LCLEF+K1-1)=K1
        ZI(LNUM+K1-1)=ZI(LLINO+K1-1)
 10   CONTINUE
      CALL TRI(ZI(LNUM),ZI(LCLEF),1,NBNO)
      DO 30 K1=1,NBNO
        IK=ZI(LCLEF+K1-1)
        ZI(LNOINT+(K1-1))=ZI(LLINO+IK-1)
        ZI(LNOINT+(K1-1)+NBNO)=ZI(LINDIN+(IK-1)*6)
        ZI(LNOINT+(K1-1)+2*NBNO)=6
        DO 40 J1=1,6
          ZI(LNOINT+(K1-1)+((2+J1)*NBNO))=J1
  40    CONTINUE
  30  CONTINUE
      CALL JEDETR('&&MODEXP.VECT_CLEFS')
      CALL JEDETR('&&MODEXP.VECT_NUM')

      CALL WKVECT('&&MOIN93.IS_DDL_INTERF','V V I',NBEQ1,LDDLD)
      K1=1
      DO 50 I1=1,NBDDL
        IF (ZI(LINDIN+I1-1).GT.0 ) ZI(LDDLD+ZI(LINDIN+I1-1)-1)=1
        IPOS1=ZI(LINDIN+I1-1)
        IF (IPOS1 .GT. 0) THEN
          ZI(LINDDL+K1-1)=IPOS1
          CALL DDLLAG(NUME,IPOS1,NBEQ1,ZI(LINLAG+(K1-1)*2),
     &                ZI(LINLAG+(K1-1)*2+1))
          ZI(LINTRF+K1-1)=I1
          K1=K1+1
        ENDIF
  50  CONTINUE
      NDDLIN=K1-1

C-- CONSTRUCTION DES MATRICES DE MASSE ET DE RAIDEUR DU PROBLEME
C--    D'INTERFACE
      SIZECO=36*NBNO
      COINT='&&MODEXP.CONNEC_INTERF'
      NUME91='&&NUME91'
      RAIINT='&&RAID91'
      SSAMI='&&MASS91'
      CALL WKVECT(COINT,'V V I',SIZECO,LCONNC)
      CALL WKVECT('&&MOIN93.IND_NOEUD','V V I',ZI(LNOINT+NBNO-1),
     &            LINDNO)
      CALL WKVECT('&&MOIN93.IPOS_DDL_INTERF','V V I',NBNO,LIPOS)
      CALL CONINT(NUME,RAIDE,COINT,SIZECO,CONNEC,NODDLI,
     &            NBNO,NUME91,RAIINT,SSAMI)

C-- CALCUL DES MODES DU MODELE D'INTERFACE
      CALL GETVR8(' ','SHIFT',1,IARG,1,SHIFT,IBID)
      SHIFT=-((SHIFT*2.D0*3.1415927D0)**2)
      MATMOD='&&MODEXP.MATRICE_MODES'
      VEFREQ='&&MODEXP.VECTEUR_FREQ'

      CALL CODENT(NUMLIA,'D0',K4BID)
C-- MOUVEMENTS DE L'INTERFACE ESCLAVE A ETENDRE
      CALL JEVEUO('&&OP0091.MAS'//K4BID,'L',LMAST)
      CALL JELIRA('&&OP0091.MAS'//K4BID,'LONMAX',IBID,KB)
      NL=INT(IBID/NBMOD)

C-- MATRICE D'OBSERVATION
      CALL JELIRA(TRAMOD,'LONMAX',IBID,KB)
      NC=INT(IBID/NL)
      CALL JEVEUO(TRAMOD,'L',LTRAMO)

      NBVECT=1

C-- ON BOUCLE POUR AVOIR UNE EXPANSION CORRECTE. TANT QUE C'EST PAS BON,
C-- ON ENRICHIT LA BASE DES MODES D'INTERFACE
 500  CONTINUE
      CALL MODINT(SSAMI,RAIINT,NDDLIN,NBVECT,SHIFT,MATMOD,MASSE,
     &              RAIDE,NBEQ1,COINT,NODDLI,NBNO,VEFREQ,0)
      CALL JEVEUO(MATMOD,'L',LMATMO)

C---------------------------C
C--                       --C
C-- EXPANSION DES DONNEES --C
C--                       --C
C---------------------------C

C-- TAILLES DES MATRICES
C--
C--  C      : NL x NC
C--  MATMOD : NC x NBVECT
C--  CPHI   : NL x NBVECT


C-- PRODUIT C*PHI_mast

      CALL MATFPE(-1)
      CALL WKVECT('&&MODEXP.CPHI','V V R',NL*NBVECT,LCPHI)

      DO 300 J1=1,NBVECT
        DO 310 K1=1,NC
          DO 320 I1=1,NL
            ZR(LCPHI+(J1-1)*NL+I1-1)=ZR(LCPHI+(J1-1)*NL+I1-1)+
     &         ZR(LTRAMO+(K1-1)*NL+(I1-1))*ZR(LMATMO+(J1-1)*NC+(K1-1))
 320      CONTINUE
 310    CONTINUE
 300  CONTINUE
C      CALL DGEMM('N','N',NL,NBVECT,NC,1.,ZR(LTRAMO),
C     &            NL,ZR(LMATMO),NC,0.,ZR(LCPHI),NL)

C-- EXPANSION DE DONNEES
      IBID=MAX(NL,NBVECT)
      CALL WKVECT('&&MODEXP.COMB_LIN','V V R',IBID*NBMOD,LCLIN)

C-- RECOPIE A LA MAIN POUR ETRE COMPATIBLE AVEC LES TAILLES
      DO 60 J1=1,NBMOD
        DO 70 I1=1,NL
          ZR(LCLIN+(J1-1)*MAX(NL,NBVECT)+(I1-1)) =
     &     ZR(LMAST+(J1-1)*NL+(I1-1))
  70    CONTINUE
  60  CONTINUE

      CALL WKVECT('&&MODEXP.VEC_VAL_SING','V V R',MIN(NL,NBVECT),IBID)

      CALL DGELSS(NL,NBVECT,NBMOD,ZR(LCPHI),NL,ZR(LCLIN),MAX(NL,NBVECT),
     &            ZR(IBID),-1.0D0,RANK,SWORK,-1,INFO)

      LWORK=INT(SWORK(1))
      CALL WKVECT('&&MODEXP.MAT_AXB','V V R',LWORK,JWORK)

      CALL DGELSS(NL,NBVECT,NBMOD,ZR(LCPHI),NL,ZR(LCLIN),MAX(NL,NBVECT),
     &            ZR(IBID),1.0D-12,RANK,ZR(JWORK),LWORK,INFO)

C-- MOUVEMENTS DE L'INTERFACE
      CALL WKVECT('&&MODEXP.PHI_EXP','V V R',NC*NBMOD,LPHIEX)

      DO 450 J1=1,NBMOD
        DO 460 K1=1,NBVECT
          DO 470 I1=1,NC
            ZR(LPHIEX+(J1-1)*NC+I1-1)=ZR(LPHIEX+(J1-1)*NC+I1-1)+
     &      ZR(LMATMO+(K1-1)*NC+(I1-1))*ZR(LCLIN+(J1-1)*NBVECT+(K1-1))
 470      CONTINUE
 460    CONTINUE
 450  CONTINUE

C-- PROJECTION POUR VERIFIER L'EXPANSION
      CALL WKVECT('&&MODEXP.C_PHI_EXP','V V R',NL*NBMOD,LCPET)

      DO 150 J1=1,NBMOD
        DO 160 K1=1,NC
          DO 170 I1=1,NL
            ZR(LCPET+(J1-1)*NL+I1-1)=ZR(LCPET+(J1-1)*NL+I1-1)+
     &         ZR(LTRAMO+(K1-1)*NL+(I1-1))*ZR(LPHIEX+(J1-1)*NC+(K1-1))
 170      CONTINUE
 160    CONTINUE
 150  CONTINUE

C-- VERIFICATION DE LA QUALITE DE L'EXPANSION

      CALL WKVECT('&&MODEXP.NORM_RESIDU','V V R',NBMOD,LNRES)

C-- NORME DE LA DIFFERENCE
      SWORK(1)=0
      DO 80 J1=1,NBMOD
        DO 90 I1=1,NL
          ZR(LNRES+J1-1)=ZR(LNRES+J1-1)+( ZR(LMAST+(J1-1)*NL+(I1-1)) -
     &      ZR(LCPET+(J1-1)*NL+(I1-1)) )**2
  90    CONTINUE
        ZR(LNRES+J1-1)=SQRT(ZR(LNRES+J1-1))/NL
        SWORK(1)=MAX(SWORK(1),ZR(LNRES+J1-1))
  80  CONTINUE

      CALL MATFPE(1)

      IF (SWORK(1) .GT. 1.D-3) THEN

        IF (NBVECT .GT. NDDLIN) THEN
C-- ON N'ARRIVE PAS A AVOIR UNE EXPANSION CORRECTE
          CALL ASSERT(.FALSE.)
        ENDIF
        NBVECT=NBVECT+NBMOD

        CALL JEDETR('&&OP0091.MAT_SM1XUT')
        CALL JEDETR('&&OP0091.MAT_VXSM1XUT')
        CALL JEDETR('&&OP0091.MAT_S')
        CALL JEDETR('&&OP0091.MAT_U')
        CALL JEDETR('&&OP0091.MAT_V')
        CALL JEDETR('&&MODINT.INTERFACES_SST')
        CALL JEDETR('&&MODEXP.CPHI')
        CALL JEDETR('&&MODEXP.COMB_LIN')
        CALL JEDETR('&&MODEXP.VEC_VAL_SING')
        CALL JEDETR('&&MODEXP.MAT_AXB')
        CALL JEDETR('&&MODEXP.PHI_EXP')
        CALL JEDETR('&&MODEXP.MATRICE_MODES')
        CALL JEDETR('&&MODEXP.C_PHI_EXP')
        CALL JEDETR('&&MODEXP.NORM_RESIDU')
        GOTO 500
      ENDIF

C-------------------------C
C--                     --C
C-- RELEVEMENT STATIQUE --C
C--                     --C
C-------------------------C

      CALL WKVECT(MODET,'V V R',NBEQ1*NBMOD,LMODET)

      IF (NC .NE. NDDLIN) THEN
        CALL ASSERT(.FALSE.)
      ENDIF

C-- EXPANSION STATIQUE

      DO 100 J1=1,NBMOD
        DO 110 I1=1,NDDLIN
          ZR(LMODET + (J1-1)*NBEQ1 + ZI(LINLAG+(I1-1)*2) -1 ) =
     &      ZR(LPHIEX + (J1-1)*NC + (I1-1))
          ZR(LMODET + (J1-1)*NBEQ1 + ZI(LINLAG+(I1-1)*2+1) -1 ) =
     &      ZR(LPHIEX + (J1-1)*NC + (I1-1))
  110   CONTINUE
  100 CONTINUE

      CALL DISMOI('F','SOLVEUR',RAIDE,'MATR_ASSE',IBID,SOLVEU,IBID)
      CALL PRERES(SOLVEU,'V',INFO,'&&OP0091.MATPRE',RAIDE,IBID,1)
      CALL RESOUD(RAIDE ,'&&MOIN93.MATPRE',SOLVEU,' '       ,NBMOD ,
     &            ' '   ,' '              ,' '   ,ZR(LMODET),CBID  ,
     &            ' '   ,.TRUE.           ,0     ,IRET      )

C------------C
C-- MENAGE --C
C------------C
      CALL JEDETR('&&MODEXP.CPHI')
      CALL JEDETR('&&MODEXP.COMB_LIN')
      CALL JEDETR('&&MODEXP.PHI_EXP')
      CALL JEDETR('&&MODEXP.VEC_VAL_SING')
      CALL JEDETR('&&MODEXP.MAT_AXB')
      CALL JEDETR('&&MODEXP.CONNEC_INTERF')
      CALL JEDETR('&&MOIN93.NOEUDS_DDL_INT')
      CALL JEDETR('&&MOIN93.V_IND_LAG')
      CALL JEDETR('&&MOIN93.DDL_ACTIF_INT')
      CALL JEDETR('&&MOIN93.V_IND_DDL_INT')
      CALL JEDETR('&&MOIN93.IS_DDL_INTERF')
      CALL JEDETR('&&MOIN93.IND_NOEUD')
      CALL JEDETR('&&MOIN93.IPOS_DDL_INTERF')
      CALL JEDETR('&&MODL91      .MODG.SSNO')
      CALL JEDETR('&&MODL91      .MODG.SSME')
      CALL JEDETR('&&MODINT.INTERFACES_SST')
      CALL JEDETR('&&MODEXP.C_PHI_EXP')
      CALL JEDETR('&&MODEXP.NORM_RESIDU')

      CALL DETRSD('MATR_ASSE','&&RAID91')
      CALL DETRSD('MATR_ASSE','&&MASS91')
      CALL JEDETC('V','&&NUME91',1)
      CALL JEDETR('&&MODEXP.MATRICE_MODES')
      CALL JEDETR('&&MODEXP.VECTEUR_FREQ')

      END
