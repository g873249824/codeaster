      SUBROUTINE PMDORC(COMPOR,CARCRI,NBVARI,K)
      IMPLICIT NONE
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 12/12/2011   AUTEUR PROIX J-M.PROIX 
C ======================================================================
C COPYRIGHT (C) 1991 - 2011  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
C (AT YOUR OPTION) ANY LATER VERSION.                                   
C                                                                       
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
C                                                                       
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.         
C ======================================================================
C RESPONSABLE PROIX J-M.PROIX
C-----------------------------------------------------------------------
C           OPERATEUR    CALC_POINT_MAT : LECTURE COMPOR ET CARCRI
C-----------------------------------------------------------------------
C      IDEM NMDORC MAIS SANS MODELEK
C ----------------------------------------------------------------------
C OUT COMPOR  : OBJET COMPOR(8) DECRIVANT LE TYPE DE COMPORTEMENT
C OUT CARCRI  : OBJET CARCRI(9) CRITERES DE CONVERGENCE LOCAUX
C OUT NBVARI  : NOMBRE DE VARIABLE INTERNES
C OUT k       : =1 si COMP_INCR, =2 si COMP_ELAS
C -------------- DEBUT DECLARATIONS NORMALISEES  JEVEUX ----------------
      INTEGER ZI
      COMMON /IVARJE/ ZI(1)
      REAL*8 ZR
      COMMON /RVARJE/ ZR(1)
      COMPLEX*16 ZC
      COMMON /CVARJE/ ZC(1)
      LOGICAL ZL
      COMMON /LVARJE/ ZL(1)
      CHARACTER*8 ZK8
      CHARACTER*16 ZK16
      CHARACTER*24 ZK24
      CHARACTER*32 ZK32
      CHARACTER*80 ZK80
      COMMON /KVARJE/ ZK8(1),ZK16(1),ZK24(1),ZK32(1),ZK80(1)
C -------------- FIN  DECLARATIONS  NORMALISEES  JEVEUX ----------------
      INTEGER      IRET,N1,NBVARI,K,ICPRI,TYPTGT,EXITS
      INTEGER      NCOMEL,NUMLC,ITEINT,ITEPAS,ITDEBO,NBOCC,IRETT
      INTEGER      GETEXM,NUNIT,IARG,INDIMP,NCMPMA,DIMAKI,DIMANV,II
C    DIMAKI = DIMENSION MAX DE LA LISTE DES RELATIONS KIT
      PARAMETER (DIMAKI=9)
C    DIMANV = DIMENSION MAX DE LA LISTE DU NOMBRE DE VAR INT EN THM
      PARAMETER (DIMANV=4)
      PARAMETER (NCMPMA=7+DIMAKI+DIMANV)
      CHARACTER*8  SDCOMP,TAVARI
      CHARACTER*16 COMPOR(NCMPMA),COMP,COMCOD,ALGO,LCOMEL(5),MOCLEF(2)
      CHARACTER*16 TYMATG,TEXTE(2),TXCP,DEFO
      CHARACTER*16 NOMSUB
      CHARACTER*128 NOMLIB
      REAL*8       CARCRI(10),RESI,ALGOR
      REAL*8       RESID,PERT,THETA,TSEUIL,TOLRAD
      LOGICAL ISZMAT
      SAVE INDIMP
      DATA INDIMP /1/
C-----------------------------------------------------------------------

      CALL JEMARQ()
      MOCLEF(1) = 'COMP_INCR'
      MOCLEF(2) = 'COMP_ELAS'
      CALL GETFAC(MOCLEF(1),NBOCC)
      IF (NBOCC.GT.0) THEN
         K=1
      ELSE
         K=2
      ENDIF
C     COMPORTEMENT
      ISZMAT = .FALSE.
      CALL GETVTX(MOCLEF(K),'RELATION',1,IARG,1,COMP,N1)
      NCOMEL=1
      LCOMEL(NCOMEL)=COMP
C     SAISIE ET VERIFICATION DE DEBORST
      CALL NMDOCP(MOCLEF(K),COMPOR,1,NCOMEL,LCOMEL,TXCP)
      IF (TXCP.EQ.'DEBORST') THEN
         TEXTE(1)='SIMU_POINT_MAT'
         TEXTE(2)=COMP
         CALL U2MESG('A','COMPOR1_52',2,TEXTE,0,0,0,0.D0)
      ENDIF
      
C     APPEL A LCINFO POUR RECUPERER LE NOMBRE DE VARIABLES INTERNES
      CALL LCCREE(NCOMEL, LCOMEL, COMCOD)
      CALL LCINFO(COMCOD, NUMLC, NBVARI)   
      
C     NOMS DES VARIABLES INTERNES
      IF ((NBVARI.GT.0).AND.(INDIMP.EQ.1)) THEN
         CALL IMVARI(MOCLEF(K),1,NCOMEL, LCOMEL,COMCOD,NBVARI,TAVARI)
      ENDIF
      INDIMP=0
                  
      CALL GETVTX(MOCLEF(K),'DEFORMATION',1,IARG,1,DEFO,N1)
C     VERIF QUE DEFO EST POSSIBLE POUR COMP
      CALL LCTEST(COMCOD,'DEFORMATION',DEFO,IRET)
      IF (IRET.EQ.0) THEN
        TEXTE(1)=DEFO
        TEXTE(2)=COMP
        CALL U2MESG('F','COMPOR1_44',2,TEXTE,0,0,0,0.D0)
      ENDIF
            IF (DEFO.EQ.'SIMO_MIEHE') NBVARI=NBVARI+6
      
C     CAS PARTICULIER DU MONOCRISTAL
      IF (COMP(1:8).EQ.'MONOCRIS') THEN
        CALL GETVID(MOCLEF(K),'COMPOR',1,IARG,1,SDCOMP,N1)
        CALL JEVEUO(SDCOMP//'.CPRI','L',ICPRI)
        NBVARI=ZI(ICPRI-1+3)
        COMPOR(7) = SDCOMP
        IF (TXCP.EQ.'DEBORST') NBVARI=NBVARI+4
        IF (DEFO.EQ.'SIMO_MIEHE') NBVARI=NBVARI+9+9
      ELSEIF (COMP(1:8).EQ.'POLYCRIS') THEN
        CALL GETVID(MOCLEF(K),'COMPOR',1,IARG,1,SDCOMP,N1)
        CALL JEVEUO(SDCOMP//'.CPRI','L',ICPRI)
        NBVARI=ZI(ICPRI-1+3)
        COMPOR(7) = SDCOMP
        IF (TXCP.EQ.'DEBORST') NBVARI=NBVARI+4
      ENDIF
      
      IF (COMP(1:4).EQ.'ZMAT') THEN
        ISZMAT = .TRUE.
        CALL GETVIS(MOCLEF(K),'NB_VARI',1,IARG,1,NBVARI,N1)
        CALL GETVIS(MOCLEF(K),'UNITE',1,IARG,1,NUNIT,N1)
        WRITE (COMPOR(7),'(I16)') NUNIT
      ELSEIF (COMP(1:4).EQ.'UMAT') THEN
        CALL GETVIS(MOCLEF(K),'NB_VARI',1,IARG,1,NBVARI,N1)
C       POUR LES COMPORTEMENTS UMAT
C       ON STOCKE LA LIB DANS KIT1-KIT8 (128 CARACTERES)
C       ET LA SUBROUTINE DANS KIT9
        CALL GETVTX(MOCLEF, 'LIBRAIRIE',1,IARG,1,NOMLIB,N1)
        CALL GETVTX(MOCLEF, 'NOM_ROUTINE',1,IARG,1,NOMSUB,N1)
        DO 30 II = 1,DIMAKI-1
          COMPOR(II+7) = NOMLIB(16*(II-1)+1:16*II)
  30    CONTINUE
        COMPOR(DIMAKI+7) = NOMSUB
C       POUR EVITER DE PLANTER DANS LC0050 / TECAEL
        COMP(9:16)='OP0033__'       
      ENDIF
      COMPOR(1)=COMP
      WRITE (COMPOR(2),'(I16)') NBVARI
      COMPOR(3)=DEFO
      COMPOR(4)=MOCLEF(K)
      COMPOR(5)=TXCP
      WRITE (COMPOR(6),'(I16)') NUMLC

C     ALGORITHME D'INTEGRATION
      CALL GETVTX(MOCLEF(K),'ALGO_INTE',1,IARG,1,ALGO,IRET) 
      IF (IRET.EQ.0) THEN
C        LOI DE COMPORTEMENT (1ERE VALEUR DE LA LISTE)
         CALL LCALGO(COMCOD,ALGO)
       ENDIF

C     CRITERES DE CONVERGENCE 
      CALL GETVR8(MOCLEF(K),'RESI_INTE_RELA',1,IARG,1,RESI,IRET)
      CALL GETVIS(MOCLEF(K),'ITER_INTE_MAXI',1,IARG,1,ITEINT,IRET)

      ITEPAS = 0
      IF (K.EQ.1) THEN
         CALL GETVIS(MOCLEF(K),'ITER_INTE_PAS' ,1,IARG,1,ITEPAS,IRET)
      ENDIF

C     CPLAN DEBORST  ET COMP1D DEBORST SEULEMENT EN COMP_INCR
      RESID=1.D-6
      PERT=0.D0
      ITDEBO=1
C     PASSAGE NOM ALGO -> IDENTIFICATEUR (VALEUR REELLE)
      CALL UTLCAL('NOM_VALE',ALGO,ALGOR)
      TYPTGT = 0
      IF ( MOCLEF(K).EQ. 'COMP_INCR') THEN
         EXITS = GETEXM(MOCLEF(K),'TYPE_MATR_TANG')
         IF (EXITS .EQ. 1) THEN
C        dans ZR(JVALV+1) on stocke le type de matrice tgte
         CALL GETVTX(MOCLEF(K),'TYPE_MATR_TANG',1,IARG,1,TYMATG,IRET)
            IF (IRET.EQ.0) THEN
               TYPTGT = 0
            ELSE
               IF (TYMATG.EQ.'PERTURBATION') THEN
                  TYPTGT = 1
                  CALL GETVR8(MOCLEF(K),'VALE_PERT_RELA',1,IARG,1,
     &                        PERT,IRET)
               ELSEIF (TYMATG.EQ.'VERIFICATION') THEN
                  TYPTGT = 2
                  CALL GETVR8(MOCLEF(K),'VALE_PERT_RELA',1,IARG,1,
     &                        PERT,IRET)
               ENDIF
C              Verif que TYMATG est possible pour COMP
               CALL LCTEST(COMCOD,'TYPE_MATR_TANG',TYMATG,IRETT)
               IF (IRETT.EQ.0) THEN
                  TEXTE(1)=TYMATG
                  TEXTE(2)=COMP
                  CALL U2MESG('F','COMPOR1_46',2,TEXTE,0,0,0,0.D0)
               ENDIF
            ENDIF
         ENDIF
      ENDIF
C      IF (TYMATG(1:16).NE.'TANGENTE_SECANTE') THEN
C         CALL GETVR8(MOCLEF(K),'RESI_RADI_RELA',1,IARG,1,
C     &                        TOLRAD,IRET)
C         IF (IRET.NE.0) THEN 
C            TSEUIL=TOLRAD
C         ELSE
C            TSEUIL=-10.D0
C         ENDIF
C      ENDIF
          

      IF (K.EQ.1) THEN
         CALL GETVIS(MOCLEF(K),'ITER_MAXI_DEBORST',
     &           1,IARG,1,ITDEBO,IRET)
         CALL GETVR8(MOCLEF(K),'RESI_DEBO_MAXI',1,IARG,1,
     &              RESID,IRET)
         IF (IRET.NE.0) THEN
            RESID=-RESID
         ELSE
            CALL GETVR8(MOCLEF(K),'RESI_DEBO_RELA',1,IARG,1,
     &              RESID,IRET)
         ENDIF
      ENDIF
      IF (K.EQ.1) THEN
          CALL GETVR8(MOCLEF(K),'PARM_THETA',1,IARG,1,THETA,IRET)
      ELSE
          THETA=1.D0
      ENDIF
      CARCRI(1)=ITEINT
      CARCRI(2)=TYPTGT
      CARCRI(3)=RESI
      CARCRI(4)=THETA
      CARCRI(5)=ITEPAS
      CARCRI(6)=ALGOR
      CARCRI(7)=PERT
      CARCRI(8)=RESID
      CARCRI(9)=ITDEBO
C      CARCRI(10)=TSEUIL
C
C     SI ZMAT, ON REINITIALISE LES ZASTER_HANDLER POUR FORCER
C     LA RELECTURE DES FICHIERS DECRIVANT LES COMPORTEMENTS
      IF (ISZMAT) THEN
        CALL ZASWRI()
      ENDIF
C
      CALL JEDEMA()
C
      END
