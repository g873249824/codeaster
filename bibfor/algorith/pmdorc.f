      SUBROUTINE PMDORC(COMPOR,CARCRI,NBVARI)
      IMPLICIT NONE
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 23/03/2010   AUTEUR PROIX J-M.PROIX 
C ======================================================================
C COPYRIGHT (C) 1991 - 2010  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
C (AT YOUR OPTION) ANY LATER VERSION.                                   
C                                                                       
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
C                                                                       
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.         
C ======================================================================
C RESPONSABLE PROIX J-M.PROIX
C-----------------------------------------------------------------------
C           OPERATEUR    CALC_POINT_MAT : LECTURE COMPOR ET CARCRI
C-----------------------------------------------------------------------
C      IDEM NMDORC MAIS SANS MODELE
C ----------------------------------------------------------------------
C OUT COMPOR  : OBJET COMPOR(8) DECRIVANT LE TYPE DE COMPORTEMENT
C OUT CARCRI  : OBJET CARCRI(9) CRITERES DE CONVERGENCE LOCAUX
C OUT NBVARI  : NOMBRE DE VARIABLE INTERNES
C
C -------------- DEBUT DECLARATIONS NORMALISEES  JEVEUX ----------------
      INTEGER ZI
      COMMON /IVARJE/ ZI(1)
      REAL*8 ZR
      COMMON /RVARJE/ ZR(1)
      COMPLEX*16 ZC,CBID
      COMMON /CVARJE/ ZC(1)
      LOGICAL ZL
      COMMON /LVARJE/ ZL(1)
      CHARACTER*8 ZK8
      CHARACTER*16 ZK16
      CHARACTER*24 ZK24,K24BID
      CHARACTER*32 ZK32
      CHARACTER*80 ZK80
      COMMON /KVARJE/ ZK8(1),ZK16(1),ZK24(1),ZK32(1),ZK80(1)
C -------------- FIN  DECLARATIONS  NORMALISEES  JEVEUX ----------------
      INTEGER      IRET,N1,NBVARI,I,K,ICPRI,JVALV,ICOMPO,TYPTGT,EXITS
      INTEGER      NCOMEL,NUMLC,ITEINT,ITEPAS,ITDEBO,IMPEXP,NBOCC,IRETT
      INTEGER      GETEXM
      CHARACTER*16 COMPOR(8),COMP,COMCOD,RESO,LCOMEL(5),MOCLEF(2),TXCP
      CHARACTER*16 DEFO,COMPK,TYMATG,TEXTE(2)
      CHARACTER*8  SDCOMP
      CHARACTER*19 CODI
      REAL*8       R8B,CARCRI(9),RESI,R8PREM
      REAL*8       RESID,PERT,THETA
      REAL*8       VALIMP(6),R(12),RINI(12),Y(12),DY(12),DDY(12),ID(6,6)
      REAL*8       DSIDEP(6,6),DRDY(12,12),KEL(6,6),CIMPO(6,12),YM(12)
      REAL*8       EE,E1,E2,TOLER,E1INI,E2INI

      CALL JEMARQ()
      MOCLEF(1) = 'COMP_INCR'
      MOCLEF(2) = 'COMP_ELAS'
      CALL GETFAC(MOCLEF(1),NBOCC)
      IF (NBOCC.GT.0) THEN
         K=1
      ELSE
         K=2
      ENDIF
C     COMPORTEMENT
      CALL GETVTX(MOCLEF(K),'RELATION',1,1,1,COMP,N1)
      NCOMEL=1
      LCOMEL(NCOMEL)=COMP
C     SAISIE ET VERIFICATION DE DEBORST
      CALL NMDOCP(MOCLEF(K),COMPOR,1,NCOMEL,LCOMEL,TXCP)
C     APPEL A LCINFO POUR RECUPERER LE NOMBRE DE VARIABLES INTERNES
      CALL LCCREE(NCOMEL, LCOMEL, COMCOD)
      CALL LCINFO(COMCOD, NUMLC, NBVARI)      
C         CAS PARTICULIER DE MONOCRISTAL
          IF (COMP(1:8).EQ.'MONOCRIS') THEN
            CALL GETVID(MOCLEF(K),'COMPOR',1,1,1,SDCOMP,N1)
            CALL JEVEUO(SDCOMP//'.CPRI','L',ICPRI)
            NBVARI=ZI(ICPRI-1+3)
            COMPOR(7) = SDCOMP
C            COMPK=SDCOMP(1:8)//'.CPRK'
C            CALL JEVEUO(COMPK,'L',ICOMPO)
C            CALL PMMACO ( ZK16(ICOMPO), CODI, JVALV )

            IF (TXCP.EQ.'DEBORST') NBVARI=NBVARI+4
          ELSEIF (COMP(1:8).EQ.'POLYCRIS') THEN
            CALL GETVID(MOCLEF(K),'COMPOR',K,1,1,SDCOMP,N1)
            CALL JEVEUO(SDCOMP//'.CPRI','L',ICPRI)
            NBVARI=ZI(ICPRI-1+3)
            COMPOR(7) = SDCOMP
            IF (TXCP.EQ.'DEBORST') NBVARI=NBVARI+4
          ENDIF
      COMPOR(1)=COMP
      WRITE (COMPOR(2),'(I16)') NBVARI
      COMPOR(3)='PETIT'
      COMPOR(4)=MOCLEF(K)
      COMPOR(5)=TXCP
      WRITE (COMPOR(6),'(I16)') NUMLC
C     CRITERES DE CONVERGENCE 
      CALL GETVTX(MOCLEF(K),'RESO_INTE',K,1,1,RESO,IRET) 
      CALL GETVR8(MOCLEF(K),'RESI_INTE_RELA',K,1,1,RESI,IRET)
      CALL GETVIS(MOCLEF(K),'ITER_INTE_MAXI',K,1,1,ITEINT,IRET)
      CALL GETVIS(MOCLEF(K),'ITER_INTE_PAS' ,K,1,1,ITEPAS,IRET)
C     CPLAN DEBORST  ET COMP1D DEBORST SEULEMENT EN COMP_INCR
      RESID=1.D-6
      PERT=0.D0
      ITDEBO=1
      IMPEXP=-999
      IF(RESO.EQ.'IMPLICITE')     IMPEXP = 0
      IF(RESO.EQ.'RUNGE_KUTTA_2') IMPEXP = 1
      IF(RESO.EQ.'RUNGE_KUTTA_4') IMPEXP = 2
      IF(RESO.EQ.'IMPLICITE_RELI')IMPEXP = 3
      TYPTGT = 0
      IF ( MOCLEF(K).EQ. 'COMP_INCR') THEN
         EXITS = GETEXM(MOCLEF(K),'TYPE_MATR_TANG')
         IF (EXITS .EQ. 1) THEN
C        dans ZR(JVALV+1) on stocke le type de matrice tgte
         CALL GETVTX(MOCLEF(K),'TYPE_MATR_TANG',K,1,1,TYMATG,IRET)
            IF (IRET.EQ.0) THEN
               TYPTGT = 0
            ELSE
               IF (TYMATG.EQ.'PERTURBATION') THEN
                  TYPTGT = 1
                  CALL GETVR8(MOCLEF(K),'VALE_PERT_RELA',K,1,1,
     &                        PERT,IRET)
               ELSEIF (TYMATG.EQ.'VERIFICATION') THEN
                  TYPTGT = 2
                  CALL GETVR8(MOCLEF(K),'VALE_PERT_RELA',K,1,1,
     &                        PERT,IRET)
               ENDIF
C              Verif que TYMATG est possible pour COMP
               CALL LCTEST(COMCOD,'TYPE_MATR_TANG',TYMATG,IRETT)
               IF (IRETT.EQ.0) THEN
                  TEXTE(1)=TYMATG
                  TEXTE(2)=COMP
                  CALL U2MESG('F','COMPOR1_46',2,TEXTE,0,0,0,0.D0)
               ENDIF
            ENDIF
         ENDIF
      ENDIF

      IF (K.EQ.1) THEN
         CALL GETVIS(MOCLEF(K),'ITER_MAXI_DEBORST',
     &           K,1,1,ITDEBO,IRET)
         CALL GETVR8(MOCLEF(K),'RESI_DEBO_MAXI',K,1,1,
     &              RESID,IRET)
         IF (IRET.NE.0) THEN
            RESID=-RESID
         ELSE
            CALL GETVR8(MOCLEF(K),'RESI_DEBO_RELA',K,1,1,
     &              RESID,IRET)
         ENDIF
      ENDIF
      IF (K.EQ.1) THEN
          CALL GETVR8(MOCLEF(K),'PARM_THETA',K,1,1,THETA,IRET)
      ELSE
          THETA=1.D0
      ENDIF
      CARCRI(1)=ITEINT
      CARCRI(2)=TYPTGT
      CARCRI(3)=RESI
      CARCRI(4)=THETA
      CARCRI(5)=ITEPAS
      CARCRI(6)=IMPEXP
      CARCRI(7)=PERT
      CARCRI(8)=RESID
      CARCRI(9)=ITDEBO
      
      CALL JEDEMA()
C
      END
