      SUBROUTINE XCONNO(MOX,CHFIS,BASE,OPT,PARAM,CHGLO)

C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 28/09/2010   AUTEUR MASSIN P.MASSIN 
C ======================================================================
C COPYRIGHT (C) 1991 - 2007  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================

      IMPLICIT NONE
      CHARACTER*(*) OPT,PARAM
      CHARACTER*1   BASE
      CHARACTER*19  CHGLO
      CHARACTER*11  CHFIS
      CHARACTER*8   MOX

C----------------------------------------------------------------------
C  BUT: CONCATENER LES CHAMPS NODAUX DES SD FISS_XFEM
C       DANS UN CHAMP GLOBAL ELNO AFFECTE AU MODELE
C
C----------------------------------------------------------------------
C
C     ARGUMENTS/
C  MOX     IN    K19 : MODELE XFEM
C  CHFIS   IN    K19 : SUFFIXE DU NOM DU CHAMP NODAL A CONCATENER
C  CHGLO   OUT   K19 : CHAMP GLOBAL RESULTANT
C  BASE    IN    K1  : BASE DE CREATION POUR CHGLO : G/V/L
C
C -------------- DEBUT DECLARATIONS NORMALISEES JEVEUX -----------------
C
      INTEGER ZI
      COMMON /IVARJE/ ZI(1)
      REAL*8 ZR
      COMMON /RVARJE/ ZR(1)
      COMPLEX*16 ZC
      COMMON /CVARJE/ ZC(1)
      LOGICAL ZL
      COMMON /LVARJE/ ZL(1)
      CHARACTER*8 ZK8
      CHARACTER*16 ZK16
      CHARACTER*24 ZK24
      CHARACTER*32 ZK32
      CHARACTER*80 ZK80
      COMMON /KVARJE/ ZK8(1),ZK16(1),ZK24(1),ZK32(1),ZK80(1)
C
C ---------------- FIN DECLARATIONS NORMALISEES JEVEUX -----------------
C
      INTEGER NFIS,IFIS,JJ,INO,II,KK
      INTEGER IMA,ICMP,NBNOM,JMACNX,JLCNX
      INTEGER IBID,JINDIC,JG,NMAENR,I
      INTEGER JNFIS,JCNSD,JCNSC,JCNSV,JCNSK,JCNSL,JCNSV2,JCNSL2
      INTEGER NCMP1,JMOFIS,JCESD,JCESV,JCESL,IAD,JNBSP,NNCP
      CHARACTER*3  TSCA
      CHARACTER*19  CES, CNS,LIGREL,CNS2,NOXFEM
      CHARACTER*24  INDIC,GRP(3)
      CHARACTER*32  JEXATR
      LOGICAL       COMPCH,LSTNO
      CHARACTER*8   MA,NOMGD,NOMFIS,LICMP(2)
C     ------------------------------------------------------------------

      CALL JEMARQ()
      CES = '&&XCONNO.CES'
      CNS = '&&XCONNO.CNS'
      LIGREL = MOX(1:8)//'.MODELE'
      LSTNO = CHFIS.EQ.'.STNO'

C     1.RECUPERATION D'INFORMATIONS DANS MOX

      CALL JEVEUO(MOX//'.NFIS','L',JNFIS)
      NFIS = ZI(JNFIS)

      CALL JEVEUO(MOX//'.FISS','L',JMOFIS)
      NOMFIS = ZK8(JMOFIS)

      CALL CNOCNS(NOMFIS//CHFIS,'V',CNS)

      CALL JEVEUO(CNS//'.CNSK','L',JCNSK)
      CALL JEVEUO(CNS//'.CNSD','L',JCNSD)
      CALL JEVEUO(CNS//'.CNSC','L',JCNSC)
      CALL JEVEUO(CNS//'.CNSV','L',JCNSV)
      CALL JEVEUO(CNS//'.CNSL','L',JCNSL)

      MA = ZK8(JCNSK-1+1)
      NOMGD = ZK8(JCNSK-1+2)
C      NBNOM = ZI(JCNSD-1+1)
      NCMP1 = ZI(JCNSD-1+2)

      CALL JEVEUO(MA//'.CONNEX','L',JMACNX)
      CALL JEVEUO(JEXATR(MA//'.CONNEX','LONCUM'),'L',JLCNX)

      CALL DISMOI('F','TYPE_SCA',NOMGD,'GRANDEUR',IBID,TSCA,IBID)
C
C --- RECUPERATION DU NOMBRE DE SOUS POINT (NBRE DE FISSURES VUES)
C
      CALL JEVEUO('&&XTYELE.NBSP','L',JNBSP)
C
C --- CREATION DE LA SD ELNO
C
      CALL CESCRE('V',CES,'ELNO',MA,NOMGD,NCMP1,ZK8(JCNSC),
     &              IBID,ZI(JNBSP),-NCMP1)
C
      CALL JEVEUO(CES//'.CESD','L',JCESD)
      CALL JEVEUO(CES//'.CESV','E',JCESV)
      CALL JEVEUO(CES//'.CESL','E',JCESL)
C
C --- ON CREE LA SD MODELE.NOXFEM EN MEME TEMPS QUE MODELE.STNO
C
      IF (LSTNO) THEN
        CNS2 = '&&XCONNO.CNS2'
        LICMP(1) = 'X1'
        LICMP(2) = 'X2'
        CALL CNSCRE(MA,'NEUT_I',2,LICMP,'V',CNS2)
        CALL JEVEUO(CNS2//'.CNSV','E',JCNSV2)
        CALL JEVEUO(CNS2//'.CNSL','E',JCNSL2)
      ENDIF
C
      DO 20 IFIS = 1,NFIS

        CALL JEVEUO(MOX//'.FISS','L',JMOFIS)
        NOMFIS = ZK8(JMOFIS-1 + IFIS)
        CALL CNOCNS(NOMFIS//CHFIS,'V',CNS)

        GRP(1)=NOMFIS//'.MAILFISS  .HEAV'
        GRP(2)=NOMFIS//'.MAILFISS  .CTIP'
        GRP(3)=NOMFIS//'.MAILFISS  .HECT'

        CALL JEVEUO(CNS//'.CNSV','L',JCNSV)
        CALL JEVEUO(CNS//'.CNSL','L',JCNSL)

        INDIC=NOMFIS//'.MAILFISS .INDIC'
        CALL JEVEUO(INDIC,'L',JINDIC)

        DO 1000, II = 1,3
C--COPIER LE CHAMP 'CHFIS' POUR LES MAILLES '.HEAV','.CTIP' ET '.HECT'
          IF (ZI(JINDIC-1+2*(II-1)+1).EQ.1) THEN
            CALL JEVEUO(GRP(II),'L',JG)
            NMAENR=ZI(JINDIC-1+2*II)

            DO 120 I=1,NMAENR
              IMA   = ZI(JG-1+I)
              NBNOM = ZI(JLCNX+IMA)-ZI(JLCNX-1+IMA)
              DO 1210, JJ = 1,NBNOM
                INO = ZI(JMACNX + ZI(JLCNX-1+IMA)-2+JJ)
                DO 1220, ICMP = 1,NCMP1

C                 POUR CHAQUE TYPE 'R', I', 'L', 'K8', SI LE CHAM_NO
C                 A DEJE ETE REMPLI, ON INCREMENTE LE SOUS POINT
C                 4 FISSURES AU MAXIMUM POUR L'INSTANT, SINON ERREUR
                  DO 100 KK=1,4
                    CALL CESEXI('S',JCESD,JCESL,IMA,JJ,KK,ICMP,IAD)
                    IF (IAD.LT.0) GOTO 110
 100              CONTINUE
                  CALL U2MESS('F','XFEM_1')
 110              CONTINUE
                  IF (TSCA.EQ.'R') THEN
                    ZL(JCESL-1-IAD) = .TRUE.
                    ZR(JCESV-1-IAD) = ZR(JCNSV-1+(INO-1)*NCMP1+ICMP)
                  ELSE IF (TSCA.EQ.'I') THEN
                    ZL(JCESL-1-IAD) = .TRUE.
                    ZI(JCESV-1-IAD) = ZI(JCNSV-1+(INO-1)*NCMP1+ICMP)
                    IF (LSTNO) THEN
                      IF ((.NOT.ZL(JCNSL2-1+(INO-1)*2+1)).AND.
     &                            ZI(JCESV-1-IAD).GT.0) THEN
                        ZL(JCNSL2-1+(INO-1)*2+1) = .TRUE.
                        ZL(JCNSL2-1+(INO-1)*2+2) = .TRUE.
                        ZI(JCNSV2-1+(INO-1)*2+1) = IMA
                        ZI(JCNSV2-1+(INO-1)*2+2) = JJ
                      ENDIF
                    ENDIF
                  ELSE IF (TSCA.EQ.'L') THEN
                    ZL(JCESL-1-IAD) = .TRUE.
                    ZL(JCESV-1-IAD) = ZL(JCNSV-1+(INO-1)*NCMP1+ICMP)
                  ELSE IF (TSCA.EQ.'K8') THEN
                    ZL(JCESL-1-IAD) = .TRUE.
                    ZK8(JCESV-1-IAD)= ZK8(JCNSV-1+(INO-1)*NCMP1+ICMP)
                  ELSE
                    CALL ASSERT(.FALSE.)
                  END IF

 1220           CONTINUE
 1210         CONTINUE

 120        CONTINUE
          ENDIF
 1000   CONTINUE

        CALL DETRSD('CHAM_NO_S',CNS)
 20   CONTINUE
C
C --- CONVERSION CHAM_ELEM_S -> CHAM_ELEM
C
      CALL CESCEL(CES,LIGREL,OPT,PARAM,'OUI',NNCP,BASE,CHGLO,'F',IBID)
      CALL DETRSD('CHAM_ELEM_S',CES)
C
C --- CONVERSION CHAM_NO_S -> CHAM_NO POUR MODELE.NOXFEM
C
      IF (LSTNO) THEN
        NOXFEM = MOX//'.NOXFEM'
        CALL CNSCNO(CNS2,' ','OUI','G',NOXFEM,'F',IBID)
        CALL DETRSD('CHAM_NO_S',CNS2)
      ENDIF
      CALL JEDEMA()
      END
