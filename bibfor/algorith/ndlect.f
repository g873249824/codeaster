      SUBROUTINE NDLECT( CMD   , MODELE, MATE,   LISCHA, STADYN, LAMORT,
     &                   ALPHA,  DELTA,  PHI,    V0VIT,  V0ACC,  A0VIT, 
     &                   A0ACC,  NBMODS, NMODAM, VALMOD, BASMOD,
     &                   NREAVI, LIMPED, LONDE,  CHONDP, NONDP, CHGRFL,
     &                   THETA,  IALGO , FONDEP, FONVIT, FONACC,
     &                   MULTAP, PSIDEL )
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 20/03/2006   AUTEUR ACBHHCD G.DEVESA 
C ======================================================================
C COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
C (AT YOUR OPTION) ANY LATER VERSION.                                 
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
C    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
C ======================================================================
C RESPONSABLE MABBAS M.ABBAS
C TOLE CRP_21

      IMPLICIT NONE
      INTEGER       NBMODS, NREAVI, NONDP, NMODAM, IALGO
      REAL*8        V0VIT, V0ACC, A0VIT, A0ACC, ALPHA, DELTA, THETA
      LOGICAL       LAMORT, LIMPED, LONDE
      CHARACTER*16  CMD
      CHARACTER*19  LISCHA
      CHARACTER*24  MODELE, MATE, STADYN, VALMOD, BASMOD, CHONDP
      CHARACTER*24  CHGRFL
      CHARACTER*24  FONDEP,FONVIT,FONACC,MULTAP,PSIDEL

C ----------------------------------------------------------------------
C
C COMMANDE DYNA_NON_LINE : LECTURE DES OPERANDES DYNAMIQUES
C
C ----------------------------------------------------------------------
C
C       IN CMD    : NOM DE LA COMMANDE
C                    'DYNA_NON_LINE'
C                    'DYNA_TRAN_EXPLI'
C       IN MODELE : NOM DU MODELE
C       IN MATE   : NOM DU CHAMP DE MATERIAU
C       IN LISCHA : SD L_CHARGES
C IN/JXVAR STADYN : CARTE INDIQUANT SI STATIQUE OU DYNAMIQUE
C                     PLUS LES PARAMETRES de NEWMARK VISIBLEMENT (?)
C      OUT LAMORT : BOOLEEN D'EXISTENCE D'AMORTISSEMENT
C      OUT ALPHA  : PARAMETRE ALPHA DE NEWMARK
C      OUT DELTA  : PARAMETRE DELTA DE NEWMARK
C      OUT PHI    : PARAMETRE PHI DE TCHAMWA
C      OUT V0VIT  : PARAMETRE METHODE
C      OUT A0VIT  : PARAMETRE METHODE
C      OUT A0ACC  : PARAMETRE METHODE
C      OUT NBMODS : NOMBRE MODE STATIQUE (MODELISATION MULTI-APPUI) (?)
C      OUT NMODAM : AMORTISSEMENT MODAL (PRESENCE ? NOMBRE ?)
C IN/JXVAR VALMOD : DONNEES AMORTISSEMENT MODAL (?)
C IN/JXVAR BASMOD : DONNEES AMORTISSEMENT MODAL (?)
C      OUT NREAVI : DONNEES AMORTISSEMENT MODAL (?)
C      OUT LIMPED : BOOLEEN DE PRESENCE D'ELEMENTS 'IMPE_ABSO'
C      OUT LONDE  : BOOLEEN D'EXISTENCE DE CHARGES 'ONDE_PLANE'
C      OUT CHONDP : DONNEES 'ONDE_PLANE' (PASSE EN SOUS-TERRAIN,
C                                         C'EST MAL)
C      OUT NONDP  : DONNEES 'ONDE_PLANE'
C IN/JXVAR CHGRFL : CHARGEMENT GRAPPE FLUIDE
C      OUT MULTIA : CHAPEAU DES CHAMPS MULTI APPUI
C      OUT THETA  : PARAMETRE DE THETA METHODE
C      OUT IALGO  : ALGORITHME D'INTEGRATION EN TEMPS
C                     (1) : NEWMARK
C                     (2) : HHT
C                     (3) : THETA-METHODE
C                     (4) : ALPHA-METHODE
C                     (6) : EXPLICITE : DIFFERENCES CENTREES
C                     (7) : EXPLICITE : TCHAMWA-WIELGOSZ
C ----------------------------------------------------------------------
C --- DEBUT DECLARATIONS NORMALISEES JEVEUX ----------------------------

      INTEGER ZI
      COMMON /IVARJE/ZI(1)
      REAL*8 ZR
      COMMON /RVARJE/ZR(1)
      COMPLEX*16 ZC
      COMMON /CVARJE/ZC(1)
      LOGICAL ZL
      COMMON /LVARJE/ZL(1)
      CHARACTER*8 ZK8
      CHARACTER*16 ZK16
      CHARACTER*24 ZK24
      CHARACTER*32 ZK32
      CHARACTER*80 ZK80
      COMMON /KVARJE/ZK8(1),ZK16(1),ZK24(1),ZK32(1),ZK80(1)

C --- FIN DECLARATIONS NORMALISEES JEVEUX ------------------------------

      INTEGER       IRET, IRET2, NBOCC, N1, IBID, I, NCHAR,
     &              JCHAR, JINF, NBOCCT, N2, NBOCCE,NBOCCW
      CHARACTER*8   K8B, LICMP(3), NOMCHA, REP
      CHARACTER*24  CHARGE, INFOCH
      REAL*8        UNDEMI,UN,DEUX,QUATRE, ZERO
      REAL*8        ALPHA0,RCMP(3),PHI
      COMPLEX*16    CPLX
C
C ----------------------------------------------------------------------

      ZERO= 0.D0
      UNDEMI = 0.5D0
      UN = 1.D0
      DEUX = 2.D0
      QUATRE = 4.D0
      LAMORT = .FALSE.

C -- EXISTENCE D'AMORTISSEMENT
      CALL DISMOI('F','EXI_AMOR_ALPHA',MATE,'CHAM_MATER',IBID,REP,IBID)
      IF (REP(1:3).EQ.'OUI') LAMORT = .TRUE.
      CALL DISMOI('F','EXI_AMOR_BETA',MATE,'CHAM_MATER',IBID,REP,IBID)
      IF (REP(1:3).EQ.'OUI') LAMORT = .TRUE.
      CALL DISMOI('F','EXI_AMOR_NOR',MATE,'CHAM_MATER',IBID,REP,IBID)
      IF (REP(1:3).EQ.'OUI') LAMORT = .TRUE.
      CALL DISMOI('F','EXI_AMOR_TAN',MATE,'CHAM_MATER',IBID,REP,IBID)
      IF (REP(1:3).EQ.'OUI') LAMORT = .TRUE.            
C -- PARAMETRES METHODE DE NEWMARK 
       
      IF (CMD.EQ.'DYNA_TRAN_EXPLI') THEN
        CALL GETFAC('DIFF_CENT',NBOCCE)
        IF (NBOCCE .EQ. 1 ) THEN
          IALGO = 6
C --- ON INITIALISE DES PARAMETRES UTILISES DANS LE CONTACT CONTINU
          ALPHA = 0.25D0
          DELTA = 0.5D0
          PHI = 1.D0
        ELSE
          CALL GETFAC('TCHAMWA',NBOCCW)
          IF (NBOCCW.EQ.1) THEN
            IALGO = 7
            ALPHA = 0.25D0
            DELTA = 0.5D0
            CALL GETVR8('TCHAMWA','PHI',1,1,1,PHI,N1)
          ENDIF
        ENDIF
      ELSE
        CALL GETFAC('NEWMARK',NBOCC)
        IF (NBOCC.EQ.1) THEN
          IALGO = 1
          CALL GETVR8('NEWMARK','ALPHA',1,1,1,ALPHA,N1)
          CALL GETVR8('NEWMARK','DELTA',1,1,1,DELTA,N1)
        ELSE
          CALL GETFAC('TETA_METHODE',NBOCCT)                  
          IF (NBOCCT .EQ. 1 ) THEN
            IALGO = 3
            CALL GETVR8('TETA_METHODE','TETA',1,1,1,THETA,N2)
          ELSE
            CALL GETFAC('HHT',NBOCCT)
            IF (NBOCCT .EQ. 1 ) THEN
              CALL GETVR8('HHT'    ,'ALPHA',1,1,1,ALPHA,N1)
              CALL GETVTX('HHT'    ,'MODI_EQUI',1,1,1,REP,N1)
              IF ( REP(1:3) .EQ. 'NON' ) THEN 
                IALGO = 2
              ELSE
                IALGO = 4
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDIF

      IF ((IALGO.EQ.2) . OR. (IALGO.EQ.4)) THEN
        ALPHA0 = ALPHA
        ALPHA = (UN-ALPHA0)* (UN-ALPHA0)/QUATRE
        DELTA = UNDEMI - ALPHA0
      END IF
         
      IF ((IALGO.EQ.1) .OR. (IALGO.EQ.2) .OR. 
     &    (IALGO.EQ.4). OR. (IALGO.EQ.6) .OR. (IALGO.EQ.7) ) THEN
        V0VIT = - (DELTA-ALPHA)/ALPHA
        V0ACC = - (DELTA-DEUX*ALPHA)/DEUX/ALPHA
        A0VIT = -UN/ALPHA
        A0ACC = - (UN-DEUX*ALPHA)/DEUX/ALPHA
C POUR LA TETA_METHODE THETA DOIT ETRE DANS [0.5;1]
      ELSEIF (IALGO.EQ.3) THEN
        V0VIT = - (UN-THETA)/THETA
        V0ACC = ZERO
        A0VIT = -UN/THETA
        A0ACC = ZERO         
      ENDIF
         
      LICMP(1) = 'STAOUDYN'
      LICMP(2) = 'ALFNMK'
      LICMP(3) = 'DELNMK'
      RCMP(1) = UN
      RCMP(2) = ALPHA
      RCMP(3) = DELTA
      CALL JEEXIN(STADYN,IRET)
      IF (IRET.NE.0) THEN
        CALL JEDETR(STADYN)
      END IF
      CALL MECACT('V',STADYN,'MODELE',MODELE(1:8)//'.MODELE',
     &            'STAOUDYN',3,LICMP,IBID,RCMP,CPLX,K8B)

C -- DONNEES MULT-APPUI
      CALL GETVID(' ','MODE_STAT',1,1,1,K8B,NBMODS)
      IF (NBMODS.NE.0) THEN
        CALL NMMUAP(FONDEP,FONVIT,FONACC,MULTAP,PSIDEL)
      END IF


C -- DONNEES AMOR_MODAL
      CALL GETFAC('AMOR_MODAL',NMODAM)
      IF (NMODAM.NE.0) THEN
        CALL NMMOAM(VALMOD,BASMOD,NREAVI)
      END IF


C -- VERIFICATION DE LA PRESENCE D'ELEMENTS AVEC 'IMPE_ABSO'
      CALL NMIMPE(MODELE,LIMPED)


C -- TEST DE LA PRESENCE DE CHARGES DE TYPE 'ONDE_PLANE'
      CALL NMONDP(LISCHA,LONDE,CHONDP,NONDP)


C --- TEST DE LA PRESENCE DE CHARGES DE TYPE 'FORCE_FLUIDE'

      CHARGE = LISCHA//'.LCHA'
      INFOCH = LISCHA//'.INFC'
      CALL JEEXIN ( CHARGE, IRET )
      IF ( IRET .NE. 0 ) THEN
         CALL JEVEUO ( INFOCH, 'L', JINF  )
         CALL JEVEUO ( CHARGE, 'L', JCHAR )
         NCHAR = ZI(JINF)
         DO 10 I = 1, NCHAR
            NOMCHA = ZK24(JCHAR+I-1)(1:8)
            CALL JEEXIN ( NOMCHA//'.CHME.GRFLU.LINO', IRET2 )
            IF ( IRET2 .NE. 0 ) THEN
               CALL GFLECT ( NOMCHA, CHGRFL )
            ENDIF
  10     CONTINUE
      ENDIF

 9999 CONTINUE
      END
