      SUBROUTINE NDLECT(RESULT,MODELE,MATE  ,LISCHA,SDDYNA)
C
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 19/12/2007   AUTEUR ABBAS M.ABBAS 
C ======================================================================
C COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
C (AT YOUR OPTION) ANY LATER VERSION.                                 
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
C    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
C ======================================================================
C RESPONSABLE MABBAS M.ABBAS
C
      IMPLICIT NONE   
      CHARACTER*8  RESULT
      CHARACTER*19 SDDYNA
      CHARACTER*24 MODELE,MATE
      CHARACTER*19 LISCHA      
C 
C ----------------------------------------------------------------------
C
C ROUTINE MECA_NON_LINE (INITIALISATION)
C
C LECTURE DES OPERANDES DYNAMIQUES ET REMPLISSAGE DE SDDYNA
C      
C ----------------------------------------------------------------------
C
C
C IN  RESULT : NOM UTILISATEUR DU RESULTAT DE MECA_NON_LINE
C IN  MODELE : NOM DU MODELE
C IN  MATE   : NOM DU CHAMP DE MATERIAU
C IN  LISCHA : SD L_CHARGES
C IN  SDDYNA : SD DYNAMIQUE
C
C -------------- DEBUT DECLARATIONS NORMALISEES  JEVEUX ----------------
C
      INTEGER ZI
      COMMON /IVARJE/ ZI(1)
      REAL*8 ZR
      COMMON /RVARJE/ ZR(1)
      COMPLEX*16 ZC
      COMMON /CVARJE/ ZC(1)
      LOGICAL ZL
      COMMON /LVARJE/ ZL(1)
      CHARACTER*8 ZK8
      CHARACTER*16 ZK16
      CHARACTER*24 ZK24
      CHARACTER*32 ZK32
      CHARACTER*80 ZK80
      COMMON /KVARJE/ ZK8(1),ZK16(1),ZK24(1),ZK32(1),ZK80(1)
C
C -------------- FIN  DECLARATIONS  NORMALISEES  JEVEUX ----------------
C
      REAL*8        ZERO,UNDEMI,UN,DEUX,QUATRE
      PARAMETER     (UNDEMI = 0.5D0,UN   = 1.D0,DEUX = 2.D0)
      PARAMETER     (QUATRE = 4.D0 ,ZERO = 0.D0)
C      
      INTEGER       NBMODS,NMODAM,NREAVI,NONDP
      INTEGER       IRET,IBID,IRET2,I
      INTEGER       JCHAR,JINF
      INTEGER       N1,N2,NCHAR,NBMG,NRV
      CHARACTER*24  TSCH ,PSCH ,CONI ,LOSD ,NOSD ,TFOR ,MUAP    
      INTEGER       JTSCH,JPSCH,JCONI,JLOSD,JNOSD,JTFOR,JMUAP
      CHARACTER*24  TCHA ,NCHA ,HHTC
      INTEGER       JTCHA,JNCHA,JHHTC      
      CHARACTER*8   K8BID, LICMP(3),REP,NOMCHA
      CHARACTER*24  CHARGE,INFOCH   
      CHARACTER*16  SCHEMA,KFORM,K16BID,NOMCMD
      CHARACTER*24  TEXTE,STADYN,SDAMMO
      CHARACTER*24  CHGRFL,CHONDP
      INTEGER       IFORM
      INTEGER       IFM,NIV
      REAL*8        ALPHA ,DELTA ,THETA      
      REAL*8        ALPHA0,PHI   ,RCMP(3)
      REAL*8        V0VIT ,V0ACC ,A0VIT ,A0ACC
      COMPLEX*16    C16BID
      LOGICAL       NDYNLO
      LOGICAL       LAMORT,LONDE ,LIMPED 
      CHARACTER*24  FEDOLD,FEPILD,DIDOLD,DIPILD,FSDOLD,FSPILD
      CHARACTER*24  DIDILD,CINELD,CNFOLD,CNINER 
      CHARACTER*24  DEPENT,VITENT,ACCENT
C
      DATA FEDOLD, FEPILD    /'&&OP0070.FEDOLD', '&&OP0070.FEPILD'/
      DATA FSDOLD, FSPILD    /'&&OP0070.FSDOLD', '&&OP0070.FSPILD'/
      DATA DIDOLD, DIPILD    /'&&OP0070.DIDOLD', '&&OP0070.DIPILD'/
      DATA DIDILD, CINELD    /'&&OP0070.DIDILD', '&&OP0070.CINELD'/  
      DATA CNFOLD, CNINER    /'&&OP0070.CNFOLD', '&&OP0070.CNINER'/
      DATA DEPENT            /'&&OP0070.DEPENT'/      
      DATA VITENT            /'&&OP0070.VITENT'/      
      DATA ACCENT            /'&&OP0070.ACCENT'/         
C
C ----------------------------------------------------------------------
C
      CALL JEMARQ()
      CALL INFDBG('MECA_NON_LINE',IFM,NIV)             
C
C --- OPERATEUR APPELANT (STATIQUE OU DYNAMIQUE)
C      
      CALL GETRES(K8BID ,K16BID,NOMCMD)
      IF (NDYNLO(SDDYNA,'DYNAMIQUE')) THEN      
        IF (NIV.GE.2) THEN
          WRITE (IFM,*) '<MECANONLINE> ... REMPLISSAGE SD DYNAMIQUE' 
        ENDIF
      ELSE
        GOTO 999  
      ENDIF
C
C --- INITIALISATIONS
C           
      CHARGE = LISCHA(1:19)//'.LCHA'
      INFOCH = LISCHA(1:19)//'.INFC'             
C
C --- ACCES AUX OBJETS DE LA SD SDDYNA
C
      TSCH = SDDYNA(1:15)//'.TYPE_SCH'
      TFOR = SDDYNA(1:15)//'.TYPE_FOR'
      PSCH = SDDYNA(1:15)//'.PARA_SCH'
      CONI = SDDYNA(1:15)//'.INI_CONT'
      LOSD = SDDYNA(1:15)//'.INFO_SD'
      NOSD = SDDYNA(1:15)//'.NOM_SD'
      TCHA = SDDYNA(1:15)//'.TYPE_CHA'
      NCHA = SDDYNA(1:15)//'.NBRE_CHA'  
      HHTC = SDDYNA(1:15)//'.HHT_COMP'      
      MUAP = SDDYNA(1:15)//'.MULT_APP' 
      CALL JEVEUO(TSCH,'E',JTSCH)        
      CALL JEVEUO(TFOR,'E',JTFOR) 
      CALL JEVEUO(PSCH,'E',JPSCH)
      CALL JEVEUO(CONI,'E',JCONI)
      CALL JEVEUO(LOSD,'E',JLOSD)
      CALL JEVEUO(NOSD,'E',JNOSD) 
      CALL JEVEUO(TCHA,'E',JTCHA)
      CALL JEVEUO(NCHA,'E',JNCHA)  
      CALL JEVEUO(HHTC,'E',JHHTC)   
      CALL JEVEUO(MUAP,'E',JMUAP)               
C
C --- EXISTENCE D'AMORTISSEMENT
C
      LAMORT = .FALSE.
      CALL DISMOI('F','EXI_AMOR_ALPHA',MATE,'CHAM_MATER',IBID,REP,IBID)
      IF (REP(1:3).EQ.'OUI') LAMORT = .TRUE.
      CALL DISMOI('F','EXI_AMOR_BETA',MATE,'CHAM_MATER',IBID,REP,IBID)
      IF (REP(1:3).EQ.'OUI') LAMORT = .TRUE.
      CALL DISMOI('F','EXI_AMOR_NOR',MATE,'CHAM_MATER',IBID,REP,IBID)
      IF (REP(1:3).EQ.'OUI') LAMORT = .TRUE.
      CALL DISMOI('F','EXI_AMOR_TAN',MATE,'CHAM_MATER',IBID,REP,IBID)
      IF (REP(1:3).EQ.'OUI') LAMORT = .TRUE.
      ZL(JLOSD+1-1) = LAMORT        
C
C --- PARAMETRES DU SCHEMA TEMPS
C
      CALL GETVTX('SCHEMA_TEMPS','SCHEMA',1,1,1,SCHEMA,IRET)
      IF(SCHEMA(1:9).EQ.'DIFF_CENT')THEN
        ALPHA  = 0.25D0
        DELTA  = 0.5D0
        PHI    = 1.D0
        ZK16(JTSCH+7-1) = 'DIFF_CENTREE'
      ELSEIF(SCHEMA(1:7).EQ.'TCHAMWA')THEN
        ALPHA  = 0.25D0
        DELTA  = 0.5D0
        CALL GETVR8('SCHEMA_TEMPS','PHI',1,1,1,PHI,N1)
        ZK16(JTSCH+8-1) = 'TCHAMWA'
      ELSEIF(SCHEMA(1:7).EQ.'NEWMARK')THEN
        CALL GETVR8('SCHEMA_TEMPS','ALPHA',1,1,1,ALPHA,N1)
        CALL GETVR8('SCHEMA_TEMPS','DELTA',1,1,1,DELTA,N1)
        ZK16(JTSCH+2-1) = 'NEWMARK'
      ELSEIF(SCHEMA(1:13).EQ.'THETA_METHODE')THEN
        CALL GETVR8('SCHEMA_TEMPS','THETA',1,1,1,THETA,N2)
        ZK16(JTSCH+4-1) = 'THETA_METHODE'
      ELSEIF(SCHEMA(1:3).EQ.'HHT')THEN
        CALL GETVR8('SCHEMA_TEMPS','ALPHA',1,1,1,ALPHA,N1)
        CALL GETVTX('SCHEMA_TEMPS','MODI_EQUI',1,1,1,REP,N1)
        IF ( REP(1:3) .EQ. 'NON' ) THEN 
           ZK16(JTSCH+3-1) = 'HHT'
        ELSE
           ZK16(JTSCH+5-1) = 'HHT_COMPLET'
        ENDIF
        ALPHA0 = ALPHA
        ALPHA = (UN-ALPHA0)* (UN-ALPHA0)/QUATRE
        DELTA = UNDEMI - ALPHA0
      ENDIF
C
      IF (SCHEMA(1:13).EQ.'THETA_METHODE') THEN
        ZR(JPSCH+4-1) = THETA       
      ELSE
        ZR(JPSCH+1-1) = ALPHA
        ZR(JPSCH+2-1) = DELTA
        IF (SCHEMA(1:9).EQ.'DIFF_CENT' .OR. 
     &      SCHEMA(1:7).EQ.'TCHAMWA')THEN
           ZR(JPSCH+3-1) = PHI
        ENDIF
      ENDIF
C
C --- COEFFICIENTS VITESSES & ACCELERATIONS INITIALES
C
      IF (SCHEMA(1:13).EQ.'THETA_METHODE') THEN
        V0VIT = - (UN-THETA)/THETA
        V0ACC = ZERO
        A0VIT = -UN/THETA
        A0ACC = ZERO         
      ELSE
        V0VIT = - (DELTA-ALPHA)/ALPHA
        V0ACC = - (DELTA-DEUX*ALPHA)/DEUX/ALPHA
        A0VIT = -UN/ALPHA
        A0ACC = - (UN-DEUX*ALPHA)/DEUX/ALPHA
      ENDIF 
C
      ZR(JCONI+1-1) = V0VIT
      ZR(JCONI+2-1) = V0ACC
      ZR(JCONI+3-1) = A0VIT
      ZR(JCONI+4-1) = A0ACC           
C
C --- TYPE DE FORMULATION
C
      CALL GETVTX('SCHEMA_TEMPS','FORMULATION',1,1,1,KFORM,N1)
      IF(KFORM(1:11).EQ.'DEPLACEMENT')THEN
        IFORM=1
      ELSEIF(KFORM(1:7).EQ.'VITESSE')THEN
        IFORM=2
      ELSEIF(KFORM(1:12).EQ.'ACCELERATION')THEN
        IFORM=3
      ENDIF
      ZI(JTFOR+1-1) = IFORM 
      
      IF(NDYNLO(SDDYNA,'IMPLICITE'))THEN
        IF (IFORM.NE.1) THEN
          CALL U2MESS('F','ALGORITH3_9')
        ENDIF
      ELSEIF(NDYNLO(SDDYNA,'EXPLICITE')) THEN
        IF (IFORM.NE.3) THEN
          CALL U2MESS('F','ALGORITH3_9')
        ENDIF   
      ENDIF   
C
C --- SCHEMAS EXPLICITES
C
      ZL(JLOSD+4-1) = .FALSE.
      ZL(JLOSD+5-1) = .FALSE.
      ZL(JLOSD+9-1) = .FALSE.
      IF (NDYNLO(SDDYNA,'EXPLICITE'))THEN
        CALL GETVTX(' ','MASS_DIAG',1,1,1,TEXTE,N1)
        IF (TEXTE(1:3).EQ.'OUI') THEN
          ZL(JLOSD+4-1) = .TRUE.
        ENDIF
        CALL GETFAC('PROJ_MODAL',IRET)
        IF (IRET.GT.0)THEN
          ZL(JLOSD+5-1)   = .TRUE.
          ZK24(JNOSD+3-1) = RESULT//'.PROJ_MODAL'
          CALL GETVID('PROJ_MODAL','MASS_GENE',1,1,1,K8BID,NBMG)
          ZL(JLOSD+9-1)   = NBMG.NE.0          
        ENDIF  
      ENDIF    
C
C --- SCHEMA HHT_COMPLET
C
      IF (ZK16(JTSCH+5-1).EQ.'HHT_COMPLET') THEN
        ZL(JLOSD+10-1)  = .FALSE.
        ZK24(JHHTC+1-1) = FEDOLD
        ZK24(JHHTC+2-1) = FEPILD
        ZK24(JHHTC+3-1) = DIDOLD
        ZK24(JHHTC+4-1) = DIPILD
        ZK24(JHHTC+5-1) = FSDOLD
        ZK24(JHHTC+6-1) = FSPILD
        ZK24(JHHTC+7-1) = DIDILD
        ZK24(JHHTC+8-1) = CINELD 
        ZK24(JHHTC+9-1) = CNFOLD  
      ELSE
        ZL(JLOSD+10-1)  = .FALSE.              
      ENDIF        
C
C --- CARTE STADYN POUR POUTRES
C       
      STADYN = '&&OP0070.STA_DYN'
      ZK24(JNOSD+4-1) = STADYN
      LICMP(1) = 'STAOUDYN'
      LICMP(2) = 'ALFNMK'
      LICMP(3) = 'DELNMK'
      RCMP(1)  = UN
      RCMP(2)  = ALPHA
      RCMP(3)  = DELTA
      CALL JEDETR(STADYN)
      CALL MECACT('V',STADYN,'MODELE',MODELE(1:8)//'.MODELE',
     &            'STAOUDYN',3,LICMP,IBID,RCMP,C16BID,K8BID)
C
C --- DONNEES MULT-APPUI
C
      CALL GETVID(' ','MODE_STAT',1,1,1,K8BID,NBMODS)
      ZK24(JMUAP+1-1) = DEPENT
      ZK24(JMUAP+2-1) = VITENT
      ZK24(JMUAP+3-1) = ACCENT      
      IF (NBMODS.NE.0) THEN
        ZL(JLOSD+2-1)   = .TRUE.
        CALL NMMUAP(RESULT,SDDYNA)
      ELSE
        ZL(JLOSD+2-1)   = .FALSE.
      END IF
C
C --- DONNEES AMOR_MODAL
C
      CALL GETFAC('AMOR_MODAL',NMODAM)
      IF (NMODAM.NE.0) THEN
        ZL(JLOSD+3-1)   = .TRUE.
        SDAMMO          = RESULT//'.AMOR_MODAL'      
        CALL NMMOAM(SDAMMO)
        NREAVI          = 0
C        
C --- REACTUALISATION DE L'AMORT A CHAQUE ITERATION ?
C
        CALL GETVTX('AMOR_MODAL','REAC_VITE',1,1,1,K8BID,NRV)
        IF (K8BID.EQ.'OUI') NREAVI = 1        
      ELSE
        ZL(JLOSD+3-1)   = .FALSE.
        SDAMMO          = ' '
        NREAVI          = 0
      END IF
      ZL(JLOSD+12-1)  = NREAVI.GT.0
      ZK24(JNOSD+2-1) = SDAMMO
C
C --- VERIFICATION DE LA PRESENCE D'ELEMENTS AVEC 'IMPE_ABSO'
C
      CALL NMIMPE(MODELE,LIMPED)
      ZL(JLOSD+6-1)   = LIMPED   
C
C --- TEST DE LA PRESENCE DE CHARGES DE TYPE 'ONDE_PLANE'
C
      CALL NMONDP(LISCHA,LONDE,CHONDP,NONDP)
      ZL(JLOSD+7-1)   = LONDE
      ZI(JNCHA+1-1)   = NONDP
      ZK24(JTCHA+1-1) = CHONDP
C
C --- TEST DE LA PRESENCE DE CHARGES DE TYPE 'FORCE_FLUIDE'
C
      CHGRFL = '&&OP0070.GRAPPE_FLUIDE  '
      ZL(JLOSD+8-1)   = .FALSE.
      CALL JEEXIN(CHARGE,IRET  )
      IF ( IRET .NE. 0 ) THEN
        CALL JEVEUO ( INFOCH, 'L', JINF  )
        CALL JEVEUO ( CHARGE, 'L', JCHAR )
        NCHAR = ZI(JINF)
        DO 10 I = 1, NCHAR
          NOMCHA = ZK24(JCHAR+I-1)(1:8)
          CALL JEEXIN ( NOMCHA//'.CHME.GRFLU.LINO', IRET2 )
          IF ( IRET2 .NE. 0 ) THEN
            CALL GFLECT(NOMCHA,CHGRFL)
            ZL(JLOSD+8-1)   = .TRUE.
          ENDIF
  10    CONTINUE
      ENDIF
      ZK24(JTCHA+2-1) = CHGRFL
C
C --- FORCES D'iNERTIE
C
      ZK24(JTCHA+3-1) = CNINER      
C
  999 CONTINUE      
C
      CALL JEDEMA()

      END
