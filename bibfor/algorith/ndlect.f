      SUBROUTINE NDLECT(RESULT,MODELE,MATE, LISCHA,STADYN,
     &                  NREAVI,LIMPED,LONDE,CHONDP,NONDP , 
     &                  CHGRFL,SDDYNA)
C     
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 01/10/2007   AUTEUR BOYERE E.BOYERE 
C ======================================================================
C COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
C (AT YOUR OPTION) ANY LATER VERSION.                                 
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
C    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
C ======================================================================
C RESPONSABLE MABBAS M.ABBAS
C
      IMPLICIT NONE
      INTEGER       NREAVI,NONDP
      LOGICAL       LAMORT,LIMPED,LONDE
      CHARACTER*8   RESULT
      CHARACTER*19  LISCHA
      CHARACTER*24  MODELE,MATE,STADYN
      CHARACTER*24  CHGRFL,CHONDP
C 
C ----------------------------------------------------------------------
C
C ROUTINE MECA_NON_LINE (DYNAMIQUE - INITIALISATIONS)
C
C LECTURE DES OPERANDES DYNAMIQUES ET CREATION DE SDDYNA
C      
C ----------------------------------------------------------------------
C
C
C IN  MODELE : NOM DU MODELE
C IN  MATE   : NOM DU CHAMP DE MATERIAU
C IN  LISCHA : SD L_CHARGES
C I/O STADYN : CARTE INDIQUANT SI STATIQUE OU DYNAMIQUE
C                     PLUS LES PARAMETRES de NEWMARK VISIBLEMENT (?)
C OUT NREAVI : REACTUALISATION DE L'AMORTISSEMENT A CHAQUE ITERATION 
C              (0:NON/1:OUI)
C OUT LIMPED : BOOLEEN DE PRESENCE D'ELEMENTS 'IMPE_ABSO'
C OUT LONDE  : BOOLEEN D'EXISTENCE DE CHARGES 'ONDE_PLANE'
C OUT CHONDP : DONNEES 'ONDE_PLANE' (PASSE EN SOUS-TERRAIN,
C                                    C'EST MAL)
C OUT NONDP  : DONNEES 'ONDE_PLANE'
C I/O CHGRFL : CHARGEMENT GRAPPE FLUIDE
C OUT SDDYNA : SD DYNAMIQUE
C
C -------------- DEBUT DECLARATIONS NORMALISEES  JEVEUX ----------------
C
      INTEGER ZI
      COMMON /IVARJE/ ZI(1)
      REAL*8 ZR
      COMMON /RVARJE/ ZR(1)
      COMPLEX*16 ZC
      COMMON /CVARJE/ ZC(1)
      LOGICAL ZL
      COMMON /LVARJE/ ZL(1)
      CHARACTER*8 ZK8
      CHARACTER*16 ZK16
      CHARACTER*24 ZK24
      CHARACTER*32 ZK32
      CHARACTER*80 ZK80
      COMMON /KVARJE/ ZK8(1),ZK16(1),ZK24(1),ZK32(1),ZK80(1)
C
C -------------- FIN  DECLARATIONS  NORMALISEES  JEVEUX ----------------
C
      REAL*8        UNDEMI,UN,DEUX,QUATRE, ZERO
      PARAMETER     (ZERO= 0.D0,UNDEMI = 0.5D0,UN = 1.D0)
      PARAMETER     (DEUX = 2.D0,QUATRE = 4.D0)
C      
      INTEGER       NBMODS,NMODAM
      INTEGER       IRET,IRET2,IBID,I
      INTEGER       JCHAR,JINF
      INTEGER       N1,N2,NCHAR,NRV
      INTEGER       JTSCH,JPSCH,JCONI,JLOSD,JNOSD,JTFOR,JCOSC
      CHARACTER*8   K8B, LICMP(3), NOMCHA, REP
      CHARACTER*16  SCHEMA
      CHARACTER*19  SDDYNA
      CHARACTER*24  CHARGE, INFOCH, TEXTE
      CHARACTER*24  TSCH,PSCH,CONI,LOSD,NOSD,TFOR,CFSC
      REAL*8        ALPHA, DELTA, THETA      
      REAL*8        ALPHA0,RCMP(3),PHI,V0VIT, V0ACC, A0VIT, A0ACC
      COMPLEX*16    CPLX
      LOGICAL       NDYNLO
C
C ----------------------------------------------------------------------
C
      CALL JEMARQ()      
C
C --- DEFINITION ET CREATION DES OBJETS DE LA SD SDDYNA
C
      TSCH = SDDYNA(1:15)//'.TYPE_SCH'
      PSCH = SDDYNA(1:15)//'.PARA_SCH'
      CONI = SDDYNA(1:15)//'.INI_CONT'
      LOSD = SDDYNA(1:15)//'.INFO_SD'
      NOSD = SDDYNA(1:15)//'.NOM_SD'
      TFOR = SDDYNA(1:15)//'.TYPE_FOR'
      CFSC = SDDYNA(1:15)//'.COEF_SCH'

      CALL JEVEUO(TSCH,'E',JTSCH)

      CALL WKVECT(PSCH,'V V R'  ,4,JPSCH)
      CALL WKVECT(CONI,'V V R'  ,4,JCONI)
      CALL WKVECT(LOSD,'V V L'  ,5,JLOSD)
      CALL WKVECT(NOSD,'V V K24',3,JNOSD)
C DANS DINIT      
      CALL WKVECT(TFOR,'V V I'  ,2,JTFOR)
      CALL WKVECT(CFSC,'V V R'  ,4,JCOSC)     


C -- EXISTENCE D'AMORTISSEMENT
      LAMORT = .FALSE.
      CALL DISMOI('F','EXI_AMOR_ALPHA',MATE,'CHAM_MATER',IBID,REP,IBID)
      IF (REP(1:3).EQ.'OUI') LAMORT = .TRUE.
      CALL DISMOI('F','EXI_AMOR_BETA',MATE,'CHAM_MATER',IBID,REP,IBID)
      IF (REP(1:3).EQ.'OUI') LAMORT = .TRUE.
      CALL DISMOI('F','EXI_AMOR_NOR',MATE,'CHAM_MATER',IBID,REP,IBID)
      IF (REP(1:3).EQ.'OUI') LAMORT = .TRUE.
      CALL DISMOI('F','EXI_AMOR_TAN',MATE,'CHAM_MATER',IBID,REP,IBID)
      IF (REP(1:3).EQ.'OUI') LAMORT = .TRUE.
      ZL(JLOSD+1-1)=LAMORT        

C -- PARAMETRES DU SCHEMA TEMPS
      CALL GETVTX('SCHEMA_TEMPS','SCHEMA',1,1,1,SCHEMA,IRET)
      IF(SCHEMA(1:9).EQ.'DIFF_CENT')THEN
        ALPHA = 0.25D0
        DELTA = 0.5D0
        PHI = 1.D0
        ZK16(JTSCH+7-1)='DIFF_CENTREE'
      ELSEIF(SCHEMA(1:7).EQ.'TCHAMWA')THEN
        ALPHA = 0.25D0
        DELTA = 0.5D0
        CALL GETVR8('SCHEMA_TEMPS','PHI',1,1,1,PHI,N1)
        ZK16(JTSCH+8-1)='TCHAMWA'
      ELSEIF(SCHEMA(1:7).EQ.'NEWMARK')THEN
        CALL GETVR8('SCHEMA_TEMPS','ALPHA',1,1,1,ALPHA,N1)
        CALL GETVR8('SCHEMA_TEMPS','DELTA',1,1,1,DELTA,N1)
        ZK16(JTSCH+2-1)='NEWMARK'
      ELSEIF(SCHEMA(1:13).EQ.'THETA_METHODE')THEN
        CALL GETVR8('SCHEMA_TEMPS','THETA',1,1,1,THETA,N2)
        ZK16(JTSCH+4-1)='THETA_METHODE'
      ELSEIF(SCHEMA(1:3).EQ.'HHT')THEN
        CALL GETVR8('SCHEMA_TEMPS','ALPHA',1,1,1,ALPHA,N1)
        CALL GETVTX('SCHEMA_TEMPS','MODI_EQUI',1,1,1,REP,N1)
        IF ( REP(1:3) .EQ. 'NON' ) THEN 
           ZK16(JTSCH+3-1)='HHT'
        ELSE
           ZK16(JTSCH+5-1)='HHT_COMPLET'
        ENDIF
        ALPHA0 = ALPHA
        ALPHA = (UN-ALPHA0)* (UN-ALPHA0)/QUATRE
        DELTA = UNDEMI - ALPHA0
      ENDIF
C
      IF (SCHEMA(1:13).EQ.'THETA_METHODE') THEN
        ZR(JPSCH+4-1)=THETA
        V0VIT = - (UN-THETA)/THETA
        V0ACC = ZERO
        A0VIT = -UN/THETA
        A0ACC = ZERO         
      ELSE
        ZR(JPSCH+1-1)=ALPHA
        ZR(JPSCH+2-1)=DELTA
        IF (SCHEMA(1:9).EQ.'DIFF_CENT' .OR. 
     &      SCHEMA(1:7).EQ.'TCHAMWA')THEN
           ZR(JPSCH+3-1)=PHI
        ENDIF
        V0VIT = - (DELTA-ALPHA)/ALPHA
        V0ACC = - (DELTA-DEUX*ALPHA)/DEUX/ALPHA
        A0VIT = -UN/ALPHA
        A0ACC = - (UN-DEUX*ALPHA)/DEUX/ALPHA
      ENDIF
C
      ZR(JCONI+1-1)=V0VIT
      ZR(JCONI+2-1)=V0ACC
      ZR(JCONI+3-1)=A0VIT
      ZR(JCONI+4-1)=A0ACC

      ZL(JLOSD+4-1)=.FALSE.
      ZL(JLOSD+5-1)=.FALSE.
      IF(NDYNLO(SDDYNA,'EXPLICITE'))THEN
        CALL GETVTX(' ','MASS_DIAG',1,1,1,TEXTE,N1)
        IF (TEXTE(1:3).EQ.'OUI') ZL(JLOSD+4-1)=.TRUE.
        CALL GETFAC('PROJ_MODAL',IRET)
        ZK24(JNOSD+3-1)=' '
        IF(IRET.GT.0)THEN
           ZL(JLOSD+5-1)=.TRUE.
           ZK24(JNOSD+3-1)=RESULT//'.PROJ_MODAL'
        ENDIF  
      ENDIF
 
        
      LICMP(1) = 'STAOUDYN'
      LICMP(2) = 'ALFNMK'
      LICMP(3) = 'DELNMK'
      RCMP(1) = UN
      RCMP(2) = ALPHA
      RCMP(3) = DELTA
      CALL JEEXIN(STADYN,IRET)
      IF (IRET.NE.0) THEN
        CALL JEDETR(STADYN)
      END IF
      CALL MECACT('V',STADYN,'MODELE',MODELE(1:8)//'.MODELE',
     &            'STAOUDYN',3,LICMP,IBID,RCMP,CPLX,K8B)

C -- DONNEES MULT-APPUI
      CALL GETVID(' ','MODE_STAT',1,1,1,K8B,NBMODS)
      IF (NBMODS.NE.0) THEN
        ZL(JLOSD+2-1)=.TRUE.
        ZK24(JNOSD+1-1)=RESULT//'.MULT_APPUI'      
        CALL NMMUAP(ZK24(JNOSD+1-1))
      ELSE
        ZL(JLOSD+2-1)=.FALSE.
        ZK24(JNOSD+1-1)=' '
      END IF


C -- DONNEES AMOR_MODAL
      CALL GETFAC('AMOR_MODAL',NMODAM)
      IF (NMODAM.NE.0) THEN
        ZL(JLOSD+3-1)=.TRUE.
        ZK24(JNOSD+2-1)=RESULT//'.AMOR_MODAL'      
        CALL NMMOAM(ZK24(JNOSD+2-1))
        NREAVI = 0
C ---- REACTUALISATION DE L'AMORT A CHAQUE ITERATION ?
        CALL GETVTX('AMOR_MODAL','REAC_VITE',1,1,1,K8B,NRV)
        IF (K8B.EQ.'OUI') NREAVI = 1
      ELSE
        ZL(JLOSD+3-1)=.FALSE.
        ZK24(JNOSD+2-1)=' '
        NREAVI=0
      END IF

C

C -- VERIFICATION DE LA PRESENCE D'ELEMENTS AVEC 'IMPE_ABSO'
      CALL NMIMPE(MODELE,LIMPED)


C -- TEST DE LA PRESENCE DE CHARGES DE TYPE 'ONDE_PLANE'
      CALL NMONDP(LISCHA,LONDE,CHONDP,NONDP)


C --- TEST DE LA PRESENCE DE CHARGES DE TYPE 'FORCE_FLUIDE'

      CHARGE = LISCHA//'.LCHA'
      INFOCH = LISCHA//'.INFC'
      CALL JEEXIN ( CHARGE, IRET )
      IF ( IRET .NE. 0 ) THEN
         CALL JEVEUO ( INFOCH, 'L', JINF  )
         CALL JEVEUO ( CHARGE, 'L', JCHAR )
         NCHAR = ZI(JINF)
         DO 10 I = 1, NCHAR
            NOMCHA = ZK24(JCHAR+I-1)(1:8)
            CALL JEEXIN ( NOMCHA//'.CHME.GRFLU.LINO', IRET2 )
            IF ( IRET2 .NE. 0 ) THEN
               CALL GFLECT ( NOMCHA, CHGRFL )
            ENDIF
  10     CONTINUE
      ENDIF

      CALL JEDEMA()

      END
