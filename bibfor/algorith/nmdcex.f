      SUBROUTINE NMDCEX(SDDISC,IC,ITERAT,DELTAT,LENIVO,
     &                  NBRPAS,RATIO ,RETOUR)
C
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 20/07/2010   AUTEUR ABBAS M.ABBAS 
C ======================================================================
C COPYRIGHT (C) 1991 - 2008  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
C (AT YOUR OPTION) ANY LATER VERSION.                                   
C                                                                       
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
C                                                                       
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.         
C ======================================================================
C RESPONSABLE ABBAS M.ABBAS
C
      IMPLICIT NONE
      CHARACTER*19 SDDISC
      INTEGER      ITERAT,RETOUR
      INTEGER      NBRPAS,LENIVO,IC
      REAL*8       RATIO,DELTAT
C
C ----------------------------------------------------------------------
C
C ROUTINE MECA_NON_LINE (ALGORITHME - DECOUPE)
C
C DECOUPE PAR EXTRAPOLATION SUR INTERVALLE [DEBUT,ITERAT]
C
C ----------------------------------------------------------------------
C
C
C IN  SDDISC : SD DISCRETISATION
C IN  IC     : NUMERO DE L'OCCURENCE DE LA METHODE DE DECOUPAGE
C IN  ITERAT : NUMERO D'ITERATION DE NEWTON
C IN  DELTAT : INCREMENT DE TEMPS
C IN  LENIVO : NIVEAU DE SOUS-DECOUPE COURANT
C IN  DEPART : NUMERO ITERATION POUR CALCUL EXTRAPOLATION
C OUT NBRPAS : NOMBRE DE PAS A CREER
C OUT RATIO  : RATIO DE CREATION DES PAS
C OUT RETOUR : CODE RETOUR ALGORITHME EXTRAPOLATION
C                0 - ON DECOUPE
C                3 - ON AUTORISE DES ITERATIONS EN PLUS
C
C -------------- DEBUT DECLARATIONS NORMALISEES  JEVEUX ----------------
C
      INTEGER ZI
      COMMON /IVARJE/ ZI(1)
      REAL*8 ZR
      COMMON /RVARJE/ ZR(1)
      COMPLEX*16 ZC
      COMMON /CVARJE/ ZC(1)
      LOGICAL ZL
      COMMON /LVARJE/ ZL(1)
      CHARACTER*8 ZK8
      CHARACTER*16 ZK16
      CHARACTER*24 ZK24
      CHARACTER*32 ZK32
      CHARACTER*80 ZK80
      COMMON /KVARJE/ ZK8(1),ZK16(1),ZK24(1),ZK32(1),ZK80(1)
C
C -------------- FIN  DECLARATIONS  NORMALISEES  JEVEUX ----------------
C 
      REAL*8       ZERO,UN,DEUX
      PARAMETER   (ZERO=0.0D0, UN=1.0D0, DEUX=2.0D0)
C
      INTEGER      NBIGNO,NBFIN,DEPART
      INTEGER      I,REGRES,IBID
      REAL*8       VRELA,VMAXI,R8PREM,R8B
      REAL*8       RGRELA,RGMAXI
      REAL*8       CIBLE,CIBLEN
      REAL*8       SX,SY,SX2,SYX
      REAL*8       XDET,XA0,XA1,XX,XXBB,XN
      INTEGER      MNITER,MXITER
      REAL*8       VALRM(4)
      INTEGER      VALIM(2)
      CHARACTER*40 VALKM(1)      
      CHARACTER*16 METHOD
      CHARACTER*8  K8B
      LOGICAL      LEXTRA
C      
C ----------------------------------------------------------------------
C
      CALL JEMARQ()

C --- NOM DE LA METHODE DE SUBDIVISION (CF. NMCRSU)   
      CALL UTDIDT('L',SDDISC,'ECHE',IC,'SUBD_METH',R8B,IBID,METHOD)
      CALL UTDIDT('L',SDDISC,'ECHE',IC,'SUBD_ITER_IGNO',R8B,NBIGNO,K8B)
      CALL UTDIDT('L',SDDISC,'ECHE',IC,'SUBD_ITER_FIN',R8B,NBFIN,K8B)

C --- LA METHODE UTILISE L'EXTRAPOLATION
C --- ON NE L'ACTIVE QUE SI SUBD_ITER_IGNO/SUBD_ITER_FIN OK
      LEXTRA = .FALSE.
      IF (     (METHOD.EQ.'EXTRAP_IGNO').AND.
     &         ((NBIGNO+3).LE.ITERAT) ) THEN
        LEXTRA = .TRUE.
        DEPART = NBIGNO
      ELSEIF ( (METHOD.EQ.'EXTRAP_FIN').AND.
     &         ((NBFIN+3).LE.ITERAT) ) THEN
        LEXTRA = .TRUE.
        DEPART = ITERAT - NBFIN
      ENDIF
      
      IF (.NOT.LEXTRA) GOTO 999   
C
C --- INITIALISATIONS
C
      RETOUR = 0
      CIBLEN = 0.D0
C
C --- LECTURE DES INFOS SUR LES CONVERGENCES
C
      CALL NMLERI(SDDISC,'L','MXITER'        ,ITERAT,MXITER)
      CALL NMLERI(SDDISC,'L','MNITER'        ,ITERAT,MNITER)
      CALL NMLERR(SDDISC,'L','RESI_GLOB_RELA',ITERAT,RGRELA)
      CALL NMLERR(SDDISC,'L','RESI_GLOB_MAXI',ITERAT,RGMAXI)        
C      
C --- REGRESSION SUR GLOB_RELA OU GLOB_MAXI ?
C
      CALL NMLERI(SDDISC,'L','TYPE_RESI'     ,ITERAT,REGRES)
      CALL NMLERR(SDDISC,'L','VRELA',ITERAT,VRELA )
      CALL NMLERR(SDDISC,'L','VMAXI',ITERAT,VMAXI )
C      
C --- SI REGRES=3 ON DOIT FAIRE LA REGRESSION SUR LES 2, MAIS ON
C --- COMMENCE PAR LA FAIRE SUR GLOB_RELA
C --- SI VRELA > RGRELA ON MET REGRES=1 POUR FAIRE LA REGRESSION
C ---  SUR GLOB_RELA
C --- SI VMAXI > RGMAXI ON MET REGRES=2 POUR FAIRE LA REGRESSION
C ---  SUR GLOB_MAXI
C
      IF  ( REGRES .EQ. 3 ) THEN
        REGRES = 0
        IF      ( VRELA .GT. RGRELA ) THEN
          REGRES = 1
        ELSE IF ( VMAXI .GT. RGMAXI ) THEN
          REGRES = 2
        ENDIF
      ENDIF      
      IF      ( REGRES .EQ. 1 ) THEN
        CIBLE = RGRELA
        XX    = LOG(VRELA)
      ELSE IF ( REGRES .EQ. 2 ) THEN
        CIBLE = RGMAXI
        XX    = LOG(VMAXI)
      ENDIF
C            
C --- LES CRITERES D'ERREUR SONT OK, MAIS PAS DETECTE DANS LE
C --- STAT_NON_LINE. CELA PEUT SE PRODUIRE QUAND IL Y A DU CONTACT
C --- AVEC DE LA REACTUALISATION GEOMETRIQUE. ON SORT SANS FAIRE
C --- DE SUBDIVISION
C
      IF ( REGRES .EQ. 0 ) THEN
        VALRM(1) = VRELA
        VALRM(2) = RGRELA
        VALRM(3) = VMAXI
        VALRM(4) = RGMAXI
        VALIM(1) = ITERAT
        CALL U2MESG('I','SUBDIVISE_9',0,VALKM,1,VALIM,4,VALRM)
        RETOUR = 0
        GOTO 999
      ENDIF      
C
C --- CALCUL DE LA REGRESSION
C --- ON DONNE UN POIDS DOUBLE AU 3 DERNIERS POINTS CELA REVIENT
C --- A AJOUTER DES POINTS => MEILLEURE EXTRAPOLATION
C
      SX  = ZERO
      SY  = ZERO
      SX2 = ZERO
      SYX = ZERO
      XN  = ZERO
      DO 110 I = DEPART, ITERAT
        IF ( I .GT. (ITERAT - 3) ) THEN
           XN   = XN  + DEUX
           SX   = SX  + DEUX*XX
           SY   = SY  + DEUX*I
           SX2  = SX2 + DEUX*(XX**2)
           SYX  = SYX + DEUX*XX*I
        ELSE
           XN   = XN  + UN
           SX   = SX  + XX
           SY   = SY  + I
           SX2  = SX2 + XX**2
           SYX  = SYX + XX*I
        ENDIF
110   CONTINUE
      XDET   = -SX**2 + SX2*XN
      XA0    =  SX2*SY - SX*SYX
      XA1    = -(SX*SY) + SYX*XN

      IF (XDET.LE.R8PREM()) THEN
        RATIO    = 24.0D0/((3.0D0*NBRPAS+UN)**2 - UN)
        RETOUR   = 0
        VALIM(1) = NBRPAS
        VALIM(2) = LENIVO
        VALRM(1) = RATIO
        VALRM(2) = DELTAT
        VALRM(3) = CIBLEN
        VALRM(4) = MNITER
        IF ( REGRES .EQ. 1 ) THEN
          VALKM(1) = 'RESI_GLOB_RELA'
        ELSE
          VALKM(1) = 'RESI_GLOB_MAXI'
        ENDIF               
        CALL U2MESG('I','SUBDIVISE_11',1,VALKM,2,VALIM,4,VALRM)
        GOTO 999
      ENDIF
C
C --- NOMBRE D'ITERATIONS TROUVEES
C      
      CIBLEN = (XA0 + XA1*LOG(CIBLE) )/XDET

C        LA METHODE TROUVE UN NOMBRE D'ITERATION < LIMITE ITERATION
C        CELA SE PRODUIT SI ON DONNE ITER_GLOB_MAXI ET ITER_GLOB_ELAS.
C        SI ITER_GLOB_ELAS EST < ITER_GLOB_MAXI ALORS L'EXTRAPOLATION
C        QUI EST FAITE LORS DE ITER_GLOB_ELAS PEUT DONNER UN NOMBRE
C        ENTRE CES 2 VALEURS.
C        ON COMPARE PAR RAPPORT AU MIN DES 2 VALEURS ITER_GLOB
C        IL FAUT FAIRE ATTENTION AUX ARRONDIS PAR SECURITE AJOUT 20%

      IF ( (CIBLEN*1.20D0) .LT. MNITER ) THEN
        RATIO    = 24.0D0/((3.0D0*NBRPAS+UN)**2 - UN)
        VALIM(1) = NBRPAS
        VALIM(2) = LENIVO
        VALRM(1) = RATIO
        VALRM(2) = DELTAT
        VALRM(3) = CIBLEN
        VALRM(4) = MNITER
        IF ( REGRES .EQ. 1 ) THEN
          VALKM(1) = 'RESI_GLOB_RELA'
        ELSE
          VALKM(1) = 'RESI_GLOB_MAXI'
        ENDIF               
        CALL U2MESG('I','SUBDIVISE_11',1,VALKM,2,VALIM,4,VALRM)
        GOTO 999
      ENDIF

      VALIM(1) = NINT(CIBLEN)
      VALIM(2) = MXITER
      CALL U2MESI('I','SUBDIVISE_16',2,VALIM)
      IF ( CIBLEN .LT. MXITER ) THEN
        IF ( CIBLEN .LE. ITERAT ) THEN
          VALIM(1) = ITERAT
          CALL U2MESI('I','SUBDIVISE_17',1,VALIM)
        ENDIF
        RETOUR = 3
      ELSE
C       CALCUL DU RATIO POUR ATTEINDRE LA CIBLE
  
        IF (XA1.LE.R8PREM()) THEN
          RATIO    = 24.0D0/((3.0D0*NBRPAS+UN)**2 - UN)
          RETOUR   = 0
          VALIM(1) = NBRPAS
          VALIM(2) = LENIVO
          VALRM(1) = RATIO
          VALRM(2) = DELTAT
          VALRM(3) = CIBLEN
          VALRM(4) = MNITER
          IF ( REGRES .EQ. 1 ) THEN
            VALKM(1) = 'RESI_GLOB_RELA'
          ELSE
            VALKM(1) = 'RESI_GLOB_MAXI'
          ENDIF               
          CALL U2MESG('I','SUBDIVISE_11',1,VALKM,2,VALIM,4,VALRM)
          GOTO 999
        ENDIF 
        IF ( (CIBLEN-MXITER) .LE. (-10.0D0*XA1/XDET) ) THEN
          RATIO = EXP( (CIBLEN-MXITER)*XDET/XA1 )
        ELSE
          RATIO = EXP( -10.0D0 )
        ENDIF
        RATIO = 0.48485D0*RATIO
        XXBB = ( -UN + (UN+24.0D0/RATIO)**0.5D0 )/3.0D0
        IF ( XXBB .LT. 2.0D0 ) THEN
          NBRPAS = 2
          RATIO  = 0.50D0
        ELSE
          NBRPAS = NINT( XXBB )
        ENDIF
        VALIM(1) = NBRPAS
        VALIM(2) = LENIVO
        VALRM(1) = RATIO
        VALRM(2) = DELTAT
        CALL U2MESG('I','SUBDIVISE_18',0,VALKM,2,VALIM,2,VALRM)
      ENDIF
C         
  999 CONTINUE   
C
      CALL JEDEMA()
      END
