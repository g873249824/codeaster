      SUBROUTINE OP0025()
C
C ----------------------------------------------------------------------
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 17/01/2011   AUTEUR ABBAS M.ABBAS 
C ======================================================================
C COPYRIGHT (C) 1991 - 2011  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C     COMMANDE:  THER_LINEAIRE
C ----------------------------------------------------------------------
C
      IMPLICIT   NONE
C
C 0.1. ==> ARGUMENTS
C
C
C 0.2. ==> COMMUNS
C
C --- DEBUT DECLARATIONS NORMALISEES JEVEUX ----------------------------
C
      INTEGER ZI
      COMMON /IVARJE/ZI(1)
      REAL*8 ZR
      COMMON /RVARJE/ZR(1)
      COMPLEX*16 ZC
      COMMON /CVARJE/ZC(1)
      LOGICAL ZL
      COMMON /LVARJE/ZL(1)
      CHARACTER*8 ZK8
      CHARACTER*16 ZK16
      CHARACTER*24 ZK24
      CHARACTER*32 ZK32
      CHARACTER*80 ZK80
      COMMON /KVARJE/ZK8(1),ZK16(1),ZK24(1),ZK32(1),ZK80(1)
C
C --- FIN DECLARATIONS NORMALISEES JEVEUX ------------------------------
C
C 0.3. ==> VARIABLES LOCALES
C
      CHARACTER*6 NOMPRO
      PARAMETER ( NOMPRO = 'OP0025' )
C
      INTEGER VALI, ETAUSR
      INTEGER NRORES
      INTEGER IFM,NIV
      INTEGER JLCHA,JFCHA,JINFC
      INTEGER NOPT,NCHAR,JINF,I,IALIFC,IALICH
      INTEGER NEQ,NUMORD,DERNIE
      INTEGER NBPASE, NRPASE
      INTEGER PARMEI(1), PARCRI(1)
C
      REAL*8 PARMER(1), PARCRR(1), PARA(2), VALR(2)
      REAL*8 TPSTHE(6),TPS1(4),DELTAT,DELTAM
      REAL*8 THETA,INSTAP,DIINST
C
      LOGICAL MATCST,COECST,LOSTAT,EVOL,ASME,ASMS,FINPAS
      LOGICAL REASVC,REASVT,REASMT,REASRG,REASMS,DIDERN
C
      CHARACTER*1 CREAS
      CHARACTER*4 TYPCAL
      CHARACTER*8 EVOLSC
      CHARACTER*8 SAUX08,MAILLA
      CHARACTER*13 INPSCO
      CHARACTER*19 SDOBSE
      CHARACTER*19 MAPREC,SOLVEU,INFCHA,LISCHA,SDDISC
      CHARACTER*19 LISINS
      CHARACTER*24 RESULT,MODELE,CHARGE,CARELE
      CHARACTER*24 FOMULT,NUMEDD
      CHARACTER*24 MEDIRI,MATASS
      CHARACTER*24 CNDIRP,CNCHCI,TIME
      CHARACTER*24 INFOCH,MATE,VHYDR
      CHARACTER*24 VEC2ND,NOOBJ
      CHARACTER*24 COMPOR,CRITHE
      CHARACTER*24 LISOPT
C
C ----------------------------------------------------------------------
      DATA RESULT          /' '/
      DATA CRITHE                 /'&&OP0025.CRITERE'/
      DATA MEDIRI/' '/
      DATA CNDIRP,CNCHCI/2*' '/
      DATA TPSTHE/6*0.D0/
      DATA SDDISC    /'&&OP0025.SDDISC'/
      DATA SDOBSE            /'&&OP0025.OBSER'/

C DEB ------------------------------------------------------------------
C====
C 1. PREALABLES
C====
C
      CALL JEMARQ()
C
C-----RECUPERATION DU NIVEAU D'IMPRESSION
C
      CALL INFMAJ
      CALL INFNIV(IFM,NIV)
C
C-----------------------------------------------------------------------
      ASME = .TRUE.
      ASMS = .FALSE.
C
C 1.2. ==> NOM DES STRUCTURES
C
C               12   345678   90123
      INPSCO = '&&'//NOMPRO//'_PSCO'
C
C               12   345678   90123456789
      SOLVEU = '&&'//NOMPRO//'.SOLVEUR   '
      INFCHA = '&&'//NOMPRO//'_INFCHA    '
      MAPREC = '&&'//NOMPRO//'_MAT_PRECON'
C
C               12   345678   9012345678901234
      VEC2ND = '&&'//NOMPRO//'_2ND_MEMBRE     '
      MATASS = '&&'//NOMPRO//'_MATR_ASSEM     '

C     DETERMINATION DU NOM DE LA SD INFO_CHARGE
C             12345678    90123    45678901234
      NOOBJ ='12345678'//'.1234'//'.EXCIT.INFC'
      CALL GNOMSD(NOOBJ,10,13)
      LISCHA = NOOBJ(1:19)
C====
C 2. LES DONNEES
C====
C
C 2.1. ==> LECTURE DES OPERANDES DE LA COMMANDE
C               12   345678
      SAUX08 = '&&'//NOMPRO
C
      CALL NXLECT (RESULT,MODELE,MATE,CARELE,MATCST,COECST,
     >             FOMULT,INFCHA,CHARGE,INFOCH,
     >             PARMEI,PARMER,SOLVEU,PARCRI,PARCRR,
     >             LISOPT,NOPT,COMPOR,EVOLSC,
     >             NBPASE, SAUX08, INPSCO )
      PARA(1) = PARMER(1)
C

C 2.3. ==> LECTURE DE L'ETAT INITIAL ET DES DONNEES D'INCREMENTATION
C
      CALL NTINIT(RESULT,MODELE,INFCHA,
     &            SOLVEU,NUMEDD,LOSTAT,EVOL  ,
     &            TIME  ,SDDISC,DERNIE,LISINS,NBPASE,
     &            INPSCO,VHYDR ,SDOBSE,MAILLA,CRITHE)
C
C 2.4. ==> ARCHIVAGE SI REPRISE D'UN CALCUL OU ETAT INITIAL NON NUL
C
      IF (.NOT.LOSTAT) THEN
        CALL NTREP0 ( SDDISC, DERNIE, VHYDR, NBPASE, INPSCO,
     &                MODELE, MATE, CARELE, LISCHA )
      END IF
C
C 2.5. ==> CALCUL DES MATRICES ELEMENTAIRES DES DIRICHLETS
C
      TYPCAL = 'THER'
      CALL MEDITH ( TYPCAL, MODELE, CHARGE, INFOCH, MEDIRI )
C
C 2.6. ==> PILOTAGE DES REACTUALISATIONS DES ASSEMBLAGES
C     REASVT : INSTANTS, DIRICHLET, TERMES DU TRANSITOIRE
C     REASVC : CHARGEMENTS (SOURCES, FLUX, ... )
C     REASRG : MATRICE DE RIGIDITE
C     REASMS : MATRICE DE MASSE
C     REASMT : MATRICE TANGENTE POUR LE NON-LINEAIRE (SANS OBJET ICI)
C
      REASVT = .TRUE.
      REASVC = .TRUE.
      REASRG = .FALSE.
      REASMS = .FALSE.
      REASMT = .FALSE.
C

      IF (LOSTAT) THEN
        ASMS = .TRUE.
        NUMORD=0
      ELSE
        NUMORD=1
      ENDIF

      DELTAT=-1.D150
C
C 2.6. ==> CREATION DES STRUCTURES
C
      CALL VTCREB (VEC2ND, NUMEDD, 'V', 'R',NEQ )
C
C====
C 3. BOUCLES SUR LES PAS DE TEMPS
C====
C
      CALL UTTCPU('CPU.OP0025','INIT',' ')

200   CONTINUE

C --- RECUPERATION DU PAS DE TEMPS ET DES PARAMETRES DE RESOLUTION

C --- CETTE BOUCLE IF SERT A MAINTENIR LE NUMERO D ORDRE
C --- A 1 DANS LE CAS D UN CALCUL STATIONNAIRE.
C --- IL FAUT EN EFFET PROCEDER A CE CALCUL AVANT DE PARCOURIR
C --- LA LISTE D INSTANT DE LA SD SDDISC

        IF (LOSTAT) THEN
          IF (.NOT.EVOL) THEN
            INSTAP=0.D0
            DELTAM=DELTAT
            DELTAT=-1.D150
            THETA=1.D0
          ELSE
            INSTAP=DIINST(SDDISC, NUMORD)
            DELTAM=DELTAT
            DELTAT=-1.D150
            THETA=1.D0
          ENDIF
        ELSE
          INSTAP = DIINST(SDDISC, NUMORD)
          DELTAM=DELTAT
          DELTAT = INSTAP-DIINST(SDDISC, NUMORD-1)
          THETA=PARMER(1)
        ENDIF
        PARA(2) = DELTAT
C --- MATRICE TANGENTE REACTUALISEE POUR UN NOUVEAU DT

          CALL UTTCPU('CPU.OP0025','DEBUT',' ')
          TPSTHE(1) = INSTAP
          TPSTHE(2) = DELTAT
          TPSTHE(3) = THETA
C
C 3.2.2. ==> BOUCLE 322 SUR LES RESOLUTIONS
C            LE PREMIER PASSAGE, 0, EST CELUI DU CALCUL STANDARD
C            LES PASSAGES SUIVANTS SONT CEUX DES DERIVATIONS
C
          DO 322 , NRORES = 0 , NBPASE
C
            NRPASE = NRORES
C
C 3.2.2.1. ==> Y-A-T'IL ASSEMBLAGE DES MATRICES ?
C
            IF ( NRORES.EQ.0 ) THEN
C
              IF ((.NOT.MATCST.OR..NOT.COECST) .OR. ASMS .OR. ASME) THEN
                REASRG = .TRUE.
                ASMS = .FALSE.
              END IF
              IF ((.NOT.MATCST) .OR.DELTAM.NE.DELTAT) THEN
                REASMS = .TRUE.
                ASME = .FALSE.
              END IF
C
            END IF
C
C 3.2.2.2. ==> RESOLUTION NUMERO NRPASE
C
            CALL NTRESO ( NRPASE, NBPASE, INPSCO, SDDISC,
     >                    MODELE,MATE,CARELE,FOMULT,CHARGE,INFCHA,
     >                    INFOCH,NUMEDD,SOLVEU,LOSTAT,TIME,
     >                    TPSTHE,REASVC,REASVT,REASMT,REASRG,REASMS,
     >                    CREAS,VEC2ND,MATASS,MAPREC,
     >                    CNDIRP,CNCHCI,MEDIRI,COMPOR,
     >                    NUMORD, PARA,
     >                    LISCHA )
C
            REASRG = .FALSE.
            REASMS = .FALSE.
C
  322     CONTINUE
C
C        ==> VERIFICATION SI INTERRUPTION DEMANDEE PAR SIGNAL USR1
C
          IF ( ETAUSR().EQ.1 ) THEN
             CALL SIGUSR()
          ENDIF        
C
C 3.2.3. ==> GESTION DU TEMPS CPU
C
          IF (.NOT.EVOL) THEN
            FINPAS=.TRUE.
          ELSE
            FINPAS = DIDERN(SDDISC, NUMORD)
          ENDIF
          CALL UTTCPU('CPU.OP0025','FIN',' ')
          CALL UTTCPR('CPU.OP0025',4,TPS1)
          IF ( TPS1(4).GT..95D0*TPS1(1)-TPS1(4) ) THEN
            VALI = NUMORD
            VALR(1) = TPS1(4)
            VALR(2) = TPS1(1)
            CALL UTEXCM(28,'ALGORITH16_68',0,' ',1,VALI,2,VALR)
          ELSE
            WRITE (IFM,'(A,1X,I6,2(1X,A,1X,1PE11.3))')
     >        'NUMERO D''ORDRE:',NUMORD,'INSTANT:',INSTAP,
     >        'DUREE MOYENNE:',TPS1(4)
          END IF
        IF (LOSTAT) THEN
          LOSTAT=.FALSE.
        ENDIF
        NUMORD = NUMORD + 1

      IF (FINPAS) GOTO 41

      GOTO 200


   41 CONTINUE
C

C
C --- COPIE DE LA SD INFO_CHARGE DANS LA BASE GLOBALE
C
      CALL GETFAC('EXCIT',NCHAR)
      CALL JEDETR(LISCHA//'.LCHA')
      CALL WKVECT(LISCHA//'.LCHA','G V K24',NCHAR,JLCHA)
      CALL JEVEUO(INFCHA//'.LCHA','L',IALICH)
      CALL JEDETR(LISCHA//'.FCHA')
      CALL WKVECT(LISCHA//'.FCHA','G V K24',NCHAR,JFCHA)
      CALL JEVEUO(FOMULT,'L',IALIFC)
      DO 51 I=1,NCHAR
        ZK24(JLCHA+I-1)=ZK24(IALICH+I-1)
        ZK24(JFCHA+I-1)=ZK24(IALIFC+I-1)
 51   CONTINUE
      CALL JEDETR(LISCHA//'.INFC')
      CALL WKVECT(LISCHA//'.INFC','G V IS',2*NCHAR+1,JINFC)
      CALL JEVEUO(INFCHA//'.INFC','L',JINF)
      DO 52 I=1,2*NCHAR+1
         ZI(JINFC+I-1)=ZI(JINF+I-1)
 52   CONTINUE


      CALL TITRE()

C     -- MENAGE FINAL :
      CALL DETMAT()

      CALL JEDEMA()
      END
