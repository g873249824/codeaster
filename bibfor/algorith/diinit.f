      SUBROUTINE DIINIT(INSTAN, PARTPS, DERNIE, RESULT)

C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 11/02/2003   AUTEUR PBADEL P.BADEL 
C ======================================================================
C COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
C (AT YOUR OPTION) ANY LATER VERSION.                                 
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
C    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
C ======================================================================
C RESPONSABLE PBADEL P.BADEL

      IMPLICIT      NONE
      INTEGER       DERNIE
      REAL*8        INSTAN
      CHARACTER*19  PARTPS
      CHARACTER*8   RESULT

C ----------------------------------------------------------------------
C
C COMMANDE STAT_NON_LINE : LISTE DES INSTANTS DE CALCUL.
C
C ----------------------------------------------------------------------
C IN   INSTAN  R8 INSTANT INITIAL QUAND ETAT_INIT (OU R8VIDE)
C IN/  JXOUT   PARTPS K19 SD DISCRETISATION
C IN   DERNIE  I  DERNIER NUMERO ARCHIVE (OU 0 SI NON REENTRANT)
C
C --- DEBUT DECLARATIONS NORMALISEES JEVEUX ----------------------------
C

      CHARACTER*32 JEXNUM , JEXNOM , JEXR8 , JEXATR
      INTEGER      ZI
      COMMON  / IVARJE / ZI(1)
      REAL*8       ZR
      COMMON  / RVARJE / ZR(1)
      COMPLEX*16   ZC
      COMMON  / CVARJE / ZC(1)
      LOGICAL      ZL
      COMMON  / LVARJE / ZL(1)
      CHARACTER*8  ZK8
      CHARACTER*16    ZK16
      CHARACTER*24        ZK24
      CHARACTER*32            ZK32
      CHARACTER*80                ZK80
      COMMON  / KVARJE / ZK8(1) , ZK16(1) , ZK24(1) , ZK32(1) , ZK80(1)

C
C --- FIN DECLARATIONS NORMALISEES JEVEUX ------------------------------

       INTEGER   NBINST, JINST, NBTEMP, JTEMPS, NLIARC, JLIARC, JARCH
       INTEGER   N1,N2,N3,N4,N5,NOCC, NUMINI, NUMFIN, SENS, POS, IRET, I
       INTEGER   NUMARC, FREARC, NUM, NUMINS, NBRPAS
       INTEGER   NB, JEXCL, JINFO, IBID
       INTEGER   LONG, NORDAR,JINSAR,JORDAR
       REAL*8    DELTAT, DELMIN, TOLE, INST, RATIO, PASMIN, R8BID
       REAL*8    R8VIDE
       REAL*8    VALE,INSTAR,DIFF
       REAL*8    DT,DTMIN,INS
       LOGICAL   TEST
       CHARACTER*8  K8BID
       CHARACTER*16 CHRONO, K16BID
       CHARACTER*19 LISINS, LISARC

C ----------------------------------------------------------------------

      CALL JEMARQ()

C ======================================================================
C CONSTRUCTION DE LA LISTE D'INSTANTS
C ======================================================================
      
      CHRONO = ' '
      LISINS = ' '

      CALL GETVTX('INCREMENT','EVOLUTION',1,1,1,CHRONO,N1)
      CALL GETVID('INCREMENT','LIST_INST'  ,1,1,1,LISINS,N1)
      CALL JEVEUO(LISINS // '.VALE', 'L', JINST)
      CALL JELIRA(LISINS // '.VALE', 'LONMAX', NBINST, K8BID)
      
      NBINST = NBINST-1
      
C -- VERIFICATIONS DIVERSES
C    IL Y A AU MOINS UN INSTANT DE CALCUL

      IF (NBINST.LE.0) CALL UTMESS('F','DIINIT','IL N''Y A AUCUN '
     &   // 'INSTANT DE CALCUL (''LIST_INST'')')

C    VERIFICATION DU CARACTERE CROISSANT DE LA LISTE D'INSTANTS

      IF (CHRONO .NE. 'SANS') THEN
       DELMIN = ZR(JINST+1) - ZR(JINST)
       DO 10 I = 0,NBINST-1
        DELTAT = ZR(JINST + I+1) - ZR(JINST + I)
        DELMIN = MIN(DELTAT,DELMIN)
        IF (DELTAT.LE.0) CALL UTMESS('F',
     &     'DIINIT','LISTE D''INSTANTS NON CROISSANTE')
10     CONTINUE

C  TOLERANCE POUR ACCES PAR INSTANT

       CALL GETVR8('INCREMENT','PRECISION'     ,1,1,1,TOLE,N1)
       TOLE = DELMIN * TOLE
      END IF

C -- DETERMINATION DU NUMERO D'ORDRE INITIAL

      CALL GETVIS('INCREMENT','NUME_INST_INIT',1,1,1,NUMINI,N1)
      CALL GETVR8('INCREMENT','INST_INIT'     ,1,1,1,INST  ,N2)
      CALL GETFAC('ETAT_INIT',N3)
      
C    L'INSTANT DE L'ETAT INITIAL EXISTE-T-IL 

      IF (INSTAN .EQ. R8VIDE()) N3=0

C    PAS D'OCCURENCE DES MOTS-CLES -> NUMERO INITIAL

      IF (N1+N2+N3 .EQ. 0) THEN
       IF (CHRONO .EQ. 'RETROGRADE') THEN
        NUMINI = NBINST
       ELSE
        NUMINI = 0
       END IF

C MOTS-CLES INST_INIT OU INSTANT DEFINI PAR ETAT_INIT

      ELSE IF (N1 .EQ. 0) THEN

C    EVOLUTION CHRONOLOGIQUE OU RETROGRADE UNIQUEMENT

       IF (CHRONO.EQ.'SANS') CALL UTMESS('F','DIINIT','ACCES PAR '
     &     // 'INSTANT SANS EVOLUTION ORDONNEE INTERDIT (INCREMENT)')

C   INSTANT DE L'ETAT INITIAL

       IF (N2 .EQ. 0) THEN
        INST = INSTAN
        CALL UTACLI(INST,ZR(JINST),NBINST,TOLE,NUMINI)

C SI INST NON PRESENT DANS LA LISTE D INSTANT 
C ON CHERCHE L INSTANT LE PLUS PROCHE

        IF (NUMINI.LT.0) THEN
         DTMIN=INST-ZR(JINST)
         INS=ZR(JINST)
         DO 40 I=1,NBINST
          DT=INST-ZR(JINST+I)
          IF (CHRONO .EQ. 'RETROGRADE') THEN 
           IF (DT.GE.0.D0) GOTO 45
           IF (DT.GT.DTMIN) THEN
            DTMIN=DT
            INS=ZR(JINST+I)
           ENDIF
          ELSE
           IF (DT.LE.0.D0) GOTO 45
           IF (DT.LT.DTMIN) THEN
            DTMIN=DT
            INS=ZR(JINST+I)
           ENDIF
          ENDIF
 40      CONTINUE
 45      CONTINUE
         INST=INS
        ENDIF
       ENDIF  

C  ACCES A L'INSTANT INST
       
       CALL UTACLI(INST,ZR(JINST),NBINST,TOLE,NUMINI)
       IF (NUMINI .LT. 0) CALL UTMESS('F','DIINIT','INSTANT INITIAL '
     &     // 'INTROUVABLE DANS LA LISTE D''INSTANTS (LIST_INST)')
      END IF

C -- DETERMINATION DU NUMERO D'ORDRE FINAL

      CALL GETVIS('INCREMENT','NUME_INST_FIN',1,1,1,NUMFIN,N1)
      CALL GETVR8('INCREMENT','INST_FIN'     ,1,1,1,INST  ,N2)

C    PAS D'OCCURENCE DES MOTS-CLES -> NUMERO INITIAL

      IF (N1+N2 .EQ. 0) THEN
       IF (CHRONO .EQ. 'RETROGRADE') THEN
        NUMFIN = 0
       ELSE
        NUMFIN = NBINST
       END IF

C    MOT-CLE NUME_INST_FIN

      ELSE IF (N1 .EQ. 0) THEN

C   EVOLUTION CHRONOLOGIQUE OU RETROGRADE UNIQUEMENT

       IF (CHRONO.EQ.'SANS') CALL UTMESS('F','DIINIT','ACCES PAR '
     &     // 'INSTANT SANS EVOLUTION ORDONNEE INTERDIT (INCREMENT)')

C   ACCES A L'INSTANT INST

       CALL UTACLI(INST,ZR(JINST),NBINST,TOLE,NUMFIN)
       IF (NUMFIN .LT. 0) CALL UTMESS('F','DIINIT','INSTANT FINAL '
     &     // 'INTROUVABLE DANS LA LISTE D''INSTANTS (LIST_INST)')
      END IF

C -- ECRITURE DE LA LISTE D'INSTANTS

      IF (CHRONO .EQ. 'RETROGRADE') THEN
       SENS = -1
       IF (NUMINI .LE. NUMFIN) CALL UTMESS('F','DIINIT',
     &   'NUME_INST_INIT '
     &   // 'PLUS PETIT QUE NUME_FIN AVEC EVOLUTION: ''RETROGRADE''')
      ELSE
       SENS = 1
       IF (NUMINI.GE.NUMFIN) CALL UTMESS('F','DIINIT','NUME_INIT '
     &     // 'PLUS GRAND QUE NUME_FIN')
      END IF
      
      IF (NUMINI.LT.0 .OR. NUMINI.GT.NBINST) CALL UTMESS('F','DIINIT',
     &  'NUME_INST_INIT N''APPARTIENT PAS A LA LISTE D''INSTANTS')
      IF (NUMFIN.LT.0 .OR. NUMFIN.GT.NBINST) THEN
       CALL UTMESS('A','DIINIT','NUME_INST_FIN N''APPARTIENT PAS A ' //
     &    'LA LISTE D''INSTANTS : ON S''ARRETE A LA FIN DE LA LISTE')  
       IF (CHRONO .EQ. 'RETROGRADE') THEN
        NUMFIN = 0
       ELSE
        NUMFIN = NBINST
       END IF
      END IF 
      NBTEMP= (NUMFIN-NUMINI)*SENS
      CALL WKVECT(PARTPS // '.DITR','V V R8',NBTEMP+1,JTEMPS)
      POS = 0
      DO 20 I = NUMINI, NUMFIN, SENS
       ZR(JTEMPS+POS) = ZR(JINST+I)
      POS = POS+1
 20   CONTINUE

C ======================================================================
C   INFORMATIONS SUR L'ARCHIVAGE
C ======================================================================

C -- LISTE D'ARCHIVAGE

      CALL WKVECT(PARTPS // '.DIAL','V V L',NBTEMP+1,JARCH)
      DO 25 I = 1, NBTEMP
       ZL(JARCH+I) = .FALSE.
 25   CONTINUE
      CALL GETVIS('ARCHIVAGE','PAS_ARCH' ,1,1,1,FREARC,N1)
      CALL GETVID('ARCHIVAGE','LIST_INST',1,1,1,LISARC,N2)
      CALL GETVR8('ARCHIVAGE','INST'     ,1,1,0,R8BID ,N3)
      N3 = -N3

C    AUCUN MOT-CLE : PAS_ARCH=1

      IF (N1+N2+N3 .EQ. 0) THEN
       FREARC = 1
       N1     = 1
      END IF

C    MOT-CLE FREQ_ARCH

      IF (N1 .GE. 1) THEN
       DO 30 I = FREARC, NBTEMP, FREARC
        ZL(JARCH+I) = .TRUE.
 30    CONTINUE

C    MOT_CLE LIST_INST OU INST

      ELSE
       IF (CHRONO.EQ.'SANS') CALL UTMESS('F','DIINIT','ACCES PAR '
     &    // 'INSTANT SANS EVOLUTION ORDONNEE INTERDIT (ARCHIVAGE)')

C   PRECISION D'ACCES A LA LISTE D'INSTANTS

       CALL GETVR8('ARCHIVAGE','PRECISION'     ,1,1,1,TOLE,NOCC)
       TOLE = DELMIN * TOLE

C RECUPERATION DE LA LISTE DES INSTANTS A ARCHIVER

       IF (N3.GE.1) THEN
        LISARC = '&&DIINIT.LISARC'
        NLIARC =  N3
        CALL WKVECT(LISARC,'V V R8',N3,JLIARC)
        CALL GETVR8('ARCHIVAGE','INST',1,1,NLIARC,ZR(JLIARC),IRET)
       ELSE
        CALL JEVEUO(LISARC // '.VALE','L',JLIARC)
        CALL JELIRA(LISARC // '.VALE','LONMAX',NLIARC,K8BID)
       END IF

C    CONSTRUCTION DE LA LISTE D'ARCHIVAGE

       DO 50 I = 1,NLIARC
        INST = ZR(JLIARC-1+I)
        CALL UTACLI(INST,ZR(JTEMPS),NBTEMP,TOLE,NUMINS)
        IF (NUMINS.NE.-1) THEN
         ZL(JARCH+NUMINS) = .TRUE.
        ENDIF
50     CONTINUE
       FREARC  = 0
      END IF

C -- CHAMPS EXCLUS DE L'ARCHIVAGE

      CALL GETVTX('ARCHIVAGE','CHAM_EXCLU' ,1,1,0,K16BID,NB)
      NB = -NB
      IF (NB .NE. 0) THEN
       CALL WKVECT(PARTPS // '.DIEK','V V K16',NB,JEXCL)
       CALL GETVTX('ARCHIVAGE','CHAM_EXCLU',1,1,NB,ZK16(JEXCL),IBID)
      ENDIF

C -- DETERMINATION DU PREMIER NUMERO ARCHIVE

      CALL GETVTX('ARCHIVAGE','ARCH_ETAT_INIT',1,1,1,K16BID,N1)
      CALL GETVIS('ARCHIVAGE','NUME_INIT'     ,1,1,1,NUMARC,N2)
      CALL GETVIS('ETAT_INIT','NUME_ORDRE',1,1,1,IBID,N3)
      CALL GETVR8('ETAT_INIT','INST',1,1,1,R8BID ,N4)
      CALL GETVR8('ETAT_INIT','INST_ETAT_INIT',1,1,1,R8BID ,N5)

C    ARCHIVAGE DE L'ETAT INITIAL

      IF (N1.GE.1) THEN
       IF (DERNIE.NE.0) CALL UTMESS('F','DIINIT','IMPOSSIBLE D''ARCHIV'
     &   //'ER L''ETAT INITIAL : LE CONCEPT EST REENTRANT (ARCHIVAGE)')
       NUMARC = 0

C    ARCHIVAGE A PARTIR D'UN NUMERO DONNE

      ELSE
       IF (N2.EQ.0) THEN
        IF ((N3.EQ.1).OR.(N4.EQ.1)) THEN
         IF ((DERNIE.EQ.0).OR.(N5.EQ.1)) THEN
          NUMARC=DERNIE+1
         ELSE
          DO 60 I=2,NBTEMP+1
           TEST = ZL(JARCH+I-1)
           IF ( TEST ) THEN
            VALE = ZR(JTEMPS+I-1)
            GOTO 1000
           ENDIF
  60      CONTINUE
 1000     CONTINUE
          CALL JELIRA(RESULT // '           .ORDR','LONUTI',LONG,K8BID)
          CALL JEVEUO(RESULT // '           .INST','L',JINSAR)
          CALL JEVEUO(RESULT // '           .ORDR','L',JORDAR)
          TEST = .FALSE.
          DO 70 I=1,LONG
           INSTAR = ZR(JINSAR+I-1)
           DIFF = ABS(INSTAR-VALE)
           IF (DIFF.LE.1.D-10) THEN
            NORDAR = ZI(JORDAR+I-1)
            TEST = .TRUE.
            GOTO 2000
           ENDIF
 70       CONTINUE
 2000     CONTINUE
          IF (TEST ) THEN
           NUMARC =NORDAR
          ELSE
           NUMARC=DERNIE+1
          ENDIF
         ENDIF
        ELSE
         NUMARC = DERNIE +1
        ENDIF
       ELSE
        
C  ON VERIFIE LES RISQUES D'ECRASEMENT

        IF (NUMARC.LE.DERNIE) THEN
         CALL GETVTX('ARCHIVAGE','DETR_NUME_SUIV',1,1,1,K16BID,NOCC)
         IF (NOCC.EQ.0) CALL UTMESS('F','DIINIT','L''ARCHIVAGE VA '
     &   // 'ECRASER DES INSTANTS DEJA CALCULES (ARCHIVAGE)')

C  ON VERIFIE QU'ON NE CREE PAS DE TROUS DANS L'ARCHIVAGE

        ELSE IF (NUMARC.GT.DERNIE+1) THEN
         CALL UTMESS('F','DIINIT','L''ARCHIVAGE VA LAISSER DES TROUS'
     &      // ' DANS LA SD EVOL_NOLI (ARCHIVAGE, NUME_INIT)')
        END IF
       END IF
      END IF

C -- ECRITURE DE LA FREQUENCE ET DU PREMIER NUMERO D'ARCHIVAGE

      CALL WKVECT(PARTPS // '.DIIR','V V R8',5,JINFO)
      ZR(JINFO-1 + 1) = NUMARC
      ZR(JINFO-1 + 2) = FREARC

C ======================================================================
C    SUBDIVISION AUTOMATIQUE DU PAS DE TEMPS
C ======================================================================

      CALL GETVIS('INCREMENT','SUBD_PAS',1,1,1,NBRPAS,NOCC)
      IF (NBRPAS .LT. 1) CALL UTMESS('F','DIINIT','LE NOMBRE DE SUBDIVI'
     & // 'SIONS DU PAS DE TEMPS DOIT ETRE PLUS GRAND QUE 1 (SUBD_PAS)')
      ZR(JINFO-1 + 3) = NBRPAS

C -- SUBDIVISION ACTIVEE

      IF (NBRPAS .GT. 1) THEN
       CALL GETVR8('INCREMENT','SUBD_PAS_MINI',1,1,1,PASMIN,NOCC)
       IF (NOCC.EQ.0) CALL UTMESS ('F','DIINIT','IL FAUT IMPOSER UNE '
     &   // 'TAILLE MINIMAL DE PAS DE TEMPS (SUBD_PAS_MINI) LORSQUE '
     &   // 'LA SUBDIVISION AUTOMATIQUE EST ACTIVEE')
       IF (PASMIN .GT. DELMIN) CALL UTMESS('F','DIINIT','CERTAINS PAS '
     &   // 'DE TEMPS DE LA LISTE (LISTE_INST) SONT PLUS PETITS QUE LE '
     &   // 'PAS DE TEMPS MINIMAL RENSEIGNE (SUBD_PAS_MINI)')
       ZR(JINFO-1 + 4) = PASMIN
       CALL GETVR8('INCREMENT','COEF_SUBD_PAS_1',1,1,1,RATIO,NOCC)
       ZR(JINFO-1 + 5) = RATIO
      END IF

      CALL JEDEMA()

      END
