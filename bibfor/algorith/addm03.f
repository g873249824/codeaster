      SUBROUTINE ADDM03 ( IERUSR, ICMD,
     >                    NBOPT, TABENT, TABREE, TABCAR, LGCAR )
C
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 05/03/2002   AUTEUR GNICOLAS G.NICOLAS 
C ======================================================================
C COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
C (AT YOUR OPTION) ANY LATER VERSION.                                 
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
C    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
C ======================================================================
C RESPONSABLE GNICOLAS G.NICOLAS
C TOLE CRP_20
C     ------------------------------------------------------------------
C      ADAPTATION - DECODAGE DE LA MACRO-COMMANDE - PHASE 03
C      --           -              -                      --
C      ECRITURE DE LA COMMANDE D'ECRITURE DU FICHIER DE CONFIGURATION
C      POUR HOMARD
C     ------------------------------------------------------------------
C
      IMPLICIT NONE
C
C 0.1. ==> ARGUMENTS
C
      INTEGER IERUSR, ICMD
      INTEGER NBOPT
      INTEGER TABENT(NBOPT), LGCAR(NBOPT)
C
      REAL*8 TABREE(NBOPT)
C
      CHARACTER*(*) TABCAR(NBOPT)
C
C 0.2. ==> VARIABLES LOCALES
C
      CHARACTER*6 NOMPRO
      PARAMETER ( NOMPRO = 'ADDM03' )
C
      INTEGER NBMCF
      PARAMETER ( NBMCF = 3 )
C
      INTEGER EDNONO
      PARAMETER (EDNONO=-1)
C
      INTEGER CODRET
      INTEGER IAUX
      INTEGER NUFIHO
      INTEGER NIVINF, IFM
      INTEGER MODHOM, TYPRAF, TYPDER
      INTEGER TYPCRR, TYPCRD
      INTEGER NIVMIN, NIVMAX
      INTEGER NUMORD, NUMPT
      INTEGER NITER
      INTEGER NBMAJS
      INTEGER BILNBR, BILQUA, BILINT, BILCXT, BILTAI
      INTEGER LCRN, LCHINM
      INTEGER LNMMN, LNMMN1
      INTEGER LNCPIN
      INTEGER LNMDIN
      INTEGER LREPHC
      INTEGER LLANGU
C
      REAL*8 CRITDE, CRITRA
C
      CHARACTER*8 NCPIN
      CHARACTER*8 CRN
      CHARACTER*16 MOTCLE
      CHARACTER*16 CHINME
      CHARACTER*16 MCLF(NBMCF)
      CHARACTER*32 NMDMN, NMDMN1
      CHARACTER*32 NMDIN
      CHARACTER*72 REPHC
      CHARACTER*128 LANGUE
      CHARACTER*128 REP
C
C====
C 1. RECUPERATION DES ARGUMENTS
C====
C
C 1.1. ==> ENTIERS
C
      NUFIHO = TABENT(1)
      MODHOM = TABENT(2)
      NITER  = TABENT(3)
      TYPRAF = TABENT(6)
      TYPDER = TABENT(7)
      NBMAJS = TABENT(8)
      TYPCRR = TABENT(9)
      TYPCRD = TABENT(10)
      NIVMAX = TABENT(11)
      NIVMIN = TABENT(12)
      NUMPT  = TABENT(15)
      NUMORD = TABENT(16)
      IFM    = TABENT(29)
      NIVINF = TABENT(30)
      BILNBR = TABENT(31)
      BILQUA = TABENT(32)
      BILCXT = TABENT(33)
      BILTAI = TABENT(34)
      BILINT = TABENT(35)
C
C 1.2. ==> CARACTERES
C
      LCRN = LGCAR(4)
      IF ( LCRN.GT.0 ) THEN
        CRN(1:LCRN) = TABCAR(4)(1:LCRN)
      ENDIF
C
      LCHINM = LGCAR(5)
      IF ( LCHINM.GT.0 ) THEN
        CHINME(1:LCHINM) = TABCAR(5)(1:LCHINM)
      ENDIF
C
      LNCPIN = LGCAR(6)
      IF ( LNCPIN.NE.0 ) THEN
        NCPIN(1:LNCPIN) = TABCAR(6)(1:LNCPIN)
      ENDIF
C
      LREPHC = LGCAR(29)
      REPHC(1:LREPHC) = TABCAR(29)(1:LREPHC)
C
      LNMMN = LGCAR(31)
      IF ( LNMMN.NE.0 ) THEN
        NMDMN(1:LNMMN) = TABCAR(31)(1:LNMMN)
      ENDIF
C
      LNMMN1 = LGCAR(32)
      IF ( LNMMN1.NE.0 ) THEN
        NMDMN1(1:LNMMN1) = TABCAR(32)(1:LNMMN1)
      ENDIF
C
      LNMDIN = LGCAR(35)
      IF ( LNMDIN.NE.0 ) THEN
        NMDIN(1:LNMDIN) = TABCAR(35)(1:LNMDIN)
      ENDIF
C
      LLANGU = LGCAR(38)
      IF ( LLANGU.NE.0 ) THEN
        LANGUE(1:LLANGU) = TABCAR(38)(1:LLANGU)
      ENDIF
C
C 1.3. ==> REELS
C
      CRITRA = TABREE(1)
      CRITDE = TABREE(2)
C
C 1.4. ==>  MOTS-CLES FACTEURS DE LA COMMANDE
C
C                1234567890123456
      MCLF(1) = 'TRAITEMENT      '
      MCLF(2) = 'ANALYSE         '
C
      IF ( NIVINF.GE.2 ) THEN
        WRITE(IFM,*) 'SUBROUTINE ', NOMPRO
      ENDIF
C
C====
C 2. ECRITURE DE LA COMMANDE
C====
C
      CODRET = 0
C
C 2.1. ==> INITIALISATION
C
      ICMD = ICMD + 1
      CALL SMDCMD ( ICMD, ' ', 'IMPR_FICO_HOMA', CODRET )
C
C 2.2. ==> LE MODE OPERATOIRE
C
C 2.2.1. ==> INITIALISATION DU MOT-CLE FACTEUR
C
      CALL SMDMCF ( MCLF(1), CODRET )
C
C 2.2.2. ==> QUEL TRAITEMENT ?
C
      IF ( MODHOM.EQ.1 ) THEN
C
        IF ( TYPRAF.EQ.0 .AND. TYPDER.EQ.0 ) THEN
C
          MOTCLE = 'UNIFORME        '
          IAUX = 4
          REP(1:IAUX) = 'RIEN'
C
        ELSEIF ( TYPRAF.EQ.0 .AND. TYPDER.EQ.2 ) THEN
C
          MOTCLE = 'UNIFORME        '
          IAUX = 13
          REP(1:IAUX) = 'DERAFFINEMENT'
C
        ELSEIF ( TYPRAF.EQ.2 .AND. TYPDER.EQ.0 ) THEN
C
          MOTCLE = 'UNIFORME        '
          IAUX = 11
          REP(1:IAUX) = 'RAFFINEMENT'
C
        ELSEIF ( TYPRAF.EQ.0 .AND. TYPDER.EQ.1 ) THEN
C
          MOTCLE = 'ADAPTATION      '
          IAUX = 13
          REP(1:IAUX) = 'DERAFFINEMENT'
C
        ELSEIF ( TYPRAF.EQ.1 .AND. TYPDER.EQ.0 ) THEN
C
          MOTCLE = 'ADAPTATION      '
          IAUX = 11
          REP(1:IAUX) = 'RAFFINEMENT'
C
        ELSEIF ( TYPRAF.EQ.1 .AND. TYPDER.EQ.1 ) THEN
C
          MOTCLE = 'ADAPTATION      '
          IAUX = 9
          REP(1:IAUX) = 'RAFF_DERA'
C                        1234567890123456
C
        ELSE
C
          CODRET = CODRET + 1
          CALL UTMESS
     > ('E',NOMPRO,'ERREUR DE PROGRAMMATION SUR LE TYPE D ADAPTATION')
C
        ENDIF
C
      ELSEIF ( MODHOM.EQ.2 ) THEN
C
        MOTCLE = 'INFORMATION     '
        IAUX = 3
        REP(1:IAUX) = 'OUI'
C
      ELSEIF ( MODHOM.EQ.3 ) THEN
C
C
      ELSE
C
        CODRET = CODRET + 1
        CALL UTMESS
     > ('E',NOMPRO,'ERREUR DE PROGRAMMATION SUR LE MODE HOMARD')
C
      ENDIF
C
      CALL PUTVTX ( MOTCLE, 1, REP, IAUX, CODRET )
C
C 2.2.3. ==> LE NUMERO D'ITERATION
C
      IF ( MODHOM.NE.2 ) THEN
C
        CALL PUTVIS ( 'NITER', 1, NITER, CODRET)
C
      ENDIF
C
C 2.2.4. ==> SI ADAPTATION LIBRE, LES CRITERES
C
C 2.2.4.1. ==> CRITERE POUR LE RAFFINEMENT
C
      IF ( TYPRAF.EQ.1 ) THEN
C
        IF ( TYPCRR.EQ.1 ) THEN
          CALL PUTVR8 ( 'CRIT_RAFF_ABS', 1, CRITRA, IAUX )
        ELSEIF ( TYPCRR.EQ.2 ) THEN
          CALL PUTVR8 ( 'CRIT_RAFF_REL', 1, CRITRA, IAUX )
        ELSEIF ( TYPCRR.EQ.3 ) THEN
          CALL PUTVR8 ( 'CRIT_RAFF_PE', 1, CRITRA, IAUX )
        ENDIF
C
      ENDIF
C
C 2.2.4.2. ==> CRITERE POUR LE DERAFFINEMENT
C
      IF ( TYPDER.EQ.1 ) THEN
C
        IF ( TYPCRD.EQ.1 ) THEN
          CALL PUTVR8 ( 'CRIT_DERA_ABS', 1, CRITDE, IAUX )
        ELSEIF ( TYPCRR.EQ.2 ) THEN
          CALL PUTVR8 ( 'CRIT_DERA_REL', 1, CRITDE, IAUX )
        ELSEIF ( TYPCRR.EQ.3 ) THEN
          CALL PUTVR8 ( 'CRIT_DERA_PE', 1, CRITDE, IAUX )
        ENDIF
C
      ENDIF
C
C 2.2.5. ==> LES EVENTUELS NIVEAUX MINIMUM ET MAXIMUM
C
C 2.2.5.1. ==> NIVEAU MAXIMUM POUR LE RAFFINEMENT
C
      IF ( NIVMAX.GT.0 ) THEN
C
        CALL PUTVIS ( 'NIVE_MAX', 1, NIVMAX, IAUX )
C
      ENDIF
C
C 2.2.5.2. ==> NIVEAU MINIMUM POUR LE DERAFFINEMENT
C
      IF ( NIVMIN.GE.0 ) THEN
C
        CALL PUTVIS ( 'NIVE_MIN', 1, NIVMIN, IAUX )
C
      ENDIF
C
C 2.2.6. ==> LES NOMS MED DES MAILLAGES
C
C 2.2.6.1. ==> MAILLAGE D'ENTREE :
C            . SI INFORMATION
C            . SI ADAPTATION LIBRE
C            . SI ADAPTATION ET ITERATION = 0
C            . SI ADAPTATION ET MAJ DE SOLUTION
C
      IF ( MODHOM.EQ.2 .OR.
     >     ( MODHOM.EQ.1 .AND. ( TYPRAF.EQ.1 .OR. TYPDER.EQ.1 ) ) .OR.
     >     ( MODHOM.EQ.1 .AND. NITER.EQ.0 ) .OR.
     >     ( MODHOM.EQ.1 .AND. NBMAJS.NE.0 ) ) THEN
C
        IAUX = LNMMN
        REP(1:LNMMN) = NMDMN(1:LNMMN)
        CALL PUTVTX ( 'NOM_MED_MAILLAGE_N' , 1, REP, IAUX, CODRET )
C
      ENDIF
C
C 2.2.6.2. ==> MAILLAGE DE SORTIE : SI ADAPTATION
C
      IF ( MODHOM.EQ.1 ) THEN
C
        IAUX = LNMMN1
        REP(1:LNMMN1) = NMDMN1(1:LNMMN1)
        CALL PUTVTX ( 'NOM_MED_MAILLAGE_NP1' , 1, REP, IAUX, CODRET )
C
      ENDIF
C
C 2.2.7. ==> POUR UNE ADAPTATION LIBRE, LES CARACTERISTIQUES DE
C            L'INDICATEUR
C
      IF ( MODHOM.EQ.1 .AND.
     >     ( TYPRAF.EQ.1 .OR. TYPDER.EQ.1 ) ) THEN
C
        IAUX = LNMDIN
        REP(1:LNMDIN) = NMDIN(1:LNMDIN)
        CALL PUTVTX ( 'NOM_MED_INDICA' , 1, REP, IAUX, CODRET )
C
        IAUX = LNCPIN
        REP(1:LNCPIN) = NCPIN(1:LNCPIN)
        CALL PUTVTX ( 'NOM_CMP_INDICA' , 1, REP, IAUX, CODRET )
C
        IF ( NUMORD.EQ.EDNONO ) THEN
C
          IAUX = LCRN
          REP(1:LCRN) = CRN(1:LCRN)
          CALL PUTVTX ( 'NOM_RESU_INDICA' , 1, REP, IAUX, CODRET )
C
          IAUX = LCHINM
          REP(1:LCHINM) = CHINME(1:LCHINM)
          CALL PUTVTX ( 'NOM_CHAM_INDICA' , 1, REP, IAUX, CODRET )
C
        ELSE
C
          CALL PUTVIS ( 'NUMPT_INDICA', 1, NUMPT, IAUX )
C
          CALL PUTVIS ( 'NUMORD_INDICA', 1, NUMORD, IAUX )
C
        ENDIF
C
      ENDIF
C
C 2.2.8. ==> MISE A JOUR DE LA SOLUTION
C
      IF ( MODHOM.NE.2 ) THEN
C
        IAUX = 3
        IF ( NBMAJS.EQ.0 ) THEN
          REP(1:IAUX) = 'NON'
        ELSE
          REP(1:IAUX) = 'OUI'
        ENDIF
C
        CALL PUTVTX ( 'MAJ_CHAM' , 1, REP, IAUX, CODRET )
C
      ENDIF
C
C 2.2.9. ==> FIN DU MOT-CLE FACTEUR
C
      CALL SMFMCF ( CODRET )
C
C 2.3. ==> L'ANALYSE
C
C 2.3.1. ==> INITIALISATION DU MOT-CLE FACTEUR
C
      CALL SMDMCF ( MCLF(2), CODRET )
C
C 2.3.2. ==> LES MOTS-CLES SIMPLES
C
C 2.3.2.1. ==> NOMBRE
C
      MOTCLE = 'NOMBRE'
C
      IAUX = 3
      IF ( BILNBR.EQ.0 ) THEN
        REP(1:IAUX) = 'NON'
      ELSEIF ( BILNBR.EQ.1 ) THEN
        REP(1:IAUX) = 'OUI'
      ELSE
        CODRET = CODRET + 1
        CALL UTMESS
     > ('E',NOMPRO,'ERREUR PROGRAMMATION SUR BILAN NOMBRE')
      ENDIF
C
      CALL PUTVTX ( MOTCLE, 1, REP, IAUX, CODRET )
C
C 2.3.2.2. ==> QUALITE
C
      MOTCLE = 'QUALITE         '
C
      IAUX = 3
      IF ( BILQUA.EQ.0 ) THEN
        REP(1:IAUX) = 'NON'
      ELSEIF ( BILQUA.EQ.1 ) THEN
        REP(1:IAUX) = 'OUI'
      ELSE
        CODRET = CODRET + 1
        CALL UTMESS
     > ('E',NOMPRO,'ERREUR DE PROGRAMMATION SUR LE BILAN EN QUALITE')
      ENDIF
C
      CALL PUTVTX ( MOTCLE, 1, REP, IAUX, CODRET )
C
C 2.3.2.3. ==> CONNEXITE
C
      MOTCLE = 'CONNEXITE'
C
      IAUX = 3
      IF ( BILCXT.EQ.0 ) THEN
        REP(1:IAUX) = 'NON'
      ELSEIF ( BILCXT.EQ.1 ) THEN
        REP(1:IAUX) = 'OUI'
      ELSE
        CODRET = CODRET + 1
        CALL UTMESS
     > ('E',NOMPRO,'ERREUR PROGRAMMATION SUR BILAN CONNEXITE')
      ENDIF
C
      CALL PUTVTX ( MOTCLE, 1, REP, IAUX, CODRET )
C
C 2.3.2.4. ==> TAILLE DES SOUS-DOMAINES
C
      MOTCLE = 'TAILLE'
C
      IAUX = 3
      IF ( BILTAI.EQ.0 ) THEN
        REP(1:IAUX) = 'NON'
      ELSEIF ( BILTAI.EQ.1 ) THEN
        REP(1:IAUX) = 'OUI'
      ELSE
        CODRET = CODRET + 1
        CALL UTMESS
     > ('E',NOMPRO,'ERREUR PROGRAMMATION SUR BILAN CONNEXITE')
      ENDIF
C
      CALL PUTVTX ( MOTCLE, 1, REP, IAUX, CODRET )
C
C 2.3.2.5. ==> INTERPENETRATION
C
      MOTCLE = 'INTERPENETRATION'
C
      IAUX = 3
      IF ( BILINT.EQ.0 ) THEN
        REP(1:IAUX) = 'NON'
      ELSEIF ( BILINT.EQ.1 ) THEN
        REP(1:IAUX) = 'OUI'
      ELSE
        CODRET = CODRET + 1
        CALL UTMESS
     > ('E',NOMPRO,'ERREUR PROGRAMMATION SUR BILAN INTERPENETRATION')
      ENDIF
C
      CALL PUTVTX ( MOTCLE, 1, REP, IAUX, CODRET )
C
C 2.3.3. ==> FIN DU MOT-CLE FACTEUR
C
      CALL SMFMCF ( CODRET )
C
C 2.4. ==> L'UNITE LOGIQUE D'ECRITURE
C
      CALL PUTVIS ( 'UNITE', 1, NUFIHO, CODRET)
C
C 2.5. ==> LE REPERTOIRE D'EXECUTION DE HOMARD
C
      IF ( LREPHC.GT.0 ) THEN
        IAUX = LREPHC
        REP(1:IAUX) = REPHC(1:LREPHC)
        CALL PUTVTX ( 'REP', 1, REP, IAUX, CODRET )
      ENDIF
C
C 2.6. ==> LA LANGUE DES MESSAGES HOMARD
C
      IF ( LLANGU.GT.0 ) THEN
        IAUX = LLANGU
        REP(1:IAUX) = LANGUE(1:LLANGU)
        CALL PUTVTX ( 'LANGUE', 1, REP, IAUX, CODRET )
      ENDIF
C
C 2.7. ==> LE NIVEAU D'INFO
C
      CALL PUTVIS ( 'INFO', 1, NIVINF, CODRET)
C
C 2.8. ==> FIN DE LA COMMANDE
C
      CALL SMFCMD ( CODRET )
C
C====
C 3. BILAN
C====
C
      IF ( CODRET .GT. 0 ) THEN
        CALL UTMESS
     > ('E',NOMPRO,'ERREURS CONSTATEES POUR MACR_ADAP')
         IERUSR = IERUSR + CODRET
      ENDIF
C
      END
