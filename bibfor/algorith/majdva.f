      SUBROUTINE MAJDVA(NUMEDD,SDNUME,SDDYNA,VALINC,SOLALG)
C
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 13/06/2012   AUTEUR COURTOIS M.COURTOIS 
C ======================================================================
C COPYRIGHT (C) 1991 - 2012  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C RESPONSABLE ABBAS M.ABBAS
C
      IMPLICIT NONE
      INCLUDE 'jeveux.h'
      CHARACTER*24 NUMEDD
      CHARACTER*19 SDDYNA,SDNUME
      CHARACTER*19 SOLALG(*),VALINC(*)
C
C ----------------------------------------------------------------------
C
C ROUTINE MECA_NON_LINE (ALGORITHME - UTILITAIRE - DYNAMIQUE)
C
C MET A JOUR LES ACCELERATIONS/VITESSES/ROTATIONS DANS
C LE CAS DES POUTRES EN GRANDES ROTATIONS
C
C ----------------------------------------------------------------------
C
C
C IN  NUMEDD : NUME_DDL
C IN  SDNUME : SD NUMEROTATION
C IN  SDDYNA : SD DYNAMIQUE
C IN  VALINC : VARIABLE CHAPEAU POUR INCREMENTS VARIABLES
C IN  SOLALG : VARIABLE CHAPEAU POUR INCREMENTS SOLUTIONS
C
C
C
C
      CHARACTER*19 VITPLU,ACCPLU
      INTEGER      JVITP,JACCP
      CHARACTER*19 DDEPLA,DVITLA,DACCLA
      INTEGER      JDDEPL,JDVITE,JDACCE
      CHARACTER*19 ROMK
      INTEGER      JROMK
      INTEGER      I,ICOMP,IRAN(3),INDRO
      INTEGER      NEQ,IRET
      CHARACTER*8  K8BID
      REAL*8       THETA1(3),THETA2(3),DELDET(3)
      CHARACTER*19 DEPPLU,DEPDEL
      INTEGER      JDEPP,JDEPDE
      CHARACTER*19 DEPKM1,VITKM1,ACCKM1,ROMKM1
      INTEGER      JDEPKM,JVITKM,JACCKM,JROMKM
C
C ----------------------------------------------------------------------
C
      CALL JEMARQ()
C
C --- POUTRES EN GRANDES ROTATIONS
C 
      CALL JEVEUO(SDNUME//'.NDRO','L',INDRO)
C
C --- INITIALISATIONS
C
      CALL DISMOI('F','NB_EQUA',NUMEDD,'NUME_DDL',NEQ,K8BID,IRET)
C
C --- DECOMPACTION VARIABLES CHAPEAUX
C
      CALL NMCHEX(VALINC,'VALINC','DEPPLU',DEPPLU)
      CALL NMCHEX(VALINC,'VALINC','VITPLU',VITPLU)
      CALL NMCHEX(VALINC,'VALINC','ACCPLU',ACCPLU)
      CALL NMCHEX(VALINC,'VALINC','DEPKM1',DEPKM1)
      CALL NMCHEX(VALINC,'VALINC','VITKM1',VITKM1)
      CALL NMCHEX(VALINC,'VALINC','ACCKM1',ACCKM1)      
      CALL NMCHEX(VALINC,'VALINC','ROMKM1',ROMKM1)      
      CALL NMCHEX(VALINC,'VALINC','ROMK  ',ROMK  )
      CALL NMCHEX(SOLALG,'SOLALG','DEPDEL',DEPDEL)
      CALL NMCHEX(SOLALG,'SOLALG','DDEPLA',DDEPLA)
      CALL NMCHEX(SOLALG,'SOLALG','DVITLA',DVITLA)
      CALL NMCHEX(SOLALG,'SOLALG','DACCLA',DACCLA)   
C
C --- RECUPERATION DES ADRESSES
C
      CALL JEVEUO(DDEPLA(1:19)//'.VALE','L',JDDEPL)
      CALL JEVEUO(DVITLA(1:19)//'.VALE','L',JDVITE)
      CALL JEVEUO(DACCLA(1:19)//'.VALE','L',JDACCE)
      CALL JEVEUO(DEPDEL(1:19)//'.VALE','E',JDEPDE)
      CALL JEVEUO(DEPPLU(1:19)//'.VALE','E',JDEPP )
      CALL JEVEUO(VITPLU(1:19)//'.VALE','E',JVITP )
      CALL JEVEUO(ACCPLU(1:19)//'.VALE','E',JACCP )
      CALL JEVEUO(DEPKM1(1:19)//'.VALE','E',JDEPKM)
      CALL JEVEUO(VITKM1(1:19)//'.VALE','E',JVITKM)
      CALL JEVEUO(ACCKM1(1:19)//'.VALE','E',JACCKM)
      CALL JEVEUO(ROMKM1(1:19)//'.VALE','E',JROMKM)
      CALL JEVEUO(ROMK(1:19)  //'.VALE','L',JROMK )
C
C --- MISE A JOUR DEPL/VITE/ACCE
C
      ICOMP  = 0
      DO 20 I = 1,NEQ
        IF (ZI(INDRO+I-1).EQ.0) THEN
          ZR(JDEPDE+I-1) = ZR(JDEPDE+I-1) + ZR(JDDEPL+I-1)
          ZR(JDEPP+I-1)  = ZR(JDEPP+I-1) + ZR(JDDEPL+I-1)
          ZR(JVITP+I-1)  = ZR(JVITP+I-1) + ZR(JDVITE+I-1)
          ZR(JACCP+I-1)  = ZR(JACCP+I-1) + ZR(JDACCE+I-1)
        ELSE IF (ZI(INDRO+I-1).EQ.1) THEN
          ZR(JDEPKM+I-1) = ZR(JDEPP+I-1)
          ZR(JVITKM+I-1) = ZR(JVITP+I-1)
          ZR(JACCKM+I-1) = ZR(JACCP+I-1)
          ZR(JROMKM+I-1) = ZR(JROMK+I-1)
          ICOMP         = ICOMP + 1
          IRAN(ICOMP)   = I
          DELDET(ICOMP) = ZR(JDDEPL+I-1)
          THETA1(ICOMP) = ZR(JDEPP+I-1)
          THETA2(ICOMP) = ZR(JROMK+I-1)
          IF (ICOMP.EQ.3) THEN
            ICOMP = 0
            CALL NDGROT(SDDYNA,VALINC,SOLALG,DELDET,THETA1,
     &                  THETA2,IRAN  )
          ENDIF
        ELSE
          CALL ASSERT(.FALSE.)
        ENDIF
20    CONTINUE
C
      CALL JEDEMA()
      END
