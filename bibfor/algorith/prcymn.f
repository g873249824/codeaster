      SUBROUTINE PRCYMN(NOMRES,SOUMAT,REPMAT)
      IMPLICIT REAL*8 (A-H,O-Z)
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 16/12/2004   AUTEUR VABHHTS J.PELLET 
C ======================================================================
C COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
C (AT YOUR OPTION) ANY LATER VERSION.                                 
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
C    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
C ======================================================================
C***********************************************************************
C  P. RICHARD     DATE 11/03/91
C-----------------------------------------------------------------------
C  BUT : < PROJECTION DES MATRICES POUR CYCLIQUE MAC-NEAL >
C
C        PROJETER LES MATRICES MASSE ET RAIDEUR ET SORTIR LES SOUS
C        MATRICES POUR TRAITER LE CAS CYCLIQUE AVEC INTERFACES
C        DE MAC NEAL OU AUCUN ( = MAC NEAL SANS MODE ATTACHE)
C-----------------------------------------------------------------------
C
C NOMRES /I/ : NOM UTILISATEUR DU RESULTAT
C SOUMAT /I/ : NOM K24 DE LA FAMILLE DES SOUS-MATRICES
C REPMAT /I/ : NOM K24 DU REPERTOIRE DES NOMS DES SOUS-MATRICES
C
C-------- DEBUT COMMUNS NORMALISES  JEVEUX  ----------------------------
C
      INTEGER          ZI
      COMMON  /IVARJE/ ZI(1)
      REAL*8           ZR
      COMMON  /RVARJE/ ZR(1)
      COMPLEX*16       ZC
      COMMON  /CVARJE/ ZC(1)
      LOGICAL          ZL
      COMMON  /LVARJE/ ZL(1)
      CHARACTER*8      ZK8
      CHARACTER*16              ZK16
      CHARACTER*24                        ZK24
      CHARACTER*32                                  ZK32
      CHARACTER*80                                            ZK80
      COMMON  /KVARJE/ ZK8(1),ZK16(1),ZK24(1),ZK32(1),ZK80(1)
C
      CHARACTER*32 JEXNOM, JEXNUM
C
C----------  FIN  COMMUNS NORMALISES  JEVEUX  --------------------------
C
      CHARACTER*6  PGC
      CHARACTER*8  NOMRES,BASMOD,MAILLA,INTF,KBID,K8BID
      CHARACTER*19 NUMDDL,RAID
      CHARACTER*24 REPMAT,SOUMAT,NOEINT,CHAMVA
      CHARACTER*1  K1BID
C
C-----------------------------------------------------------------------
       DATA PGC /'PRCYMN'/
C-----------------------------------------------------------------------
C
C --- RECUPERATION DES CONCEPTS AMONT
C
      CALL JEMARQ()
      CALL JEVEUO(NOMRES//'      .CYCL.REFE','L',LLREF)
      INTF=ZK24(LLREF+1)
      BASMOD=ZK24(LLREF+2)
      CALL JELIBE(NOMRES//'      .CYCL.REFE')
      CALL JEVEUO(BASMOD//'           .REFE','L',LLREF)
      NUMDDL=ZK24(LLREF+1)
      RAID=ZK24(LLREF+2)
      CALL JELIBE(BASMOD//'           .REFE')
C
C --- RECUPERATION DES DIMENSIONS DU PROBLEME GENERALISE
C
      CALL JEVEUO(NOMRES//'      .CYCL.DESC','L',LLDESC)
      NBMOD=ZI(LLDESC)
      NBDDR=ZI(LLDESC+1)
      NBDAX=ZI(LLDESC+2)
      CALL JELIBE(NOMRES//'      .CYCL.DESC')
C
C --- ALLOCATION DU REPERTOIRE DES NOMS DES SOUS-MATRICES
C
      IF(NBDAX.GT.0) THEN
        NBSMA=13
      ELSE
        NBSMA=6
      ENDIF
C
      CALL JECREO(REPMAT,'V N K8')
      CALL JEECRA(REPMAT,'NOMMAX',NBSMA,' ')
C
C --- CREATION DE LA FAMILLE DES SOUS-MATRICES
C
      CALL JECREC(SOUMAT,'V V R','NU','DISPERSE','VARIABLE',
     &            NBSMA)
C
C --- ALLOCATION DES MATRICES (STOCKAGE PLEIN)
C
      NTAIL=NBMOD*(NBMOD+1)/2
C
      CALL JECROC(JEXNOM(REPMAT,'K0II'))
      CALL JENONU(JEXNOM(REPMAT,'K0II'),IBID)
      CALL JEECRA(JEXNUM(SOUMAT,IBID),'LONMAX',NTAIL,' ')
C
      CALL JECROC(JEXNOM(REPMAT,'M0II'))
      CALL JENONU(JEXNOM(REPMAT,'M0II'),IBID)
      CALL JEECRA(JEXNUM(SOUMAT,IBID),'LONMAX',NTAIL,' ')
C
      NTRIAN=NBDDR*(NBDDR+1)/2
      NTAIL=NBDDR*NBDDR
C
      CALL JECROC(JEXNOM(REPMAT,'K0JI'))
      CALL JENONU(JEXNOM(REPMAT,'K0JI'),IBID)
      CALL JEECRA(JEXNUM(SOUMAT,IBID),'LONMAX',NBMOD*NBDDR,' ')
C
      CALL JECROC(JEXNOM(REPMAT,'K0JJ'))
      CALL JENONU(JEXNOM(REPMAT,'K0JJ'),IBID)
      CALL JEECRA(JEXNUM(SOUMAT,IBID),'LONMAX',NTRIAN,' ')
C
      CALL JECROC(JEXNOM(REPMAT,'KPLUSJI'))
      CALL JENONU(JEXNOM(REPMAT,'KPLUSJI'),IBID)
      CALL JEECRA(JEXNUM(SOUMAT,IBID),'LONMAX',NBMOD*NBDDR,' ')
C
      CALL JECROC(JEXNOM(REPMAT,'KPLUSJJ'))
      CALL JENONU(JEXNOM(REPMAT,'KPLUSJJ'),IBID)
      CALL JEECRA(JEXNUM(SOUMAT,IBID),'LONMAX',NTAIL,' ')
C
      IF(NBDAX.GT.0) THEN
C
        NTAIL=NBDDR*NBDAX
C
        CALL JECROC(JEXNOM(REPMAT,'K0AI'))
        CALL JENONU(JEXNOM(REPMAT,'K0AI'),IBID)
        CALL JEECRA(JEXNUM(SOUMAT,IBID),'LONMAX',NBMOD*NBDAX,' ')
C
        CALL JECROC(JEXNOM(REPMAT,'K0AJ'))
        CALL JENONU(JEXNOM(REPMAT,'K0AJ'),IBID)
        CALL JEECRA(JEXNUM(SOUMAT,IBID),'LONMAX',NTAIL,' ')
C
        CALL JECROC(JEXNOM(REPMAT,'K0AA'))
        CALL JENONU(JEXNOM(REPMAT,'K0AA'),IBID)
        CALL JEECRA(JEXNUM(SOUMAT,IBID),'LONMAX',NBDAX**2,' ')
C
        CALL JECROC(JEXNOM(REPMAT,'KPLUSAA'))
        CALL JENONU(JEXNOM(REPMAT,'KPLUSAA'),IBID)
        CALL JEECRA(JEXNUM(SOUMAT,IBID),'LONMAX',NBDAX**2,' ')
C
        CALL JECROC(JEXNOM(REPMAT,'KPLUSAI'))
        CALL JENONU(JEXNOM(REPMAT,'KPLUSAI'),IBID)
        CALL JEECRA(JEXNUM(SOUMAT,IBID),'LONMAX',NBMOD*NBDAX,' ')
C
        CALL JECROC(JEXNOM(REPMAT,'KPLUSAJ'))
        CALL JENONU(JEXNOM(REPMAT,'KPLUSAJ'),IBID)
        CALL JEECRA(JEXNUM(SOUMAT,IBID),'LONMAX',NTAIL,' ')
C
      ENDIF
C
C --- TRAITEMENT DES PRODUITS MODES-MODES
C
      CALL JENONU(JEXNOM(REPMAT,'K0II'),IBID)
      CALL JEVEUO(JEXNUM(SOUMAT,IBID),'E',LDK0II)
      CALL JENONU(JEXNOM(REPMAT,'M0II'),IBID)
      CALL JEVEUO(JEXNUM(SOUMAT,IBID),'E',LDM0II)
C
      DO 10 I=1,NBMOD
        CALL RSADPA(BASMOD,'L',1,'RIGI_GENE',I,0,LLKGE,K8BID)
        ZR(LDK0II+I*(I-1)/2) = ZR(LLKGE)
        CALL RSADPA(BASMOD,'L',1,'MASS_GENE',I,0,LLMGE,K8BID)
        ZR(LDM0II+I*(I-1)/2) = ZR(LLMGE)
 10   CONTINUE
C
C --- ALLOCATION DES TABLEAUX DE TRAVAIL
C
      CALL WKVECT('&&'//PGC//'.EXTR.DROI','V V I',NBDDR,LTEXD)
      CALL WKVECT('&&'//PGC//'.EXTR.GAUC','V V I',NBDDR,LTEXG)
      IF(NBDAX.GT.0) THEN
        CALL WKVECT('&&'//PGC//'.EXTR.AXE','V V I',NBDAX,LTEXA)
      ENDIF
C
C --- RECUPERATION NB EQUATIONS
C
      CALL DISMOI('F','NB_EQUA',RAID,'MATR_ASSE',NEQ,K8BID,IRET)
      CALL JEVEUO(NUMDDL//'.DEEQ','L',IDDEEQ)
C
C --- RECUPERATION DES NUMEROS D'INTERFACE DROITE ET GAUCHE
C
      CALL JEVEUO(NOMRES//'      .CYCL.NUIN','L',LLNIN)
      NUMD=ZI(LLNIN)
      NUMG=ZI(LLNIN+1)
      NUMA=ZI(LLNIN+2)
C
C --- RECUPERATION DU NOMBRE DE NOEUDS DES INTERFACES
C
      NOEINT=INTF//'      .INTD.LINO'
C
      CALL JELIRA(JEXNUM(NOEINT,NUMD),'LONMAX',NBNOD,K1BID)
      CALL JEVEUO(JEXNUM(NOEINT,NUMD),'L',LLNOD)
C
      CALL JELIRA(JEXNUM(NOEINT,NUMG),'LONMAX',NBNOG,K1BID)
      CALL JEVEUO(JEXNUM(NOEINT,NUMG),'L',LLNOG)
C
      IF(NBDAX.GT.0) THEN
        CALL JELIRA(JEXNUM(NOEINT,NUMA),'LONMAX',NBNOA,K1BID)
        CALL JEVEUO(JEXNUM(NOEINT,NUMA),'L',LLNOA)
      ENDIF
C
C --- RECUPERATION DU NOMBRE DE SECTEURS
C
      CALL JEVEUO(NOMRES//'      .CYCL.NBSC','L',LLNOMS)
      NBSEC=ZI(LLNOMS)
      CALL JELIBE(NOMRES//'      .CYCL.NBSC')
C
C --- RECUPERATION RANGS DDL INTERFACE DANS VECTEUR ASSEMBLE
C
C --- RECUPERATION  DEFORMEES ET DDL NOEUDS DROITE
C
      KBID=' '
      CALL BMRADI(BASMOD,KBID,'        ',NUMD,NBDDR,ZI(LTEXD),IBID)
C
C --- RECUPERATION DEFORMEES ET DDL NOEUDS GAUCHE
C
      KBID=' '
      CALL BMRADI(BASMOD,KBID,'        ',NUMG,NBDDR,ZI(LTEXG),IBID)
C
C --- RECUPERATION DEFORMEES EVENTUELS NOEUDS AXE
C
      IF(NBDAX.GT.0) THEN
        KBID=' '
        CALL BMRADI(BASMOD,KBID,'        ',NUMA,NBDAX,ZI(LTEXA),IBID)
      ENDIF
C
C --- CALCUL DES TRANSPOSEES MATRICES TETA DE CHANGEMENT DE REPERE
C
C     ATTENTION LE PARTAGE DES ROUTINES DE CALCUL DE CES MATRICES
C     AVEC CRAIG-BAMPTON IMPOSE DE CALCULER LES TRANPOSEES DES
C     MATRICES TETA QUI APPARAISSENT DANS LA THEORIE DE MAC-NEAL
C
      CALL WKVECT('&&'//PGC//'.TETGD','V V R',NBDDR*NBDDR,LTETGD)
      CALL CTETGD(BASMOD,NUMD,NUMG,NBSEC,ZR(LTETGD),NBDDR)
      IF(NBDAX.GT.0) THEN
        CALL WKVECT('&&'//PGC//'.TETAX','V V R',NBDAX*NBDAX,LTETAX)
        CALL CTETAX(BASMOD,NUMA,NBSEC,ZR(LTETAX),NBDAX)
      ENDIF
C
      CALL WKVECT('&&'//PGC//'.VECT','V V R',NEQ,LTVEC)

C --- DETERMINATION DES TABLEAUX EXTRACTION SUR MODES PROPRES
C
C --- POUR K0JI
C
      CALL JENONU(JEXNOM(REPMAT,'K0JI'),IBID)
      CALL JEVEUO(JEXNUM(SOUMAT,IBID),'E',LDK0JI)
      CALL WKVECT('&&'//PGC//'CDPHI','V V R',NBMOD*NBDDR,LTCDP)
C
      DO 80 I=1,NBMOD
        CALL DCAPNO(BASMOD,'DEPL    ',I,CHAMVA)
        CALL JEVEUO(CHAMVA,'L',LLCHAM)
        CALL DCOPY(NEQ,ZR(LLCHAM),1,ZR(LTVEC),1)
        CALL ZERLAG(ZR(LTVEC),NEQ,ZI(IDDEEQ))
C
        DO 81 J=1,NBDDR
C
C ------- EXTRACTION DDL DROITE
C
          IRAN=ZI(LTEXD+J-1)
          XX=ZR(LTVEC+IRAN-1)
          CALL AMPPR(ZR(LTCDP),NBDDR,NBMOD,XX,1,1,J,I)
81      CONTINUE
        CALL JELIBE(CHAMVA)
80    CONTINUE
C
      CALL DAXPY(NBMOD*NBDDR,-1.D0,ZR(LTCDP),1,ZR(LDK0JI),1)
      CALL JEDETR('&&'//PGC//'CDPHI')
C
C --- POUR KPLUSJI
C
      CALL JENONU(JEXNOM(REPMAT,'KPLUSJI'),IBID)
      CALL JEVEUO(JEXNUM(SOUMAT,IBID),'E',LDKPJI)
      CALL WKVECT('&&'//PGC//'CGPHI','V V R',NBMOD*NBDDR,LTCGP)
C
      DO 90 I=1,NBMOD
        CALL DCAPNO(BASMOD,'DEPL    ',I,CHAMVA)
        CALL JEVEUO(CHAMVA,'L',LLCHAM)
        CALL DCOPY(NEQ,ZR(LLCHAM),1,ZR(LTVEC),1)
        CALL ZERLAG(ZR(LTVEC),NEQ,ZI(IDDEEQ))
C
        DO 91 J=1,NBDDR
C
C ------- EXTRACTION DDL GAUCHE
C
          IRAN=ZI(LTEXG+J-1)
          XX=ZR(LTVEC+IRAN-1)
          CALL AMPPR(ZR(LTCGP),NBDDR,NBMOD,XX,1,1,J,I)
91      CONTINUE
        CALL JELIBE(CHAMVA)
90    CONTINUE
C
      CALL PMPPR(ZR(LTETGD),NBDDR,NBDDR,-1,ZR(LTCGP),NBDDR,NBMOD,1,
     &           ZR(LDKPJI),NBDDR,NBMOD)
C
      CALL JEDETR('&&'//PGC//'CGPHI')
C
      IF(NBDAX.GT.0) THEN
C
C ----- POUR K0AA ET KPLUSAA
C
        CALL WKVECT('&&'//PGC//'CAPHI','V V R',NBMOD*NBDAX,LTCAP)
        CALL JENONU(JEXNOM(REPMAT,'K0AI'),IBID)
        CALL JEVEUO(JEXNUM(SOUMAT,IBID),'E',LDK0AI)
        CALL JENONU(JEXNOM(REPMAT,'KPLUSAI'),IBID)
        CALL JEVEUO(JEXNUM(SOUMAT,IBID),'E',LDKPAI)
C
        DO 100 I=1,NBMOD
          CALL DCAPNO(BASMOD,'DEPL    ',I,CHAMVA)
          CALL JEVEUO(CHAMVA,'L',LLCHAM)
          CALL DCOPY(NEQ,ZR(LLCHAM),1,ZR(LTVEC),1)
          CALL ZERLAG(ZR(LTVEC),NEQ,ZI(IDDEEQ))
C
          DO 101 J=1,NBDAX
C
C --------- EXTRACTION DDL AXE
C
            IRAN=ZI(LTEXA+J-1)
            XX=ZR(LTVEC+IRAN-1)
            CALL AMPPR(ZR(LTCAP),NBDAX,NBMOD,XX,1,1,J,I)
101       CONTINUE
          CALL JELIBE(CHAMVA)
          CALL JEDETR('&&'//PGC//'.VECT')
100     CONTINUE
C
        CALL PMPPR(ZR(LTETAX),NBDAX,NBDAX,-1,ZR(LTCAP),NBDAX,NBMOD,
     &             1,ZR(LDKPAI),NBDAX,NBMOD)
        CALL DAXPY(NBMOD*NBDAX,-1.D0,ZR(LTCAP),1,ZR(LDK0AI),1)
        CALL JEDETR('&&'//PGC//'CAPHI')
C
      ENDIF
C
C --- ALLOCATION TABLEAU DE TRAVAIL ET FLEXIBILITE COURANTE
C
      NBV=MAX(NBDDR,NBMOD)
      NBV=MAX(NBDAX,NBV)
      NTAIL=NBV**2
      CALL WKVECT('&&'//PGC//'.MAT.TRAV','V V R',NTAIL,LTMAT)
      CALL WKVECT('&&'//PGC//'.FLEX.RES','V V R',NTAIL,LTFLEX)
C
C --- CALCUL DES TERMES DE FLEXIBILITE
C
C --- POUR K0JJ
C
      CALL JENONU(JEXNOM(REPMAT,'K0JJ'),IBID)
      CALL JEVEUO(JEXNUM(SOUMAT,IBID),'E',LDK0JJ)
C
      CALL FLEXIB(BASMOD,NBMOD,ZR(LTFLEX),NBDDR,NBDDR,NUMD,NUMD)
      CALL DAXPY(NBDDR*NBDDR,-1.D0,ZR(LTFLEX),1,ZR(LTMAT),1)
      K = 0
      DO 110 J=1,NBDDR
      DO 110 I=J,1,-1
         ZR(LDK0JJ+K) = ZR(LTMAT-1+(J-1)*NBDDR+I)
         K = K + 1
 110  CONTINUE
C
      CALL FLEXIB(BASMOD,NBMOD,ZR(LTFLEX),NBDDR,NBDDR,NUMG,NUMG)
      CALL PMPPR(ZR(LTETGD),NBDDR,NBDDR,-1,ZR(LTFLEX),NBDDR,NBDDR,1,
     &             ZR(LTMAT),NBDDR,NBDDR)
      CALL PMPPR(ZR(LTMAT),NBDDR,NBDDR,1,ZR(LTETGD),NBDDR,NBDDR,1,
     &             ZR(LTFLEX),NBDDR,NBDDR)
      CALL R8INIR(NBDDR*NBDDR,0.D0,ZR(LTMAT),1)
      CALL DAXPY(NBDDR*NBDDR,-1.D0,ZR(LTFLEX),1,ZR(LTMAT),1)
      K = 0
      DO 120 J=1,NBDDR
      DO 120 I=J,1,-1
         ZR(LDK0JJ+K) = ZR(LDK0JJ+K)+ZR(LTMAT-1+(J-1)*NBDDR+I)
         K = K + 1
 120  CONTINUE
C
C --- POUR KPLUSJJ
C
      CALL JENONU(JEXNOM(REPMAT,'KPLUSJJ'),IBID)
      CALL JEVEUO(JEXNUM(SOUMAT,IBID),'E',LDKPJJ)
C
      CALL FLEXIB(BASMOD,NBMOD,ZR(LTFLEX),NBDDR,NBDDR,NUMG,NUMD)
      CALL PMPPR(ZR(LTETGD),NBDDR,NBDDR,-1,ZR(LTFLEX),NBDDR,NBDDR,1,
     &           ZR(LTMAT),NBDDR,NBDDR)
      CALL AMPPR(ZR(LDKPJJ),NBDDR,NBDDR,ZR(LTMAT),NBDDR,NBDDR,1,1)
C
C
      IF(NBDAX.GT.0) THEN
C
C --- POUR K0AJ ET KPLUSAJ
C
        CALL JENONU(JEXNOM(REPMAT,'K0AJ'),IBID)
        CALL JEVEUO(JEXNUM(SOUMAT,IBID),'E',LDK0AJ)
        CALL JENONU(JEXNOM(REPMAT,'KPLUSAJ'),IBID)
        CALL JEVEUO(JEXNUM(SOUMAT,IBID),'E',LDKPAJ)
C
        CALL FLEXIB(BASMOD,NBMOD,ZR(LTFLEX),NBDAX,NBDDR,
     &              NUMA,NUMD)
        CALL DAXPY(NBDAX*NBDDR,-1.D0,ZR(LTFLEX),1,ZR(LDK0AJ),1)
        CALL PMPPR(ZR(LTETAX),NBDAX,NBDAX,-1,ZR(LTFLEX),NBDAX,NBDDR,1,
     &             ZR(LTMAT),NBDAX,NBDDR)
        CALL AMPPR(ZR(LDKPAJ),NBDAX,NBDDR,ZR(LTMAT),NBDAX,NBDDR,1,1)
C
        CALL FLEXIB(BASMOD,NBMOD,ZR(LTFLEX),NBDAX,NBDDR,
     &              NUMA,NUMG)
        CALL PMPPR(ZR(LTFLEX),NBDAX,NBDDR,1,ZR(LTETGD),NBDDR,NBDDR,1,
     &             ZR(LTMAT),NBDAX,NBDDR)
        CALL R8INIR(NBDAX*NBDDR,0.D0,ZR(LTFLEX),1)
        CALL DAXPY(NBDAX*NBDDR,-1.D0,ZR(LTMAT),1,ZR(LTFLEX),1)
        CALL AMPPR(ZR(LDK0AJ),NBDAX,NBDDR,ZR(LTFLEX),NBDAX,NBDDR,1,1)
C
C
C --- POUR KPLUSJA
C
        CALL JENONU(JEXNOM(REPMAT,'KPLUSJA'),IBID)
        CALL JEVEUO(JEXNUM(SOUMAT,IBID),'E',LDKPJA)
C
        CALL FLEXIB(BASMOD,NBMOD,ZR(LTFLEX),NBDDR,NBDAX,
     &              NUMG,NUMA)
        CALL PMPPR(ZR(LTETGD),NBDDR,NBDDR,-1,ZR(LTFLEX),NBDDR,NBDAX,1,
     &             ZR(LDKPJA),NBDDR,NBDAX)
C
C
C --- POUR K0AA ET KPLUSAA
C
        CALL JENONU(JEXNOM(REPMAT,'K0AA'),IBID)
        CALL JEVEUO(JEXNUM(SOUMAT,IBID),'E',LDK0AA)
        CALL JENONU(JEXNOM(REPMAT,'KPLUSAA'),IBID)
        CALL JEVEUO(JEXNUM(SOUMAT,IBID),'E',LDKPAA)
C
        CALL FLEXIB(BASMOD,NBMOD,ZR(LTFLEX),NBDAX,NBDAX,
     &              NUMA,NUMA)
        CALL DAXPY(NBDAX*NBDAX,-1.D0,ZR(LTFLEX),1,ZR(LDK0AA),1)
        CALL PMPPR(ZR(LTETAX),NBDAX,NBDAX,-1,ZR(LTFLEX),NBDAX,NBDAX,1,
     &             ZR(LTMAT),NBDAX,NBDAX)
        CALL AMPPR(ZR(LDKPAA),NBDAX,NBDAX,ZR(LTMAT),NBDAX,NBDAX,1,1)
        CALL PMPPR(ZR(LTMAT),NBDAX,NBDAX,1,ZR(LTETAX),NBDAX,NBDAX,1,
     &             ZR(LTFLEX),NBDAX,NBDAX)
        CALL R8INIR(NBDAX*NBDAX,0.D0,ZR(LTMAT),1)
        CALL DAXPY(NBDAX*NBDAX,-1.D0,ZR(LTFLEX),1,ZR(LTMAT),1)
        CALL AMPPR(ZR(LDK0AA),NBDAX,NBDAX,ZR(LTMAT),NBDAX,NBDAX,1,1)
C
C
      ENDIF
C
      CALL JEDETR('&&'//PGC//'.MAT.TRAV')
      CALL JEDETR('&&'//PGC//'.TETGD')
      CALL JEDETR('&&'//PGC//'.FLEX.RES')
      CALL JEDETR('&&'//PGC//'.EXTR.DROI')
      CALL JEDETR('&&'//PGC//'.EXTR.GAUC')
      CALL JEDETR('&&'//PGC//'.VECT')
      IF(NBDAX.GT.0) THEN
        CALL JEDETR('&&'//PGC//'.TETAX')
        CALL JEDETR('&&'//PGC//'.EXTR.AXE')
      ENDIF
C
 9999 CONTINUE
      CALL JEDEMA()
      END
