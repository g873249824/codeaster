      SUBROUTINE NMCRSU(SDDISC,LISINS,DELMIN,NOMCMD)
C
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 20/07/2009   AUTEUR GENIAUT S.GENIAUT 
C ======================================================================
C COPYRIGHT (C) 1991 - 2007  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C RESPONSABLE ABBAS M.ABBAS
C
      IMPLICIT     NONE
      CHARACTER*19 LISINS,SDDISC
      REAL*8       DELMIN
      CHARACTER*16 NOMCMD
C
C ----------------------------------------------------------------------
C
C ROUTINE *_NON_LINE (STRUCTURES DE DONNES)
C
C CREATION SD DISCRETISATION - SUBDIVISION AUTO
C
C ----------------------------------------------------------------------
C
C
C IN  NOMCMD : NOM DE LA COMMANDE APPELANTE (THER, STAT OU DYNA)
C IN  LISINS : SD_LIST_INST OU SD_LISTR8
C I/O SDDISC : SD DISCRETISATION
C IN  DELMIN : PAS DE TEMPS MINI ENTRE INSTANT DE LA LISTE
C
C --- DEBUT DECLARATIONS NORMALISEES JEVEUX ----------------------------
C
      INTEGER      ZI
      COMMON  / IVARJE / ZI(1)
      REAL*8       ZR
      COMMON  / RVARJE / ZR(1)
      COMPLEX*16   ZC
      COMMON  / CVARJE / ZC(1)
      LOGICAL      ZL
      COMMON  / LVARJE / ZL(1)
      CHARACTER*8  ZK8
      CHARACTER*16    ZK16
      CHARACTER*24        ZK24
      CHARACTER*32            ZK32
      CHARACTER*80                ZK80
      COMMON  / KVARJE / ZK8(1) , ZK16(1) , ZK24(1) , ZK32(1) , ZK80(1)
C
C --- FIN DECLARATIONS NORMALISEES JEVEUX ------------------------------
C
      CHARACTER*24 TPSERR
      INTEGER      JERRE
      CHARACTER*16 METHOD,OPTION,PRED,TYPECO
      INTEGER      N1,N2,NOCC,IRET,IRE1,IRE2,NBVAL
      REAL*8       PASMIN,RATIO,R8VIDE,R8B,ELASDT,VALR
      INTEGER      NIVEAU,NBRPAS,NBPLUS,ITEIGN,ITEFIN
      INTEGER      ITER1,ITER2,NBITER,CEIL,JECHE,I,IBID,IOCC,NIGNO,NFIN
      INTEGER      IFM,NIV,IDIV,ITMX,VALI
      CHARACTER*8  K8B,SDLIST,VALK,METLIS
      CHARACTER*19 EVEN
      CHARACTER*16 NOPARA 
      INTEGER      JEEVR,JEEVK,JESUR
      INTEGER      LEEVR,LEEVK,LESUR
      PARAMETER   (LEEVR=4,LEEVK=3,LESUR=8)
C ----------------------------------------------------------------------
C
      CALL JEMARQ()
C
C --- AFFICHAGE
C
      IF (NOMCMD(1:4).EQ.'THER') THEN
         CALL INFDBG('THER_NON_LINE',IFM,NIV)
         IF (NIV.GE.2) THEN
            WRITE (IFM,*) '<THERNONLINE> ... CREATION SD SUBDIVISION'
         ENDIF
      ELSE
         CALL INFDBG('MECA_NON_LINE',IFM,NIV)
         IF (NIV.GE.2) THEN
            WRITE (IFM,*) '<MECANONLINE> ... CREATION SD SUBDIVISION'
         ENDIF
      ENDIF
C
C --- ACCES SD LISTE D'INSTANTS
      CALL GETTCO(LISINS, TYPECO)

      TPSERR = SDDISC(1:19)//'.ERRE'
C
C --- RECUPERATION DES CRITERES DE CONVERGENCE GLOBAUX
C
      CALL GETVIS('CONVERGENCE','ITER_GLOB_MAXI',1,1,1,ITER1,IRET)

      ELASDT = 0.D0
      IF (NOMCMD.EQ.'THER_NON_LINE') THEN
         ITER2  = ITER1
      ELSE
         CALL GETVIS('CONVERGENCE','ITER_GLOB_ELAS',1,1,1,ITER2,IRET)
C        SI ON NE DONNE PAS NEWTON/PAS_MINI_ELAS ALORS ON NE DOIT PAS
C        TENIR COMPTE DE ITER_GLOB_ELAS
         CALL GETVR8('NEWTON','PAS_MINI_ELAS',1,1,1,R8B,IRET)
         IF (IRET.LE.0) THEN
            ITER2 = ITER1
         ELSE
            ELASDT = R8B
         ENDIF
      ENDIF
C
C --- RECUPERE LA METHODE DE DECOUPAGE ET SES PARAMETRES
C
      IF (TYPECO.EQ.'LISTR8_SDASTER') THEN
C       ON A DONNE UNE LISTE DE R8 : SOUS-DECOUPAGE INTERDIT
        NOCC = 1
        CALL WKVECT(SDDISC//'.EEVR','V V R',  (NOCC+1)*LEEVR,JEEVR)
        CALL WKVECT(SDDISC//'.EEVK','V V K16',(NOCC+1)*LEEVK,JEEVK)
        CALL WKVECT(SDDISC//'.ESUR','V V R'  ,(NOCC+1)*LESUR,JESUR)
C       EVEN = DIVERGENCE_ITER ET METHODE = 'AUCUNE'
        IOCC = 1
        ZR(JEEVR-1+LEEVR*(IOCC-1)+1)=0.D0
        ZR(JESUR-1+LESUR*(IOCC-1)+1)=0.D0
C       EVEN = DIVERGENCE_ERRE ET METHODE = 'AUCUNE'
        IOCC = 2
        ZR(JEEVR-1+LEEVR*(IOCC-1)+1)=1.D0
        ZR(JESUR-1+LESUR*(IOCC-1)+1)=0.D0
      ELSEIF (TYPECO.EQ.'LIST_INST') THEN   
C       COPIE LOCALE DES OBJETS DE LA SD_LIST_INST
        SDLIST = LISINS(1:8)
        CALL JEDUP1(SDLIST//'.ECHE.EVENR','V',SDDISC//'.EEVR')
        CALL JEDUP1(SDLIST//'.ECHE.EVENK','V',SDDISC//'.EEVK')
        CALL JEDUP1(SDLIST//'.ECHE.SUBDR','V',SDDISC//'.ESUR')
        CALL JEEXIN(SDDISC//'.EEVR',IRET)
        CALL ASSERT(IRET.NE.0)
        CALL JEEXIN(SDLIST//'.ADAP.EVENR',IRET)
        IF (IRET.NE.0) THEN
          CALL JEDUP1(SDLIST//'.ADAP.EVENR','V',SDDISC//'.AEVR')
          CALL JEDUP1(SDLIST//'.ADAP.EVENK','V',SDDISC//'.AEVK')
          CALL JEDUP1(SDLIST//'.ADAP.TPLUR','V',SDDISC//'.ATPR')
          CALL JEDUP1(SDLIST//'.ADAP.TPLUK','V',SDDISC//'.ATPK')
        ENDIF

C       SI NEWTON/PREDICTION ='DEPL_CALCULE',
C       ALORS ON INTERDIT LA SUBDIVISION 
        CALL GETVTX('NEWTON','PREDICTION',1,1,1,PRED,IRET)
        IF (IRET.NE.0.AND.PRED.EQ.'DEPL_CALCULE') THEN
          CALL UTDIDT('L',SDDISC,'ECHE',IBID,'NB_OCC',R8B,NOCC,K8B)
          DO 10 IOCC=1,NOCC
C           A-T-ON DEMANDE DU SOUS-DECOUPAGE ?        
            CALL UTDIDT('L',SDDISC,'ECHE',IOCC,'SUBD_METH',R8B,IBID,
     &                                                           METHOD)
            IF (METHOD.NE.'AUCUNE') THEN
              CALL U2MESK('A','SUBDIVISE_1',1,METHOD)     
              VALK = 'AUCUNE'
              CALL UTDIDT('E',SDDISC,'ECHE',IOCC,'SUBD_METH',R8B,IBID,
     &                                                             VALK)
            ENDIF
 10       CONTINUE
        ENDIF

      ENDIF
C
C --- ECRITURE DES DIFFERENTES INFOS
C     ZR(JINFO-1 + 1) <===> 'ARCHIVAGE','NUME_INIT' (NMCRAR)
C     ZR(JINFO-1 + 2) <===> 'ARCHIVAGE','PAS_ARCH'  (NMCRAR)
C
C --- VERIFIE COHERENCE SUBD_METHODE / NEWTON
C
      CALL UTDIDT('L',SDDISC,'ECHE',IBID,'NB_OCC',R8B,NOCC,K8B)
      DO 20 IOCC=1,NOCC
        CALL UTDIDT('L',SDDISC,'ECHE',IOCC,'SUBD_METH',R8B,IBID,METHOD)
        IF (METHOD.EQ.'EXTRAP_IGNO') THEN
          CALL UTDIDT('L',SDDISC,'ECHE',IOCC,'SUBD_ITER_IGNO',R8B,NIGNO,
     &                                                              K8B)
          IF (NIGNO.GE.ITER1) CALL U2MESS('F','DISCRETISATION_6')
        ELSE IF (METHOD.EQ.'EXTRAP_FIN') THEN
          CALL UTDIDT('L',SDDISC,'ECHE',IOCC,'SUBD_ITER_FIN',R8B,NFIN,
     &                                                              K8B)
          IF (NFIN.GE.ITER1 ) CALL U2MESS('F','DISCRETISATION_7')
        ENDIF
 20   CONTINUE

C
C --- EN GESTION AUTO, AVEC UN CRITERE D'ADAPTATION EN SEUIL SUR 
C     NB_ITER_NEWT, ON MET VALE = ITER_GLOB_MAXI/2 SI VALE N'A PAS
C     ETE RENSIGNE DANS DEFI_LIST_INST
C     ON NE CONSIDERE PAS LE CAS DE DE ITER_GLOB_ELAS CAR C'EST ACTIVE
C     (MATRICE SECANTE) QU'EN CAS DE DIFFICULTE
      CALL UTDIDT('L',SDDISC,'LIST',IBID,'METHODE',R8B,IBID,METLIS)
      IF (METLIS.EQ.'AUTO') THEN
        CALL GETVIS('CONVERGENCE','ITER_GLOB_MAXI',1,1,1,ITMX,IRE1)
        CALL UTDIDT('L',SDDISC,'ADAP',IBID,'NB_OCC',R8B,NOCC,K8B)
        DO 25 IOCC=1,NOCC
          CALL UTDIDT('L',SDDISC,'ADAP',IOCC,'NOM_EVEN',R8B,IBID,EVEN)
          IF (EVEN.NE.'SEUIL_SANS_FORMULE') GOTO 25
          CALL UTDIDT('L',SDDISC,'ADAP',IOCC,'NOM_PARA',R8B,IBID,NOPARA)
          IF (NOPARA.NE.'NB_ITER_NEWT') GOTO 25
          CALL UTDIDT('L',SDDISC,'ADAP',IOCC,'VALE',R8B,VALI,K8B)
          IF (VALI.NE.0) GOTO 25
          VALI = ITMX / 2
          VALR = VALI
          CALL UTDIDT('E',SDDISC,'ADAP',IOCC,'VALE',VALR,VALI,K8B)    
 25     CONTINUE      
      ENDIF
C
C
C --- CREATION DU TABLEAU DES ERREURS AU COURS DES ITERATIONS
C     NATURE DU STOCKAGE
C          JEREUR + 0 : NB VALEURS MEMORISEES AVANT LES ITERATIONS
C          JEREUR + 1 : MAX( ITER_GLOB_MAXI , ITER_GLOB_ELAS )
C          JEREUR + 2 : MIN( ITER_GLOB_MAXI , ITER_GLOB_ELAS )
C          JEREUR + 3 : NBITER (DIMENSION DU VECTEUR)
C          JEREUR + 4 : RESI_GLOB_RELA
C          JEREUR + 5 : RESI_GLOB_MAXI
C          JEREUR + 6 : =1 ON A DONNE RESI_GLOB_RELA
C                       =2 ON A DONNE RESI_GLOB_MAXI
C                       =3 ON A DONNE RESI_GLOB_RELA ET RESI_GLOB_MAXI
C                       =0 ON A RIEN DONNE ==> =1
C          JEREUR + 7 : PAS_MINI_ELAS
C     IL Y A 8 VALEURS A STOCKER ==> ZR(JERRE) = 8
C
C          + 2 VALEURS PAR ITERATIONS PRECEDENTES
C          + 2 VALEURS POUR L'ITERATION EN COURS
C          + 2 VALEURS POUR L'ITERATION A VENIR
C        !!!! LE NUMERO DES ITERATIONS COMMENCE A ZERO
C

C     LE STATUT DE L'OBJET .ERRE N'EST PAS TRES CLAIR
C     POUR LE MOMENT, ON LE CREE SI ON A UNE OCCURENCE DE 'ECHEC', 
C     AVEC EVENEMENT ='DIVERGENCE_ITER' 
C     RQ : ON DOIT EN AVOIR SOIT 0 SOIT UNE SEULE
      CALL UTDIDT('L',SDDISC,'ECHE',IBID,'NB_OCC',R8B,NOCC,K8B)
C     RECHERCHE DE L'OCCURENCE OU ON A EVENEMENT ='DIVERGENCE_ITER' 
      IDIV=0
      DO 30 IOCC=1,NOCC
        CALL UTDIDT('L',SDDISC,'ECHE',IOCC,'NOM_EVEN',R8B,IBID,EVEN)
        IF (EVEN.EQ.'DIVERGENCE_ITER') IDIV = IOCC
 30   CONTINUE

      IF (IDIV.EQ.0) GOTO 9999
      
      CALL UTDIDT('L',SDDISC,'ECHE',IDIV,'SUBD_METH',R8B,IBID,METHOD)

      IF ( METHOD .EQ. 'AUCUNE' ) THEN
         NBVAL=4
         CALL WKVECT(TPSERR,'V V R8',NBVAL,JERRE)
         ZR(JERRE)   = NBVAL
         ZR(JERRE+1) = 0.D0
         ZR(JERRE+2) = 0.D0
         ZR(JERRE+3) = 0.D0
      ELSE
C       NOMBRE D'ITERATIONS AUTORISEES EN PLUS
        CALL UTDIDT('L',SDDISC,'ECHE',IDIV,'SUBD_ITER_PLUS',
     &                                                   R8B,NBPLUS,K8B)
C       ARRONDI A L'ENTIER SUPERIEUR
        NBITER = CEIL(MAX(ITER1,ITER2)*(1.D0 + NBPLUS/100.0D0))
        NBVAL  = 8
        CALL WKVECT(TPSERR,'V V R8',NBVAL+NBITER*2+2+2,JERRE)
        ZR(JERRE)   = NBVAL
        ZR(JERRE+1) = MAX(ITER1,ITER2)
        ZR(JERRE+2) = MIN(ITER1,ITER2)
        ZR(JERRE+3) = NBITER
        ZR(JERRE+7) = ELASDT
        ZR(JERRE+6) = 0.D0
        CALL GETVR8('CONVERGENCE','RESI_GLOB_RELA',1,1,1,
     &                             ZR(JERRE+4),IRE1)
        IF (IRE1.LE.0) THEN
          ZR(JERRE+4) = R8VIDE()
        ELSE
          ZR(JERRE+6) = ZR(JERRE+6) + 1.D0
        ENDIF
        CALL GETVR8('CONVERGENCE','RESI_GLOB_MAXI',1,1,1,
     &                            ZR(JERRE+5),IRE2)
        IF (IRE2.LE.0) THEN
          ZR(JERRE+5) = R8VIDE()
        ELSE
          ZR(JERRE+6) = ZR(JERRE+6) + 1.D0 + 1.D0
        ENDIF
        IF (IRE1.LE.0 .AND. IRE2.LE.0) THEN
          ZR(JERRE+4) = 1.0D-06
          ZR(JERRE+5) = 1.0D-06
          ZR(JERRE+6) = 1.D0
        ENDIF
      ENDIF
C
 9999 CONTINUE
      CALL JEDEMA()

      END
