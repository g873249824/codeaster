      SUBROUTINE PREGCP(NEQ,NBLIAI,TOLE,EPSI,MU,DIREP,APCOEF,APDDL,
     &                  APPOIN,INLIAC,LMAT,SSGRAD,SSGRPR)

C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 20/12/2006   AUTEUR TARDIEU N.TARDIEU 
C ======================================================================
C COPYRIGHT (C) 1991 - 2006  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
C (AT YOUR OPTION) ANY LATER VERSION.                                   
C                                                                       
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
C                                                                       
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.         
C ======================================================================

      IMPLICIT     NONE

      INTEGER NEQ,NBLIAI,LMAT,APDDL(*),APPOIN(*),INLIAC(*)
      REAL*8 APCOEF(*),SSGRAD(*),SSGRPR(*),MU(*),DIREP(*)
      REAL*8 TOLE,EPSI
C ======================================================================
C ROUTINE APPELEE PAR : ALGOCG
C ======================================================================
C - PRECONDITIONNEMENT DE L'ALGORITHME DU GRADIENT CONJUGUE PROJETE
C - RESOLUTION D'UN PROBLEME ANNEXE A DEPLACEMENT IMPOSE SUR LES NOEUDS
C - EFFECTIVEMENT EN CONTACT.

      REAL*8 UU(NEQ),GRAD(NBLIAI),DU(NEQ)
      REAL*8 VALE,NUMER,DENOM,CONVER,DDOT,VECT0(NEQ),ALPHA
      REAL*8 ADU(NBLIAI),DIRECH(NBLIAI),NUMERP,NUMERM,BETA
      REAL*8 CONVM, COEF
      PARAMETER (COEF=1.D-2)
      INTEGER ILIAC,LLIAC,JDECAL,NBDDL,I,ITERAT,NBLIAC,II,IFM,NIV

C ----------------------------------------------------------------------

C ======================================================================
C                             INITIALISATIONS
C ======================================================================

      CALL INFNIV(IFM,NIV)


C --- COMPTAGE DU NOMBRE DE LIAISONS REELLEMENT ACTIVES
      NBLIAC = 0
      DO 10 ILIAC = 1,NBLIAI
        IF ((MU(ILIAC).GT.TOLE) .OR. (SSGRAD(ILIAC).GT.EPSI)) THEN
          NBLIAC = NBLIAC + 1
          INLIAC(NBLIAC) = ILIAC
        END IF
   10 CONTINUE
      IF (NIV.GE.2) THEN
        WRITE (IFM,*) '<CONTACT> <> <> PRECONDITIONNEUR DIRICHLET'
        WRITE (IFM,9010) NBLIAC, EPSI
      END IF

C --- SI AUCUNE LIAISON ACTIVE ON SORT CAR
C --- LE PRECONDITIONNEUR EST INUTILE
      IF (NBLIAC.EQ.0) THEN
        CALL DCOPY(NBLIAI,DIREP,1,SSGRPR,1)
        GO TO 120
      END IF

C --- SSGRAD = -DIREP
      CALL DCOPY(NBLIAI,DIREP,1,SSGRAD,1)
      CALL DSCAL(NBLIAI,-1.D0,SSGRAD,1)

C --- MISE A ZERO DES VECTEURS DE TRAVAIL
      CALL R8INIR(NEQ,0.D0,UU,1)
      CALL R8INIR(NBLIAI,0.D0,GRAD,1)
      CALL R8INIR(NEQ,0.D0,VECT0,1)
      ITERAT = 1


C ======================================================================
C =========================== BOUCLE PRINCIPALE ========================
C ======================================================================
   20 CONTINUE

      CALL R8INIR(NEQ,0.D0,DU,1)
      CALL R8INIR(NBLIAI,0.D0,ADU,1)

C --- NOUVELLE VALEUR DU GRADIENT
      DO 30 ILIAC = 1,NBLIAC
        LLIAC = INLIAC(ILIAC)
        JDECAL = APPOIN(LLIAC)
        NBDDL = APPOIN(LLIAC+1) - APPOIN(LLIAC)
C       GRAD=A(AC,:)*UU-SSGRAD(AC)
        CALL CALADU(NEQ,NBDDL,APCOEF(1+JDECAL),APDDL(1+JDECAL),UU,
     &              GRAD(ILIAC))
        GRAD(ILIAC) = GRAD(ILIAC) - SSGRAD(LLIAC)
   30 CONTINUE


C --- TEST DE CONVERGENCE
      CONVER = -1.D0
      DO 40 I = 1,NBLIAC
        CONVER = MAX(CONVER,ABS(GRAD(I)))
   40 CONTINUE
      IF (NIV.GE.2) THEN
        IF (ITERAT.EQ.1) CONVM=10*CONVER/COEF
        IF (CONVER.LT.(COEF*CONVM)) THEN
          WRITE (IFM,9000) ITERAT,CONVER
          CONVM=CONVER
        END IF
      END IF


C --- ON A CONVERGE
      IF (CONVER.LT.EPSI) THEN
        IF (NIV.GE.2) THEN
          WRITE (IFM,9020) ITERAT,CONVER
        END IF
        GO TO 90
      END IF

C --- NOUVELLE DIRECTION DE RECHERCHE
C --- DIRECH=GRAD+BETA*DIRECH
      IF (ITERAT.EQ.1) THEN
        NUMERP = DDOT(NBLIAI,GRAD,1,GRAD,1)
        CALL DCOPY(NBLIAI,GRAD,1,DIRECH,1)
      ELSE
        NUMERM = NUMERP
        NUMERP = DDOT(NBLIAI,GRAD,1,GRAD,1)
        BETA = NUMERP/NUMERM
        CALL DSCAL(NBLIAI,BETA,DIRECH,1)
        CALL DAXPY(NBLIAI,1.D0,GRAD,1,DIRECH,1)
      ENDIF



C --- CALCUL DU SECOND MEMBRE
C --- DU=A(AC,:)'*GRAD
      DO 50 ILIAC = 1,NBLIAC
        LLIAC = INLIAC(ILIAC)
        JDECAL = APPOIN(LLIAC)
        NBDDL = APPOIN(LLIAC+1) - APPOIN(LLIAC)
        CALL CALATM(NEQ,NBDDL,DIRECH(ILIAC),APCOEF(1+JDECAL),
     &              APDDL(1+JDECAL),DU)
   50 CONTINUE


C --- RESOLUTION
C --- DU=K-1*A(AC,:)'*DIRECH
      CALL NMRLDB(LMAT,VECT0,DU,1)


C --- EVALUATION DU COMPLEMENT DE SCHUR SUR GRAD
C --- ADU=A(AC,:)*K-1*A(AC,:)'*DIRECH
      DO 60 ILIAC = 1,NBLIAC
        LLIAC = INLIAC(ILIAC)
        JDECAL = APPOIN(LLIAC)
        NBDDL = APPOIN(LLIAC+1) - APPOIN(LLIAC)
C       ADU=A(AC,:)*DU
        CALL CALADU(NEQ,NBDDL,APCOEF(1+JDECAL),APDDL(1+JDECAL),DU,
     &              ADU(ILIAC))
   60 CONTINUE


C --- PAS D'AVANCEMENT
      NUMER = DDOT(NBLIAC,GRAD,1,GRAD,1)
      DENOM = DDOT(NBLIAC,GRAD,1,ADU,1)
      ALPHA = NUMER/DENOM

      IF (ALPHA.LT.0.D0) CALL U2MESS('F','ALGORITH_8')


C --- ACTUALISATION DU SOUS GRADIENT ET DU DEPLACEMENT
      DO 70 ILIAC = 1,NBLIAC
        LLIAC = INLIAC(ILIAC)
        SSGRPR(LLIAC) = SSGRPR(LLIAC) + ALPHA*DIRECH(ILIAC)
   70 CONTINUE

      CALL DAXPY(NEQ,-ALPHA,DU,1,UU,1)


C --- ON A ATTEINT LE NOMBRE D'ITERATION MAXIMAL=2*NBLIAC
      IF (ITERAT.GE.(2*NBLIAC)) GO TO 80


C --- ON N A PAS CONVERGE MAIS IL RESTE DES ITERATIONS A FAIRE
      ITERAT = ITERAT + 1
      GO TO 20

   80 CONTINUE
      IF (NIV.GE.2) THEN
        WRITE (IFM,*) '<CONTACT> <> <> PRECONDITIONNEUR : '//
     &    'NOMBRE MAXIMUM D''ITERATION ATTEINT'
      END IF


   90 CONTINUE

C ======================================================================
C ============================= ON A CONVERGE ==========================
C ======================================================================

C     LES CRITERES DE CONVERGENCE SONT DECALES ENTRE L'APPELANT
C     ET CETTE ROUTINE. DU COUP, ON PEUT ENTRER ICI ET S'APERCEVOIR
C     QUE L'ON A RIEN A FAIRE. DANS CE CAS, ON RECOPIE.
      IF (ITERAT.EQ.1) THEN
        DO 100 ILIAC = 1,NBLIAC
          LLIAC = INLIAC(ILIAC)
          SSGRPR(LLIAC) = GRAD(ILIAC)
  100   CONTINUE
      END IF

C     ON REPROJETE LE SOUS-GRADIENT PRECONDITIONNE POUR
C     ASSURER LA POSITIVITE DES MULTIPLICATEURS
      DO 110 II = 1,NBLIAI
        IF (MU(II).LT.TOLE) THEN
          SSGRPR(II) = MAX(SSGRPR(II),0.D0)
        END IF
  110 CONTINUE


  120 CONTINUE


 9000 FORMAT (' <CONTACT> <> <> PRECONDITIONNEUR : ITERATION =',I6,
     &        ' RESIDU =',1PE12.5)
 9010 FORMAT (' <CONTACT> <> <> PRECONDITIONNEUR : ',I6,
     &        ' LIAISON ACTIVES, CRITERE DE CONVERGENCE =',1PE12.5)
 9020 FORMAT (' <CONTACT> <> <> PRECONDITIONNEUR : ITERATION =',I6,
     &        ' RESIDU =',1PE12.5,' => CONVERGENCE')
      END
