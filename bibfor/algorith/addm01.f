      SUBROUTINE ADDM01 ( IERUSR, ICMD,
     >                    NBOPT, TABENT, TABREE, TABCAR, LGCAR )
C
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 05/03/2002   AUTEUR GNICOLAS G.NICOLAS 
C ======================================================================
C COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
C (AT YOUR OPTION) ANY LATER VERSION.                                 
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
C    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
C ======================================================================
C RESPONSABLE GNICOLAS G.NICOLAS
C     ------------------------------------------------------------------
C      ADAPTATION - DECODAGE DE LA MACRO-COMMANDE - PHASE 01
C      --           -              -                      --
C      ECRITURE DE LA COMMANDE DE CREATION DES DONNEES MED
C     ------------------------------------------------------------------
C
      IMPLICIT NONE
C
C 0.1. ==> ARGUMENTS
C
      INTEGER IERUSR, ICMD
      INTEGER NBOPT
      INTEGER TABENT(NBOPT), LGCAR(NBOPT)
C
      REAL*8 TABREE(NBOPT)
C
      CHARACTER*(*) TABCAR(NBOPT)
C
C 0.2. ==> COMMUNS
C
C --------------- COMMUNS NORMALISES  JEVEUX  --------------------------
      INTEGER      ZI
      CHARACTER*8  ZK8
      CHARACTER*16 ZK16
      CHARACTER*24 ZK24
      CHARACTER*32 ZK32
      CHARACTER*80 ZK80
      COMMON /IVARJE/ZI(1)
      COMMON /KVARJE/ZK8(1),ZK16(1),ZK24(1),ZK32(1),ZK80(1)
C     -----  FIN  COMMUNS NORMALISES  JEVEUX --------------------------
C
C 0.3. ==> VARIABLES LOCALES
C
      CHARACTER*6 NOMPRO
      PARAMETER ( NOMPRO = 'ADDM01' )
C
      INTEGER EDNONO
      PARAMETER (EDNONO=-1)
C
      INTEGER CODRET
      INTEGER IAUX, JAUX
      INTEGER IDEB, IFIN
C
      INTEGER NIVINF, IFM
      INTEGER LCO, LCHP, NORDLO
      INTEGER LCMN, LCRN, LCHINM
      INTEGER LNCPIN
      INTEGER NUROUL, LNOMFI
      INTEGER NUMORD
      INTEGER NITER
      INTEGER NBMAJS
      INTEGER ADTRA1, ADTRA2
      INTEGER ADAUX1, ADAUX2
C
      CHARACTER*8 CONCPT
      CHARACTER*8 COMN, CRN
      CHARACTER*8 NCPIN
      CHARACTER*16 CHAMP
      CHARACTER*16 CHINME
      CHARACTER*16 NOMFIC
      CHARACTER*24 NTRAV1, NTRAV2
      CHARACTER*128 REP
C
      LOGICAL AFAIRE
C
C     ------------------------------------------------------------------
C====
C 1. RECUPERATION DES ARGUMENTS
C====
C
      CODRET = 0
C
C 1.1. ==> ENTIERS
C
      NITER  = TABENT(3)
      NBMAJS = TABENT(8)
      NUMORD = TABENT(16)
      IFM    = TABENT(29)
      NIVINF = TABENT(30)
C
      IF ( NIVINF.GE.2 ) THEN
        WRITE(IFM,*) 'SUBROUTINE ', NOMPRO
      ENDIF
C
C 1.2. ==> CARACTERES
C
      LCMN = LGCAR(2)
      COMN(1:LCMN) = TABCAR(2)(1:LCMN)
C
      LCRN = LGCAR(4)
      IF ( LCRN.GT.0 ) THEN
        CRN(1:LCRN) = TABCAR(4)(1:LCRN)
      ENDIF
C
      LCHINM = LGCAR(5)
      IF ( LCHINM.GT.0 ) THEN
        CHINME(1:LCHINM) = TABCAR(5)(1:LCHINM)
      ENDIF
C
      LNCPIN = LGCAR(6)
      IF ( LNCPIN.NE.0 ) THEN
C                12345678
        NCPIN = '        '
        NCPIN(1:LNCPIN) = TABCAR(6)(1:LNCPIN)
      ENDIF
C
      IAUX = LGCAR(26)
      IF ( IAUX.NE.0 ) THEN
C                 123456789012345678901234
        NTRAV1 = '                        '
        NTRAV1(1:IAUX) = TABCAR(26)(1:IAUX)
      ENDIF
C
      IAUX = LGCAR(27)
      IF ( IAUX.NE.0 ) THEN
        NTRAV2 = '                        '
        NTRAV2(1:IAUX) = TABCAR(27)(1:IAUX)
      ENDIF
C
C 1.3. ==> NOM SYMBOLIQUE DU FICHIER D'ECRITURE
C          REMARQUE : ON LE TRONQUE A 7 CAR DEFUFI IGNORE AU DELA !
C
      LNOMFI = 11
      NOMFIC(1:16) = 'FICHIER_MED    '
C
      LNOMFI = MIN(7,LCMN)
      NOMFIC = ' '
      NOMFIC(1:LNOMFI) = COMN(1:LNOMFI)
C
C====
C 2. POUR LA MISE A JOUR DE SOLUTION, REPERAGE DES TABLEAUX DE STOCKAGE
C          ON TROUVE POUR CHAQUE CHAMP A INTERPOLER :
C       K8 : NOM DU RESULTAT (LG MAX = 8)
C            NOM SYMBOLIQUE DU CHAMP (LG MAX = 16)
C            TYPE DU CHAMP (LG MAX = 16)
C            NOM DE L'OBJET (LG MAX = 8)
C       I  : LONGUEUR DU NOM DU RESULTAT
C            LONGUEUR DU NOM SYMBOLIQUE DU CHAMP
C            LONGUEUR DU TYPE DU CHAMP
C            LONGUEUR DU NOM DE L'OBJET
C            NUMERO D'ORDRE
C====
C
      IF ( NBMAJS.NE.0 ) THEN
C
        CALL JEVEUO ( NTRAV1, 'L', ADTRA1 )
        CALL JEVEUO ( NTRAV2, 'L', ADTRA2 )
C
        ADAUX1 = ADTRA1 - 1
        ADAUX2 = ADTRA2 - 1
C
      ENDIF
C
C====
C 3. DETERMINATION DES GRANDEURS A ECRIRE
C A PRIORI, ON BOUCLE POUR CHAQUE TYPE DE GRANDEUR :
C       1. MAILLAGE
C       2. INDICATEUR D'ERREUR
C       N. CHAMP(S) A INTERPOLER
C
C REMARQUE : LE MAILLAGE EST TOUJOURS ECRIT A L'ITERATION INITIALE
C            ENSUITE, IL SERA RELU PAR HOMARD DEPUIS LE FICHIER PROPRE
C            A HOMARD, DONC SON ECRITURE EST INUTILE POUR REALISER
C            UNE ADAPTATION. IL FAUT EN REVANCHE QUAND MEME L'ECRIRE SI
C            ON DOIT ECRIRE UN CHAMP, SINON MED SE PLANTE.
C====
C
      IFIN = NBMAJS + 2
      IF ( NITER.EQ.0 .OR. LCHINM.GT.0 .OR. NBMAJS.GT.0 ) THEN
        IDEB = 1
      ELSE
        IDEB = IFIN + 1
      ENDIF
C
      DO 100 , IAUX = IDEB , IFIN
C
      AFAIRE = .FALSE.
C
      IF ( CODRET.EQ.0 ) THEN
C
      NUROUL = TABENT(19+2*IAUX)
C
C 3.1. ==> LE CONCEPT EN COURS : MAILLAGE (IAUX=1)
C                                INDICATEUR (IAUX=2)
C                                SOLUTION (SUITE)
C
C               12345678
      CONCPT = '        '
      IF ( IAUX.EQ.1 ) THEN
        LCO = LCMN
        CONCPT(1:LCO) = COMN(1:LCO)
        AFAIRE = .TRUE.
      ELSEIF ( IAUX.EQ.2 ) THEN
        LCO = LCRN
        IF ( LCO.GT.0 ) THEN
          CONCPT(1:LCO) = CRN(1:LCO)
          AFAIRE = .TRUE.
        ENDIF
      ELSE
        ADAUX2 = ADAUX2 + 1
        LCO = ZI(ADAUX2)
        ADAUX1 = ADAUX1 + 1
        CONCPT(1:LCO) = ZK8(ADAUX1)(1:LCO)
        AFAIRE = .TRUE.
      ENDIF
C
C 3.2. ==> LE CHAMP LIE AU RESULTAT
C          EN L'ABSENCE DE CHAMP, RIEN N'EST A FAIRE
C
C              1234567890123456
      CHAMP = '                '
      IF ( IAUX.EQ.1 ) THEN
        LCHP = 0
      ELSEIF ( IAUX.EQ.2 ) THEN
        LCHP = LCHINM
        IF ( LCHP.EQ.0 ) THEN
          AFAIRE = .FALSE.
        ELSE
          CHAMP(1:LCHP) = CHINME(1:LCHP)
          AFAIRE = .TRUE.
        ENDIF
      ELSE
        ADAUX2 = ADAUX2 + 1
        LCHP = ZI(ADAUX2)
        ADAUX1 = ADAUX1 + 1
        IF ( LCHP.LE.8 ) THEN
          CHAMP(1:LCHP) = ZK8(ADAUX1)(1:LCHP)
          ADAUX1 = ADAUX1 + 1
        ELSE
          CHAMP(1:8) = ZK8(ADAUX1)
          ADAUX1 = ADAUX1 + 1
          CHAMP(9:LCHP) = ZK8(ADAUX1)(1:LCHP-8)
        ENDIF
        AFAIRE = .TRUE.
      ENDIF
C
C 3.3. ==> LE NUMERO D'ORDRE
C          REMARQUE : ATTENTION A SAUTER LE STOCKAGE DU CHAMP DE
C                     RECUPERATION DE L'INTERPOLATION
C
      IF ( IAUX.EQ.1 ) THEN
        NORDLO = 0
      ELSEIF ( IAUX.EQ.2 ) THEN
        NORDLO = NUMORD
      ELSE
        ADAUX1 = ADAUX1 + 3
        ADAUX2 = ADAUX2 + 3
        NORDLO = ZI(ADAUX2)
      ENDIF
C
      ENDIF
C
C====
C 4. ECRITURE DE LA COMMANDE DE CHANGEMENT DE L'UNITE LOGIQUE
C====
C
      IF ( AFAIRE ) THEN
C
C 4.1. ==> INITIALISATION
C
      ICMD = ICMD + 1
      CALL SMDCMD ( ICMD, ' ', 'DEFUFI', CODRET )
C
C 4.2. ==> LES MOTS-CLES
C
C 4.2.1. ==> INITIALISATION DU MOT-CLE FACTEUR
C
      CALL SMDMCF ( 'IMPRESSION', CODRET )
C
C 4.2.2. ==> L'UNITE RETENUE
C
      CALL PUTVIS ( 'UNITE', 1, NUROUL, CODRET)
C
      CALL PUTVTX ( 'NOM', 1, NOMFIC, LNOMFI, CODRET)
C
C 4.2.3. ==> FIN DU MOT-CLE FACTEUR
C
      CALL SMFMCF ( CODRET )
C
C 4.3. ==> FIN DE LA COMMANDE
C
      CALL SMFCMD ( CODRET )
C
      IF ( NIVINF.GE.2 ) THEN
        WRITE(IFM,*) 'UNITE LOGIQUE : ',NUROUL
        WRITE(IFM,*) 'FICHIER SYMBOLIQUE : ',NOMFIC(1:LNOMFI)
      ENDIF
C
      ENDIF
C
C====
C 5. ECRITURE DE LA COMMANDE D'IMPRESSION
C====
C
      IF ( AFAIRE ) THEN
C
C 5.1. ==> INITIALISATION
C
      ICMD = ICMD + 1
      CALL SMDCMD ( ICMD, ' ', 'IMPR_RESU', CODRET )
C
C 5.2. ==> LES MOTS-CLES
C
C 5.2.1. ==> LES INFORMATIONS
C
      CALL PUTVIS ( 'INFO', 1, NIVINF, CODRET)
C
C 5.2.2. ==> LE MOT_CLE FACTEUR RESU
C
C 5.2.2.1. ==> INITIALISATION DU MOT-CLE FACTEUR
C
      CALL SMDMCF ( 'RESU', CODRET )
C
C 5.2.2.2. ==> LES INFORMATIONS
C
      JAUX = 3
      IF ( NIVINF.EQ.2 ) THEN
        REP(1:JAUX) = 'OUI'
      ELSE
        REP(1:JAUX) = 'NON'
      ENDIF
C
      CALL PUTVTX ( 'INFO_MAILLAGE', 1, REP, JAUX, CODRET)
C
C 5.2.2.3. ==> LE FICHIER
C
      CALL PUTVTX ( 'FICHIER', 1, NOMFIC, LNOMFI, CODRET)
C
C 5.2.2.4. ==> LE FORMAT
C
      JAUX = 3
      REP(1:JAUX) = 'MED'
      CALL PUTVTX ( 'FORMAT', 1, REP, JAUX, CODRET)
C
C 5.2.2.5. ==> LA STRUCTURE
C
      IF ( IAUX.EQ.1 ) THEN
C
        CALL PUTVID ( 'MAILLAGE', 1, CONCPT, CODRET)
C
      ELSE
C
        CALL PUTVID ( 'RESULTAT', 1, CONCPT, CODRET)
C
        IF ( NORDLO.NE.EDNONO ) THEN
          CALL PUTVIS ( 'NUME_ORDRE', 1, NORDLO, CODRET)
        ENDIF
C
        CALL PUTVTX ( 'NOM_CHAM', 1, CHAMP, LCHP, CODRET)
C
        IF ( IAUX.EQ.2 ) THEN
          CALL PUTVTX ( 'NOM_CMP', 1, NCPIN, LNCPIN, CODRET)
        ENDIF
C
      ENDIF
C
C 5.2.2.6. ==> FIN DU MOT-CLE FACTEUR
C
      CALL SMFMCF ( CODRET )
C
C 5.3. ==> FIN DE LA COMMANDE
C
      CALL SMFCMD ( CODRET )
C
      ENDIF
C
  100 CONTINUE
C
C====
C 6. BILAN
C====
C
      IF ( CODRET .GT. 0 ) THEN
        CALL UTMESS
     > ('E',NOMPRO,'ERREURS CONSTATEES POUR MACR_ADAP')
         IERUSR = IERUSR + CODRET
      ENDIF
C
      END
