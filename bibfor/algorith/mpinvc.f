      SUBROUTINE MPINVC ( NBMESU,NBMODE,NBABS, 
     &                    PHI,CMESU,COEF,XABS, 
     &                    LFONCT,CETA,CETAP,CETA2P )
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 19/06/2007   AUTEUR LEBOUVIER F.LEBOUVIER 
C ======================================================================
C COPYRIGHT (C) 1991 - 2002  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
C (AT YOUR OPTION) ANY LATER VERSION.                                   
C                                                                       
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
C                                                                       
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.         
C ======================================================================
C     PROJ_MESU_MODAL : RESOLUTION DU SYSTEME PAR SVD OU PAR LU
C                       (DONNEES FREQUENTIELLES)
C
C     IN  : NBMESU : NOMBRE DE MESURE
C     IN  : NBMODE : NOMBRE DE MODES 
C     IN  : NBABS  : NOMBRE D ABSCISSES
C     IN  : PHI    : BASE DE PROJECTION
C     IN  : CMESU  : VALEURS MESUREES
C     IN  : COEF   : COEFFICIENTS DE PONDERATION
C     IN  : XABS   : LISTE REELLE D ABSCISSES
C     IN  : LFONCT : .TRUE. SI COEFFICIENTS DE PONDERATION 
C                    DEPENDENT DE LA FREQUENCE
C     OUT : CETA   : DEPLACEMENT GENERALISE   ( MATRICE )
C     OUT : CETAP  : VITESSE  GENERALISEE     ( MATRICE )
C     OUT : CETA2P : ACCELERATION GENERALISE  ( MATRICE )
C
      IMPLICIT NONE
C
C-------- DEBUT COMMUNS NORMALISES  JEVEUX  ----------------------------
C
      INTEGER          ZI
      COMMON  /IVARJE/ ZI(1)
      REAL*8           ZR
      COMMON  /RVARJE/ ZR(1)
      COMPLEX*16       ZC
      COMMON  /CVARJE/ ZC(1)
      LOGICAL          ZL
      COMMON  /LVARJE/ ZL(1)
      CHARACTER*8      ZK8
      CHARACTER*16              ZK16
      CHARACTER*24                        ZK24
      CHARACTER*32                                  ZK32
      CHARACTER*80                                            ZK80
      COMMON  /KVARJE/ ZK8(1),ZK16(1),ZK24(1),ZK32(1),ZK80(1)
C
C----------  FIN  COMMUNS NORMALISES  JEVEUX  --------------------------
C
      INTEGER       NBMESU,NBMODE,NBABS
      INTEGER VALI
      REAL*8        PHI(NBMESU,NBMODE),XABS(NBABS),COEF(*)
      REAL*8 VALR
      COMPLEX*16    CMESU(NBMESU,NBABS),CETA(NBMODE,NBABS)
      COMPLEX*16    CETAP(NBMODE,NBABS),CETA2P(NBMODE,NBABS)
      LOGICAL       LFONCT

      INTEGER       IMOD,JMOD,IMES,IABS,IERR,IBID,JMES
      INTEGER LSECMB,LWKS,LPHIPH,LPHITP,LMATSY,LWORK,LETA,LVALS,LU,LV
      REAL*8        ALPHA,R8PREM,EPS
      REAL*8        R8DEPI
      REAL*8        ZERO,DEPI,RVAL
      COMPLEX*16    CVAL
      LOGICAL       NUL
      CHARACTER*3   METHOD
      CHARACTER*8   REGUL
      CHARACTER*16  NOMCHA
      CHARACTER*16  SECMB,WKS,PHIPHT,PHITPH,MATSYS,WORK,ETA,VALS,U,V
C
C ----------------------------------------------------------------------
C
      CALL JEMARQ()

C CREATION DES VECTEURS DE TRAVAIL
      SECMB = '&SECMB'
      WKS = '&WKS'
      PHIPHT = '&PHIPHT'
      PHITPH = '&PHITPH'
      MATSYS = '&MATSYS'
      WORK = '&WORK'
      ETA = '&ETA'
      VALS = '&VALS'
      U = '&U'
      V = '&V'

      CALL WKVECT(SECMB,'V V R',NBMODE*2,LSECMB)
      CALL WKVECT(WKS,'V V R',NBMODE,LWKS)
      CALL WKVECT(PHIPHT,'V V R',NBMESU*NBMESU,LPHIPH)
      CALL WKVECT(PHITPH,'V V R',NBMODE*NBMODE,LPHITP)
      CALL WKVECT(MATSYS,'V V R',NBMODE*NBMODE,LMATSY)
      CALL WKVECT(WORK,'V V R',NBMODE,LWORK)
      CALL WKVECT(ETA,'V V R',NBMODE*2,LETA)
      CALL WKVECT(VALS,'V V R',NBMODE,LVALS)
      CALL WKVECT(U,'V V R',NBMODE*NBMODE,LU)
      CALL WKVECT(V,'V V R',NBMODE*NBMODE,LV)

C METHODE DE RESOLUTION : LU / SVD
      CALL GETVTX ('RESOLUTION','METHODE',1,1,1,METHOD,IBID)
      IF (IBID .EQ. 0) METHOD = 'LU'

      IF (METHOD .EQ. 'SVD') THEN
        CALL GETVR8 ('RESOLUTION','EPS',1,1,1,EPS,IBID)
        IF (IBID .EQ. 0) EPS = 0.D0
      END IF

C REGULARISATION : NON / NORM_MIN / TIK_RELA
      CALL GETVTX ('RESOLUTION','REGUL',1,1,1,REGUL,IBID)
      IF (IBID .EQ. 0) REGUL = 'NON'

      CALL GETVTX ('MODELE_MESURE','NOM_CHAM',1,1,1,NOMCHA,IBID)
C
      ZERO  = 0.D0
      DEPI  = R8DEPI()
C
C ===============================
C CALCUL DE PHI_TRANSPOSEE * PHI 
C ===============================
      DO 30 IMOD = 1,NBMODE
        DO 20 JMOD = 1,NBMODE
          ZR(LPHITP-1 +IMOD+NBMODE*(JMOD-1)) = 0.D0
          DO 10 IMES = 1,NBMESU
            ZR(LPHITP-1 +IMOD+NBMODE*(JMOD-1)) = 
     &                             ZR(LPHITP-1 +IMOD+NBMODE*(JMOD-1)) 
     &                           + PHI(IMES,IMOD)*PHI(IMES,JMOD)
 10       CONTINUE
 20     CONTINUE
 30   CONTINUE

      IF (NBMESU .LT. NBMODE) THEN
C ===============================
C CALCUL DE PHI * PHI_TRANSPOSEE
C ===============================
        DO 40 IMES = 1,NBMESU
          DO 50 JMES = 1,NBMESU
            ZR(LPHIPH-1 +IMES+NBMESU*(JMES-1)) = 0.D0
            DO 60 IMOD = 1,NBMODE
              ZR(LPHIPH-1 +IMES+NBMESU*(JMES-1)) = 
     &                             ZR(LPHIPH-1 +IMES+NBMESU*(JMES-1))
     &                           + PHI(IMES,IMOD)*PHI(JMES,IMOD)
 60         CONTINUE
 50       CONTINUE
 40     CONTINUE
      END IF
C
C =======================================
C CALCUL DE LA REPONSE GENERALISEE : CETA
C =======================================
C
C DEBUT DE LA BOUCLE SUR LES ABSCISSES (FREQUENCE)
C *****************************
      DO 100 IABS = 1,NBABS
C
        NUL = .TRUE.
C
C DEBUT DE LA BOUCLE SUR LES MODES
C ********************************
        DO 90 IMOD = 1,NBMODE
C
C RECHERCHE DU COEFFICIENT DE PONDERATION
C ***************************************
          IF (LFONCT) THEN
C             -> ALPHA DEPENDANT DES ABSCISSES
              ALPHA = COEF (NBMODE*(IABS-1)+IMOD)
            ELSE
C             -> ALPHA INDEPENDANT DES ABSCISSES
              ALPHA = COEF (IMOD)
          ENDIF
C
C         -> ON VERIFIE QUE ALPHA > 0, SINON ARRET
          IF (ALPHA .LT. 0.D0) THEN
              VALI = IABS
              CALL U2MESG('F','ALGORITH15_31',0,' ',1,VALI,0,0.D0)
            ELSE IF (ALPHA .GT. R8PREM()) THEN
              NUL=.FALSE.
          ENDIF
C
C DETERMINATION DE LA MATRICE A INVERSER :
C MATSYS(IABS) = PHI_T*PHI + ALPHA(IABS)
C ****************************************
          DO 80 JMOD = 1,NBMODE
            ZR(LMATSY-1 +IMOD+NBMODE*(JMOD-1)) = 
     &                 ZR(LPHITP-1 +IMOD+NBMODE*(JMOD-1))
 80       CONTINUE
C
          ZR(LMATSY-1 +IMOD+NBMODE*(IMOD-1)) = 
     &                 ZR(LMATSY-1 +IMOD+NBMODE*(IMOD-1)) + ALPHA
C
C DETERMINATION DU SECOND MEMBRE :
C SCDMB(IABS) = PHI_T*Q + ALPHA(IABS)*CETA(IABS-1)
C RQ : A IABS=1, CETA(0)=0 (LA SOLUTION A PRIORI EST NULLE)
C ********************************************************
          ZR(LSECMB-1 +IMOD) = 0.D0
          ZR(LSECMB-1 +NBMODE+IMOD) = 0.D0
C
          DO 70 IMES = 1,NBMESU
            CVAL = CMESU(IMES,IABS)
C TRAITEMENT PARTIE REELLE / PARTIE IMAGINAIRE
            ZR(LSECMB-1 +IMOD) = ZR(LSECMB-1 +IMOD)
     &                          +PHI(IMES,IMOD)*DBLE(CVAL)
            ZR(LSECMB-1 +NBMODE+IMOD) = ZR(LSECMB-1 +NBMODE+IMOD)
     &                                +PHI(IMES,IMOD)*DIMAG(CVAL)
 70       CONTINUE
C
          IF ((REGUL .EQ. 'TIK_RELA') .AND. (IABS .GT. 1)) THEN
            CVAL = CETA(IMOD,IABS-1)
C TRAITEMENT PARTIE REELLE / PARTIE IMAGINAIRE
            ZR(LSECMB-1 +IMOD) = ZR(LSECMB-1 +IMOD)+ALPHA*DBLE(CVAL)
            ZR(LSECMB-1 +NBMODE+IMOD) = ZR(LSECMB-1 +NBMODE+IMOD)
     &                                 +ALPHA*DIMAG(CVAL)
          ENDIF
C
C FIN DE LA BOUCLE SUR LES MODES
C ******************************
 90     CONTINUE


C RESOLUTION DU SYSTEME : 
C MATSYS(IABS) * ETA(IABS) = SCDMB(IABS)
C **************************************
C       -> ALARME SI ALPHA NUL ET NBMESU<NBMODE : MOINDRE NORME
        IF ((NBMESU .LT. NBMODE) .AND. (NUL)) THEN
          CALL U2MESG('A','ALGORITH15_32',0,' ',0,0,0,0.D0)

          IF (REGUL .EQ. 'NON') THEN
C CALCUL MOINDRE NORME
            CALL U2MESG('A','ALGORITH15_33',0,' ',0,0,0,0.D0)
            DO 71 IMES = 1,NBMESU
              CVAL = CMESU(IMES,IABS)
C TRAITEMENT PARTIE REELLE / PARTIE IMAGINAIRE
              ZR(LSECMB-1 +IMES) =  DBLE(CVAL)
              ZR(LSECMB-1 +NBMODE+IMES) =  DIMAG(CVAL)
              DO 77 JMES = 1,NBMESU
                ZR(LMATSY-1 +IMES+NBMODE*(JMES-1)) = 
     &                     ZR(LPHIPH-1 +IMES+NBMESU*(JMES-1))
 77           CONTINUE
 71         CONTINUE
C
C CHOIX POUR LA METHODE D INVERSION
            IF (METHOD .EQ. 'SVD') THEN
C METHODE SVD
C CREATION DU VECTEUR SECOND MEMBRE
              DO 75 JMES = 1,NBMESU
                ZR(LETA-1 +JMES) = ZR(LSECMB-1 +JMES)
                ZR(LETA-1 +NBMODE+JMES) = ZR(LSECMB-1 +NBMODE+JMES)
 75           CONTINUE
C
              CALL RSLSVD (NBMODE, NBMESU, NBMESU,ZR(LMATSY),ZR(LVALS),
     &                   ZR(LU),ZR(LV),2,ZR(LETA),EPS,IERR,ZR(LWORK) )
              IF ( IERR . NE. 0 ) THEN
              VALI = IABS
              VALR = XABS ( IABS )
              CALL U2MESG('F','ALGORITH15_34',0,' ',1,VALI,1,VALR)
              END IF
C
            ELSE
C METHODE DE CROUT
              CALL MTCROG (ZR(LMATSY), ZR(LSECMB), NBMODE, NBMESU, 2,
     &                           ZR(LETA), ZR(LWKS), IERR)
              IF ( IERR . NE. 0 ) THEN
              VALI = IABS
              VALR = XABS ( IABS )
              CALL U2MESG('F','ALGORITH15_35',0,' ',1,VALI,1,VALR)
              END IF
            END IF
C
C COPIE DES RESULTATS DANS CETA
            CVAL = DCMPLX(ZERO,DEPI*XABS(IABS))
            RVAL = -DEPI*DEPI*XABS(IABS)*XABS(IABS)
            DO 76 JMOD = 1,NBMODE
              DO 74 JMES = 1,NBMESU
                CETA(JMOD,IABS) = PHI(JMES,JMOD)
     &               *DCMPLX(ZR(LETA-1 +JMES),ZR(LETA-1 +NBMODE+JMES))
 74           CONTINUE
              CETAP(JMOD,IABS) = CVAL * CETA(JMOD,IABS)
              CETA2P(JMOD,IABS) = RVAL * CETA(JMOD,IABS)
 76         CONTINUE
C
            GO TO 100
          END IF
        END IF
C FIN CALCUL MOINDRE NORME

C
C RESOLUTION EN FONCTION DE LA METHODE DE RESOLUTION
        IF (METHOD .EQ. 'SVD') THEN
C METHODE SVD
C CREATION DU VECTEUR SECOND MEMBRE
          DO 81 JMOD = 1,NBMODE
             ZR(LETA-1 +JMOD) = ZR(LSECMB-1 +JMOD)
             ZR(LETA-1 +NBMODE+JMOD) = ZR(LSECMB-1 +NBMODE+JMOD)
 81       CONTINUE
C
          CALL RSLSVD ( NBMODE, NBMODE, NBMODE, ZR(LMATSY), ZR(LVALS), 
     &                  ZR(LU),ZR(LV),2,ZR(LETA),EPS,IERR,ZR(LWORK) )
          IF ( IERR . NE. 0 ) THEN
          VALI = IABS
          VALR = XABS ( IABS )
          CALL U2MESG('F','ALGORITH15_36',0,' ',1,VALI,1,VALR)
          END IF
C
        ELSE
C METHODE DE CROUT
          CALL MTCROG ( ZR(LMATSY), ZR(LSECMB), NBMODE, NBMODE, 2,
     &                           ZR(LETA), ZR(LWKS), IERR )
          IF ( IERR . NE. 0 ) THEN
          VALI = IABS
          VALR = XABS ( IABS )
          CALL U2MESG('F','ALGORITH15_37',0,' ',1,VALI,1,VALR)
          END IF
        END IF
C
C RECUPERATION DES RESULTATS
        CVAL = DCMPLX(ZERO,DEPI*XABS(IABS))
        RVAL = -DEPI*DEPI*XABS(IABS)*XABS(IABS)
        DO 73 JMOD = 1,NBMODE
          CETA(JMOD,IABS)=DCMPLX(ZR(LETA-1+JMOD),ZR(LETA-1+NBMODE+JMOD))
          CETAP(JMOD,IABS) = CVAL * CETA(JMOD,IABS)
          CETA2P(JMOD,IABS) = RVAL * CETA(JMOD,IABS)
 73     CONTINUE
C
C FIN DE LA BOUCLE SUR LES ABSCISSES (FREQUENCE)
C ***************************
100   CONTINUE

      IF (NOMCHA .EQ. 'VITE') THEN
        CVAL = DCMPLX(ZERO,DEPI*XABS(IABS))
        DO 200 IABS = 1,NBABS
          DO 201 JMOD = 1,NBMODE
            CETAP(JMOD,IABS) = CETA(JMOD,IABS)
            CETA2P(JMOD,IABS) = CVAL * CETAP(JMOD,IABS)
            CETA(JMOD,IABS) = -CVAL * CETAP(JMOD,IABS)
 201      CONTINUE
200     CONTINUE
      ENDIF
C
      IF (NOMCHA .EQ. 'ACCE') THEN
        CVAL = DCMPLX(ZERO,DEPI*XABS(IABS))
        DO 202 IABS = 1,NBABS
          DO 203 JMOD = 1,NBMODE
            CETA2P(JMOD,IABS) = CETA(JMOD,IABS)
            CETAP(JMOD,IABS) = -CVAL * CETA2P(JMOD,IABS)
            CETA(JMOD,IABS) = -CVAL * CETAP(JMOD,IABS)
 203      CONTINUE
202     CONTINUE
      ENDIF
C
C DESTRUCTION DES VECTEURS DE TRAVAIL

      CALL JEDETR (SECMB)
      CALL JEDETR (WKS)
      CALL JEDETR (PHIPHT)
      CALL JEDETR (PHITPH)
      CALL JEDETR (MATSYS)
      CALL JEDETR (WORK)
      CALL JEDETR (ETA)
      CALL JEDETR (VALS)
      CALL JEDETR (U)
      CALL JEDETR (V)

      CALL JEDEMA ()
      END
