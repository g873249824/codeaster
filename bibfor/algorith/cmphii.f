      SUBROUTINE CMPHII(CK,CM,NDIM,NBMOD,NITER,XCRIT,CEIGEN,CMOD,
     &NDIMAX,CMAT1,CMAT2,CVEC,IFIC)
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 03/07/2012   AUTEUR PELLET J.PELLET 
C TOLE CRS_1404
C ======================================================================
C COPYRIGHT (C) 1991 - 2012  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
      IMPLICIT NONE
C
C***********************************************************************
C    P. RICHARD                                 DATE 31/07/91
C-----------------------------------------------------------------------
C  BUT:  < COMPLEXE MODES PROBLEME HERMITIEN ITERATION INVERSE >
C
C   CALCULER LES PREMIERS MODES PROPRES D'UN PROBLEME
C       AUX VALEURS PROPRES A MATRICES RAIDEURS ET MASSE COMPLEXES
C       HERMITTIENNES STOCKEES TRIANGULAIRES SUPERIEURES
C
C                     CK*X= L CM*X
C
C    METHODE D'ITERATION INVERSE
C
C-----------------------------------------------------------------------
C
C CK       /I/: MATRICE RAIDEUR DU PROBLEME
C CM       /I/: MATRICE MASSE DU PROBLEME
C NDIM     /I/: DIMENSION DES MATRICES
C NBMOD    /I/: NOMBRE DE MODES PROPRES DESIRE
C NITER    /I/: NOMBRE MAX D'ITERATIONS PAR MODE
C XCRIT    /I/: TOLERANCE DE COLINEARITE RELATIVE (CRITERE CONVERGENCE)
C CEIGEN   /O/: VALEURS PROPRES COMPLEXES DU PROBLEME
C CMOD     /O/: MODES PROPRES COMPLEXES SOLUTIONS
C NDIMAX   /I/: NOMBRE DE DDL GENERALISES DES MODES >=NDIM
C CMAT1    /M/: MATRICE COMPLEXE DE TRAVAIL
C CMAT2    /M/: MATRICE COMPLEXE DE TRAVAIL
C CVEC     /M/: VECTEUR COMPLEXE DE TRAVAIL
C IFIC     /I/: NUMERO UNITE LOGIQUE POUR MESSAGE
C
C-----------------------------------------------------------------------
C
      INTEGER VALI
      COMPLEX*16 CK(*),CM(*),CEIGEN(NBMOD)
      COMPLEX*16 CMOD(NDIMAX,NBMOD),CPROD,CMOD0(NDIM)
      COMPLEX*16 CMAT1(*),CMAT2(NDIM,NDIM),CVEC(NDIM),CVEC0(NDIM)
      LOGICAL CONVOK
      INTEGER I ,IDIAG ,IFIC ,IPIVO ,IV ,IVDIAG ,J
      INTEGER K ,NBMOD ,NDIM ,NDIMAX ,NITER
      REAL*8 XCRIT ,XER
C-----------------------------------------------------------------------
C
      WRITE(IFIC,*)'     '
      WRITE(IFIC,*)'     '
      WRITE(IFIC,*)'     '
      WRITE(IFIC,*)'****************************************************
     &*******************'
      WRITE(IFIC,*)'               CALCUL MODAL PAR CMPHII'
      WRITE(IFIC,*)'         '
      WRITE(IFIC,1000)
C
C      RECOPIE DE LA MATRICE DE RAIDEUR
      CALL ZCOPY(NDIM*(NDIM+1)/2,CK,1,CMAT1,1)
C
C    FACTORISATION DE LA MATRICE DE RAIDEUR
      CALL TRLDC(CMAT1,NDIM,IPIVO)
C    GESTION DU PIVOT NUL
      IF(IPIVO.NE.0) THEN
        VALI = IPIVO
        CALL U2MESG('F', 'ALGORITH12_53',0,' ',1,VALI,0,0.D0)
      ENDIF
C
C
C   CALCUL DE L'INVERSE DE LA MATRICE DE MASSE
      DO 40 IV=1,NDIM
         IVDIAG = IV*(IV-1)/2+1
         DO 20 I=1,NDIM
            IF (I.LE.IV) THEN
               CMAT2(I,IV)=CM(IVDIAG+IV-I)
            ELSE
               IDIAG = I*(I-1)/2+1
               CMAT2(I,IV)=DCONJG(CM(IDIAG+I-IV))
            ENDIF
 20      CONTINUE
 40   CONTINUE
      CALL RRLDC(CMAT1,NDIM,CMAT2,NDIM)

      DO 66 IV=1,NDIM
        CVEC(IV)=DCMPLX(0.D0,0.D0)
        CVEC0(IV)=DCMPLX(0.D0,0.D0)
        CMOD0(IV)=DCMPLX(0.D0,0.D0)
 66   CONTINUE
C
C
C   INITIALISATION ALEATOIRE DES VECTEURS PROPRES DE DEPART
      CALL CVALEA(NDIM,CMOD,NDIMAX,NBMOD)
C
C
C     DEBUT DE LA BOUCLE D'ITERATION SUR LES MODES
C
      DO 50 J=1,NBMOD
C
C       INITIALISATION DES CRITERES D'ARRET
        K=0
        CONVOK=.TRUE.
C
C   BOUCLE D'ITERATION SUR CHAQUE MODES
 100    CONTINUE
C
        K=K+1
C
C    PRODUIT MATRICIEL INV(M)*VECTEUR
        CALL CMATVE(CMAT2,CMOD(1,J),CVEC,NDIM)
C
C    CALCUL DE L'ERREUR COLINEARITE ET REECOPIE
C    DE CVEC DANS CMOD
        CALL CTESCV(CVEC,CMOD(1,J),CVEC0,CMOD0,NDIM,XER)
C
C      RECOPIE DU VECTEUR DE L'ITERATION PRECEDENTE
        CALL ZCOPY(NDIM,CMOD(1,J),1,CMOD0,1)
        CALL ZCOPY(NDIM,CVEC,1,CVEC0,1)

C   ORTHORMALISATION PAR RAPPORT MATRICE DE MASSE
        CALL CSCHMI(CM,NDIM,CMOD(1,J),CMOD,NDIMAX,J-1)
C

C   CALCUL VALEURS PROPRES PAR COEF RAYLEIGH
C    En fait on calcul explicitement CMOD*inv(M)*K*CMOD
          CALL SESQUI(CK,CMOD(1,J),NDIM,CEIGEN(J))
          CALL SESQUI(CM,CMOD(1,J),NDIM,CPROD)
          CEIGEN(J)=CEIGEN(J)/CPROD
C
C         TEST SUR LA PRECISION
          IF(XER.LE.XCRIT) CONVOK=.FALSE.
C
      IF(K.LT.NITER.AND.CONVOK) GOTO 100
C
C
C     IMPRESSION DES FREQUENCES PROPRES
      WRITE(IFIC,1100) J,K,XER,DBLE(CEIGEN(J)),DIMAG(CEIGEN(J))
 1000 FORMAT('NUMERO       ', 'ITERATION         ',
     &       'ERREUR           ', 'VALEUR PROPRE')
 1100 FORMAT(I4,11X,I4,10X,1PD10.3,5X,'  (',1PD9.2,', ',1PD9.2,' )')
C
 50   CONTINUE
C
      WRITE(IFIC,*)'     '
      WRITE(IFIC,*)'     '
C
      END
