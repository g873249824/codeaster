      SUBROUTINE OP0079()

C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 19/03/2013   AUTEUR BRIE N.BRIE 
C ======================================================================
C COPYRIGHT (C) 1991 - 2013  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C
C  CALCUL PROJECTION SD_RESULTAT SUR BASE DE RITZ
C
C----------------------------------------------------------------------
C
      IMPLICIT NONE
C
C
C
C
      INCLUDE 'jeveux.h'

      INTEGER      JSMDE,NBMODE,NBO,II,IRET,NBSYM,IDBASE
      INTEGER      IDVEC1,IDVEC2
C-----------------------------------------------------------------------
      INTEGER IADREF ,IADRIF ,IADVEC ,IAMATR ,IARG ,IBID ,ICOD
      INTEGER IDDEEQ ,IDVECT ,ILIORD ,IMOD ,IND ,IORD ,ISYM
      INTEGER JMOD ,JREFA ,LLNEQU ,N0 ,N1 ,N2 ,N4
      INTEGER NBID ,NEQ
      REAL*8 BID ,EBID ,PIJ
C-----------------------------------------------------------------------
      PARAMETER    (NBSYM=3)
      CHARACTER*1  TYPVEC
      CHARACTER*8  NOMRES,BASEMO,NOMTYP,K8BID,RES,NUMGEN
      CHARACTER*9  NOSYIN(NBSYM)
      CHARACTER*4  NOSYOU(NBSYM), NOSY
      CHARACTER*14 NU,NUMDD1,NUMDD2
      CHARACTER*16 TYPRES,NOMCOM,TYPBAS,MATRI2
      CHARACTER*19 NOCHNO
      CHARACTER*24 MATRIC,KBID,DEEQ
      COMPLEX*16   CBID
      REAL*8       DDOT
      DATA  NOSYIN / 'DEPL','VITE','ACCE'/
      DATA  NOSYOU / 'DEPL','VITE','ACCE'/
C
C     ------------------------------------------------------------------
C     ------------------------------------------------------------------
C
C REMARQUE : ACTUELLEMENT, SEULS LES CHAMPS DEPL, VITE ET ACCE SONT
C TRAITES. IL CONVIENDRAIT NORMALEMENT DE TRAITER LES FORC_NODAL, MAIS
C POUR CELA, IL FAUT CREER UN CHAMP EQUIVALENT DANS LA SD_TRAN_GENE.
C OBJECTIF : POUVOIR DEFINIR UN CHARGEMENT GENERALISE POUR DTM AVEC UN
C TYPAGE CORRECT POUR LE CHARGEMENT. ACTUELLEMENT, LE CHARGEMENT
C APPLIQUE AVEC EXCIT_RESU EST UNE SD RESULTAT AVEC DES CHAMPS DEPL,
C DANS DYBNA_TRAN_MODAL ET DYNA_LINE_TRAN.

      CALL JEMARQ()
      CALL INFMAJ()
C
C --- RECUPERATION DES ARGUMENTS DE LA COMMANDE
C
      CALL GETRES(NOMRES,TYPRES,NOMCOM)
      CALL GETVID(' ','NUME_DDL_GENE',0,IARG,1,NUMGEN,N0)
      CALL GETVID(' ','RESU',0,IARG,1,RES,N1)
C LE CAS RESU_GENE N'EST PAS ACTIVE POUR LE MOMENT
C      CALL GETVID(' ','RESU_GENE',0,IARG,1,RES,N3)
      CALL GETVID(' ','BASE',0,IARG,1,BASEMO,N4)
      CALL GETVTX(' ','TYPE_VECT',0,IARG,1,NOMTYP,N2)
      CALL GETTCO(BASEMO,TYPBAS)
C
C --- RECUPERATION DU NB DE MODES
C
      CALL RSORAC(BASEMO,'LONUTI',IBID,BID,K8BID,CBID,EBID,'ABSOLU',
     &            NBMODE,1,NBID)
C
C
      CALL JEVEUO(NUMGEN//'      .SMOS.SMDE','L',JSMDE)

C
C --- RECUPERATION DU NOMBRE DE NUME_ORDRE DE LA SD_RESU
C
      CALL RSORAC(RES,'LONUTI',IBID,BID,K8BID,CBID,EBID,'ABSOLU',
     &            NBO,1,NBID)
      CALL JEVEUO(RES//'           .ORDR','L',ILIORD)


C --- VERIFICATION DE LA CONFORMITE DES NUMEROTATIONS
C     DES MODES ET DU VECTEUR ASSEMBLE
C     ON RECUPERE LES NUME_DDL DANS LES REFD DES DEUX SD
C     SI ELLES SONT ABSENTES, ON ESSAYE AVEC LES MATRICES

      CALL JEVEUO(RES//'           .REFD','L',IADREF)
      CALL JEVEUO(BASEMO//'           .REFD','L',IADRIF)

      IF (TYPBAS(1:9).EQ.'MODE_MECA') THEN
        NU=ZK24(IADREF+3)
        IF (NU(1:1).NE.' ') THEN
          NUMDD1=NU
        ELSE
          MATRIC = ZK24(IADREF)
          CALL EXISD('MATR_ASSE',MATRIC,IRET)
          IF (IRET.NE.0) THEN
            CALL DISMOI('F','NOM_NUME_DDL',MATRIC,'MATR_ASSE',IBID,
     &                  NU,IRET)
            NUMDD1=NU
          ENDIF
          IF (IRET.EQ.0) CALL U2MESK('F','ALGORITH17_8',1,RES)
        ENDIF
        NU=ZK24(IADRIF+3)
        IF (NU(1:1).NE.' ') THEN
          NUMDD2=NU
        ELSE
          MATRIC = ZK24(IADRIF)
          CALL EXISD('MATR_ASSE',MATRIC,IRET)
          IF (IRET.NE.0) THEN
            CALL DISMOI('F','NOM_NUME_DDL',MATRIC,'MATR_ASSE',IBID,
     &              NU,IRET)
            NUMDD2=NU
          ENDIF
          IF (IRET.EQ.0) CALL U2MESK('F','ALGORITH17_8',1,BASEMO)
        ENDIF

      ELSEIF (TYPBAS(1:9).EQ.'MODE_GENE') THEN
        NUMDD1=ZK24(IADREF+1)
        MATRIC = ZK24(IADRIF)
        MATRI2 = MATRIC(1:16)
        CALL JEVEUO(MATRI2//'   .REFA','L',JREFA)
        NUMDD2=ZK24(JREFA-1+2)
      ENDIF

      IF (NUMDD1.NE.NUMDD2) THEN
        CALL U2MESS('I','ALGORITH9_41')
      ENDIF
C
C --- RECUPERATION DU NOMBRE D'EQUATIONS DU SYSTEME PHYSIQUE
C
      IF ((TYPBAS(1:9).EQ.'MODE_MECA')) THEN
        CALL DISMOI('F','NB_EQUA',NUMDD1,'NUME_DDL',NEQ,KBID,IRET)
      ELSEIF (TYPBAS(1:9).EQ.'MODE_GENE') THEN
        CALL JEVEUO(NUMDD1//'.NUME.NEQU','L',LLNEQU)
        NEQ = ZI(LLNEQU)
      ENDIF

      DEEQ = NU//'.NUME.DEEQ'
      CALL JEVEUO(DEEQ,'L',IDDEEQ)
C
C --- INITIALISATION DE LA SD_RESULTAT
C
      CALL MDALL2(NOMRES,BASEMO,NUMGEN,RES,NBO,NBMODE)

C --- RECUPERE LA BASE MODALE SOUS LA FORME D'UN VECT NBMODE*NEQ
C
      CALL WKVECT('&&OP0072.BASEMO','V V R',NBMODE*NEQ,IDBASE)
      CALL COPMOD(BASEMO,'DEPL',NEQ,NU,NBMODE,'R',ZR(IDBASE),CBID)
C
C --- BOUCLE SUR LES NUM_ORDR ET LES NOMSY DE LA SD_RESULTAT
C     ATTENTION : ON NE TRAITE QUE LES NOMSY STOCKABLES DANS
C     UN TRAN_GENE : DEPL, ACCE, VITE

      DO 40 ISYM=1,NBSYM

        DO 50 IORD=1,NBO

          NOSY=NOSYOU(ISYM)

C --- RECUP DU CHAMP DE LA SDIN CORRESPONDANT AU NUME_ORDR ET ISYM
          CALL RSEXCH(' ',RES,NOSYIN(ISYM),ZI(ILIORD-1+IORD),NOCHNO,
     &                IRET)
          IF (IRET.NE.0) GOTO 40
          CALL JEVEUO(NOCHNO//'.VALE','L',IADVEC)
          CALL JEVEUO(NOCHNO//'.REFE','L',IADREF)
          CALL JEVEUO(BASEMO//'           .REFD','L',IADRIF)
          CALL JELIRA(NOCHNO//'.VALE','TYPE',IBID,TYPVEC)
C --- LE CAS COMPLEXE (SD HARMONIQUES) N'EST PAS TRAITE
          IF (TYPVEC.EQ.'C') THEN
            CALL U2MESS('F','ALGORITH17_19')
          ENDIF

C --- INDICE DE STOCKAGE
          CALL JEVEUO(NOMRES//'           .'//NOSY,'E',II)

          IF (NOMTYP(1:4).EQ.'FORC') THEN
C
C --- PROJECTION D UN VECTEUR DE TYPE FORCE
C
            CALL WKVECT('&&OP0079.VECTASSE','V V R',NEQ,IDVECT)
            DO 10 IMOD = 1,NBMODE

C
C --------- RECOPIE DU IEME MODE DANS UN VECTEUR TEMP
C
              CALL DCOPY(NEQ,ZR(IDBASE+(IMOD-1)*NEQ),1,ZR(IDVECT),1)
C
C ------- MISE A ZERO DES DDLS DE LAGRANGE
C
              CALL ZERLAG('R',ZR(IDVECT),CBID,NEQ,ZI(IDDEEQ))
C
C ------- PRODUIT SCALAIRE VECTASS * MODE
C
              IND = II-1+(IORD-1)*NBMODE+IMOD
              ZR(IND) = DDOT(NEQ,ZR(IDVECT),1,ZR(IADVEC),1)

C ------- LIBERATION DU VECTEUR TEMP
10          CONTINUE
            CALL JEDETR('&&OP0079.VECTASSE')
          ELSE
C
C --- PROJECTION D UN VECTEUR DE TYPE DEPL OU VITE
C
            CALL WKVECT('&&OP0079.VECTASS1','V V R',NEQ,IDVEC1)
            CALL WKVECT('&&OP0079.VECTASS2','V V R',NEQ,IDVEC2)
            CALL WKVECT('&&OP0079.MATRNORM','V V R',
     &                  NBMODE*NBMODE,IAMATR)

C ----- CALCUL DE TMODE*MODE
C
            DO 20 IMOD = 1,NBMODE
C
C ----- RECOPIE DU IEME MODE
C
              CALL DCOPY(NEQ,ZR(IDBASE+(IMOD-1)*NEQ),1,ZR(IDVEC1),1)
C
C ------- MISE A ZERO DES DDLS DE LAGRANGE
C
              CALL ZERLAG('R',ZR(IDVEC1),CBID,NEQ,ZI(IDDEEQ))
C
C-------- PRODUIT SCALAIRE MODE(IMOD)*MODE(JMOD)
C
              DO 20 JMOD = IMOD,NBMODE
C
C ------- RECOPIE DU JEME MODE
C
                CALL DCOPY(NEQ,ZR(IDBASE+(JMOD-1)*NEQ),1,ZR(IDVEC2),1)
C --------- MISE A ZERO DES DDLS DE LAGRANGE
C
                CALL ZERLAG('R',ZR(IDVEC2),CBID,NEQ,ZI(IDDEEQ))
C
C --------- PRODUIT SCALAIRE MODE(IMOD)*MODE(JMOD)
C
                PIJ = DDOT(NEQ,ZR(IDVEC1),1,ZR(IDVEC2),1)
                ZR(IAMATR+IMOD+ (JMOD-1)*NBMODE-1) = PIJ
                ZR(IAMATR+JMOD+ (IMOD-1)*NBMODE-1) = PIJ
20            CONTINUE
C
C ----- CALCUL DE LA PROJECTION
C
            DO 30 IMOD = 1,NBMODE
C
C ------- RECOPIE DU IEME MODE
C
              CALL DCOPY(NEQ,ZR(IDBASE+(IMOD-1)*NEQ),1,ZR(IDVEC1),1)
C
C ------- MISE A ZERO DES DDLS DE LAGRANGE
C
              CALL ZERLAG('R',ZR(IDVEC1),CBID,NEQ,ZI(IDDEEQ))
C
C ------- PRODUIT SCALAIRE VECTASS * MODE
C
              ZR(IDVEC2+IMOD-1) = DDOT(NEQ,ZR(IDVEC1),1,ZR(IADVEC),1)

30          CONTINUE
C
C ----- FACTORISATION ET RESOLUTION SYSTEME
C
            IND = II-1+(IORD-1)*NBMODE+IMOD
            CALL TRLDS(ZR(IAMATR),NBMODE,NBMODE,ICOD)
            IF (ICOD.NE.0) THEN
              CALL U2MESS('F','ALGORITH9_42')
            ENDIF
            CALL RRLDS(ZR(IAMATR),NBMODE,NBMODE,ZR(IDVEC2),1)
            CALL DCOPY(NBMODE,ZR(IDVEC2),1,ZR(IND),1)
            CALL JEDETR('&&OP0079.VECTASS1')
            CALL JEDETR('&&OP0079.VECTASS2')
            CALL JEDETR('&&OP0079.MATRNORM')
            IF (TYPVEC.EQ.'C') CALL JEDETR('&&OP0079.VECTASC2')
          ENDIF

50      CONTINUE
40    CONTINUE
C
      CALL JEDEMA()
      END
