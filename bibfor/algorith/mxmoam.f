      SUBROUTINE MXMOAM(SDDYNA,NBMODP)
C
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 09/11/2012   AUTEUR DELMAS J.DELMAS 
C ======================================================================
C COPYRIGHT (C) 1991 - 2012  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C RESPONSABLE ABBAS M.ABBAS
C
      IMPLICIT     NONE
      INCLUDE 'jeveux.h'

      CHARACTER*32 JEXNUM
      CHARACTER*19 SDDYNA
      INTEGER      NBMODP
C
C ----------------------------------------------------------------------
C
C ROUTINE MECA_NON_LINE (ALGORITHME - EXPLICITE)
C
C PROJECTION MODALE EN EXPLICITE
C
C ----------------------------------------------------------------------
C
C
C IN  SDDYNA : SD DEDIEE A LA DYNAMIQUE (CF NDLECT)
C OUT NBMODP : NOMBRE DE MODES DE PROJECTION
C
C
C
C
      INTEGER      NBMD,NBMG,NEQ,NBMAX,NBRG,NBAG
      INTEGER      NDYNIN,NBGENE
      INTEGER      IDDEEQ,JVAL
      INTEGER      JLIFGE,JFGE
      INTEGER      LDBLO,LDBLO1,LDBLO2
      INTEGER      IMODE,IFONC,IMODE2
      INTEGER      IRET,IBID,NF,LPAR,VALI(3)
      REAL*8       R8BID
      CHARACTER*8  K8BID
      CHARACTER*8  MODMEC,MAGENE,AMGENE,RIGENE
      CHARACTER*14 NUMDDL
      CHARACTER*19 FMODAL,VALFON
      INTEGER      JFMODA,JVALFO
      CHARACTER*19 DEPGEM,VITGEM,ACCGEM
      INTEGER      JDEPGM,JVITGM,JACCGM
      CHARACTER*19 DEPGEP,VITGEP,ACCGEP
      INTEGER      JDEPGP,JVITGP,JACCGP
      CHARACTER*19 BASMOD
      INTEGER      JBASMO
      CHARACTER*19 RIGGEN,MASGEN,AMOGEN,FONGEN,FORGEN
      INTEGER      JRIGGE,JMASGE,JAMOGE,JFONGE,JFORGE
      CHARACTER*19 ACCGCN
      INTEGER      JACCCN
      CHARACTER*24 DEEQ
      CHARACTER*24 NOMCHA
      INTEGER      IARG
C
C ----------------------------------------------------------------------
C
      CALL JEMARQ()
C
C --- NOM DES OBJETS POUR PROJECTION MODALE
C
      CALL NDYNKK(SDDYNA,'PRMO_DEPGEM',DEPGEM)
      CALL NDYNKK(SDDYNA,'PRMO_VITGEM',VITGEM)
      CALL NDYNKK(SDDYNA,'PRMO_ACCGEM',ACCGEM)
      CALL NDYNKK(SDDYNA,'PRMO_DEPGEP',DEPGEP)
      CALL NDYNKK(SDDYNA,'PRMO_VITGEP',VITGEP)
      CALL NDYNKK(SDDYNA,'PRMO_ACCGEP',ACCGEP)
      CALL NDYNKK(SDDYNA,'PRMO_BASMOD',BASMOD)
      CALL NDYNKK(SDDYNA,'PRMO_MASGEN',MASGEN)
      CALL NDYNKK(SDDYNA,'PRMO_AMOGEN',AMOGEN)
      CALL NDYNKK(SDDYNA,'PRMO_RIGGEN',RIGGEN)
      CALL NDYNKK(SDDYNA,'PRMO_FONGEN',FONGEN)
      CALL NDYNKK(SDDYNA,'PRMO_FORGEN',FORGEN)
      CALL NDYNKK(SDDYNA,'PRMO_ACCGCN',ACCGCN)
      CALL NDYNKK(SDDYNA,'PRMO_VALFON',VALFON)
      CALL NDYNKK(SDDYNA,'PRMO_FMODAL',FMODAL)
C
C --- MATRICE DES MODES MECA
C
      CALL GETVID('PROJ_MODAL','MODE_MECA',1,IARG,1,MODMEC,NBMD)
      IF (NBMD.EQ.0) THEN
        CALL ASSERT(.FALSE.)
      ENDIF
C
C --- MASSE, RIGIDITE ET AMORTISSEMENT GENERALISES
C
      CALL GETVID('PROJ_MODAL','MASS_GENE',1,IARG,1,MAGENE,NBMG  )
      CALL GETVID('PROJ_MODAL','RIGI_GENE',1,IARG,1,RIGENE,NBRG  )
      CALL GETVID('PROJ_MODAL','AMOR_GENE',1,IARG,1,AMGENE,NBAG  )
C
C --- IL FAUT MASS_GENE _ET_ RIGI_GENE (VOIR CAPY)
C
      IF ((NBMG.GT.0).AND.(NBRG.EQ.0)) THEN
        CALL ASSERT(.FALSE.)
      ENDIF
C
C --- INFORMATIONS SUR MATRICE DES MODES MECANIQUES
C
      CALL MGINFO(MODMEC,NUMDDL,NBMODP,NEQ   )
      DEEQ = NUMDDL//'.NUME.DEEQ'
      CALL JEVEUO(DEEQ,'L',IDDEEQ)
C
C --- NOMBRE DE MODES
C
      CALL GETVIS('PROJ_MODAL','NB_MODE',1,IARG,1,NBMAX,IBID  )
      IF (NBMAX.NE.NBMODP) THEN
        VALI(1) = NBMODP
        VALI(2) = NBMAX
        VALI(3) = MIN(NBMODP,NBMAX)
        CALL U2MESG('I','MECANONLINE5_29',0,K8BID,3,VALI,0,R8BID)
        NBMODP = MIN(NBMODP,NBMAX)
      ENDIF
C
C --- CREATION VECTEUR DES FORCES MODALES
C
      CALL WKVECT(FMODAL,'V V R',NBMODP,JFMODA)
C
C --- CREATION MASSES GENERALISEES
C
      CALL WKVECT(MASGEN,'V V R',NBMODP,JMASGE)
C
C --- CREATION BASE MODALE
C
      CALL WKVECT(BASMOD,'V V R',NBMODP*NEQ,JBASMO)
C
C --- SI MASS_GENE NON DONNE
C
      IF (NBMG.EQ.0) THEN
C
C ---   ON RECUPERE MODES DANS MODE_MECA
C
        DO 61 IMODE = 1,NBMODP
          CALL RSEXCH('F',MODMEC,'DEPL',IMODE,NOMCHA,IRET)
          CALL JEVEUO(NOMCHA(1:19)//'.VALE','L',JVAL)
          CALL DCOPY(NEQ,ZR(JVAL),1,ZR(JBASMO+(IMODE-1)*NEQ),1)
          CALL ZERLAG(ZR(JBASMO+(IMODE-1)*NEQ),NEQ,ZI(IDDEEQ))
 61     CONTINUE
C
C ---   ON RECUPERE MASSES GENERALISEES DANS MODE_MECA
C
        DO 10 IMODE = 1,NBMODP
          CALL RSADPA(MODMEC,'L',1,'MASS_GENE',IMODE,0,LPAR,K8BID)
          ZR(JMASGE+IMODE-1) = ZR(LPAR)
 10     CONTINUE
C
C --- CREATION ACCELERATION DE REFERENCE
C
        CALL WKVECT(ACCGCN,'V V R',NBMODP,JACCCN)
      ELSE
C
C --- CREATION DEPL/VITE/ACCE GENERALISES T- ET T+
C
        CALL WKVECT(ACCGEM,'V V R',NBMODP,JACCGM)
        CALL WKVECT(ACCGEP,'V V R',NBMODP,JACCGP)
        CALL WKVECT(VITGEM,'V V R',NBMODP,JVITGM)
        CALL WKVECT(VITGEP,'V V R',NBMODP,JVITGP)
        CALL WKVECT(DEPGEM,'V V R',NBMODP,JDEPGM)
        CALL WKVECT(DEPGEP,'V V R',NBMODP,JDEPGP)
C
C --- ON RECUPERE MODES DANS MODE_MECA
C
        DO 67 IMODE = 1,NBMODP
          CALL RSEXCH('F',MODMEC,'DEPL',IMODE,NOMCHA,IRET)
          CALL JEVEUO(NOMCHA(1:19)//'.VALE','L',JVAL)
          CALL DCOPY(NEQ,ZR(JVAL),1,ZR(JBASMO+(IMODE-1)*NEQ),1)
          CALL ZERLAG(ZR(JBASMO+(IMODE-1)*NEQ),NEQ,ZI(IDDEEQ))
 67     CONTINUE
C
C --- CREATION RIGIDITES GENERALISEES
C
        CALL WKVECT(RIGGEN,'V V R',NBMODP*NBMODP,JRIGGE)
C
C --- CREATION AMORTISSEMENTS GENERALISES
C
        CALL WKVECT(AMOGEN,'V V R',NBMODP*NBMODP,JAMOGE)
C
C --- CREATION FORCES/FONC_MULT GENERALISEES
C
        NBGENE = NDYNIN(SDDYNA,'NBRE_EXCIT_GENE')
        IF (NBGENE.NE.0) THEN
          CALL WKVECT(FONGEN,'V V K24',NBGENE,JFONGE)
          CALL WKVECT('&&MXMOAM.LIFOGE','V V K24',NBGENE,JLIFGE)
          CALL WKVECT(FORGEN,'V V R',NBGENE*NBMODP,JFORGE)
        ENDIF
C
C --- CREATION VECTEUR DE RESOLUTION FORCES
C
        IF (NBGENE.NE.0) THEN
          CALL WKVECT(VALFON,'V V R',NBGENE,JVALFO)
        ENDIF
C
C --- RECUPERATION MASSES GENERALISEES
C
        CALL JEVEUO(JEXNUM(MAGENE//'           .VALM',1),'L',LDBLO)
        DO 20 IMODE=1,NBMODP
          ZR(JMASGE+IMODE-1) = ZR(LDBLO+IMODE-1)
  20    CONTINUE
C
C --- RECUPERATION RIGIDITES GENERALISEES
C
        CALL JEVEUO(JEXNUM(RIGENE//'           .VALM',1),'L',LDBLO1)
        DO 30 IMODE = 1 , NBMODP
          DO 40 IMODE2 = 1 , IMODE
            ZR(JRIGGE+(IMODE-1)*NBMODP+IMODE2-1) =
     &                 ZR(LDBLO1+IMODE*(IMODE-1)/2+IMODE2-1)
            ZR(JRIGGE+(IMODE2-1)*NBMODP+IMODE-1) =
     &                 ZR(LDBLO1+IMODE*(IMODE-1)/2+IMODE2-1)
 40       CONTINUE
 30     CONTINUE
C
C --- RECUPERATION AMORTISSEMENTS GENERALISES
C
        CALL JEVEUO(JEXNUM(AMGENE//'           .VALM',1),'L',LDBLO2)
        DO 31 IMODE = 1 , NBMODP
          DO 41 IMODE2 = 1 , IMODE
            IF (NBAG.NE.0) THEN
              ZR(JAMOGE+(IMODE-1)*NBMODP+IMODE2-1) =
     &                   ZR(LDBLO2+IMODE*(IMODE-1)/2+IMODE2-1)
              ZR(JAMOGE+(IMODE2-1)*NBMODP+IMODE-1) =
     &                   ZR(LDBLO2+IMODE*(IMODE-1)/2+IMODE2-1)
            ENDIF
 41       CONTINUE
 31     CONTINUE
C
C --- RECUPERATION FORCES/FONC_MULT GENERALISEES
C
        IF (NBGENE.NE.0) THEN
          DO 11 IFONC = 1,NBGENE
            CALL GETVID('EXCIT_GENE','FONC_MULT',IFONC,IARG,1,
     &                  ZK24(JFONGE+IFONC-1),NF)
            CALL GETVID('EXCIT_GENE','VECT_GENE',IFONC,IARG,1,
     &                  ZK24(JLIFGE+IFONC-1),NF)
            CALL JEVEUO(ZK24(JLIFGE+IFONC-1)(1:19)//'.VALE','L',JFGE)
            DO 12 IMODE = 1,NBMODP
              ZR(JFORGE+(IFONC-1)*NBMODP+IMODE-1) = ZR(JFGE+IMODE-1)
 12         CONTINUE
 11       CONTINUE
        ENDIF
      ENDIF
C
C --- MENAGE
C
      CALL JEDETR('&&MXMOAM.LIFOGE')
      CALL JEDEMA()
      END
