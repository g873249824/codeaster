      SUBROUTINE MXMOAM(SDDYNA)
C
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 23/09/2008   AUTEUR ABBAS M.ABBAS 
C ======================================================================
C COPYRIGHT (C) 1991 - 2003  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C RESPONSABLE ABBAS M.ABBAS
C
      IMPLICIT     NONE
      CHARACTER*19 SDDYNA
C
C ----------------------------------------------------------------------
C
C ROUTINE MECA_NON_LINE (ALGORITHME - EXPLICITE)
C
C PROJECTION MODALE EN EXPLICITE
C
C ----------------------------------------------------------------------
C
C
C IN  SDDYNA : SD DEDIEE A LA DYNAMIQUE (CF NDLECT)
C
C -------------- DEBUT DECLARATIONS NORMALISEES  JEVEUX ----------------
C
      CHARACTER*32       JEXNUM
      INTEGER            ZI
      COMMON  / IVARJE / ZI(1)
      REAL*8             ZR
      COMMON  / RVARJE / ZR(1)
      COMPLEX*16         ZC
      COMMON  / CVARJE / ZC(1)
      LOGICAL            ZL
      COMMON  / LVARJE / ZL(1)
      CHARACTER*8        ZK8
      CHARACTER*16                ZK16
      CHARACTER*24                          ZK24
      CHARACTER*32                                    ZK32
      CHARACTER*80                                              ZK80
      COMMON  / KVARJE / ZK8(1) , ZK16(1) , ZK24(1) , ZK32(1) , ZK80(1)
C
C -------------- FIN  DECLARATIONS  NORMALISEES  JEVEUX ----------------
C
      INTEGER      NBMD,NBMG,NEQ,NBMODE,NBMAX,NBRG,NBAG,NFONC
      INTEGER      IDDEEQ,JVAL
      INTEGER      JLIFGE,JFGE
      INTEGER      LDBLO,LDBLO1,LDBLO2
      INTEGER      IMODE,IFONC,IMODE2
      INTEGER      IRET,NM,NF,LPAR
      CHARACTER*8  K8BID
      CHARACTER*8  MODMEC,MAGENE,AMGENE,RIGENE
      CHARACTER*14 NUMDDL
      CHARACTER*19 FMODAL,VALFON
      INTEGER      JFMODA,JVALFO
      CHARACTER*19 DEPGEM,VITGEM,ACCGEM
      INTEGER      JDEPGM,JVITGM,JACCGM
      CHARACTER*19 DEPGEP,VITGEP,ACCGEP
      INTEGER      JDEPGP,JVITGP,JACCGP  
      CHARACTER*19 BASMOD
      INTEGER      JBASMO
      CHARACTER*19 RIGGEN,MASGEN,AMOGEN,FONGEN,FORGEN
      INTEGER      JRIGGE,JMASGE,JAMOGE,JFONGE,JFORGE  
      CHARACTER*19 ACCGCN
      INTEGER      JACCCN  
      CHARACTER*24 DEEQ,SDPRMO, NDYNKK
      CHARACTER*24 NOMCHA
C
C ----------------------------------------------------------------------
C
      CALL JEMARQ()
C
C --- OBJETS PROJECTION MODALE
C
      SDPRMO = NDYNKK(SDDYNA,'PROJ_MODAL')
      DEPGEM = SDPRMO(1:14)//'.DGEM'
      VITGEM = SDPRMO(1:14)//'.VGEM'
      ACCGEM = SDPRMO(1:14)//'.AGEM' 
      DEPGEP = SDPRMO(1:14)//'.DGEP'
      VITGEP = SDPRMO(1:14)//'.VGEP'
      ACCGEP = SDPRMO(1:14)//'.AGEP'
      BASMOD = SDPRMO(1:14)//'.BASM'              
      MASGEN = SDPRMO(1:14)//'.MASG'   
      RIGGEN = SDPRMO(1:14)//'.RIGG'
      AMOGEN = SDPRMO(1:14)//'.AMOG' 
      FONGEN = SDPRMO(1:14)//'.FONG'     
      FORGEN = SDPRMO(1:14)//'.FORG'    
      ACCGCN = SDPRMO(1:14)//'.AGCN' 
C
C --- MATRICE DES MODES MECA
C
      CALL GETVID('PROJ_MODAL','MODE_MECA',1,1,1,MODMEC,NBMD) 
      IF (NBMD.EQ.0) THEN
        CALL ASSERT(.FALSE.)
      ENDIF 
C
C --- MASSE, RIGIDITE ET AMORTISSEMENT GENERALISES
C
      CALL GETVID('PROJ_MODAL','MASS_GENE',1,1,1,MAGENE,NBMG)      
      CALL GETVID('PROJ_MODAL','RIGI_GENE',1,1,1,RIGENE,NBRG)
      CALL GETVID('PROJ_MODAL','AMOR_GENE',1,1,1,AMGENE,NBAG)
      IF ((NBMG.GT.0).AND.(NBRG.EQ.0)) THEN
        CALL ASSERT(.FALSE.)
      ENDIF       
C
C --- INFORMATIONS SUR MATRICE DES MODES MECANIQUES
C
      CALL MGINFO(MODMEC,NUMDDL,NBMODE,NEQ   )
      DEEQ = NUMDDL//'.NUME.DEEQ'
      CALL JEVEUO(DEEQ,'L',IDDEEQ)
C
C --- NOMBRE DE MODES
C
      CALL GETVIS('PROJ_MODAL','NB_MODE',1,1,1,NBMAX,NM)
      NBMODE = MIN(NBMODE,NBMAX)
C
C --- CREATION VECTEUR DES FORCES MODALES
C        
      FMODAL = SDPRMO(1:14)//'.FMOD'
      CALL WKVECT(FMODAL,'V V R',NBMODE,JFMODA)      
C
C --- CREATION MASSES GENERALISEES   
C     
      CALL WKVECT(MASGEN,'V V R',NBMODE,JMASGE)       
C
C --- CREATION BASE MODALE
C
      CALL WKVECT(BASMOD,'V V R',NBMODE*NEQ,JBASMO)       
C
C --- SI MASS_GENE NON DONNE  
C     
      IF (NBMG.EQ.0) THEN
C
C ---   ON RECUPERE MODES DANS MODE_MECA 
C        
        DO 61 IMODE = 1,NBMODE
          CALL RSEXCH(MODMEC,'DEPL',IMODE,NOMCHA,IRET)
          CALL JEVEUO(NOMCHA(1:19)//'.VALE','L',JVAL)
          CALL DCOPY(NEQ,ZR(JVAL),1,ZR(JBASMO+(IMODE-1)*NEQ),1)
          CALL ZERLAG(ZR(JBASMO+(IMODE-1)*NEQ),NEQ,ZI(IDDEEQ))
 61     CONTINUE  
C
C ---   ON RECUPERE MASSES GENERALISEES DANS MODE_MECA 
C  
        DO 10 IMODE = 1,NBMODE
          CALL RSADPA(MODMEC,'L',1,'MASS_GENE',IMODE,0,LPAR,K8BID)
          ZR(JMASGE+IMODE-1) = ZR(LPAR)
 10     CONTINUE
C
C --- CREATION ACCELERATION DE REFERENCE
C
        CALL WKVECT(ACCGCN,'V V R',NBMODE,JACCCN) 
C
C ---   ON SORT...
C       
        GOTO 9999   
      ENDIF 
C
C --- CREATION DEPL/VITE/ACCE GENERALISES T- ET T+
C        
      CALL WKVECT(ACCGEM,'V V R',NBMODE,JACCGM)
      CALL WKVECT(ACCGEP,'V V R',NBMODE,JACCGP)
      CALL WKVECT(VITGEM,'V V R',NBMODE,JVITGM)
      CALL WKVECT(VITGEP,'V V R',NBMODE,JVITGP)
      CALL WKVECT(DEPGEM,'V V R',NBMODE,JDEPGM)
      CALL WKVECT(DEPGEP,'V V R',NBMODE,JDEPGP)              
C
C --- CREATION RIGIDITES GENERALISEES   
C                            
      CALL WKVECT(RIGGEN,'V V R',NBMODE*NBMODE,JRIGGE)
C
C --- CREATION AMORTISSEMENTS GENERALISES   
C      
      CALL WKVECT(AMOGEN,'V V R',NBMODE*NBMODE,JAMOGE)    
C
C --- CREATION FORCES/FONC_MULT GENERALISEES
C        
      CALL GETFAC('EXCIT_GENE',NFONC)
      IF (NFONC.NE.0) THEN
        CALL WKVECT(FONGEN,'V V K24',NFONC,JFONGE)
        CALL WKVECT('&&MXMOAM.LIFOGE','V V K24',NFONC,JLIFGE)
        CALL WKVECT(FORGEN,'V V R',NFONC*NBMODE,JFORGE)
      ENDIF
C
C --- CREATION VECTEUR DE RESOLUTION FORCES 
C        
      IF (NFONC.NE.0) THEN
        VALFON = SDDYNA(1:15)//'.VFC'
        CALL WKVECT(VALFON,'V V R',NFONC,JVALFO)
      ENDIF      
C
C --- RECUPERATION MASSES GENERALISEES   
C     
      CALL JEVEUO(JEXNUM(MAGENE//'           .VALM',1),'L',LDBLO)
      DO 20 IMODE=1,NBMODE
        ZR(JMASGE+IMODE-1) = ZR(LDBLO+IMODE-1)
  20  CONTINUE      
C
C --- RECUERATION RIGIDITES GENERALISEES   
C                         
      CALL JEVEUO(JEXNUM(RIGENE//'           .VALM',1),'L',LDBLO1)
      DO 30 IMODE = 1 , NBMODE
        DO 40 IMODE2 = 1 , IMODE
          ZR(JRIGGE+(IMODE-1)*NBMODE+IMODE2-1) =
     &               ZR(LDBLO1+IMODE*(IMODE-1)/2+IMODE2-1)
          ZR(JRIGGE+(IMODE2-1)*NBMODE+IMODE-1) =
     &               ZR(LDBLO1+IMODE*(IMODE-1)/2+IMODE2-1)
 40     CONTINUE
 30   CONTINUE   
C
C --- RECUERATION AMORTISSEMENTS GENERALISES   
C                         
      CALL JEVEUO(JEXNUM(AMGENE//'           .VALM',1),'L',LDBLO2)
      DO 31 IMODE = 1 , NBMODE
        DO 41 IMODE2 = 1 , IMODE
          IF (NBAG.NE.0) THEN
            ZR(JAMOGE+(IMODE-1)*NBMODE+IMODE2-1) =
     &                 ZR(LDBLO2+IMODE*(IMODE-1)/2+IMODE2-1)
            ZR(JAMOGE+(IMODE2-1)*NBMODE+IMODE-1) = 
     &                 ZR(LDBLO2+IMODE*(IMODE-1)/2+IMODE2-1)
          ENDIF
 41     CONTINUE
 31   CONTINUE          
C
C --- RECUPERATION FORCES/FONC_MULT GENERALISEES
C        
      IF (NFONC.NE.0) THEN
        DO 11 IFONC = 1,NFONC
          CALL GETVID('EXCIT_GENE','FONC_MULT',IFONC,1,1,
     &                ZK24(JFONGE+IFONC-1),NF)
          CALL GETVID('EXCIT_GENE','VECT_GENE',IFONC,1,1,
     &                ZK24(JLIFGE+IFONC-1),NF)
          CALL JEVEUO(ZK24(JLIFGE+IFONC-1)(1:19)//'.VALE','L',JFGE)
          DO 12 IMODE = 1,NBMODE
            ZR(JFORGE+(IFONC-1)*NBMODE+IMODE-1) = ZR(JFGE+IMODE-1)
 12       CONTINUE
 11     CONTINUE
      ENDIF  
C
C --- MENAGE
C
      CALL JEDETR('&&MXMOAM.LIFOGE')
C
 9999 CONTINUE
      CALL JEDEMA()
      END
