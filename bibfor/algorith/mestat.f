      SUBROUTINE MESTAT ( MODELZ, FOMULZ, LISCHZ,
     &                    MATE,   CARAZ,
     &                    LTPSZ,  SOLVEZ,
     &                    NBPASE, INPSCO  )
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 11/09/2002   AUTEUR VABHHTS J.PELLET 
C ======================================================================
C COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C TOLE CRP_20
C ----------------------------------------------------------------------
C     BUT:  FAIRE UN CALCUL DE MECANIQUE STATIQUE : K(T)*U = F(T)
C           POUR LES DIFFERENTS INSTANTS "T" DE LTPS.
C     IN: MODELZ : NOM D'1 MODELE
C         FOMULZ : LISTE DES FONCTIONS MULTIPLICATRICES
C         LISCHZ : INFORMATION SUR LES CHARGEMENTS
C         MATE   : NOM DU MATERIAU
C         CARAZ  : NOM D'1 CARAC_ELEM
C         LTPSZ  : LISTE DES INSTANTS DE CALCUL
C         SOLVEZ : METHODE DE RESOLUTION 'LDLT' OU 'GCPC'
C         NBPASE : NOMBRE DE PARAMETRES SENSIBLES
C         INPSCO : SD CONTENANT LA LISTE DES NOMS POUR LA SENSIBILITE
C
C     OUT: L'EVOL_ELAS  EST REMPLI (POUR SA PARTIE 'DEPL')
C ----------------------------------------------------------------------
C
      IMPLICIT NONE
C
C 0.1. ==> ARGUMENTS
C
      INTEGER      NBPASE
C
      CHARACTER*(*) MODELZ, FOMULZ, LISCHZ
      CHARACTER*(*) MATE, CARAZ, LTPSZ, SOLVEZ
      CHARACTER*(*) INPSCO
      CHARACTER*19  LISCHA, SOLVEU
      CHARACTER*8   LTPS
C
C 0.2. ==> COMMUNS
C
C     ----- DEBUT COMMUNS NORMALISES  JEVEUX  --------------------------
      INTEGER ZI
      COMMON /IVARJE/ZI(1)
      REAL*8 ZR
      COMMON /RVARJE/ZR(1)
      COMPLEX*16 ZC
      COMMON /CVARJE/ZC(1)
      LOGICAL ZL
      COMMON /LVARJE/ZL(1)
      CHARACTER*8 ZK8
      CHARACTER*16 ZK16
      CHARACTER*24 ZK24
      CHARACTER*32 ZK32
      CHARACTER*80 ZK80
      COMMON /KVARJE/ZK8(1),ZK16(1),ZK24(1),ZK32(1),ZK80(1)
C     -----  FIN  COMMUNS NORMALISES  JEVEUX  --------------------------
C
C 0.3. ==> VARIABLES LOCALES
C
      CHARACTER*6 NOMPRO
      PARAMETER ( NOMPRO = 'MESTAT' )
C
      INTEGER JCHAR, JINF, NCHAR, NBVAL, IBID, IERD, ICHAR
      INTEGER JVAL, ITPS, ITPS0
      INTEGER IRET, IAUX
      INTEGER NRPASE, NRORES
C
      REAL*8 TIME
      REAL*8 TPS1(4), TPS2(4), TPS3(4), TCPU, PARTPS(3)
C
      CHARACTER*1 BASE
      CHARACTER*8  K8BID, REPK,RESULT
      CHARACTER*8  NOMODE, NOMA
      CHARACTER*14 NUPOSS
      CHARACTER*16 K16BID
      CHARACTER*19 MATASS
      CHARACTER*19 MAPREC
      CHARACTER*19 VECASS
      CHARACTER*24 NUMEDD
      CHARACTER*24 CHNUMC
      CHARACTER*24 CHARGE, INFOCH, CRITER
      CHARACTER*24 MODELE, CARELE, FOMULT
C
      LOGICAL MATCST, ASSMAT
C
C DEB-------------------------------------------------------------------
C====
C 1. PREALABLES
C====
C
      CALL JEMARQ()
C
C 1.1. ==> LES ARGUMENTS
C
      SOLVEU = SOLVEZ
      MODELE = MODELZ
      CARELE   = CARAZ
      FOMULT = FOMULZ
      LISCHA = LISCHZ
      LTPS   = LTPSZ
C
C 1.2. ==> LES CONSTANTES
C
C               12   345678   90123456789
      VECASS = '&&'//NOMPRO//'.2NDMBR_ASS'
      MAPREC = '&&'//NOMPRO//'_MAT_PRECON'
      MATASS = '&&'//NOMPRO//'_MATR_ASSEM'
C
      PARTPS(2) = 0.D0
      PARTPS(3) = 0.D0
      NOMODE = MODELE(1:8)
      BASE   = 'V'
      CRITER = '&&RESGRA_GCPC'
C
      CHARGE = LISCHA//'.LCHA'
      INFOCH = LISCHA//'.INFC'
C
      CALL JEVEUO(CHARGE,'L',JCHAR)
      CALL JEVEUO(INFOCH,'L',JINF)
      NCHAR = ZI(JINF)
      CALL DISMOI('F','NOM_MAILLA',NOMODE,'MODELE',IBID,NOMA,IRET)
      CALL MECHNC (NOMA,' ',0,CHNUMC)
C
C 1.3. ==> ALLOCATION DES RESULTATS
C
      CALL JELIRA(LTPS//'           .VALE','LONMAX',NBVAL,K8BID)
      CALL UTCRRE ( NBPASE, INPSCO, NBVAL )
C
C 1.4. ==> ON REGARDE SI LE MATERIAU EST UNE FONCTION DU TEMPS
C     (DEPENDANCE AVEC LA TEMPERATURE)
C
      MATCST = .TRUE.
      CALL DISMOI('F','ELAS_F_TEMP',MATE,'CHAM_MATER',IBID,REPK,IERD)
      IF ( REPK .EQ. 'OUI' ) THEN
        DO 11,ICHAR = 1,NCHAR
          CALL DISMOI('F','EXI_TEMPER',ZK24(JCHAR-1+ICHAR)(1:8),
     &                'CHARGE',IBID,K8BID,IERD)
          IF (K8BID(1:4).EQ.'EVOL') THEN
            MATCST = .FALSE.
            GOTO 13
          ENDIF
   11   CONTINUE
      ENDIF
   13 CONTINUE
C
C --- ON REGARDE SI LE MATERIAU EST UNE FONCTION DU TEMPS
C     (DEPENDANCE AVEC L HYDRATATION)
C
      CALL DISMOI('F','ELAS_F_HYDR',MATE,'CHAM_MATER',IBID,REPK,IERD)
      IF ( REPK .EQ. 'OUI' ) THEN
        DO 21,ICHAR = 1,NCHAR
          CALL DISMOI('F','EXI_HYDRAT',ZK24(JCHAR-1+ICHAR)(1:8),
     &                'CHARGE',IBID,K8BID,IERD)
          IF (K8BID(1:4).EQ.'EVOL') THEN
            MATCST = .FALSE.
            GOTO 23
          ENDIF
   21   CONTINUE
      ENDIF
   23 CONTINUE
C
C --- ON REGARDE SI LE MATERIAU EST UNE FONCTION DU TEMPS
C     (DEPENDANCE AVEC LE SECHAGE)
C
      CALL DISMOI('F','ELAS_F_SECH',MATE,'CHAM_MATER',IBID,REPK,IERD)
      IF ( REPK .EQ. 'OUI' ) THEN
        DO 31,ICHAR = 1,NCHAR
          CALL DISMOI('F','EXI_SECHAG',ZK24(JCHAR-1+ICHAR)(1:8),
     &                'CHARGE',IBID,K8BID,IERD)
          IF (K8BID(1:4).EQ.'EVOL') THEN
            MATCST = .FALSE.
            GOTO 33
          ENDIF
   31   CONTINUE
      ENDIF
   33 CONTINUE
C
C 2.2. ==> NUMEROTATION ET CREATION DU PROFIL DE LA MATRICE
C
      NUMEDD=  '12345678.NUMED'
      CALL GCNCON ( '_',NUMEDD(1:8) )

      CALL GETRES (RESULT,K16BID,K16BID)
      CALL RSNUME(RESULT,'DEPL',NUPOSS)
      CALL NUMERO ( NUPOSS,MODELE,LISCHA,SOLVEU,'VG',NUMEDD )
C
      CALL VTCREB ( VECASS, NUMEDD, 'V', 'R', IAUX )
C
C     ??? IL SERAIT PEUT ETRE BON DE VERIFIER QUE QUELQUE CHOSE BOUGE
C     AVEC LE TEMPS. POUR L'INSTANT ON RECALCULE LE 2EME MEMBRE A CHA
C     QUE FOIS.
C
      CALL UTTCPU(1, 'INIT', 4, TPS1)
      CALL UTTCPU(2, 'INIT', 4, TPS2)
      CALL UTTCPU(3, 'INIT', 4, TPS3)
C
      CALL JEVEUO(LTPS//'           .VALE','L',JVAL)
C
C====
C 2. BOUCLE 2 SUR LES PAS DE TEMPS
C====
C
      DO 2 , ITPS = 1 , NBVAL
C
C 2.1. ==> L'INSTANT
C
        ITPS0 = ITPS
        TIME = ZR(JVAL-1+ITPS)
        PARTPS(1) = TIME
C
C 2.2. ==> BOUCLE 22 SUR LES RESOLUTIONS
C          LE PREMIER PASSAGE, 0, EST CELUI DU CALCUL STANDARD
C          LES PASSAGES SUIVANTS SONT CEUX DES DERIVATIONS
C
        DO 22 , NRORES = 0 , NBPASE
C
          NRPASE = NRORES
C
C 2.2.1. ==> Y-A-T'IL ASSEMBLAGE DES MATRICES ?
C
          IF ( NRORES.EQ.0 ) THEN
C
            IF ( .NOT.MATCST .OR. ITPS.EQ.1 ) THEN
              ASSMAT = .TRUE.
            ELSE
              ASSMAT = .FALSE.
            ENDIF
          ELSE
            ASSMAT = .FALSE.
          ENDIF
C
C 2.2.2. ==> RESOLUTION NUMERO NRPASE
C
          CALL MERESO ( NRPASE, NBPASE, INPSCO,
     >                  MODELE, MATE, CARELE, FOMULT, LISCHA,
     >                  ITPS0, PARTPS,
     >                  NUMEDD, VECASS,
     >                  ASSMAT, SOLVEU, MATASS, MAPREC,
     >                  BASE, TPS1, TPS2, TPS3 )
C
   22   CONTINUE
C
C 2.3. ==> CONTROLE DU TEMPS CPU
C
        IF ( .NOT.MATCST .OR. ITPS.EQ.1 ) THEN
          TCPU = TPS1(4) + TPS2(4) + TPS3(4)
        ELSE
          TCPU = TPS3(4)
        ENDIF
        IF ( NBVAL .GT. 1    .AND.
     >       ITPS .LT. NBVAL .AND.
     >       TCPU .GT. .95D0*TPS3(1)  ) THEN
          CALL UTDEBM('S',NOMPRO, 'ARRET PAR MANQUE DE TEMPS CPU')
          CALL UTIMPI('S',' AU PAS DE TEMPS : ',1,ITPS)
          CALL UTIMPR('S',' A L''INSTANT : ',1,TIME)
          CALL UTIMPR('L',' TEMPS MOYEN PAR PAS : ',1,TCPU)
          CALL UTIMPR('L',' TEMPS CPU RESTANT : ',1,TPS3(1))
          CALL UTFINM()
          GOTO 9999
        ENDIF
C
    2 CONTINUE
C
C        -- MENAGE DES OBJETS PROVISOIRES:
 9999 CONTINUE
C
      CALL DETRSD ( 'CHAMP_GD',  VECASS )
      CALL DETRSD ( 'MATR_ASSE', MATASS )
C
      CALL JEEXIN (CRITER(1:19)//'.CRTI',IRET)
      IF ( IRET .NE. 0 ) THEN
         CALL JEDETR ( CRITER(1:19)//'.CRTI' )
         CALL JEDETR ( CRITER(1:19)//'.CRTR' )
         CALL JEDETR ( CRITER(1:19)//'.CRDE' )
      ENDIF
C
      CALL JEDEMA()
C
      END
