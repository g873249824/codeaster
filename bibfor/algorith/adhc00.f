      SUBROUTINE ADHC00 ( NBOPT, TABENT, TABREE, TABCAR, LGCAR )
C
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 22/07/2003   AUTEUR G8BHHXD X.DESROCHES 
C ======================================================================
C COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
C (AT YOUR OPTION) ANY LATER VERSION.                                 
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
C    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
C ======================================================================
C RESPONSABLE GNICOLAS G.NICOLAS
C-----------------------------------------------------------------------
C TOLE CRP_20
C-----------------------------------------------------------------------
C      ADAPTATION PAR HOMARD - DECODAGE DE LA COMMANDE - PHASE 00
C      --             -                       -                --
C      DECODAGE DES OPTIONS
C-----------------------------------------------------------------------
C
      IMPLICIT NONE
C
C 0.1. ==> ARGUMENTS
C
      INTEGER NBOPT
      INTEGER TABENT(NBOPT), LGCAR(NBOPT)
C
      REAL*8 TABREE(NBOPT)
C
      CHARACTER*(*) TABCAR(NBOPT)
C
C 0.2. ==> COMMUNS
C
C --- DEBUT DECLARATIONS NORMALISEES JEVEUX ----------------------------
      INTEGER      ZI
      COMMON /IVARJE/ZI(1)
      CHARACTER*8 ZK8
      CHARACTER*16 ZK16
      CHARACTER*24 ZK24
      CHARACTER*32 ZK32
      CHARACTER*80 ZK80
      COMMON /KVARJE/ZK8(1),ZK16(1),ZK24(1),ZK32(1),ZK80(1)
C --- FIN DECLARATIONS NORMALISEES JEVEUX ------------------------------
C
C 0.3. ==> VARIABLES LOCALES
C
      CHARACTER*6 NOMPRO
      PARAMETER ( NOMPRO = 'ADHC00' )
C
      INTEGER NBMCF
      PARAMETER ( NBMCF = 2 )
C
      INTEGER LXLGUT
      INTEGER IUNIFI
C
      INTEGER CODRET
      INTEGER IAUX, JAUX, IOCC
      INTEGER IER
      INTEGER IFM, NIVINF
      INTEGER ADTRAV
      INTEGER NBGRMA
      INTEGER NUFICO, NUFIDO
      INTEGER MODHOM, TYPRAF, TYPDER
      INTEGER TYPCRR, TYPCRD
      INTEGER NIVMIN, NIVMAX
      INTEGER BILNBR, BILQUA, BILINT, BILCXT, BILTAI
      INTEGER CVSOLU
      INTEGER NITER
      INTEGER NUMPT, NUMORD
      INTEGER NOSMPX
      INTEGER LGSN, LGSNP1
      INTEGER LCN, LCNP1
      INTEGER LOMN, LOMNP1
      INTEGER LMMN, LMMNP1
      INTEGER LHMN, LHMNP1
      INTEGER LLISTE
      INTEGER LNMMN, LNMMN1
      INTEGER LNMDIN
      INTEGER LNMDFR
      INTEGER LNCPIN
      INTEGER LLANGU
C
      REAL*8 CRITDE, CRITRA
      REAL*8 INST
      REAL*8 PREC
C
      CHARACTER*2 SUFN, SUFNP1
      CHARACTER*8 OMN, OMNP1
      CHARACTER*8 CRN
      CHARACTER*8 NCPIN
      CHARACTER*8 CRIT
      CHARACTER*8 SAUX08
      CHARACTER*16 CN, CNP1
      CHARACTER*16 CHINME
      CHARACTER*16 MCLF(NBMCF)
      CHARACTER*16 SAUX16
      CHARACTER*24 NTRAVA
      CHARACTER*24 LIGRMA
      CHARACTER*32 NMDMN, NMDMN1
      CHARACTER*32 NMDIN
      CHARACTER*32 NMDFR
      CHARACTER*72 FMMN, FMMNP1
      CHARACTER*72 FHMN, FHMNP1
      CHARACTER*72 FLISTE
      CHARACTER*72 REP
      CHARACTER*128 LANGUE
C
C====
C 1. PREALABLES
C====
C
      CODRET = 0
C
C 1.1. ==>  MOTS-CLES FACTEURS DE LA COMMANDE
C
C                1234567890123456
      MCLF(1) = 'TRAITEMENT      '
      MCLF(2) = 'ANALYSE         '
C
C 1.2. ==> L'INFO
C
      CALL INFNIV ( IFM, NIVINF )
C
C 1.3. ==> VALEURS PAR DEFAUT
C
      NITER = 0
      CVSOLU = 0
      LNMMN = 0
      LNMMN1 = 0
      LNMDIN = 0
      LNMDFR = 0
      TYPCRR = -1
      TYPCRD = -1
      NIVMAX = -1
      NIVMIN = -1
      LNCPIN = 0
      NBGRMA = 0
C
      CRITRA = 0.D0
      CRITDE = 0.D0
C
C====
C 2. LE MODE OPERATOIRE
C====
C
      CALL GETFAC ( MCLF(1), IOCC )
C
      IF ( IOCC.NE.0 ) THEN
C
      CALL GETVTX ( MCLF(1), 'ADAPTATION' , 1,1,1, REP, IAUX )
      IF ( IAUX.EQ.0 ) THEN
        CALL GETVTX ( MCLF(1), 'UNIFORME', 1,1,1, REP, IAUX )
        IF ( IAUX.EQ.0 ) THEN
          CALL GETVTX ( MCLF(1), 'INFORMATION', 1,1,1, REP, IAUX )
          IF ( IAUX.EQ.0 ) THEN
            CODRET = CODRET + 1
C
C 2.1. ==> INFORMATION
C
          ELSE
            MODHOM = 2
          ENDIF
C
C 2.2. ==> ADAPTATION UNIFORME
C
        ELSE
          MODHOM = 1
          IF ( REP.EQ.'RAFFINEMENT' ) THEN
            TYPRAF = -1
            TYPDER = 0
          ELSEIF ( REP.EQ.'DERAFFINEMENT' ) THEN
            TYPRAF = 0
            TYPDER = -1
          ELSEIF ( REP.EQ.'RIEN' ) THEN
            TYPRAF = 0
            TYPDER = 0
          ENDIF
        ENDIF
C
C 2.3. ==> ADAPTATION LIBRE
C
      ELSE
        MODHOM = 1
        IF ( REP.EQ.'RAFF_DERA' ) THEN
          TYPRAF = 1
          TYPDER = 1
        ELSEIF ( REP.EQ.'RAFFINEMENT' ) THEN
          TYPRAF = 1
          TYPDER = 0
        ELSEIF ( REP.EQ.'DERAFFINEMENT' ) THEN
          TYPRAF = 0
          TYPDER = 1
        ENDIF
      ENDIF
C
      ELSE
C
        CODRET = CODRET + 1
C
      ENDIF
C
C====
C 3. LES INFORMATIONS GENERALES
C====
C
C 3.1. ==> LANGUE DES MESSAGES DE HOMARD
C
      CALL GETVTX ( ' ', 'LANGUE', 1,1,1, LANGUE, IAUX )
      LLANGU = LXLGUT(LANGUE)
C
C 3.2. ==> LES FICHIERS LOCAUX ET LES NUMEROS D'UNITE LOGIQUE
C 3.2.1. ==> FICHIER DE CONFIGURATION
C
      CALL GETVTX ( ' ', 'FICHIER_CONF', 1,1,1, SAUX16, IAUX )
      NUFICO = IUNIFI(SAUX16)
C
C 3.2.2. ==> FICHIER DE DONNEES
C
      IF ( MODHOM.NE.1 ) THEN
C
        CALL GETVTX ( ' ', 'FICHIER_DONN', 1,1,1, SAUX16, IAUX )
        NUFIDO = IUNIFI(SAUX16)
C
      ENDIF
C
C====
C 4. POUR UNE ADAPTATION LIBRE, LES CARACTERISTIQUES DE L'INDICATEUR
C====
C
      IF ( MODHOM.EQ.1 ) THEN
C
      IF ( TYPRAF.GT.0 .OR. TYPDER.GT.0 ) THEN
C
C 4.1. ==> NOM MED DU CHAMP
C
        CALL GETVTX ( MCLF(1), 'NOM_MED' , 1,1,1, NMDIN, IAUX )
C
        LNMDIN = LXLGUT(NMDIN)
C
C 4.2. ==> NOM DE LA COMPOSANTE
C
        CALL GETVTX ( MCLF(1), 'COMPOSANTE' , 1,1,1, NCPIN, IAUX )
C
        LNCPIN = LXLGUT(NCPIN)
C
C 4.3. ==> NUMERO D'ORDRE
C
        CALL GETVIS ( MCLF(1), 'NUME_ORDRE', 1,1,1, NUMORD, IAUX )
C
C 4.3.1. ==> SANS NUMERO D'ORDRE, ON CHERCHE SI UN INSTANT EST PRESENT
C
        IF ( IAUX.EQ.0 ) THEN
C
C 4.3.1.1. ==> PREPARATION
C
C                   12   345678   9012345678901234
          NTRAVA = '&&'//NOMPRO//'.LISTE_NUMO     '
C
          CALL GETVID ( MCLF(1), 'RESULTAT' , 1,1,1, CRN, IAUX )
C
          CALL GETVR8 ( MCLF(1), 'INST', 1,1,1, INST, IAUX )
C
C 4.3.1.2. ==> AVEC UN INSTANT, ON CHERCHE LE NUMERO D'ORDRE ASSOCIE
C
          IF ( IAUX.NE.0 ) THEN
C
            CALL GETVR8 ( MCLF(1), 'PRECISION', 1,1,1, PREC, IAUX )
            CALL GETVTX ( MCLF(1), 'CRITERE'  , 1,1,1, CRIT, IAUX )
            CALL RSUTNU ( CRN, MCLF(1), 1, NTRAVA, JAUX,
     >                    PREC, CRIT, IER )
C
C 4.3.1.3. ==> SANS NUMERO D'ORDRE NI INSTANT, ON CHERCHE CE QUI EST
C              PRESENT DANS LA STRUCTURE ; ON PRENDRA LE SEUL QUI
C              EXISTE
C
          ELSE
C
            CALL GETVTX ( MCLF(1), 'NOM_CHAM' , 1,1,1,
     >                    CHINME, IAUX )
C
            CALL RSCHOR ( CRN, CHINME, JAUX, NTRAVA, IER )
C
          ENDIF
C
C 4.3.1.4. ==> RECUPERATION DU NUMERO D'ORDRE
C
          IF ( IER.EQ.0 ) THEN
            IF ( JAUX.EQ.1 ) THEN
              CALL JEVEUO ( NTRAVA, 'L', ADTRAV )
              NUMORD = ZI(ADTRAV)
            ELSE
              CALL UTMESS ( 'E', NOMPRO,
     >  'QUEL NUMERO D''ORDRE CHOISIR POUR L''INDICATEUR D''ERREUR ? ('
     > //CRN//','//CHINME//')' )
              CODRET = CODRET + 1
            ENDIF
          ELSE
            CALL UTMESS ( 'E', NOMPRO, 'PROBLEME DE DECODAGE.' )
            CODRET = CODRET + 1
          ENDIF
          CALL JEDETR(NTRAVA)
C
        ENDIF
C
      ENDIF
C
C 4.4. ==> LE NUMERO DE PAS DE TEMPS EST IDENTIFIE AU D'ORDRE
C
      NUMPT = NUMORD
CGN         PRINT *,'================== NUMORD : ', NUMORD
C
      ENDIF
C
C====
C 5. SI ADAPTATION LIBRE, LES CRITERES
C====
C
      IF ( MODHOM.EQ.1 ) THEN
C
C 5.1. ==> CRITERE POUR LE RAFFINEMENT LIBRE
C
      IF ( TYPRAF.GT.0 ) THEN
C
        CALL GETVR8 ( MCLF(1), 'CRIT_RAFF_ABS', 1,1,1, CRITRA, IAUX)
C
        IF ( IAUX.EQ.0 ) THEN
          CALL GETVR8 ( MCLF(1), 'CRIT_RAFF_REL', 1,1,1, CRITRA, IAUX)
C
          IF ( IAUX.EQ.0 ) THEN
            CALL GETVR8 ( MCLF(1), 'CRIT_RAFF_PE', 1,1,1, CRITRA, IAUX)
C
            IF ( IAUX.EQ.0 ) THEN
              CALL UTMESS ( 'E', NOMPRO,
     >                      'IL FAUT LE CRITERE DE RAFFINEMENT')
              CODRET = CODRET + 1
            ELSE
              TYPCRR = 3
            ENDIF
          ELSE
            TYPCRR = 2
          ENDIF
C
        ELSE
          TYPCRR = 1
        ENDIF
C
      ENDIF
C
C 5.2. ==> CRITERE POUR LE DERAFFINEMENT LIBRE
C
      IF ( TYPDER.GT.0 ) THEN
C
        CALL GETVR8 ( MCLF(1), 'CRIT_DERA_ABS', 1,1,1, CRITDE, IAUX)
C
        IF ( IAUX.EQ.0 ) THEN
          CALL GETVR8 ( MCLF(1), 'CRIT_DERA_REL', 1,1,1, CRITDE, IAUX)
C
          IF ( IAUX.EQ.0 ) THEN
            CALL GETVR8 ( MCLF(1), 'CRIT_DERA_PE', 1,1,1, CRITDE, IAUX)
C
            IF ( IAUX.EQ.0 ) THEN
              CALL UTMESS ( 'E', NOMPRO,
     >                      'IL FAUT LE CRITERE DE DERAFFINEMENT' )
              CODRET = CODRET + 1
            ELSE
              TYPCRD = 3
            ENDIF
C
          ELSE
            TYPCRD = 2
          ENDIF
C
        ELSE
          TYPCRD = 1
        ENDIF
C
      ENDIF
C
      ENDIF
C
C====
C 6. SI ADAPTATION, LES NIVEAUX EXTREMES
C====
C
      IF ( MODHOM.EQ.1 ) THEN
C
C 6.1. ==> NIVEAU MAXIMUM POUR LE RAFFINEMENT
C
      IF ( TYPRAF.NE.0 ) THEN
C
        CALL GETVIS ( MCLF(1), 'NIVE_MAX', 1,1,1, NIVMAX, IAUX )
C
        IF ( IAUX.NE.0 ) THEN
          IF ( NIVMAX.LE.0 ) THEN
            CALL UTMESS ( 'E', NOMPRO,
     >      'LE NIVEAU MAXIMUM DOIT ETRE STRICTEMENT POSITIF.' )
            CODRET = CODRET + 1
          ENDIF
        ENDIF
C
      ENDIF
C
C 6.2. ==> NIVEAU MINIMUM POUR LE DERAFFINEMENT
C
      IF ( TYPDER.NE.0 ) THEN
C
        CALL GETVIS ( MCLF(1), 'NIVE_MIN', 1,1,1, NIVMIN, IAUX )
C
        IF ( IAUX.NE.0 ) THEN
          IF ( NIVMIN.LT.0 ) THEN
            CALL UTMESS ( 'E', NOMPRO,
     >      'LE NIVEAU MINIMUM DOIT ETRE POSITIF.' )
            CODRET = CODRET + 1
          ENDIF
        ENDIF
C
      ENDIF
C
C 6.3. ==> COHERENCE
C
      IF ( TYPRAF.NE.0 .AND. TYPDER.NE.0 ) THEN
C
        IF ( NIVMAX.LT.NIVMIN ) THEN
          CALL UTMESS ( 'E', NOMPRO,
     >    'LE NIVEAU MAXIMUM DOIT ETRE > AU NIVEAU MINIMUM.')
          CODRET = CODRET + 1
        ENDIF
C
      ENDIF
C
      ENDIF
C
C====
C 7. POUR UNE ADAPTATION, CONVERSION DE SOLUTION ?
C====
C
      IF ( MODHOM.EQ.1 ) THEN
C
        CALL GETVTX ( MCLF(1), 'MAJ_CHAM' , 1,1,1, REP, IAUX )
C
        IF ( IAUX.NE.0 ) THEN
          IF ( REP(1:3).EQ.'OUI' ) THEN
            CVSOLU = 1
          ELSEIF ( REP(1:3).EQ.'NON' ) THEN
            CVSOLU = 0
          ENDIF
        ELSE
          CVSOLU = 0
        ENDIF
C
      ENDIF
C
C====
C 8. SUIVI DE FRONTIERE ?
C====
C
C 8.1. ==> SUIT-ON LA FRONTIERE ?
C
      CALL GETVTX ( MCLF(1), 'NOM_MED_MAILLAGE_FRONTIERE' , 1,1,1,
     >              NMDFR, IAUX )
C
C 8.2. ==> SI OUI, EST-CE SELON DES GROUPES DE MAILLES ?
C
      IF ( IAUX.NE.0 ) THEN
C
        LNMDFR = LXLGUT(NMDFR)
C
        CALL GETVID ( MCLF(1), 'GROUP_MA', 1,1,1, SAUX08, IAUX )
C
        IF ( IAUX.EQ.0 ) THEN
C
          NBGRMA = 0
C
        ELSE
          NBGRMA = ABS(IAUX)
C                   12   345678   9012345678901234
          LIGRMA = '&&'//NOMPRO//'.LIST_GRMA      '
          CALL WKVECT ( LIGRMA, 'V V K8', NBGRMA, JAUX )
          CALL GETVID ( MCLF(1), 'GROUP_MA', 1,1,NBGRMA,
     >                  ZK8(JAUX), IAUX )
        ENDIF
C
      ENDIF
C
C====
C 9. QUE FAIRE DES NON SIMPLEXES ?
C====
C
      CALL GETVIS ( ' ', 'NON_SIMPLEXE' , 1,1,1, NOSMPX, IAUX )
C
C====
C 10. SI PAS DE L'INFORMATION : NUMERO DE L'ITERATION
C====
C
      IF ( MODHOM.NE.2 ) THEN
C
        CALL GETVIS ( MCLF(1), 'NITER' , 1,1,1, NITER, IAUX )
C
        IF ( IAUX.EQ.0 ) THEN
          CODRET = CODRET + 1
        ENDIF
C
      ENDIF
C
C====
C 11. L'ANALYSE
C====
C
      CALL GETFAC ( MCLF(2), IOCC )
C
      IF ( IOCC.NE.0 ) THEN
C
C 11.1. CONTROLE DES NOMBRES D'ENTITES
C
        CALL GETVTX ( MCLF(2), 'NOMBRE' , 1,1,1, REP, IAUX )
        IF ( IAUX.NE.0 ) THEN
          IF ( REP(1:3).EQ.'OUI' ) THEN
            BILNBR = 1
          ELSEIF ( REP(1:3).EQ.'NON' ) THEN
            BILNBR = 0
          ENDIF
        ELSE
          BILNBR = 0
        ENDIF
C
C 11.2. ==> QUALITE DU MAILLAGE
C
        CALL GETVTX ( MCLF(2), 'QUALITE' , 1,1,1, REP, IAUX )
        IF ( IAUX.NE.0 ) THEN
          IF ( REP(1:3).EQ.'OUI' ) THEN
            BILQUA = 1
          ELSEIF ( REP(1:3).EQ.'NON' ) THEN
            BILQUA = 0
          ENDIF
        ELSE
          BILQUA = 0
        ENDIF
C
C 11.3. CONTROLE DE LA CONNEXITE DU MAILLAGE
C
        CALL GETVTX ( MCLF(2), 'CONNEXITE' , 1,1,1, REP, IAUX )
        IF ( IAUX.NE.0 ) THEN
          IF ( REP(1:3).EQ.'OUI' ) THEN
            BILCXT = 1
          ELSEIF ( REP(1:3).EQ.'NON' ) THEN
            BILCXT = 0
          ENDIF
        ELSE
          BILCXT = 0
        ENDIF
C
C 11.4. TAILLE DES SOUS-DOMAINES
C
        CALL GETVTX ( MCLF(2), 'TAILLE' , 1,1,1, REP, IAUX )
        IF ( IAUX.NE.0 ) THEN
          IF ( REP(1:3).EQ.'OUI' ) THEN
            BILTAI = 1
          ELSEIF ( REP(1:3).EQ.'NON' ) THEN
            BILTAI = 0
          ENDIF
        ELSE
          BILTAI = 0
        ENDIF
C
C 11.5. CONTROLE DE LA NON-INTERPENETRATION DES ELEMENTS
C
        CALL GETVTX ( MCLF(2), 'INTERPENETRATION' , 1,1,1, REP, IAUX )
        IF ( IAUX.NE.0 ) THEN
          IF ( REP(1:3).EQ.'OUI' ) THEN
            BILINT = 1
          ELSEIF ( REP(1:3).EQ.'NON' ) THEN
            BILINT = 0
          ENDIF
        ELSE
          BILINT = 0
        ENDIF
C
      ELSE
C
        BILNBR = 1
        BILQUA = 0
        BILINT = 0
        BILCXT = 0
        BILTAI = 0
C
      ENDIF
C
C====
C 12. LES NOMS MED DES MAILLAGES
C     REMARQUE : ON NE LE FAIT QU'ICI CAR ON NE CONNAIT TOUTES LES
C                DIFFERENTES OPTIONS QUE MAINTENANT
C====
C
C 12.1. ==> MAILLAGE D'ENTREE :
C            . SI INFORMATION
C            . SI ADAPTATION LIBRE
C            . SI ADAPTATION ET ITERATION = 0
C            . SI ADAPTATION ET MAJ DE SOLUTION
C
      IF ( MODHOM.EQ.2 .OR.
     >     ( MODHOM.EQ.1 .AND. ( TYPRAF.EQ.1 .OR. TYPDER.EQ.1 ) ) .OR.
     >     ( MODHOM.EQ.1 .AND. NITER.EQ.0 ) .OR.
     >     ( MODHOM.EQ.1 .AND. CVSOLU.NE.0 ) ) THEN
C
        CALL GETVTX ( MCLF(1), 'NOM_MED_MAILLAGE_N' , 1,1,1,
     >                NMDMN, IAUX )
C
        LNMMN = LXLGUT(NMDMN)
C
      ENDIF
C
C 12.2. ==> MAILLAGE DE SORTIE : SI ADAPTATION
C
      IF ( MODHOM.EQ.1 ) THEN
C
        CALL GETVTX ( MCLF(1), 'NOM_MED_MAILLAGE_NP1' , 1,1,1,
     >                NMDMN1, IAUX )
C
        LNMMN1 = LXLGUT(NMDMN1)
C
      ENDIF
C
C====
C 13. LES NOMS DES FICHIERS
C====
C 13.1. ==> SUFFIXES EN FONCTION DU NUMERO DE L'ITERATION
C
      CALL CODENT ( NITER, 'G', SUFN )
      LGSN = LXLGUT(SUFN)
C
      CALL CODENT ( NITER+1, 'G', SUFNP1 )
      LGSNP1 = LXLGUT(SUFNP1)
C
      CN(1:LGSN) = SUFN(1:LGSN)
      LCN = LGSN + 4
      CN(LGSN+1:LCN) = '.MED'
C
      CNP1(1:LGSNP1) = SUFNP1(1:LGSNP1)
      LCNP1 = LGSNP1 + 4
      CNP1(LGSNP1+1:LCNP1) = '.MED'
C
C 13.2. ==> LA LISTE DE SORTIE
C
      FLISTE(1:6) = 'LISTE.'
      IAUX = 6 + LGSN
      FLISTE(7:IAUX) = SUFN(1:LGSN)
      IF ( MODHOM.EQ.1 ) THEN
        FLISTE(IAUX+1:IAUX+6) = '.VERS.'
        LLISTE = IAUX+6+LGSNP1
        FLISTE(IAUX+7:LLISTE) = SUFNP1(1:LGSNP1)
      ELSEIF ( MODHOM.EQ.2 ) THEN
        LLISTE = IAUX+5
        FLISTE(IAUX+1:LLISTE) = '.INFO'
      ELSE
        FLISTE(IAUX+1:IAUX+6) = '.MJSO.'
        LLISTE = IAUX+6+LGSNP1
        FLISTE(IAUX+7:LLISTE) = SUFNP1(1:LGSNP1)
      ENDIF
C
C 13.3. ==> LES FICHIERS ET LES OBJETS
C          OMN    : OBJET MAILLAGE HOMARD A L'ITERATION N
C          OMNP1  : OBJET MAILLAGE HOMARD A L'ITERATION N+1
C          LOMN OU LOMNP1 : LONGUEUR DU NOM DE L'OBJET MAILLAGE HOMARD
C          FMMN   : FICHIER MED A L'ITERATION N
C          FHMN   : FICHIER HOMARD A L'ITERATION N
C          FMMNP1 : FICHIER MED A L'ITERATION N+1
C          FHMNP1 : FICHIER HOMARD A L'ITERATION N+1
C          LYMN OU LYMNP1 : LONGUEUR DU NOM DU FICHIER DE TYPE Y
C          REMARQUE : ON DETERMINE TOUS LES NOMS ET ON FILTRERA AU
C                     MOMENT DE L'ARCHIVAGE
C
      FMMN(1:6) = 'MAILL.'
      FMMN(7:6+LCN) = CN(1:LCN)
      LMMN = LCN + 6
      LHMN= LMMN
      FHMN = FMMN
      FHMN(LHMN-2:LHMN) = 'HOM'
C
      OMN(1:3) = 'MAI'
      OMN(4:3+LGSN) = SUFN(1:LGSN)
      LOMN = LGSN + 3
C
      FMMNP1(1:6) = 'MAILL.'
      FMMNP1(7:6+LCNP1) = CNP1(1:LCNP1)
      LMMNP1 = LCNP1 + 6
      LHMNP1= LMMNP1
      FHMNP1 = FMMNP1
      FHMNP1(LHMNP1-2:LHMNP1) = 'HOM'
C
      OMNP1(1:3) = 'MAI'
      OMNP1(4:3+LGSNP1) = SUFNP1(1:LGSNP1)
      LOMNP1 = LGSNP1 + 3
C
C====
C 14. STOCKAGE DES ARGUMENTS
C====
C
C 14.1. ==> ENTIERS
C
      TABENT(1) = NUFICO
      TABENT(2) = MODHOM
      TABENT(3) = NITER
      TABENT(4) = TYPRAF
      TABENT(5) = TYPDER
      TABENT(6) = TYPCRR
      TABENT(7) = TYPCRD
      TABENT(8) = CVSOLU
      TABENT(9) = NBGRMA
      TABENT(10) = NOSMPX
      TABENT(11) = NIVMAX
      TABENT(12) = NIVMIN
      TABENT(15) = NUMPT
      TABENT(16) = NUMORD
      TABENT(30) = NIVINF
      TABENT(31) = BILNBR
      TABENT(32) = BILQUA
      TABENT(33) = BILCXT
      TABENT(34) = BILTAI
      TABENT(35) = BILINT
      TABENT(40) = NUFIDO
C
C 14.2. ==> CARACTERES
C
      LGCAR(1) = LLISTE
      TABCAR(1)(1:LLISTE) = FLISTE(1:LLISTE)
C
      LGCAR(6) = LNCPIN
      IF ( LNCPIN.GT.0 ) THEN
        TABCAR(6)(1:LNCPIN) = NCPIN(1:LNCPIN)
      ENDIF
C
      LGCAR(11) = LMMN
      TABCAR(11)(1:LMMN) = FMMN(1:LMMN)
C
      IF ( MODHOM.EQ.1 ) THEN
        LGCAR(12) = LMMNP1
        TABCAR(12)(1:LMMNP1) = FMMNP1(1:LMMNP1)
      ELSE
        LGCAR(12) = 0
      ENDIF
C
      LGCAR(19) = LHMN
      TABCAR(19)(1:LHMN) = FHMN(1:LHMN)
C
      LGCAR(21) = LOMN
      TABCAR(21)(1:LOMN) = OMN(1:LOMN)
C
      IF ( MODHOM.NE.2 ) THEN
        LGCAR(20) = LHMNP1
        TABCAR(20)(1:LHMNP1) = FHMNP1(1:LHMNP1)
        LGCAR(22) = LOMNP1
        TABCAR(22)(1:LOMNP1) = OMNP1(1:LOMNP1)
      ELSE
        LGCAR(20) = 0
        LGCAR(22) = 0
        LGCAR(24) = 0
      ENDIF
C
      LGCAR(31) = LNMMN
      IF ( LNMMN.GT.0 ) THEN
        TABCAR(31)(1:LNMMN) = NMDMN(1:LNMMN)
      ENDIF
C
      LGCAR(32) = LNMMN1
      IF ( LNMMN1.GT.0 ) THEN
        TABCAR(32)(1:LNMMN1) = NMDMN1(1:LNMMN1)
      ENDIF
C
      LGCAR(33) = LNMDIN
      IF ( LNMDIN.GT.0 ) THEN
        TABCAR(33)(1:LNMDIN) = NMDIN(1:LNMDIN)
      ENDIF
C
      LGCAR(34) = LNMDFR
      IF ( LNMDFR.GT.0 ) THEN
        TABCAR(34)(1:LNMDFR) = NMDFR(1:LNMDFR)
      ENDIF
C
      LGCAR(38) = LLANGU
      IF ( LLANGU.GT.0 ) THEN
        TABCAR(38)(1:LLANGU) = LANGUE(1:LLANGU)
      ENDIF
C
      IF ( NBGRMA.GT.0 ) THEN
        LGCAR(39) = 24
        TABCAR(39)(1:24) = LIGRMA
      ENDIF
C
C 14.3. ==> REELS
C
      TABREE(1) = CRITRA
      TABREE(2) = CRITDE
C
C====
C 15. ARRET SI PROBLEME
C====
C
      IF ( CODRET .GT. 0 ) THEN
        CALL UTMESS ('F',NOMPRO,'ERREURS CONSTATEES')
      ENDIF
C
      END
