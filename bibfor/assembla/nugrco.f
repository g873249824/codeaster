      SUBROUTINE NUGRCO(NU,BASE)
      IMPLICIT NONE
      INCLUDE 'jeveux.h'
      CHARACTER*14 NU
      CHARACTER*2  BASE
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ASSEMBLA  DATE 18/12/2012   AUTEUR SELLENET N.SELLENET 
C ======================================================================
C COPYRIGHT (C) 1991 - 2012  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
C (AT YOUR OPTION) ANY LATER VERSION.                                   
C                                                                       
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
C                                                                       
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.         
C ======================================================================
C RESPONSABLE SELLENET N.SELLENET
C ----------------------------------------------------------------------
C  NUME_DDL - CREATION DU GRAPH DE COMMUNICATION
C  --                     --       --
C ----------------------------------------------------------------------
C
C   ON CREE LE GRAPH DE COMMUNICATION QUI PERMETTRA DANS LES
C    ROUTINES PETSC DE SAVOIR QUEL PROCESSEUR DOIT COMMUNIQUER
C    AVEC QUEL AUTRE
C
C IN  :
C   NU      K14  NOM DU NUME_DDL
C   BASE    K2   BASE(1:1) : BASE POUR CREER LE NUME_DDL
C                    (SAUF LE PROF_CHNO)
C                BASE(2:2) : BASE POUR CREER LE PROF_CHNO
C
      INTEGER      RANG,NBPROC,JPDDL,JCOMM1,IDDL,JNEQUL,NEQL,JGRACO
      INTEGER      IPROC,NBEDGE,IAUX,JMASQU,JTMP,NMATCH,IPROC1
      INTEGER      IPROC2,POSIT,JORDJO,NUM,JNEQUG,NEQG,JNUGL,NULODD
      INTEGER      JPOSPR,NBDDLJ,JJOINT,CURPOS,NUMPRO,JJOIN2,JNULG
      INTEGER      IDDLG,IDDLL
C
      INTEGER*4    IBID4
C
      REAL*8       RBID
      PARAMETER    (RBID=0.D0)
C
      CHARACTER*4  CHNBJO
      CHARACTER*24 NOJOIN,NOGRCO
      PARAMETER    (NOGRCO='&&NUGRCO.GRAPH_COMM')
C
      CALL JEMARQ()
C
      CALL MPICM0(RANG,NBPROC)
C
      CALL JEVEUO(NU//'.NUML.NUGL','L',JNUGL)
      CALL JEVEUO(NU//'.NUML.NULG','L',JNULG)
      CALL JEVEUO(NU//'.NUML.PDDL','L',JPDDL)
      CALL JEVEUO(NU//'.NUML.NEQU','L',JNEQUL)
      CALL JEVEUO(NU//'.NUME.NEQU','L',JNEQUG)
      NEQL=ZI(JNEQUL)
      NEQG=ZI(JNEQUG)
      CALL WKVECT('&&NUGRCO.COMM1','V V I',NBPROC,JCOMM1)
C
C---- DETERMINATION DE QUI COMMUNIQUE AVEC QUI
      DO 10 IDDL=0,NEQL-1
        NUMPRO=ZI(JPDDL+IDDL)
        CALL ASSERT(NUMPRO.LT.NBPROC)
        ZI(JCOMM1+NUMPRO)=ZI(JCOMM1+NUMPRO)+1
   10 CONTINUE
      ZI(JCOMM1+RANG)=0
C
      CALL WKVECT(NOGRCO,'V V I',NBPROC*NBPROC,JGRACO)
      DO 20 IPROC=0,NBPROC-1
        IF ( ZI(JCOMM1+IPROC).NE.0 ) THEN
          ZI(JGRACO+IPROC+RANG*NBPROC)=1
          ZI(JGRACO+RANG+IPROC*NBPROC)=1
        ENDIF
   20 CONTINUE
      CALL MPICM2('MPI_SUM',NOGRCO)
C
C---- RECHERCHE DES COUPLAGES DANS LE GRAPH
      NBEDGE=0
      DO 50, IAUX = 1,NBPROC*NBPROC
        IF( ZI(JGRACO+IAUX-1).EQ.1 ) NBEDGE=NBEDGE+1
   50 CONTINUE
      NBEDGE=NBEDGE/2
C
C---- RECHERCHE DES COUPLAGES MAXIMAUX
      CALL WKVECT('&&NUGRCO.MASQUE','V V I',
     &            NBPROC*NBPROC,JMASQU)
      CALL WKVECT('&&NUGRCO.TMP','V V I',
     &            NBPROC,JTMP)
      NMATCH=1
   60 CONTINUE
      DO 30, IPROC1 = 0,NBPROC-1
        DO 40, IPROC2 = 0,NBPROC-1
          POSIT=IPROC1*NBPROC+IPROC2
          IF( ZI(JGRACO+POSIT).EQ.1.AND.
     &        ZI(JTMP+IPROC1).EQ.0.AND.
     &        ZI(JTMP+IPROC2).EQ.0 ) THEN
            ZI(JGRACO+POSIT)=0
            ZI(JMASQU+POSIT)=NMATCH
            POSIT=IPROC2*NBPROC+IPROC1
            ZI(JGRACO+POSIT)=0
            ZI(JMASQU+POSIT)=NMATCH
            NBEDGE=NBEDGE-1
            ZI(JTMP+IPROC1)=1
            ZI(JTMP+IPROC2)=1
          ENDIF
   40    CONTINUE
   30 CONTINUE
      NMATCH=NMATCH+1
      DO 70, IAUX = 0,NBPROC-1
        ZI(JTMP+IAUX)=0
   70 CONTINUE
      IF ( NBEDGE.GT.0 ) GOTO 60
      CALL JEDETR('&&NUGRCO.TMP')
C
C---- CREATION DU GRAPH
      NMATCH=NMATCH-1
      CALL WKVECT(NU//'.NUML.JOIN',BASE(1:1)//' V I',NMATCH,JORDJO)
      CALL WKVECT('&&NUGRCO.POSPROC','V V I',2*NBPROC,JPOSPR)
      DO 80, IAUX = 0,NMATCH-1
        ZI(JORDJO+IAUX)=-1
   80 CONTINUE
      DO 90, IAUX = 0,NBPROC-1
        NUM=ZI(JMASQU+RANG*NBPROC+IAUX)
        CALL ASSERT(NUM.LE.NMATCH)
        IF ( NUM.NE.0 ) THEN
          ZI(JORDJO+NUM-1)=IAUX
C
          CALL CODENT(NUM,'G',CHNBJO)
          NOJOIN=NU//'.NUML.'//CHNBJO
          NBDDLJ=ZI(JCOMM1+IAUX)
          IF ( NBDDLJ.NE.0 ) THEN
            CALL WKVECT(NOJOIN,BASE(1:1)//' V I',NBDDLJ,JJOINT)
            ZI(JPOSPR+2*IAUX)=JJOINT
            ZI(JPOSPR+2*IAUX+1)=0
          ELSE
            ZI(JPOSPR+2*IAUX)=-1
            ZI(JPOSPR+2*IAUX+1)=-1
          ENDIF
        ELSE
          ZI(JPOSPR+2*IAUX)=-1
          ZI(JPOSPR+2*IAUX+1)=-1
        ENDIF
   90 CONTINUE
C
      DO 100, IDDL=0,NEQG-1
        NULODD=ZI(JNUGL+IDDL)
        IF ( NULODD.NE.0 ) THEN
          NUMPRO=ZI(JPDDL+NULODD-1)
          IF ( NUMPRO.NE.RANG ) THEN
            JJOINT=ZI(JPOSPR+2*NUMPRO)
            CALL ASSERT(JJOINT.NE.-1)
C
            CURPOS=ZI(JPOSPR+2*NUMPRO+1)
            ZI(JJOINT+CURPOS)=NULODD
            ZI(JPOSPR+2*NUMPRO+1)=ZI(JPOSPR+2*NUMPRO+1)+1
          ENDIF
        ENDIF
  100 CONTINUE
C
      DO 110, IAUX=0,NMATCH-1
        NUMPRO=ZI(JORDJO+IAUX)
        IF ( NUMPRO.EQ.-1 ) GOTO 110
C
        IF ( RANG.GT.NUMPRO ) THEN
          NBDDLJ=ZI(JPOSPR+2*NUMPRO+1)
          CALL MPIPPV('MPI_SEND','I',1,NBDDLJ,IBID4,RBID,NUMPRO,IAUX)
C
          JJOINT=ZI(JPOSPR+2*NUMPRO)
          CALL WKVECT('&&NUGRCO.TMP','V V I',NBDDLJ,JJOIN2)
          DO 120, IDDL=0,NBDDLJ-1
            IDDLG=ZI(JNULG+ZI(JJOINT+IDDL)-1)
            CALL ASSERT(IDDLG.NE.0)
            ZI(JJOIN2+IDDL)=IDDLG
  120     CONTINUE
C
          CALL MPIPPV('MPI_SEND','I',NBDDLJ,ZI(JJOIN2),
     &                IBID4,RBID,NUMPRO,IAUX)
          CALL JEDETR('&&NUGRCO.TMP')
        ELSEIF ( RANG.LT.NUMPRO ) THEN
          CALL MPIPPV('MPI_RECV','I',1,NBDDLJ,IBID4,RBID,NUMPRO,IAUX)
          CALL WKVECT('&&NUGRCO.TMP','V V I',NBDDLJ,JJOIN2)
C
          NUM=IAUX+1
          CALL CODENT(NUM,'G',CHNBJO)
          NOJOIN=NU//'.NUML.'//CHNBJO
          CALL WKVECT(NOJOIN,BASE(1:1)//' V I',NBDDLJ,JJOINT)
C
          CALL MPIPPV('MPI_RECV','I',NBDDLJ,ZI(JJOIN2),
     &                IBID4,RBID,NUMPRO,IAUX)
          DO 130, IDDL=0,NBDDLJ-1
            IDDLL=ZI(JNUGL+ZI(JJOIN2+IDDL)-1)
            CALL ASSERT(IDDLL.NE.0)
            ZI(JJOINT+IDDL)=IDDLL
  130     CONTINUE
          CALL JEDETR('&&NUGRCO.TMP')
        ELSE
          CALL ASSERT(.FALSE.)
        ENDIF
  110 CONTINUE
C
      CALL JEDETR('&&NUGRCO.COMM1')
      CALL JEDETR(NOGRCO)
      CALL JEDETR('&&NUGRCO.MASQUE')
      CALL JEDETR('&&NUGRCO.POSPROC')
C
      CALL JEDEMA()
C
      END
