      SUBROUTINE SH8MEK(XETEMP,SIGMA,RE)
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ELEMENTS  DATE 13/06/2012   AUTEUR COURTOIS M.COURTOIS 
C ======================================================================
C COPYRIGHT (C) 1991 - 2012  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
C (AT YOUR OPTION) ANY LATER VERSION.                                   
C                                                                       
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
C                                                                       
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.         
C ======================================================================
C
C ELEMENT SHB8-PS 
C               ELEMENT SHB8
C
      IMPLICIT REAL*8 (A-H,O-Z)
      INCLUDE 'jeveux.h'
      INTEGER IPROPE
      REAL*8 XE(24),RE(24,24)
      REAL*8 XXG5(5),PXG5(5),XCOQ(3,4),BKSIP(3,8,5),B(3,8)
      REAL*8 XCENT(3),PPP(3,3),TMPKE2(24,24),SIGMAG(6)
      REAL*8 XL(3,4),XXX(3),YYY(3),SIGMA(*),TMPKE(24,24)
      REAL*8 SIGLOC(6),SITMP1(8,8),SITMP2(8,8),XETEMP(*)
C
C
C INITIALISATIONS
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C INFOS:
C XE EST RANGE COMME CA:
C (XNOEUD1 YNOEUD1 ZNOEUD1, XNOEUD2 YNOEUD2 ZNOEUD2,...)
C DANS SHB8_TEST_NUM: ATTENTION A LA NUMEROTATION DES NOEUDS
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C      IF (NOMSHB.EQ.'SHB8') THEN
C
C ON DEFINI LES POINTS GAUSS ET LES POIDS
C
      XXG5(1) = -0.906179845938664D0
      XXG5(2) = -0.538469310105683D0
      XXG5(3) = 0.D0
      XXG5(4) = 0.538469310105683D0
      XXG5(5) = 0.906179845938664D0
C
      PXG5(1) = 0.236926885056189D0
      PXG5(2) = 0.478628670499366D0
      PXG5(3) = 0.568888888888889D0
      PXG5(4) = 0.478628670499366D0
      PXG5(5) = 0.236926885056189D0
C -----------------------------------------------------
C ON VERIFIE QUE LA CONNECTIVITE DONNE UN REPERE DIRECT
C SI CE N EST PAS LE CAS ON PERMUTE LES NOEUDS
C -----------------------------------------------------
C     ON FAIT UNE COPIE DE XETEMP DANS XE
      DO 10 I = 1,24
         XE(I) = XETEMP(I)
   10 CONTINUE
C
C CALCUL DE B (1 2 3) AUX 5 POINTS DE GAUSS
C
      CALL SHBKSI(5,XXG5,BKSIP)
      DO 930 J = 1,8
         DO 920 I = 1,8
            SITMP2(I,J) = 0.D0
  920    CONTINUE
  930 CONTINUE
C
C DEBUT DE LA BOUCLE SUR LES 5 PTS GAUSS
C
      DO 990 IP = 1,5
C
C CALCUL DE B
C
         CALL SHCALB(BKSIP(1,1,IP),XE,B,AJAC)
C
C CALCUL DE MATRICE DE PASSAGE POUR POUVOIR CALCULER LES
C CONTRAINTES DANS LE REPERE GLOBAL
C
         DO 940 I = 1,6
C C'EST LES CONTRAINTES LOCALES POUR POUVOIR TRAITER LA PLASTICITE AVANT
            SIGLOC(I) = SIGMA((IP-1)*6+I)
  940    CONTINUE
         ZETA = XXG5(IP)
         ZLAMB = 0.5D0* (1.D0-ZETA)
         DO 960 I = 1,4
            DO 950 J = 1,3
              XCOQ(J,I) = ZLAMB*XE((I-1)*3+J) +
     &                    (1.D0-ZLAMB)*XE((I-1+4)*3+J)
  950       CONTINUE
  960    CONTINUE
         CALL RLOSHB(XCOQ,XCENT,PPP,XL,XXX,YYY,RBID)
C
C PASSAGE DES CONTRAINTES AU REPERE GLOBAL
C
         CALL CHRP3D(PPP,SIGLOC,SIGMAG,1)
         DO 962 J = 1,8
           DO 961 I = 1,8
             SITMP1(I,J) = 0.D0
  961      CONTINUE
  962    CONTINUE
C
         DO 964 J = 1,8
           DO 963 I = 1,8
             SITMP1(I,J) = SIGMAG(1)*B(1,I)*B(1,J) + 
     &         SIGMAG(2)*B(2,I)*B(2,J) +
     &         SIGMAG(3)*B(3,I)*B(3,J) + 
     &         SIGMAG(4)*(B(1,I)*B(2,J)+B(2,I)*B(1,J)) +
     &         SIGMAG(6)*(B(1,I)*B(3,J)+B(3,I)*B(1,J)) +
     &         SIGMAG(5)*(B(3,I)*B(2,J)+B(2,I)*B(3,J))
  963      CONTINUE
  964    CONTINUE
         DO 980 J = 1,8
            DO 970 I = 1,8
              SITMP2(I,J) = SITMP2(I,J) +
     &                4.D0*AJAC*PXG5(IP)*SITMP1(I,J)
  970       CONTINUE
  980    CONTINUE
  990 CONTINUE
      CALL R8INIR(576,0.D0,TMPKE,1)
      DO 1020 KK = 1,3
         DO 1010 I = 1,8
            DO 1000 J = 1,8
              TMPKE(I+(KK-1)*8,J+(KK-1)*8) = SITMP2(I,J)
 1000       CONTINUE
 1010    CONTINUE
 1020 CONTINUE
C
C ON MET DE L'ORDRE:
C
      CALL R8INIR(576,0.D0,TMPKE2,1)
      DO 1040 J = 1,8
         DO 1030 I = 1,24
            TMPKE2(I, (J-1)*3+1) = TMPKE(I,J)
            TMPKE2(I, (J-1)*3+2) = TMPKE(I,J+8)
            TMPKE2(I, (J-1)*3+3) = TMPKE(I,J+16)
 1030    CONTINUE
 1040 CONTINUE
C
      CALL R8INIR(576,0.D0,TMPKE,1)
      DO 1060 I = 1,8
         DO 1050 J = 1,24
            TMPKE((I-1)*3+1,J) = TMPKE2(I,J)
            TMPKE((I-1)*3+2,J) = TMPKE2(I+8,J)
            TMPKE((I-1)*3+3,J) = TMPKE2(I+16,J)
 1050    CONTINUE
 1060 CONTINUE
C
      IPROPE = 1
      IF (IPROPE.EQ.0) THEN
           CALL DCOPY(576,TMPKE,1,RE,1)
      ENDIF
C
      IF(IPROPE.EQ.1) THEN
           CALL DAXPY(576,1.D0,TMPKE,1,RE,1)
      ENDIF
C      K = 0
C      DO 750 J = 1,24
C          DO 740 I = 1,24
C            K = K + 1
C            REV(K) = RE(I,J)
C  740     CONTINUE
C  750 CONTINUE
C*      WRITE(6,*) 'RE = ',RE
      END
