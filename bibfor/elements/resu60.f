      SUBROUTINE RESU60 (RESU1,RESU2)
      IMPLICIT NONE
C ----------------------------------------------------------------------
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ELEMENTS  DATE 27/08/2012   AUTEUR ALARCON A.ALARCON 
C ======================================================================
C COPYRIGHT (C) 1991 - 2012  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
C (AT YOUR OPTION) ANY LATER VERSION.                                 
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
C    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
C ======================================================================
C
C     CETTE ROUTINE PERMET LA CONCATENATION DE DEUX CONCEPTS DYNA_GENE
C     DE TYPE HARMONIQUE CALCULES PAR DEUX COMMANDE DYNA_LINE_HARM
C     RESU1 ET RESU2 SONT COPIES DANS RESU1
C
C     LA ROUTINE RESU74 FAIT LA MEME CHOSE MAIS POUR DES CALCULS TRANS.
C ----------------------------------------------------------------------
      INCLUDE 'jeveux.h'
      CHARACTER*8  RESU1, RESU2
C
C IN  : RESU1 : PREMIER CONCEPT DYNA_GENE HARMONIQUE
C IN  : RESU2 : SECOND CONCEPT DYNA_GENE HARMONIQUE
C
      INTEGER      NBSTO1, NBSAU1, NBSTO2, NBSAU2
      INTEGER      NBSTOC, NBSAUV
      CHARACTER*1  K1BID
      CHARACTER*8  RESU
      INTEGER      I
      INTEGER      FLAGD1,FLAGV1,FLAGA1,FLAGD2,FLAGV2,FLAGA2
      LOGICAL      FLAGD,FLAGV,FLAGA
C-----------------------------------------------------------------------
C
C-----------------------------------------------------------------------
      INTEGER LREF1 ,LREF2
      INTEGER JACCE ,JACCE1 ,JACCE2, JVITE, JVITE1, JVITE2
      INTEGER JDEPL ,JDEPL1 ,JDEPL2 ,JDESC
      INTEGER JFREQ ,JFREQ1 ,JFREQ2 ,JORDR, JORDR1 ,JORDR2
C-----------------------------------------------------------------------
      CALL JEMARQ()
      RESU = '88888'
C
C     --- VERIFICATION DE LA COMPATIBILITE DES RESULTATS A MERGER
      CALL JEEXIN (RESU1//'           .DEPL', FLAGD1)
      CALL JEEXIN (RESU1//'           .VITE', FLAGV1)
      CALL JEEXIN (RESU1//'           .ACCE', FLAGA1)
      CALL JEEXIN (RESU2//'           .DEPL', FLAGD2)
      CALL JEEXIN (RESU2//'           .VITE', FLAGV2)
      CALL JEEXIN (RESU2//'           .ACCE', FLAGA2)
C
      FLAGD = ((FLAGD1.EQ.0).AND.(FLAGD2.EQ.0))
     &        .OR.((FLAGD1.NE.0).AND.(FLAGD2.NE.0))
      FLAGV = ((FLAGV1.EQ.0).AND.(FLAGV2.EQ.0))
     &        .OR.((FLAGV1.NE.0).AND.(FLAGV2.NE.0))
      FLAGA = ((FLAGA1.EQ.0).AND.(FLAGA2.EQ.0))
     &        .OR.((FLAGA1.NE.0).AND.(FLAGA2.NE.0))
C
C     CONDITION POUR SAVOIR SI LES FLAGS SONT BIEN TOUS LES 2 ZEROS
C     OU BIEN DIFFERENTS DE ZERO = COMPATIBILITE DES RESUS
      IF (.NOT.(FLAGD.AND.FLAGV.AND.FLAGA)) THEN
        CALL U2MESS('F','ALGORITH17_25')
      ENDIF
C
      CALL JEVEUO (RESU1//'           .DESC','E',JDESC)
C
C     --- RECHERCHE DU NUMERO D'ORDRE DE LA FREQUENCE DE REPRISE
      IF (FLAGD1.GT.0) THEN
        CALL JELIRA(RESU1//'           .DEPL','LONUTI',NBSTO1,K1BID)
        CALL JELIRA(RESU2//'           .DEPL','LONUTI',NBSTO2,K1BID)
      ELSEIF (FLAGV1.GT.0) THEN
        CALL JELIRA(RESU1//'           .VITE','LONUTI',NBSTO1,K1BID)
        CALL JELIRA(RESU2//'           .VITE','LONUTI',NBSTO2,K1BID)
      ELSE
        CALL JELIRA(RESU1//'           .ACCE','LONUTI',NBSTO1,K1BID)
        CALL JELIRA(RESU2//'           .ACCE','LONUTI',NBSTO2,K1BID)
      ENDIF
C
      NBSTOC = NBSTO1+NBSTO2
C
C     --- RECUPERATION DES CHAMPS DEPL VITE ET ACCE ---
      IF (FLAGD1.NE.0) THEN
        CALL JEVEUO(RESU1//'           .DEPL' ,'E',JDEPL1)
        CALL JEVEUO(RESU2//'           .DEPL' ,'E',JDEPL2)
        CALL WKVECT(RESU //'           .DEPL','G V C',NBSTOC,JDEPL)
        CALL ZCOPY(NBSTO1,ZC(JDEPL1),1,ZC(JDEPL),1)
        CALL ZCOPY(NBSTO2,ZC(JDEPL2),1,ZC(JDEPL+NBSTO1),1)
      ENDIF
C                         ^
C                         |______________
C       --- VALEURS COMPLEXES = COPIER |2| FOIS PLUS DE REELS
C  
      IF (FLAGV1.NE.0) THEN
        CALL JEVEUO(RESU1//'           .VITE' ,'E',JVITE1)
        CALL JEVEUO(RESU2//'           .VITE' ,'E',JVITE2)
        CALL WKVECT(RESU //'           .VITE','G V C',NBSTOC,JVITE)
        CALL ZCOPY(NBSTO1,ZC(JVITE1),1,ZC(JVITE),1)
        CALL ZCOPY(NBSTO2,ZC(JVITE2),1,ZC(JVITE+NBSTO1),1)
      ENDIF
C
      IF (FLAGA1.NE.0) THEN
        CALL JEVEUO(RESU1//'           .ACCE' ,'E',JACCE1)
        CALL JEVEUO(RESU2//'           .ACCE' ,'E',JACCE2)
        CALL WKVECT(RESU //'           .ACCE','G V C',NBSTOC,JACCE)
        CALL ZCOPY(NBSTO1,ZC(JACCE1),1,ZC(JACCE),1)
        CALL ZCOPY(NBSTO2,ZC(JACCE2),1,ZC(JACCE+NBSTO1),1)
      ENDIF
C
C     --- RECUPERATION DES CHAMPS ORDR
C
      CALL JEVEUO(RESU1//'           .ORDR' ,'E',JORDR1)
      CALL JELIRA(RESU1//'           .ORDR' ,'LONUTI',NBSAU1,K1BID)
C
      CALL JEVEUO(RESU2//'           .ORDR' ,'E',JORDR2)
      CALL JELIRA(RESU2//'           .ORDR' ,'LONUTI',NBSAU2,K1BID)
C     --- CUMULER LES NUMEROS D'ORDRE POUR CONSERVER LA MONOTONIE
      DO 20 I = 0,NBSAU2-1
         ZI(JORDR2+I) = ZI(JORDR2+I) + ZI(JORDR1+NBSAU1-1) + 1
  20  CONTINUE
C
      NBSAUV = NBSAU1 + NBSAU2
C
      CALL WKVECT(RESU//'           .ORDR','G V I',NBSAUV,JORDR)
      CALL COPVIS(NBSAU1,ZI(JORDR1),ZI(JORDR))
      CALL COPVIS(NBSAU2,ZI(JORDR2),ZI(JORDR+NBSAU1))
C
      CALL JEVEUO(RESU1//'           .DISC' ,'E',JFREQ1)
      CALL JEVEUO(RESU2//'           .DISC' ,'E',JFREQ2)
      CALL WKVECT(RESU//'           .DISC','G V R',NBSAUV,JFREQ)
      CALL DCOPY(NBSAU1,ZR(JFREQ1),1,ZR(JFREQ),1)
      CALL DCOPY(NBSAU2,ZR(JFREQ2),1,ZR(JFREQ+NBSAU1),1)
C
C     --- DUPLICATION ---
C
      IF (FLAGD1.NE.0) CALL JEDUPO(RESU//'           .DEPL',
     +            'G',RESU1//'           .DEPL',.FALSE.)
      IF (FLAGV1.NE.0) CALL JEDUPO(RESU//'           .VITE',
     +            'G',RESU1//'           .VITE',.FALSE.)
      IF (FLAGA1.NE.0) CALL JEDUPO(RESU//'           .ACCE',
     +            'G',RESU1//'           .ACCE',.FALSE.)
      CALL JEDUPO(RESU//'           .ORDR',
     +            'G',RESU1//'           .ORDR',.FALSE.)
      CALL JEDUPO(RESU//'           .DISC',
     +            'G',RESU1//'           .DISC',.FALSE.)

C
C     --- COPIE DU NOUVEAU .REFD DANS LA SD FINALE ---
C
      CALL JEVEUO(RESU1//'           .REFD','E',LREF1)
      CALL JEVEUO(RESU2//'           .REFD','L',LREF2)
      DO 10 I = 0,4
        ZK24(LREF1+I) = ZK24(LREF2+I)
  10  CONTINUE
C
C     --- DESTRUCTION DES OBJETS PROVISOIRES
C
      CALL JEDETC('G',RESU//'           ',1)
      CALL JEDETC('G',RESU2//'           ',1)
C
      CALL JEDEMA()
C
      END
