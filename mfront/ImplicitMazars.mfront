@Parser Implicit;
@Behaviour ImplicitMazars;

@Algorithm NewtonRaphson_NumericalJacobian;
@MaximumIncrementValuePerIteration 1.e-3;

@ModellingHypotheses {".+"};
@Theta 1. ;
@Epsilon 1.e-12 ;
@IterMax 100 ;

@MaterialProperty stress young; /* mandatory for castem */
young.setGlossaryName("YoungModulus");
@MaterialProperty real nu;    /* mandatory for castem */
nu.setGlossaryName("PoissonRatio");

@MaterialProperty real Ac;
@MaterialProperty real At;
@MaterialProperty real Bc;
@MaterialProperty real Bt;
@MaterialProperty real k;
@MaterialProperty real ed0;



@Includes{
#include"TFEL/Material/Lame.hxx"
}

@StateVariable real    d;

@StateVariable<PlaneStress> real etozz;
PlaneStress::etozz.setGlossaryName("AxialStrain");

@AuxiliaryStateVariable real Y;
@AuxiliaryStateVariable real Tmax;
@AuxiliaryStateVariable real eeqcor;

@LocalVariable real    lambda;
@LocalVariable real    mu;
@LocalVariable real    A,B,dmax,gam, tr;
@LocalVariable Stensor e , s0 ;

/* Initialize Lame coefficients */
@InitLocalVars{
  using namespace tfel::material::lame;
  lambda = computeLambda(young,nu);
  mu = computeMu(young,nu);
  e  = eto+deto;
  tr = trace(e);
  s0 = lambda*tr*Stensor::Id()+2*mu*e;
  dmax=0.99999;
}

@TangentOperator{
  using namespace tfel::material::lame;
  StiffnessTensor Hooke;
  computeAlteredElasticStiffness<hypothesis,Type>::exe(Hooke,lambda,mu);
  if((smt==ELASTIC)||(smt==TANGENTOPERATOR)){
       Dt=Hooke;
  } else if (smt==SECANTOPERATOR){
       Dt = (1.0-d)*Hooke ;
  } else if (smt==CONSISTENTTANGENTOPERATOR){
      Stensor eplus;
      const real RTEMP=B*(Y-ed0);
      real COEF=0.;
      if((d<dmax)&&(dd>0.)&&(Y>1.e-6)){
	      COEF=ed0*(1.-A)/(Y*Y);
	      if(RTEMP<200.0){
	         COEF=COEF+A*B/exp(RTEMP);
	      }
	      COEF=gam*gam*COEF/Y;
      }
      for(unsigned short i=0;i!=e.size();++i){
	      eplus[i]=max(0.,e[i]);
      }
      Dt = (1.-d)*Hooke-COEF*(s0^eplus);
  }
}

@ComputeStress{
    sig = (1.-d)*(lambda*trace(eel)*Stensor::Id()+2*mu*eel);
}

@Integrator{
  //e  = eto+deto;
  //const real    tr = trace(e);
  //const Stensor s0 = lambda*tr*Stensor::Id()+2*mu*e;
  //dmax=0.99999;
  strain e1,e2,e3;
  e.computeEigenValues(e1,e2,e3);
  // eigen values of s0
  const stress s1 = 2*mu*e1+lambda*tr;
  const stress s2 = 2*mu*e2+lambda*tr;
  const stress s3 = 2*mu*e3+lambda*tr;
  const real sn = max(abs(s1),max(abs(s2),abs(s3)));
  const real ppe1=max(strain(0),e1);
  const real ppe2=max(strain(0),e2);
  const real ppe3=max(strain(0),e3);
  const stress pps1=max(stress(0),s1);
  const stress pps2=max(stress(0),s2);
  const stress pps3=max(stress(0),s3);
  real r=1.;
  if (sn>1.e-6*young){
     r=(pps1+pps2+pps3)/(abs(s1)+abs(s2)+abs(s3));
  }
  gam=1. ;
  if ((min(s1,min(s2,s3))<0.)&&(r==0.)){
    const stress pns1=min(stress(0),s1);
    const stress pns2=min(stress(0),s2);
    const stress pns3=min(stress(0),s3);
    gam=-sqrt(pns1*pns1+pns2*pns2+pns3*pns3)/(pns1+pns2+pns3);
  }
  const real eeqc= sqrt(ppe1*ppe1+ppe2*ppe2+ppe3*ppe3);
  eeqcor=max(gam*eeqc,eeqcor);
   A=At*(2*r*r*(1.-2*k)-r*(1-4*k))+Ac*(2*r*r-3*r+1);
   B=r*r*Bt+(1-r*r)*Bc;
  const real Y1=max(ed0,eeqcor);
  Y=max(Y1,Y);
  real dnew=1-(1-A)*ed0/Y-A*exp(-B*(Y-ed0));
  dnew=min(dmax,dnew);

  feel -= deto;
  fd = dd-dnew+d;
}

@UpdateAuxiliaryStateVars{
  Tmax=max(Tmax,T);
}

@Integrator<PlaneStress,Append,AtEnd>{
  // the plane stress equation is satisfied at the end of the time
  // step
  const stress szz = (lambda+2*mu)*(eel(2)+deel(2))+lambda*(eel(0)+deel(0)+eel(1)+deel(1));
  fetozz   = szz/young;
  // modification of the partition of strain
  feel(2) -= detozz;
  cout << "PlaneStress, detozz=" << detozz << endl ;
  // jacobian
  //dfeel_ddetozz(2)=-1;
  ////dfetozz_ddetozz  = real(0);
  //dfetozz_ddeel(2) = (lambda+2*mu)/young;
  //dfetozz_ddeel(0) = lambda/young;
  //dfetozz_ddeel(1) = lambda/young;
}
