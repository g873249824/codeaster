# coding=utf-8

import os
import os.path as osp
from glob import glob
import subprocess
from functools import partial

from waflib import Configure, Context, Build, TaskGen, Task, Utils, Errors

def options(self):
    group = self.get_option_group('Code_Aster options')

def configure(self):
    self.find_program('mfront')
    self.find_program('tfel-config')
    self.check_cfg(path='tfel-config',
                   args='--cppflags --includes --oflags ' \
                        '--libs --material --utilities --system',
                   package='', uselib_store='MFRONT', mandatory=True)
    if self.get_define('_USE_64_BITS'):
        arch = 'ASTER_ARCH=64'
    else:
        arch = 'ASTER_ARCH=32'
    self.env.append_value('DEFINES_MFRONT', arch)
    # remove C++ specific options from CFLAGS
    self.safe_remove('CFLAGS_MFRONT', '-fvisibility-inlines-hidden')
    self.safe_remove('CFLAGS_MFRONT', '-ftree-vectorize')
    # remove some g++ options if icpc is used
    if 'icpc' in self.env.CXX:
        self.safe_remove('CXXFLAGS_MFRONT', '-ftree-vectorize')
    self.check_mfront_libs()

def build(self):
    # POST_LAZY: Groups are processed sequentially: all tasks from previous
    # groups are executed before the task generators from the next group
    # are processed
    self.post_mode = Build.POST_LAZY

    # build mfront_request
    self(
        features = 'c cxx cxxprogram',
            name = 'mfront_request',
             idx = 2,     # use a different target for source shared with bibcxx
          source = ['../bibcxx/mfront/MFrontBehaviour.cxx',
                    '../bibcxx/mfront/MFrontBehaviour.h',
                    'mfront_request.c'],
        includes = '../bibcxx/mfront',
          target = 'mfront_request',
             use = ('MFRONT', ),
    )

    get_srcs = self.path.get_src().ant_glob
    excl = (
        'MonoCristal_DD_CC_InteractionMatrix.mfront',
        'MonoCristal_DD_CFC_InteractionMatrix.mfront',
        'MonoCristal_DD_CC_SlidingSystems.mfront',
        'PolyCristal_DD_CC_SlidingSystems.mfront',
        'PolyCristal_Orientation.mfront',
        'PolyCristal_Orientation_100grains.mfront',
        'Plasticity_Sy.mfront',
    )
    self(
            name = 'mfront_convert',
          source = get_srcs('**/*.mfront', excl=excl),
             use = ('MFRONT', ),
    )

    # force
    self.add_group()

    self(
        features = 'cxx cxxshlib',
            name = 'asterbehaviour',
  dynamic_source = '**/*.cxx',
dynamic_incpaths = '../include',
          target = self.env['_ASTERBEHAVIOUR'],
    install_path = self.env.ASTERLIBDIR,
             use = ('MFRONT', ),
    )
    lst = [i.name for i in get_srcs('**/*.mfront', excl=excl)]
    self(
        features = 'mfront_mater',
            name = 'mfront_mater',
             lst = lst,
            path = self.path,
          target = 'c_mfront_official.capy',
             use = 'asterbehaviour',
    )

###############################################################################
@Configure.conf
def check_mfront_libs(self):
    check_mfront = partial(self.check_cc, mandatory=True, uselib_store='MFRONT', use='MFRONT')
    check_lib = lambda lib: check_mfront(lib=lib)
    libs = ['AsterInterface', ]
    map(check_lib, Utils.to_list(libs))

@TaskGen.extension('.mfront')
def process_mfront(self, node):
    tsk = self.create_task('mfront2cxx', node)

class mfront2cxx(Task.Task):
    """Convert a MFront source file into C++"""
    color   = 'PINK'

    def run(self):
        """Call MFront to convert `.mfront` to C++"""
        name = osp.splitext(self.inputs[0].name)[0]
        mfrdir = self.inputs[0].parent
        wrknode = mfrdir.get_bld().find_or_declare(name)
        wrknode.delete()
        wrknode.mkdir()
        if len(name) > 16:
            msg = "The behaviour name is too long, max. 16 characters: " \
                  "'%s'" % name
            raise Errors.WafError(msg)
        wrkdir = wrknode.abspath()
        cmd = '%s --interface=aster --search-path=%s %s' % (
            self.env.MFRONT,
            mfrdir.get_src().abspath(),
            self.inputs[0].abspath()
        )
        # self.generator.bld.cmd_and_log(cmd, cwd=wrkdir, quiet=Context.STDOUT)
        self.exec_command(cmd, cwd=wrkdir)

@TaskGen.feature('mfront_mater')
@TaskGen.before('catapy')
def mater_capy(self):
    """Create the capy for MFront materials"""
    gen = self.bld.get_tgen_by_name('mfront_request')
    req = gen.link_task.outputs[0]
    link_task = self.bld.get_tgen_by_name('asterbehaviour').link_task
    target = self.bld.bldnode.make_node(self.target)
    tsk = self.create_task('mfront_capy', src=[req] + link_task.outputs, tgt=target)

class mfront_capy(Task.Task):
    color   = 'PINK'
    ext_out = ['.capy']

    def run(self):
        """Create a .capy file for the MFront behaviours"""
        req = self.inputs[0].abspath()
        # open libAsterBehaviour.so
        libpath = self.inputs[1].abspath()
        lst = self.generator.lst
        target = self.outputs[0]
        lines = [capy_header]
        for comport in lst:
            comport = osp.splitext(comport)[0]
            try:
                props = getMaterialProperties(req, libpath, comport)
            except ValueError:
                raise ValueError("Behaviour '%(nam)s': not found in library. "
                    "Please check that '%(nam)s.mfront' defines a behaviour "
                    "named '%(nam)s'." % { 'nam' : comport })
            lines.extend(_capy_comport(comport, props, "'R'", " " * 8))
            lines.extend(_capy_comport(comport + '_FO', props,
                                       "fonction_sdaster", " " * 8))
        lines.append(capy_footer)
        open(target.abspath(), 'w').write(os.linesep.join(lines))
        target.sig = Utils.h_file(target.abspath())

###############################################################################
def getMaterialProperties(binary, libpath, behav):
    """Return the list of material properties"""
    symb = 'aster%s' % behav.lower()
    try:
        out = subprocess.check_output([binary, "Tridimensional", libpath, symb])
    except subprocess.CalledProcessError, exc:
        msg = "%r exits with status %s" % (exc.cmd, exc.returncode)
        raise Errors.WafError(msg)
    return [p for p in out.split()]

def _capy_comport(comport, properties, typ, indent):
    """Return the lines for the catalog for `comport`"""
    assert typ in ("'R'", "fonction_sdaster"), 'unknown type: %s' % typ
    lines = ["'%s' : FACT(statut='f'," % comport]
    for i in properties:
        lines.append("    %s = SIMP(statut='o', typ=%s)," % (i, typ))
        if len(i) > 16:
            msg = "Behaviour  '%s': The material property '%s' exceeds " \
                  "16 characters." % (comport, i)
            raise Errors.WafError(msg)
    lines.append('),')
    return [indent + k for k in lines]

capy_header = """#
# Automatically-generated file. Do not edit!
#
# COPYRIGHT (C) 1991 - 2014  EDF R&D                  WWW.CODE-ASTER.ORG
#
def C_MFRONT_OFFICIAL():
    keywords = {
"""

capy_footer = """    }
    return keywords
"""
