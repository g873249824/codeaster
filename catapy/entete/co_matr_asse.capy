# ======================================================================
# COPYRIGHT (C) 1991 - 2011  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# person_in_charge: mathieu.courtois at edf.fr

class matr_asse(ASSD):
    cata_sdj = "SD.sd_matr_asse.sd_matr_asse"

    def EXTR_MATR(self,sparse=False) :
        """ retourne les valeurs de la matrice  dans un format numpy
            Si sparse=True, la valeur de retour est un triplet de 
            numpy.array prÃªt pour scipy formats rares.
            Attributs retourne
              - self.valeurs : numpy.array contenant les valeurs (sparse=False)
              ou
              - self.valeurs : numpy.array contenant les valeurs (sparse=True)
              - self.lignes : numpy.array numpy.array contenant les indices des lignes (sparse=True)
              - self.colonnes : numpy.array contenant les indices des colonnes (sparse=True)
              - self.dim : int qui donne la dimension de la matrice
        """
        from numpy import array
        from numpy import zeros
        from numpy import fromiter
        from numpy import where
        from numpy import copy
        from numpy import delete
        from numpy import concatenate
        from SD.sd_stoc_morse import sd_stoc_morse

        if not self.accessible():
            raise Accas.AsException("Erreur dans matr_asse.EXTR_MATR en PAR_LOT='OUI'")

        refa = array(self.sdj.REFA.get())
        ma=refa[0]
        nu=refa[1]
        smos = sd_stoc_morse(nu[:14]+'.SMOS')

        valm=self.sdj.VALM.get()
        smhc=smos.SMHC.get()
        smdi=smos.SMDI.get()

        sym=len(valm)==1
        dim=len(smdi)
        nnz=smdi[dim-1]

        triang_sup = array(valm[1])
        if sym:
            triang_inf = triang_sup
        else:
            triang_inf = array(valm[2])

        if type(valm[1][0]) == type(1.j) :
            dtype=complex
        else :
            dtype=float
        
        if sparse :
            smhc=array(smhc)-1
            smdi=array(smdi)-1
            # classe d'itération pour la liste de la colonne
            class iterateur :
                def __init__(self) :
                    self.jcol=0
                    self.kterm=0

                def __iter__(self) :
                    return self

                def next(self) :
                    if self.kterm==0:
                        self.kterm+=1
                        return self.jcol
                    if (smdi[self.jcol] < self.kterm):
                        self.jcol+=1
                    self.kterm+=1
                    return self.jcol

            col_iter=iterateur()
            # générer la liste de colonnes
            cols=fromiter(col_iter,count=nnz,dtype=int)

            # entrées filtre de pivot de triang_inf
            helper=smhc-cols
            indices_to_filter=where(helper==0)[0]
            smdi_inf=copy(smhc)
            smdi_inf=delete(smdi_inf,indices_to_filter)
            smhc_inf=copy(cols)
            smhc_inf=delete(smhc_inf,indices_to_filter)
            triang_inf=delete(triang_inf,indices_to_filter)

            # joindre les listes
            lignes=concatenate((cols,smdi_inf))
            colonnes=concatenate((smhc,smhc_inf))
            valeurs=concatenate((triang_sup,triang_inf))
            return valeurs, lignes, colonnes, dim
            
        else :
            valeur=zeros([dim, dim], dtype=dtype)

            jcol=1
            for kterm in xrange(1,nnz+1):
                ilig=smhc[kterm-1]
                if (smdi[jcol-1] < kterm):
                    jcol+=1
                valeur[jcol-1,ilig-1]=triang_inf[kterm-1]
                valeur[ilig-1,jcol-1]=triang_sup[kterm-1]

            return valeur

class matr_asse_gd(matr_asse):
    cata_sdj = "SD.sd_matr_asse.sd_matr_asse"

class matr_asse_depl_c(matr_asse_gd):
    pass

class matr_asse_depl_r(matr_asse_gd):
    pass

class matr_asse_pres_c(matr_asse_gd):
    pass

class matr_asse_pres_r(matr_asse_gd):
    pass

class matr_asse_temp_c(matr_asse_gd):
    pass

class matr_asse_temp_r(matr_asse_gd):
    pass
