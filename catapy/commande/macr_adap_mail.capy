#& MODIF COMMANDE  DATE 20/10/2008   AUTEUR PELLET J.PELLET 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE GNICOLAS G.NICOLAS


from Macro.macr_adap_mail_ops import macr_adap_mail_ops

def macr_adap_mail_prod(self,MAJ_CHAM,ADAPTATION,**args):
#
# 0. Typage des structures produites
#
  maillage_np1=args['MAILLAGE_NP1']
  self.type_sdprod(maillage_np1,maillage_sdaster)
#
  if ( args['MAILLAGE_NP1_ANNEXE'] is not None ) :
    maillage_np1_annexe=args['MAILLAGE_NP1_ANNEXE']
    self.type_sdprod(maillage_np1_annexe,maillage_sdaster)
#
  if MAJ_CHAM == None:return None
# Remarque : la liste qui suit doit etre conforme à son homologue de LIRE_CHAMP
  for ch in MAJ_CHAM:
    t=ch['TYPE_CHAM']
    if t[0:5] == "NOEU_":self.type_sdprod(ch['CHAM_MAJ'],cham_no_sdaster)
    if t[0:2] == "EL":   self.type_sdprod(ch['CHAM_MAJ'],cham_elem)
  return None


MACR_ADAP_MAIL=MACRO(nom="MACR_ADAP_MAIL",op=macr_adap_mail_ops,sd_prod=macr_adap_mail_prod,
                     fr="Adapter un maillage avec le logiciel HOMARD.",
                     ang="Mesh adaptation with HOMARD software.",
                     docu="U7.03.01-b",UIinfo={"groupe":("Maillage",)},
#
# 1. Le niveau d'information
#
  INFO = SIMP(statut='f',typ='I',defaut=1,into=(1,2,3,4)),
#
# 2. Version de HOMARD
#
  VERSION_HOMARD = SIMP(statut='f',typ='TXM',defaut="V9_5",
                        into=("V9_5", "V9_N", "V9_N_PERSO"),
                        fr="Version de HOMARD",
                        ang="HOMARD release"),
#
# 3. Langue des messages produits par HOMARD
#
  LANGUE = SIMP(statut='f',typ='TXM',defaut="FRANCAIS",    
                into=("FRANCAIS","FRENCH","ANGLAIS","ENGLISH",),
                fr="Langue des messages produits par HOMARD.",
                ang="Language for HOMARD messages." ),
#
# 4. Les maillages
# 4.1. Quel que soit le type de traitement, il faut donner  :
#      A. Le concept du maillage initial (entree)
#      B. Le concept du maillage final (sortie)
#
  MAILLAGE_N   = SIMP(statut='o',typ=maillage_sdaster,
                      fr="Maillage avant adaptation",
                      ang="Mesh before adaptation" ),
#
  MAILLAGE_NP1 = SIMP(statut='o',typ=CO,
                      fr="Maillage apres adaptation",
                      ang="Mesh after adaptation" ),
#
# 4.2. Eventuellement, on peut produire un maillage annexe
#      Actuellement, c'est le maillage n+1, mais de degré différent.
#
  MAILLAGE_NP1_ANNEXE = SIMP(statut='f',typ=CO,
                             fr="Maillage annexe apres adaptation",
                             ang="Additional mesh after adaptation" ),
#
# 5. Le pilotage de l'adaptation, avec les variantes suivantes :
#  . Raffinement et deraffinement, selon un champ d'indicateurs d'erreur
#  . Raffinement seul, selon un champ d'indicateurs d'erreur
#  . Deraffinement seul, selon un champ d'indicateurs d'erreur
#  . Raffinement seul, selon des zones geometriques
#  . Raffinement uniforme : toutes les mailles sont divisées
#  . Deraffinement uniforme : toutes les mailles sont regroupées
#  . Rien : le maillage est le meme a la sortie et a l'entree
#
  ADAPTATION = SIMP(statut='o',typ='TXM',
                    into=("RAFF_DERA","RAFFINEMENT","DERAFFINEMENT","RAFFINEMENT_ZONE", \
                          "RAFFINEMENT_UNIFORME","DERAFFINEMENT_UNIFORME","RIEN"),    
                    fr="Pilotage de l'adaptation : selon un indicateur d'erreur ou uniforme.",
                    ang="Adaptation control : among an error indicator or uniform" ),
#
# 6. Pour de l'adaptation libre, il faut un indicateur d'erreur
#
  b_indicateur_d_erreur = BLOC( condition = " (ADAPTATION == 'RAFF_DERA') or \
                                              (ADAPTATION == 'RAFFINEMENT') or \
                                              (ADAPTATION == 'DERAFFINEMENT') " ,
                                fr="Pour une adaptation libre, choix de l'indicateur d'erreur ou d'une zone à raffiner",
                                ang="For free adaptation, selection of error indicator or zone",
#
    regles=(UN_PARMI('CHAM_GD','RESULTAT_N')),
#
# 6.1. Repérage de la zone à raffiner à l'aide d'un indicateur
#
# 6.1.1. Sous forme de champ de grandeur
#
    CHAM_GD    = SIMP(statut='f',typ=cham_gd_sdaster,
                      fr="Champ de grandeur Code_Aster contenant l'indicateur d'erreur",
                      ang="Code_Aster champ de grandeur with error indicator" ),
#
# 6.1.2. Sous forme de concept resultat_sdaster
#
    RESULTAT_N = SIMP(statut='f',typ=(evol_elas,evol_noli,evol_ther) ,
                      fr="Concept resultat Code_Aster contenant l'indicateur d'erreur",
                      ang="Code_Aster result with error indicator" ),
#
    b_champ_indicateur = BLOC(condition="(RESULTAT_N != None)",
      INDICATEUR = SIMP(statut='o',typ='TXM',     
                        fr="Champ de l'indicateur d'erreur dans le résultat",
                        ang="Error indicator field in the result structure" ),
    ),
#
# 6.1.3. Est-ce un champ dérivé
#
    b_sensibilite = BLOC(condition=" (RESULTAT_N != None) or (CHAM_GD != None) ",
                        fr="Est-ce un champ dérivé",
                        ang="Is the indicator a derivative field",
#
      SENSIBILITE = SIMP(statut='f',typ=(para_sensi,theta_geom),
                         fr="Paramètre de sensibilité.",
                         ang="Sensitivity parameter")
#
    ),
#
# 6.1.4. La composante retenue
#
    b_composante = BLOC(condition=" (RESULTAT_N != None) or (CHAM_GD != None) ",
                        fr="Choix de la composante pour l'indicateur",
                        ang="Component selection for error indicator",
#
      NOM_CMP_INDICA = SIMP(statut='o',typ='TXM',
                            fr="Composante retenue pour l'indicateur d'erreur",
                            ang="Selected component for error indicator" ),
#
    ),
#
# 6.1.5. Le paramètre temporel pour l'indicateur
#
    b_parametre_temporel = BLOC(condition="(RESULTAT_N != None)",
                                fr="Choix éventuel du paramètre temporel pour l'indicateur",
                                ang="Time selection for error indicator (option)",
#
      regles=(EXCLUS('NUME_ORDRE','INST'),),
#
# 6.1.5.1. Soit le numero d'ordre
#
      NUME_ORDRE = SIMP(statut='f',typ='I',
                        fr="Numero d ordre",
                        ang="Rank" ),  
#
# 6.1.5.2. Soit l'instant
# 6.1.5.2.1. Sa valeur
#
      INST       = SIMP(statut='f',typ='R',
                        fr="Instant associé",
                        ang="Instant" ),
#
# 6.1.5.2.2. La précision du choix de l'instant
#
      b_precision = BLOC(condition="(INST != None)",
                         fr="Choix de la précision du choix de l'instant",
                         ang="Selection for instant choice",
        CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),
                         fr="Critère de précision sur le choix de l'instant associé",
                         ang="Accuracy criterium over instant choice"),
        b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
            PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,
                             fr="Précision relative sur le choix de l'instant associé",
                             ang="Relative accuracy over instant choice"),),
        b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
            PRECISION       =SIMP(statut='o',typ='R',
                             fr="Précision absolue sur le choix de l'instant associé",
                             ang="Absolute accuracy over instant choice"),),
      ),
#
    ),
#
# 6.1.6. Type de valeur de l'indicateur : absolue ou relative
#
    b_valeur_indicateur = BLOC(condition=" (RESULTAT_N != None) or (CHAM_GD != None) ",
                               fr="Type de valeur pour l'indicateur",
                               ang="Value type for error indicator",
#
      TYPE_VALEUR_INDICA = SIMP(statut='f',typ='TXM',defaut="V_ABSOLUE",into=("V_ABSOLUE","V_RELATIVE"),
                                fr="Valeur absolue ou relative pour l'indicateur",
                                ang="Absolute or relative value for error indicator" ),
#
    ),
#
# 6.1.7. Type d'opération sur l'indicateur : la valeur par maille ou le max du saut entre mailles
#
    b_usage_indicateur = BLOC(condition=" (RESULTAT_N != None) or (CHAM_GD != None) ",
                              fr="Usage de l'indicateur : direct ou saut",
                              ang="Use type for error indicator : direct or jump",
#
      TYPE_OPER_INDICA = SIMP(statut='f',typ='TXM',defaut="MAILLE",into=("MAILLE","SAUT"),
                              fr="Usage de l'indicateur : la valeur par maille ou le saut entre mailles voisines",
                              ang="Use of indicator : value over every mesh or jump between neighbour" ),
#
    ),
#
  ) ,
#
# 7. Les criteres pour de l'adaptation libre avec un indicateur d'erreur :
#        absolu, relatif, en proportion d'entite
# 7.1. Pour le raffinement :
#
  b_critere_de_raffinement = BLOC( condition = " (ADAPTATION == 'RAFF_DERA') or \
                                                 (ADAPTATION == 'RAFFINEMENT') " ,
                                fr="Critère de raffinement.",
                                ang="Refinement threshold.",
#
    regles=(UN_PARMI ( 'CRIT_RAFF_ABS', 'CRIT_RAFF_REL', 'CRIT_RAFF_PE' ),),
#
    CRIT_RAFF_ABS = SIMP(statut='f',typ='R',
                         fr="Critère absolu",
                         ang="Absolute threshold" ),  
    CRIT_RAFF_REL = SIMP(statut='f',typ='R',
                         fr="Critère relatif : fraction réelle entre 0. et 1.",
                         ang="Relative threshold : ratio between 0. and 1." ),  
    CRIT_RAFF_PE  = SIMP(statut='f',typ='R',
                         fr="Pourcentage d'éléments : fraction réelle entre 0. et 1.",
                         ang="Percentage of elements : ratio between 0. and 1." ),  
  ) ,
#
# 7.2. Pour le deraffinement :
#
  b_critere_de_deraffinement = BLOC( condition = " (ADAPTATION == 'RAFF_DERA') or \
                                                   (ADAPTATION == 'DERAFFINEMENT') " ,
                                     fr="Critère de déraffinement.",
                                     ang="Unrefinement threshold.",
#
    regles=(UN_PARMI ( 'CRIT_DERA_ABS', 'CRIT_DERA_REL', 'CRIT_DERA_PE' ),),
#
    CRIT_DERA_ABS = SIMP(statut='f',typ='R' ,
                         fr="Critère absolu",
                         ang="Absolute threshold" ),  
    CRIT_DERA_REL = SIMP(statut='f',typ='R',
                         fr="Critère relatif : fraction réelle entre 0. et 1.",
                         ang="Relative threshold : ratio between 0. and 1." ),  
    CRIT_DERA_PE  = SIMP(statut='f',typ='R',
                         fr="Pourcentage d'éléments : fraction réelle entre 0. et 1.",
                         ang="Percentage of elements : ratio between 0. and 1." ),  
  ) ,
#
# 8. Pour de l'adaptation par zone, définitions des zones
#
  b_zone = BLOC( condition = " (ADAPTATION == 'RAFFINEMENT_ZONE') " ,
                                fr="Pour une adaptation selon une zone à raffiner",
                                ang="For adaptation among zone",
    ZONE = FACT(statut='f',max='**',
                  fr="Définition de zones à raffiner.",
                  ang="Refined zone definition.",
#
      regles=(AU_MOINS_UN('X_MINI','X_CENTRE'),
              EXCLUS('X_MINI','X_CENTRE',),
              EXCLUS('Z_MINI','X_CENTRE',),
              EXCLUS('X_MINI','Z_CENTRE',),
              EXCLUS('Z_MINI','Z_CENTRE',),
              PRESENT_PRESENT('X_MINI','X_MAXI','Y_MINI','Y_MAXI'),
              PRESENT_PRESENT('Z_MINI','Z_MAXI'),
              PRESENT_PRESENT('X_CENTRE','Y_CENTRE','RAYON'),),
#
# 6.2.1. Une boite parallelepipedique
#
      X_MINI = SIMP(statut='f',typ='R',
                    fr="Abscisse minimum de la boite",
                    ang="Minimum X for the box"),
      X_MAXI = SIMP(statut='f',typ='R',
                    fr="Abscisse maximum de la boite",
                    ang="Maximum X for the box"),
#
      Y_MINI = SIMP(statut='f',typ='R',
                    fr="Orodnnée minimum de la boite",
                    ang="Minimum Y for the box"),
      Y_MAXI = SIMP(statut='f',typ='R',
                    fr="Abscisse maximum de la boite",
                    ang="Maximum Y for the box"),
#
      Z_MINI = SIMP(statut='f',typ='R',
                    fr="Cote minimum de la boite",
                    ang="Minimum Z for the box"),
      Z_MAXI = SIMP(statut='f',typ='R',
                    fr="Cote maximum de la boite",
                    ang="Maximum Z for the box"),
#
# 6.2.2. Une sphere
#
      X_CENTRE = SIMP(statut='f',typ='R',
                      fr="Abscisse du centre de la sphere",
                      ang="X for the center of the sphere"),
      Y_CENTRE = SIMP(statut='f',typ='R',
                      fr="Ordonnee du centre de la sphere",
                      ang="Y for the center of the sphere"),
      Z_CENTRE = SIMP(statut='f',typ='R',
                      fr="Cote du centre de la sphere",
                      ang="Z for the center of the sphere"),
      RAYON = SIMP(statut='f',typ='R',
                   fr="Rayon de la sphere",
                   ang="Radius of the sphere"),
#
    ) ,
#
  ) ,
#
# 9. Les niveaux extremes pour le maillage adapte
# 9.1. Pour le raffinement :
#
  b_niveau_maximum = BLOC( condition = " (ADAPTATION == 'RAFF_DERA') or \
                                         (ADAPTATION == 'RAFFINEMENT') or \
                                         (ADAPTATION == 'RAFFINEMENT_UNIFORME') or \
                                         (ADAPTATION == 'RAFFINEMENT_ZONE') " ,
                           fr="Niveau maximum de profondeur de raffinement",
                           ang="Maximum level for refinement",
    NIVE_MAX = SIMP(statut='f',typ='I',
                    fr="Niveau maximum de profondeur de raffinement",
                    ang="Maximum level for refinement"),
  ) ,
#
# 9.2. Pour le deraffinement :
#
  b_niveau_minimum = BLOC( condition = " (ADAPTATION == 'RAFF_DERA') or \
                                         (ADAPTATION == 'DERAFFINEMENT') or \
                                         (ADAPTATION == 'DERAFFINEMENT_UNIFORME') " ,
                           fr="Niveau minimum de profondeur de déraffinement",
                           ang="Minimum level for unrefinement",
    NIVE_MIN = SIMP(statut='f',typ='I',
                    fr="Niveau minimum de profondeur de déraffinement",
                    ang="Minimum level for unrefinement"),
  ) ,
#
# 10. Filtrage de l'adaptation par des groupes
#
  b_filtrage_par_des_groupes = BLOC( condition = " (ADAPTATION == 'RAFF_DERA') or \
                                                   (ADAPTATION == 'RAFFINEMENT') or \
                                                   (ADAPTATION == 'RAFFINEMENT_UNIFORME') or \
                                                   (ADAPTATION == 'RAFFINEMENT_ZONE') or \
                                                   (ADAPTATION == 'DERAFFINEMENT') or \
                                                   (ADAPTATION == 'DERAFFINEMENT_UNIFORME') " ,
                                fr="Filtrage de l'adaptation par des groupes.",
                                ang="Filtering of adaptation by groups.",
#
    GROUP_MA = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**',
                    fr="Liste des groupes de mailles pour le filtrage de l'adaptation.",
                    ang="List of groups of meshes for filtering of adaptation." ),  
#
    GROUP_NO = SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**',
                    fr="Liste des groupes de noeuds pour le filtrage de l'adaptation.",
                    ang="List of groups of nodes for filtering of adaptation." ),  
  ) ,
#
# 11. Suivi d'une frontiere
#
  MAILLAGE_FRONTIERE = SIMP(statut='f',typ=maillage_sdaster,
                           fr="Maillage de la frontiere à suivre",
                           ang="Boundary mesh" ),
#
  b_frontiere = BLOC( condition = " MAILLAGE_FRONTIERE != None " ,
                      fr="Information complémentaire sur la frontière",
                      ang="Further information about boundary",
#
    GROUP_MA_FRONT = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**',
                          fr="Liste des groupes de mailles définissant la frontière",
                          ang="Mesh groups which define the boundary" ),
#
  ) ,
#
# 12. Mise à jour de champs sur le nouveau maillage
#
  MAJ_CHAM = FACT(statut='f',max='**',
                  fr="Mise à jour de champs sur le nouveau maillage.",
                  ang="Updating of fields over the new mesh.",
#
# 12.1. Le nom du champ de grandeur qui contiendra le resultat de la mise a jour
#
    CHAM_MAJ = SIMP(statut='o',typ=CO,
                    fr="Nom du champ de grandeur qui contiendra le champ mis à jour",
                    ang="Name of the field for the updated field"),
#
# 12.2. Le type du champ qui contiendra le resultat de la mise a jour
#
    TYPE_CHAM = SIMP(statut='o',typ='TXM',into=C_TYPE_CHAM_INTO(),
                     fr="Type du champ qui contiendra le champ mis à jour",
                     ang="Type of the field for the updated field" ),
#
# 12.3. Le champ a interpoler
#
    regles=(UN_PARMI('CHAM_GD','RESULTAT')),
#
# 12.3.1. Sous forme de champ de grandeur
#
    CHAM_GD = SIMP(statut='f',typ=cham_gd_sdaster,
                   fr="Champ de grandeur Code_Aster contenant le champ à mettre à jour",
                   ang="Champ de grandeur with field to be updated" ),
#
# 12.3.2. Sous forme de champ dans un resultat
#
    RESULTAT = SIMP(statut='f',typ=(evol_elas,evol_noli,evol_ther),
                    fr="Resultat contenant le champ à mettre à jour",
                    ang="Result with field to be updated" ),
#
    b_nom_du_champ = BLOC(condition="(RESULTAT != None)",
                          fr="Choix éventuel du nom du champ à interpoler",
                          ang="Selection for the name of the field (option)",
#
      NOM_CHAM = SIMP(statut='o',typ='TXM',
                      fr="Nom du champ à mettre à jour",
                      ang="Name of the field to be updated" ),
#
    ),
#
# 12.4. Est-ce un champ dérivé
#
    SENSIBILITE = SIMP(statut='f',typ=(para_sensi,theta_geom),
                       fr="Paramètre de sensibilité.",
                       ang="Sensitivity parameter"),
#
# 12.5. Le paramètre temporel pour le champ a interpoler
#
    b_parametre_temporel = BLOC(condition="(RESULTAT != None)",
                                fr="Choix éventuel du paramètre temporel pour le champ à interpoler",
                                ang="Time selection for the field (option)",
#
      regles=(EXCLUS('NUME_ORDRE','INST'),),
#
# 12.5.1. Soit le numero d'ordre
#
      NUME_ORDRE = SIMP(statut='f',typ='I',
                        fr="Numero d ordre du champ à mettre à jour",
                        ang="Rank of the field to be updated" ),
#
# 12.5.2. Soit l'instant
# 12.5.2.1. Sa valeur
#
      INST = SIMP(statut='f',typ='R',
                  fr="Instant associé",
                  ang="Instant" ),
#
# 12.5.2.2. La précision du choix de l'instant
#
      b_precision = BLOC(condition="(INST != None)",
                         fr="Choix de la précision du choix de l'instant",
                         ang="Selection for instant choice",
#
        CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),
                         fr="Critère de précision sur le choix de l'instant associé",
                         ang="Accuracy criterium over instant choice"),
        b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
            PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,
                             fr="Précision relative sur le choix de l'instant associé",
                             ang="Relative accuracy over instant choice"),),
        b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
            PRECISION       =SIMP(statut='o',typ='R',
                             fr="Précision absolue sur le choix de l'instant associé",
                             ang="Absolute accuracy over instant choice"),),
#
      ),
#
    ),
  ),
#
# 13. Les options d'analyse de maillage ; par defaut, on ne fait que les nombres
# 13.1. Nombre de noeuds et éléments
#
  NOMBRE         = SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON"),
                          fr="Nombre de noeuds et éléments du maillage",
                          ang="Number of nodes and éléments in the mesh" ),
#
# 13.2. Determination de la qualité des éléments du maillage
#
  QUALITE        = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),
                          fr="Qualité du maillage",
                          ang="Mesh quality" ),
#
# 13.3. Connexite du maillage
#
  CONNEXITE      = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),
                          fr="Connexité du maillage.",
                          ang="Mesh connexity." ),
#
# 13.4. Taille des sous-domaines du maillage
#
  TAILLE         = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),
                          fr="Tailles des sous-domaines du maillage.",
                          ang="Sizes of mesh sub-domains." ),
#
# 13.5. Controle de la non-interpenetration des éléments
#
  INTERPENETRATION= SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),
                          fr="Controle de la non interpénétration des éléments.",
                          ang="Overlapping checking." ),
#
# 14. Gestion des éléments autres que ceux compatibles avec HOMARD
#       "REFUSER" : ils sont refuses (defaut)
#       "IGNORER" : ils sont ignorés
#
  ELEMENTS_NON_HOMARD = SIMP(statut='f',typ='TXM',defaut="REFUSER",into=("REFUSER","IGNORER"),
                             fr="Acceptation d'éléments incompatibles avec HOMARD",
                             ang="Incompatible elements for HOMARD" ),
#
) ;
