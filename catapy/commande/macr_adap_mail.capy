#& MODIF COMMANDE  DATE 28/06/2011   AUTEUR COURTOIS M.COURTOIS 
# -*- coding: iso-8859-1 -*-
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2011  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# RESPONSABLE GNICOLAS G.NICOLAS



def macr_adap_mail_prod(self, MAJ_CHAM, ADAPTATION, **args):
#
# 0. Typage des structures produites
#
  maillage_np1=args['MAILLAGE_NP1']
  self.type_sdprod(maillage_np1,maillage_sdaster)
#
  if ( args['MAILLAGE_NP1_ANNEXE'] is not None ) :
    maillage_np1_annexe=args['MAILLAGE_NP1_ANNEXE']
    self.type_sdprod(maillage_np1_annexe,maillage_sdaster)
#
  if MAJ_CHAM == None:return None
# Remarque : la liste qui suit doit etre conforme à son homologue de LIRE_CHAMP
  for ch in MAJ_CHAM:
    t=ch['TYPE_CHAM']
    if t[0:5] == "NOEU_":self.type_sdprod(ch['CHAM_MAJ'],cham_no_sdaster)
    if t[0:2] == "EL":   self.type_sdprod(ch['CHAM_MAJ'],cham_elem)
  return None


MACR_ADAP_MAIL=MACRO(nom="MACR_ADAP_MAIL",
                     op=OPS('Macro.macr_adap_mail_ops.macr_adap_mail_ops'),
                     sd_prod=macr_adap_mail_prod,
                     fr="Adapter un maillage avec le logiciel HOMARD.",
                     ang="Mesh adaptation with the HOMARD software.",
                     UIinfo={"groupes":("Maillage",)},
#
# 1. Le niveau d'information
#
  INFO = SIMP(statut='f',typ='I',defaut=1,into=(1,2,3,4)),
#
# 2. Version de HOMARD
#
  VERSION_HOMARD = SIMP(statut='f',typ='TXM',defaut="V10_1",
                        into=("V10_1", "V10_N", "V10_N_PERSO"),
                        fr="Version de HOMARD",
                        ang="HOMARD release"),
#
# 3. Langue des messages produits par HOMARD
#
  LANGUE = SIMP(statut='f',typ='TXM',defaut="FRANCAIS",
                into=("FRANCAIS","FRENCH","ANGLAIS","ENGLISH",),
                fr="Langue des messages produits par HOMARD.",
                ang="Language for the HOMARD messages." ),
#
# 4. Les maillages
# 4.1. Quel que soit le type de traitement, il faut donner  :
#      A. Le concept du maillage initial (entree)
#      B. Le concept du maillage final (sortie)
#
  MAILLAGE_N   = SIMP(statut='o',typ=maillage_sdaster,
                      fr="Maillage avant adaptation",
                      ang="Mesh before adaptation" ),
#
  MAILLAGE_NP1 = SIMP(statut='o',typ=CO,
                      fr="Maillage après adaptation",
                      ang="Mesh after adaptation" ),
#
# 4.2. Eventuellement, on peut produire un maillage annexe
#      Actuellement, c'est le maillage n+1, mais de degré différent.
#
  MAILLAGE_NP1_ANNEXE = SIMP(statut='f',typ=CO,
                             fr="Maillage annexe après adaptation",
                             ang="Additional mesh after adaptation" ),
#
# 5. Le pilotage de l'adaptation, avec les variantes suivantes :
#  . Raffinement et deraffinement, selon un champ
#  . Raffinement seul, selon un champ
#  . Deraffinement seul, selon un champ
#  . Raffinement seul, selon des zones geometriques
#  . Raffinement uniforme : toutes les mailles sont divisées
#  . Deraffinement uniforme : toutes les mailles sont regroupées
#  . Modification : le maillage subit des transformations specifiques
#  . Rien : le maillage est le meme a la sortie et a l'entree
#
  ADAPTATION = SIMP(statut='o',typ='TXM',
                    into=("RAFF_DERA","RAFFINEMENT","DERAFFINEMENT","RAFFINEMENT_ZONE", \
                          "RAFFINEMENT_UNIFORME","DERAFFINEMENT_UNIFORME", \
                          "MODIFICATION","RIEN"),
                    fr="Pilotage de l'adaptation : selon un champ ou uniforme.",
                    ang="Adaptation control : either among an field or uniform" ),
#
# 6. Pour de l'adaptation libre, il faut un champ ou une zone
#
  b_champ = BLOC( condition = " (ADAPTATION == 'RAFF_DERA') or \
                                (ADAPTATION == 'RAFFINEMENT') or \
                                (ADAPTATION == 'DERAFFINEMENT') " ,
                  fr="Pour une adaptation libre, choix du champ ou d'une zone à raffiner",
                  ang="For a free adaptation, selection of the field or of a zone",
#
    regles=(UN_PARMI('CHAM_GD','RESULTAT_N')),
#
# 6.1. Reperage de la zone a raffiner a l'aide d'un champ
#
# 6.1.1. Sous forme de champ de grandeur
#
    CHAM_GD    = SIMP(statut='f',typ=cham_gd_sdaster,
                      fr="Champ de grandeur Code_Aster pilotant l'adaptation",
                      ang="Code_Aster 'champ de grandeur' governing the adapatation" ),
#
# 6.1.2. Sous forme de concept resultat_sdaster
#
    RESULTAT_N = SIMP(statut='f',typ=(evol_elas,evol_noli,evol_ther) ,
                      fr="Concept résultat Code_Aster contenant le champ",
                      ang="The Code_Aster result with the field" ),
#
    b_champ_adaptation = BLOC(condition="(RESULTAT_N != None)",
      NOM_CHAM = SIMP(statut='o',typ='TXM',into=C_NOM_CHAM_INTO(),
                        fr="Champ dans le résultat",
                        ang="The field in the result structure" ),
    ),
#
# 6.1.3. Est-ce un champ derive
#
    b_sensibilite = BLOC(condition=" (RESULTAT_N != None) or (CHAM_GD != None) ",
                        fr="Est-ce un champ dérivé",
                        ang="Is the field a derivative field",
#
      SENSIBILITE = SIMP(statut='f',typ=(para_sensi,theta_geom),
                         fr="Paramètre de sensibilité.",
                         ang="Sensitivity parameter")
#
    ),
#
# 6.1.4. La ou les composantes retenues
#
    b_composante = BLOC(condition=" (RESULTAT_N != None) or (CHAM_GD != None) ",
                        fr="Choix de la composante ou des composantes pour le champ",
                        ang="Selection of the component(s) for the field",
#
      NOM_CMP = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**',
                            fr="Liste des composante(s) retenue(s) pour le champ.",
                            ang="List of the selected component(s) for the field." ),
#
    ),
#
# 6.1.5. Le paramètre temporel pour le champ
#
    b_parametre_temporel = BLOC(condition="(RESULTAT_N != None)",
                                fr="Choix éventuel du paramètre temporel pour le champ",
                                ang="Time selection for the field (option)",
#
      regles=(EXCLUS('NUME_ORDRE','INST'),),
#
# 6.1.5.1. Soit le numero d'ordre
#
      NUME_ORDRE = SIMP(statut='f',typ='I',
                        fr="Numéro d ordre",
                        ang="Rank" ),
#
# 6.1.5.2. Soit l'instant
# 6.1.5.2.1. Sa valeur
#
      INST       = SIMP(statut='f',typ='R',
                        fr="Instant associé",
                        ang="Instant" ),
#
# 6.1.5.2.2. La précision du choix de l'instant
#
      b_precision = BLOC(condition="(INST != None)",
                         fr="Choix de la précision du choix de l'instant",
                         ang="Precision for the choice of the instant",
        CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),
                         fr="Critère de précision sur le choix de l'instant associé",
                         ang="Accuracy criterium over the choice of the instant"),
        b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
            PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,
                             fr="Précision relative sur le choix de l'instant associé",
                             ang="Relative accuracy over the choice of the instant"),),
        b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
            PRECISION       =SIMP(statut='o',typ='R',
                             fr="Précision absolue sur le choix de l'instant associé",
                             ang="Absolute accuracy over the choice of the instant"),),
      ),
#
    ),
#
# 6.1.6. Usage des composantes : maximum, maximum de la valeur absolue, ou de la norme L2, ou de la norme infinie
#
    b_usage_cmp = BLOC(condition=" (RESULTAT_N != None) or (CHAM_GD != None) ",
                       fr="Type d'usage de(s) composante(s)",
                       ang="Type of the use for the component(s)",
#
      USAGE_CMP = SIMP(statut='f',typ='TXM',defaut="NORME_L2",
                       into=("ABSOLU", "NORME_L2", "NORME_INFINIE", "RELATIF"),
                       fr="Valeur absolue de la composante, ou norme du champ, ou valeur relative de la composante",
                       ang="Absolute value of the component, or norm of the field, or relative value of the component" ),
#
    ),
#
# 6.1.7. Usage du champ : la valeur par maille ou le max du saut entre mailles
#
    b_usage_champ = BLOC(condition=" (RESULTAT_N != None) or (CHAM_GD != None) ",
                         fr="Usage du champ : par maille ou saut entre mailles voisines",
                         ang="Use type for the field : direct or jump",
#
      USAGE_CHAMP = SIMP(statut='f',typ='TXM',defaut="MAILLE",into=("MAILLE","SAUT"),
                         fr="Usage du champ : la valeur par maille ou le saut entre mailles voisines",
                         ang="Use of the field : value over every mesh or jump between the neighbours" ),
#
    ),
#
  ) ,
#
# 7. Les criteres pour de l'adaptation libre avec un champ :
#        absolu, relatif, en proportion d'entite
# 7.1. Pour le raffinement :
#
  b_critere_de_raffinement = BLOC( condition = " (ADAPTATION == 'RAFF_DERA') or \
                                                 (ADAPTATION == 'RAFFINEMENT') " ,
                                fr="Critère de raffinement.",
                                ang="Refinement threshold.",
#
    regles=(UN_PARMI ( 'CRIT_RAFF_ABS', 'CRIT_RAFF_REL', 'CRIT_RAFF_PE' ),),
#
    CRIT_RAFF_ABS = SIMP(statut='f',typ='R',
                         fr="Critère absolu",
                         ang="Absolute threshold" ),
    CRIT_RAFF_REL = SIMP(statut='f',typ='R',
                         fr="Critère relatif : fraction réelle entre 0. et 1.",
                         ang="Relative threshold : ratio between 0. and 1." ),
    CRIT_RAFF_PE  = SIMP(statut='f',typ='R',
                         fr="Pourcentage de mailles : fraction réelle entre 0. et 1.",
                         ang="Percentage of meshes : ratio between 0. and 1." ),
  ) ,
#
# 7.2. Pour le deraffinement :
#
  b_critere_de_deraffinement = BLOC( condition = " (ADAPTATION == 'RAFF_DERA') or \
                                                   (ADAPTATION == 'DERAFFINEMENT') " ,
                                     fr="Critère de déraffinement.",
                                     ang="Unrefinement threshold.",
#
    regles=(UN_PARMI ( 'CRIT_DERA_ABS', 'CRIT_DERA_REL', 'CRIT_DERA_PE' ),),
#
    CRIT_DERA_ABS = SIMP(statut='f',typ='R' ,
                         fr="Critère absolu",
                         ang="Absolute threshold" ),
    CRIT_DERA_REL = SIMP(statut='f',typ='R',
                         fr="Critère relatif : fraction réelle entre 0. et 1.",
                         ang="Relative threshold : ratio between 0. and 1." ),
    CRIT_DERA_PE  = SIMP(statut='f',typ='R',
                         fr="Pourcentage de mailles : fraction réelle entre 0. et 1.",
                         ang="Percentage of meshes : ratio between 0. and 1." ),
  ) ,
#
# 8. Pour de l'adaptation par zone, définitions des zones
#
  b_zone = BLOC( condition = " (ADAPTATION == 'RAFFINEMENT_ZONE') " ,
                 fr="Pour une adaptation selon une zone à raffiner",
                 ang="For adaptation among a zone",
#
    ZONE = FACT(statut='o',min=1,max='**',
                fr="Définition de zones à raffiner.",
                ang="Refined zone definition.",
#
# 8.1. Type de la zone
#
      TYPE = SIMP(statut='o',typ='TXM',into=("RECTANGLE", "BOITE", "DISQUE", "SPHERE", "CYLINDRE", "DISQUE_PERCE", "TUYAU"),
                  fr="Type de la zone",
                  ang="Type of the zone" ),
#
# Ne sachant pas exploiter les blocs, je mets des regles
#
      regles=(AU_MOINS_UN('X_MINI','X_CENTRE','HAUTEUR'),
              EXCLUS('X_MINI','X_CENTRE','HAUTEUR',),
              EXCLUS('Z_MINI','X_CENTRE','HAUTEUR',),
              EXCLUS('X_MINI','Z_CENTRE','HAUTEUR',),
              EXCLUS('Z_MINI','Z_CENTRE','HAUTEUR',),
              EXCLUS('X_MINI','RAYON',),
              EXCLUS('Z_MINI','RAYON',),
              EXCLUS('X_MINI','X_CENTRE','RAYON_INT',),
              EXCLUS('Z_MINI','X_CENTRE','RAYON_INT',),
              EXCLUS('X_MINI','X_CENTRE','RAYON_EXT',),
              EXCLUS('Z_MINI','X_CENTRE','RAYON_EXT',),
              EXCLUS('RAYON','RAYON_INT',),),
#
# 8.2. Une boite rectangulaire ou parallelepipedique
# 8.2.1. Incontournables
#
##gn      b_z_boiteXY = BLOC( condition = " (TYPE == 'RECTANGLE') or (TYPE == 'BOITE') " ,
##gn                          fr="X et Y mini/maxi pour un rectangle ou un parallelepipede.",
##gn                          ang="X and Y min/max for a rectangle or a parallelepipedic box",
      X_MINI = SIMP(statut='f',typ='R',
                    fr="Abscisse minimum de la boite",
                    ang="Minimum X for the box"),
      X_MAXI = SIMP(statut='f',typ='R',
                    fr="Abscisse maximum de la boite",
                    ang="Maximum X for the box"),
      Y_MINI = SIMP(statut='f',typ='R',
                    fr="Ordonnée minimum de la boite",
                    ang="Minimum Y for the box"),
      Y_MAXI = SIMP(statut='f',typ='R',
                      fr="Abscisse maximum de la boite",
                      ang="Maximum Y for the box"),
##gn      ) ,
#
# 8.2.2. Complement pour une boite parallelepipedique
#
##gn      b_z_boiteZ = BLOC( condition = " (TYPE == 'BOITE') " ,
##gn                         fr="Z mini/maxi pour un parallelepipede.",
##gn                         ang="Z min/max for a parallelepipedic box",
      Z_MINI = SIMP(statut='f',typ='R',
                    fr="Cote minimum de la boite",
                    ang="Minimum Z for the box"),
      Z_MAXI = SIMP(statut='f',typ='R',
                    fr="Cote maximum de la boite",
                    ang="Maximum Z for the box"),
##gn      ) ,
#
# 8.3. Rayon pour un disque, une sphere ou un cylindre
#
##gn      b_z_rayon = BLOC( condition = " (TYPE == 'DISQUE') or (TYPE == 'SPHERE') or (TYPE == 'CYLINDRE') " ,
##gn                        fr="Le rayon d'un disque, d'une sphere ou d'un cylindre.",
##gn                        ang="The radius of a disk or of a sphere or of a cylinder.",
      RAYON = SIMP(statut='f',typ='R',
                   fr="Rayon",
                   ang="Radius"),
##gn      ) ,
#
# 8.4. Pour un disque plein ou perce, une sphere
# 8.4.1. Incontournables
#
##gn      b_z_di_sp_XY = BLOC( condition = " (TYPE == 'DISQUE') or (TYPE == 'SPHERE') or (TYPE == 'DISQUE_PERCE') " ,
##gn                           fr="X et Y du centre d'un disque plein ou perce, d'une sphere.",
##gn                           ang="X and Y of the centre of a disk or of a sphere.",
      X_CENTRE = SIMP(statut='f',typ='R',
                      fr="Abscisse du centre du disque ou de la sphère",
                      ang="X for the center of the disk or of the sphere"),
      Y_CENTRE = SIMP(statut='f',typ='R',
                      fr="Ordonnée du centre du disque ou de la sphère",
                      ang="Y for the center of the disk or of the sphere"),
##gn      ) ,
#
# 8.4.2. Complement pour une sphere
#
##gn      b_z_sp_Z = BLOC( condition = " (TYPE == 'SPHERE') " ,
##gn                       fr="Cote du centre de la sphere.",
##gn                       ang="Z for the center of the sphere.",
       Z_CENTRE = SIMP(statut='f',typ='R',
                       fr="Cote du centre de la sphère",
                       ang="Z for the center of the sphere"),
##gn      ) ,
#
# 8.5. Rayons interieur et exterieur pour un disque perce ou un tuyau
#
##gn      b_z_rayon_int_ext = BLOC( condition = " (TYPE == 'DISQUE_PERCE') or (TYPE == 'TUYAU') " ,
##gn                                fr="Le rayon d'un disque perce ou d'un tuyau.",
##gn                                ang="The radius of a holed disk or of a pipe.",
      RAYON_INT = SIMP(statut='f',typ='R',
                       fr="Rayon intérieur",
                       ang="Internal radius"),
      RAYON_EXT = SIMP(statut='f',typ='R',
                       fr="Rayon extérieur",
                       ang="External radius"),
##gn      ) ,
#
# 8.6. Un cylindre ou un tuyau
#
##gn      b_z_cylindre_tuyau = BLOC( condition = " (TYPE == 'CYLINDRE') or (TYPE == 'TUYAU') " ,
##gn                                 fr="Pour un cylindre ou un tuyau.",
##gn                                 ang="For a cylinder or a pipe.",
      X_AXE = SIMP(statut='f',typ='R',
                   fr="Abscisse du vecteur directeur de l'axe",
                   ang="X for the axial vector"),
      Y_AXE = SIMP(statut='f',typ='R',
                   fr="Ordonnée du vecteur directeur de l'axe",
                   ang="Y for the axial vector"),
      Z_AXE = SIMP(statut='f',typ='R',
                   fr="Cote du vecteur directeur de l'axe",
                   ang="Z for the axial vector"),
      X_BASE = SIMP(statut='f',typ='R',
                    fr="Abscisse d'un point de la base, sur l'axe",
                    ang="X for the basis, on the axis"),
      Y_BASE = SIMP(statut='f',typ='R',
                    fr="Ordonnée d'un point de la base, sur l'axe",
                    ang="Y for the basis, on the axis"),
      Z_BASE = SIMP(statut='f',typ='R',
                    fr="Cote d'un point de la base, sur l'axe",
                    ang="Z for the basis, on the axis"),
      HAUTEUR = SIMP(statut='f',typ='R',
                     fr="Hauteur",
                     ang="Height"),
##gn     ) ,
#
    ) ,
#
  ) ,
#
# 9. Les niveaux extremes pour le maillage adapte
# 9.1. Pour le raffinement :
#
  b_niveau_maximum = BLOC( condition = " (ADAPTATION == 'RAFF_DERA') or \
                                         (ADAPTATION == 'RAFFINEMENT') or \
                                         (ADAPTATION == 'RAFFINEMENT_UNIFORME') or \
                                         (ADAPTATION == 'RAFFINEMENT_ZONE') " ,
                           fr="Profondeur maximale de raffinement",
                           ang="Maximum depth for the refinement",
#
    NIVE_MAX = SIMP(statut='f',typ='I',
                    fr="Niveau maximum de profondeur de raffinement",
                    ang="Maximum level for the refinement"),
#
    DIAM_MIN = SIMP(statut='f',typ='R',
                    fr="Diamètre minimal de maille",
                    ang="Minimal diameter for the mesh" ),
#
  ) ,
#
# 9.2. Pour le deraffinement :
#
  b_niveau_minimum = BLOC( condition = " (ADAPTATION == 'RAFF_DERA') or \
                                         (ADAPTATION == 'DERAFFINEMENT') or \
                                         (ADAPTATION == 'DERAFFINEMENT_UNIFORME') " ,
                           fr="Niveau minimum de profondeur de déraffinement",
                           ang="Minimum level for the unrefinement",
    NIVE_MIN = SIMP(statut='f',typ='I',
                    fr="Niveau minimum de profondeur de déraffinement",
                    ang="Minimum level for the unrefinement"),
  ) ,
#
# 10. Filtrage de l'adaptation par des groupes
#
  b_filtrage_par_des_groupes = BLOC( condition = " (ADAPTATION == 'RAFF_DERA') or \
                                                   (ADAPTATION == 'RAFFINEMENT') or \
                                                   (ADAPTATION == 'RAFFINEMENT_UNIFORME') or \
                                                   (ADAPTATION == 'RAFFINEMENT_ZONE') or \
                                                   (ADAPTATION == 'DERAFFINEMENT') or \
                                                   (ADAPTATION == 'DERAFFINEMENT_UNIFORME') " ,
                                fr="Filtrage de l'adaptation par des groupes.",
                                ang="Filtering of adaptation by the groups.",
#
    GROUP_MA = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**',
                    fr="Liste des groupes de mailles pour le filtrage de l'adaptation.",
                    ang="List of the groups of meshes for filtering of the adaptation." ),
#
    GROUP_NO = SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**',
                    fr="Liste des groupes de noeuds pour le filtrage de l'adaptation.",
                    ang="List of the groups of nodes for filtering of the adaptation." ),
  ) ,
#
# 11. Suivi d'une frontière
#
# 11.1. Definition d'une frontière par un maillage (valable seulement pour des frontières 1D)
#
  MAILLAGE_FRONTIERE = SIMP(statut='f',typ=maillage_sdaster,
                           fr="Maillage de la frontière discrète à suivre",
                           ang="Discrete boundary mesh" ),
#
  b_FRONTIERE = BLOC( condition = " MAILLAGE_FRONTIERE != None " ,
                      fr="Information complémentaire sur la frontière discrète",
                      ang="Further information about discrete boundary",
#
    GROUP_MA_FRONT = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**',
                          fr="Liste des groupes de mailles définissant la frontière discrète",
                          ang="Mesh groups which define the discrete boundary" ),
#
  ) ,
#
# 11.2. Definition analytique d'une frontière
#
  FRONTIERE_ANALYTIQUE = FACT(statut='f',max='**',
                              fr="Definition analytique de frontières a suivre.",
                              ang="Analytical definition of a boundary.",
#
# 11.2.1. Nom de la frontière
#
    NOM = SIMP(statut='o',typ='TXM',validators=NoRepeat(),max=1,
               fr="Nom de la frontière analytique",
               ang="Name of the analytic boundary" ),
#
# 11.2.2. Type de la frontière
#
    TYPE = SIMP(statut='o',typ='TXM',into=("SPHERE", "CYLINDRE"),
                fr="Type de la frontière analytique",
                ang="Type of the analytic boundary" ),
#
# 11.2.3. Pour une sphere ou un cylindre : rayon et centre
#
    b_fr_rayon = BLOC( condition = " (TYPE == 'SPHERE') or (TYPE == 'CYLINDRE') " ,
                       fr="Le rayon et le centre d'une sphère ou d'un cylindre.",
                       ang="The radius and the centre of a sphere or of a cylinder.",
      RAYON = SIMP(statut='o',typ='R',
                   fr="Rayon",
                   ang="Radius"),
      X_CENTRE = SIMP(statut='o',typ='R',
                      fr="Abscisse du centre",
                      ang="X for the center"),
      Y_CENTRE = SIMP(statut='o',typ='R',
                      fr="Ordonneée du centre",
                      ang="Y for the center"),
      Z_CENTRE = SIMP(statut='o',typ='R',
                      fr="Cote du centre",
                      ang="Z for the center"),
    ) ,
#
# 11.2.4. Complement pour un cylindre
#
    b_fr_cylindre = BLOC( condition = " (TYPE == 'CYLINDRE') " ,
                          fr="Pour un cylindre.",
                          ang="For a cylinder.",
      X_AXE = SIMP(statut='o',typ='R',
                   fr="Abscisse du vecteur directeur de l'axe",
                   ang="X for the axial vector"),
      Y_AXE = SIMP(statut='o',typ='R',
                   fr="Ordonnée du vecteur directeur de l'axe",
                   ang="Y for the axial vector"),
      Z_AXE = SIMP(statut='o',typ='R',
                   fr="Cote du vecteur directeur de l'axe",
                   ang="Z for the axial vector"),
    ) ,
#
# 11.2.5. Groupe(s) lie(s) a la frontière
#
    GROUP_MA = SIMP(statut='o',typ=grma,validators=NoRepeat(),max='**',
                    fr="Liste des groupes de mailles placées sur la frontière",
                    ang="Groups of meshes which are located on the boundary" ),
#
  ) ,
#
# 12. mise à jour de champs sur le nouveau maillage
#
  MAJ_CHAM = FACT(statut='f',max='**',
                  fr="Mise à jour de champs sur le nouveau maillage.",
                  ang="Updating of the fields over the new mesh.",
#
# 12.1. Le nom du champ de grandeur qui contiendra le resultat de la mise a jour
#
    CHAM_MAJ = SIMP(statut='o',typ=CO,
                    fr="Nom du champ de grandeur qui contiendra le champ mis à jour",
                    ang="Name of the field for the updated field"),
#
# 12.2. Le type du champ qui contiendra le resultat de la mise a jour
#
    TYPE_CHAM = SIMP(statut='o',typ='TXM',into=C_TYPE_CHAM_INTO( ('NOEU', 'ELNO', 'ELEM') ),
                     fr="Type du champ qui contiendra le champ mis à jour",
                     ang="Type of the field for the updated field" ),
#
# 12.3. Le champ a interpoler
#
    regles=(UN_PARMI('CHAM_GD','RESULTAT')),
#
# 12.3.1. Sous forme de champ de grandeur
#
    CHAM_GD = SIMP(statut='f',typ=cham_gd_sdaster,
                   fr="Champ de grandeur Code_Aster contenant le champ à mettre à jour",
                   ang="Champ de grandeur with the field to be updated" ),
#
# 12.3.2. Sous forme de champ dans un resultat
#
    RESULTAT = SIMP(statut='f',typ=(evol_elas,evol_noli,evol_ther),
                    fr="Résultat contenant le champ à mettre à jour",
                    ang="Result with the field to be updated" ),
#
    b_nom_du_champ = BLOC(condition="(RESULTAT != None)",
                          fr="Choix éventuel du nom du champ à interpoler",
                          ang="Selection for the name of the field (option)",
#
      NOM_CHAM = SIMP(statut='o',typ='TXM',into=C_NOM_CHAM_INTO(),
                      fr="Nom du champ à mettre à jour",
                      ang="Name of the field to be updated" ),
#
    ),
#
# 12.4. Les composantes
#
    NOM_CMP = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**',
                   fr="Liste des composante(s) retenue(s) pour le champ.",
                   ang="List of the selected component(s) for the field." ),
#
# 12.5. Le paramètre temporel pour le champ a interpoler
#
    b_parametre_temporel = BLOC(condition="(RESULTAT != None)",
                                fr="Choix éventuel du paramètre temporel pour le champ à interpoler",
                                ang="Time selection for the field (option)",
#
      regles=(EXCLUS('NUME_ORDRE','INST'),),
#
# 12.5.1. Soit le numero d'ordre
#
      NUME_ORDRE = SIMP(statut='f',typ='I',
                        fr="Numéro d ordre du champ à mettre à jour",
                        ang="Rank of the field to be updated" ),
#
# 12.5.2. Soit l'instant
# 12.5.2.1. Sa valeur
#
      INST = SIMP(statut='f',typ='R',
                  fr="Instant associé",
                  ang="Instant" ),
#
# 12.5.2.2. La précision du choix de l'instant
#
      b_precision = BLOC(condition="(INST != None)",
                         fr="Choix de la précision du choix de l'instant",
                         ang="Selection for the choice of the instant",
#
        CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),
                         fr="Critère de précision sur le choix de l'instant associé",
                         ang="Accuracy criterium over the choice of the instant"),
        b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
            PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,
                             fr="Précision relative sur le choix de l'instant associé",
                             ang="Relative accuracy over the choice of the instant"),),
        b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
            PRECISION       =SIMP(statut='o',typ='R',
                             fr="Précision absolue sur le choix de l'instant associé",
                             ang="Absolute accuracy over the choice of the instant"),),
#
      ),
#
    ),
#
# 12.6. Type d'interpolation
#
    TYPE_MAJ = SIMP(statut='f',typ='TXM',defaut="AUTO",
                    into=("AUTO", "ISOP2"),
                    fr="Type de mise à jour : automatique ou iso-P2",
                    ang="Type of the updating" ),
#
# 12.7. Est-ce un champ dérivé
#
    SENSIBILITE = SIMP(statut='f',typ=(para_sensi,theta_geom),
                       fr="Paramètre de sensibilité.",
                       ang="Sensitivity parameter"),
  ),
#
# 13. Les Modifications
#
  b_modifications = BLOC( condition = " (ADAPTATION == 'MODIFICATION') " ,
                          fr="Modification de maillage.",
                          ang="Modification of the mesh.",
#
      #regles=(AU_MOINS_UN('DEGRE','JOINT'),),
#
# 13.1. Changement de degre
#
      DEGRE         = SIMP(statut='o',typ='TXM',defaut="NON",into=("OUI","NON"),
                          fr="Changement de degré du maillage",
                          ang="Modification of the degree of the mesh" ),
#
# 13.2. Création des joints
#
      #JOINT         = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),
                          #fr="Creations des joints",
                          #ang="Creation of the junctions" ),
#
  ) ,
#
# 14. Les options d'analyse de maillage ; par defaut, on ne fait que les nombres
# 14.1. Nombre de noeuds et mailles
#
  NOMBRE         = SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON"),
                        fr="Nombre de noeuds et de mailles du maillage",
                        ang="Number of nodes and meshes in the mesh" ),
#
# 14.2. Determination de la qualité des mailles du maillage
#
  QUALITE        = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),
                        fr="Qualité du maillage",
                        ang="Quality of the mesh" ),
#
# 14.3. Connexite du maillage
#
  CONNEXITE      = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),
                        fr="Connexité du maillage.",
                        ang="Connexity of the mesh." ),
#
# 14.4. Taille des sous-domaines du maillage
#
  TAILLE         = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),
                        fr="Tailles des sous-domaines du maillage.",
                        ang="Sizes of mesh sub-domains." ),
#
# 14.5. Controle de la non-interpenetration des mailles
#
  INTERPENETRATION=SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),
                        fr="Controle de la non interpénétration des mailles.",
                        ang="Overlapping checking." ),
#
# 14.6. Propriétés du maillage de calcul
#
  PROP_CALCUL    = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),
                        fr="Propriétés du maillage de calcul.",
                        ang="Properties of the calculation mesh." ),
#
# 15. Unite logique d'un fichier a ajouter a HOMARD.Configuration
#
  b_unite = BLOC( condition = " (VERSION_HOMARD == 'V10_N') or \
                                (VERSION_HOMARD == 'V10_N_PERSO') " ,
                                fr="Fichier supplémentaire.",
                                ang="Additional file.",
#
  UNITE = SIMP(statut='f',typ='I',
               fr="Unite logique du fichier à ajouter à HOMARD.Configuration",
               ang="Additional file to HOMARD.Configuration" ),
#
  ) ,
#
# 16. Gestion des mailles autres que celles compatibles avec HOMARD
#       "REFUSER" : elles sont refusées (defaut)
#       "IGNORER" : elles sont ignorées
#
  ELEMENTS_NON_HOMARD = SIMP(statut='f',typ='TXM',defaut="REFUSER",into=("REFUSER","IGNORER"),
                             fr="Acceptation de mailles incompatibles avec HOMARD",
                             ang="Incompatible meshes for HOMARD" ),
#
) ;
