#& MODIF COMMANDE  DATE 14/09/2004   AUTEUR MCOURTOI M.COURTOIS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE GNICOLAS G.NICOLAS

from Macro.macr_adap_mail_ops import macr_adap_mail_ops

def macr_adap_mail_prod(self,MAJ_CHAM,ADAPTATION,**args):
  maillage_np1=ADAPTATION['MAILLAGE_NP1']
  self.type_sdprod(maillage_np1,maillage_sdaster)
  if MAJ_CHAM == None:return None
# Remarque : la liste qui suit doit etre conforme à son homologue de LIRE_CHAMP
  for ch in MAJ_CHAM:
    t=ch['TYPE_CHAM']
    if t[0:5] == "NOEU_":self.type_sdprod(ch['CHAM_MAJ'],eval("cham_no_"+string.lower(t[5:])))
    if t == "ELEM_G_DEPL_R":self.type_sdprod(ch['CHAM_MAJ'],cham_elem_g_depl)
    if t[0:5] == "ELEM_":self.type_sdprod(ch['CHAM_MAJ'],eval("cham_elem_"+string.lower(t[5:])))
    if t == "ELNO_G_DEPL_R":self.type_sdprod(ch['CHAM_MAJ'],cham_elem_g_depl)
    if t[0:5] == "ELNO_":self.type_sdprod(ch['CHAM_MAJ'],eval("cham_elem_"+string.lower(t[5:])))
    if t == "ELGA_G_DEPL_R":self.type_sdprod(ch['CHAM_MAJ'],cham_elem_g_depl)
    if t[0:5] == "ELGA_":self.type_sdprod(ch['CHAM_MAJ'],eval("cham_elem_"+string.lower(t[5:])))
  return None

MACR_ADAP_MAIL=MACRO(nom="MACR_ADAP_MAIL",op=macr_adap_mail_ops,sd_prod=macr_adap_mail_prod,
                     fr="Adapter un maillage avec le logiciel HOMARD.",
                     ang="Mesh adaptation with HOMARD software.",
                     docu="U7.03.01-b",
#
# 1. Le niveau d'information
#
         INFO           = SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
#
# 2. Version de HOMARD
#
         VERSION_HOMARD = SIMP(statut='f',typ='TXM',defaut="V6_6",
                               into=("V6_6", "V6_N", "V6_N_PERSO"),
                           fr="Version de HOMARD",
                           ang="HOMARD release"),
#
# 3. Langue des messages issus de HOMARD
#
         LANGUE = SIMP(statut='f',typ='TXM',defaut="FRANCAIS",    
                               into=("FRANCAIS","FRENCH","ANGLAIS","ENGLISH",),
                           fr="Langue des messages issus de HOMARD.",
                           ang="Language for HOMARD messages." ),
#
# 4. Gestion des éléments autres que des simplexes
#       0 : autres elements refuses
#       1 : raffinement sur les simplexes, mais autres acceptes
#       2 : tous (defaut)
#
         NON_SIMPLEXE   = SIMP(statut='f',typ='I',defaut=2,into=(0,1,2),
                          fr="Type d'éléments acceptés.",
                          ang="Type of authorized elements." ),
#
# 5. Le type de traitement :
#
         ADAPTATION      =FACT(statut='o',
                           fr="Type d'adaptation",
                           ang="Type of adaptation",
#
# 5.1. Deux choix d'adaptation exclusifs :
#
# 5.1.
#      A. Selon un indicateur d'erreur, avec trois variantes :
#         . Raffinement et deraffinement
#         . Raffinement seul
#         . Deraffinement seul
#      B. Uniforme, avec trois variantes :
#         . Raffinement seul
#         . Deraffinement seul
#         . Rien : le maillage est le meme a la sortie et a l'entree
#
           regles=(
                   UN_PARMI('LIBRE','UNIFORME'),
                  ),
           LIBRE          = SIMP(statut='f',typ='TXM',
                                 into=("RAFF_DERA","RAFFINEMENT","DERAFFINEMENT"),    
                           fr="Adaptation selon un indicateur d'erreur.",
                           ang="Adaptation among an error indicator" ),
           UNIFORME       = SIMP(statut='f',typ='TXM',
                                 into=("RAFFINEMENT","DERAFFINEMENT","RIEN"),    
                           fr="Adaptation uniforme.",
                           ang="Uniform adaptation" ),
#
# 5.2. Quel que soit le type de traitement, il faut donner  :
#      A. Le concept du maillage initial
#      B. Le concept du maillage final
#
           MAILLAGE_N     = SIMP(statut='o',typ=maillage_sdaster,
                           fr="Maillage avant adaptation",
                           ang="Mesh before adaptation" ),
           MAILLAGE_NP1   = SIMP(statut='o',typ=(CO,maillage_sdaster),
                           fr="Maillage apres adaptation",
                           ang="Mesh after adaptation" ),
#
# 5.3. Pour de l'adaptation libre, il faut l'indicateur d'erreur
#
#
           b_indicateur_d_erreur   =BLOC( condition = " LIBRE != None " ,
                           fr="Choix de l'indicateur d'erreur",
                           ang="Selection of error indicator",
#
# 5.3.1. Le nom du concept resultat_sdaster
#
                           RESULTAT_N     = SIMP(statut='o',typ=(evol_elas,evol_noli,evol_ther) ,
                           fr="Concept resultat Code_Aster contenant l'indicateur d'erreur",
                           ang="Result with error indicator" ),
#
# 5.3.2. Le champ d'indicateur d'erreur
#
                           INDICATEUR     = SIMP(statut='o',typ='TXM',     
                           fr="Champ de l'indicateur d'erreur",
                           ang="Error indicator field" ),
#
# 5.3.3. La composante retenue
#
                           NOM_CMP_INDICA = SIMP(statut='o',typ='TXM',
                           fr="Composante retenue",
                           ang="Selected component" ),
#
# 5.3.4. Le paramètre temporel pour l'indicateur
#
                           regles=(EXCLUS('NUME_ORDRE','INST'),),
#
# 5.3.4.1. Soit le numero d'ordre
#
                           NUME_ORDRE     = SIMP(statut='f',typ='I',
                           fr="Numero d ordre",
                           ang="Rank" ),  
#
# 5.3.4.2. Soit l'instant
# 5.3.4.2.1. Sa valeur
#
                           INST           = SIMP(statut='f',typ='R',
                           fr="Instant associé",
                           ang="Instant" ),
#
# 5.3.4.2.2. La précision du choix de l'instant
#
                           b_precision     =BLOC(condition="(INST != None)",
                             PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-3,
                             fr="Précision sur le choix de l'instant associé",
                             ang="Accuracy over instant choice" ),
                             CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU"),
                             fr="Critère de précision sur le choix de l'instant associé",
                             ang="Accuracy criterium over instant choice" ),),
#
                           ) ,
#
# 5.4. Les criteres pour de l'adaptation libre :
#        absolu, relatif, en proportion d'entite
# 5.4.1. Pour le raffinement :
#
           b_critere_de_raffinement =BLOC( condition = " ( LIBRE == 'RAFF_DERA' ) or ( LIBRE == 'RAFFINEMENT' ) " ,
                           fr="Critère de raffinement.",
                           ang="Refinement threshold.",
                           regles=(UN_PARMI ( 'CRIT_RAFF_ABS', 'CRIT_RAFF_REL', 'CRIT_RAFF_PE' ),),
                           CRIT_RAFF_ABS  = SIMP(statut='f',typ='R',
                                                   fr="Critère absolu",
                                                   ang="Absolute threshold" ),  
                           CRIT_RAFF_REL  = SIMP(statut='f',typ='R',
                                                   fr="Critère relatif : fraction entre 0 et 1",
                                                   ang="Relative threshold : ratio between 0 and 1" ),  
                           CRIT_RAFF_PE   = SIMP(statut='f',typ='R',
                                                   fr="Pourcentage d'éléments : fraction entre 0 et 1",
                                                   ang="Percentage of elements : ratio between 0 and 1" ),  
                           ) ,
#
# 5.4.2. Pour le deraffinement :
#
           b_critere_de_deraffinement =BLOC ( condition = " ( LIBRE == 'RAFF_DERA' ) or ( LIBRE == 'DERAFFINEMENT' ) " ,
                           fr="Critère de déraffinement.",
                           ang="Unrefinement threshold.",
                           regles=(UN_PARMI ( 'CRIT_DERA_ABS', 'CRIT_DERA_REL', 'CRIT_DERA_PE' ),),
                           CRIT_DERA_ABS  = SIMP(statut='f',typ='R' ,
                                                 fr="Critère absolu",
                                                 ang="Absolute threshold" ),  
                           CRIT_DERA_REL  = SIMP(statut='f',typ='R',
                                                 fr="Critère relatif : fraction entre 0 et 1",
                                                 ang="Relative threshold : ratio between 0 and 1" ),  
                           CRIT_DERA_PE   = SIMP(statut='f',typ='R',
                                                 fr="Pourcentage d'éléments : fraction entre 0 et 1",
                                                 ang="Percentage of elements : ratio between 0 and 1" ),  
                           ) ,
#
# 5.5. Les niveaux extremes pour le maillage adapte
# 5.5.1. Pour le raffinement :
#
           b_niveau_maximum =BLOC ( condition = " ( LIBRE == 'RAFF_DERA' ) or ( LIBRE == 'RAFFINEMENT' ) or \
                                                  ( UNIFORME == 'RAFFINEMENT' ) " ,
                           fr="Niveau maximum de profondeur de raffinement",
                           ang="Maximum level for refinement",
                           NIVE_MAX       = SIMP(statut='f',typ='I' ),
                           ) ,
#
# 5.5.2. Pour le deraffinement :
#
           b_niveau_minimum =BLOC ( condition = " ( LIBRE == 'RAFF_DERA' ) or ( LIBRE == 'DERAFFINEMENT' ) or \
                                                  ( UNIFORME == 'DERAFFINEMENT' ) " ,
                           fr="Niveau minimum de profondeur de déraffinement",
                           ang="Minimum level for unrefinement",
                           NIVE_MIN       = SIMP(statut='f',typ='I' ),
                           ) ,
#
         ),
#
# 6. Suivi d'une frontiere
#
         MAILLAGE_FRONTIERE = SIMP(statut='f',typ=maillage_sdaster,
                           fr="Maillage de la frontiere à suivre",
                           ang="Boundary mesh" ),
#
         b_frontiere   =BLOC( condition = " MAILLAGE_FRONTIERE != None " ,
                           fr="Groupes définissant la frontière",
                           ang="Groups which define the boundary",
                           GROUP_MA       = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**' ),
                           ) ,
#
# 7. Mise à jour de champs sur le nouveau maillage
#
         MAJ_CHAM        =FACT(statut='f',max='**',
                           fr="Mise à jour de champs sur le nouveau maillage.",
                           ang="Updating of fields over the new mesh.",
#
# 7.1. Le nom du champ qui contiendra le resultat de la mise a jour
#
           CHAM_MAJ       = SIMP(statut='o',typ=(CO,cham_gd_sdaster),
                           fr="Nom du champ qui contiendra le champ mis à jour",
                           ang="Name of the field for the updated field"),
#
# 7.2. Le type du champ qui contiendra le resultat de la mise a jour
#
           TYPE_CHAM      = SIMP(statut='o',typ='TXM',into=C_TYPE_CHAM_INTO(),
                           fr="Type du champ qui contiendra le champ mis à jour",
                           ang="Type of the field for the updated field" ),
#
# 7.3. Le nom du resultat du champ a interpoler
#
           RESULTAT       = SIMP(statut='o',
                                 typ=(evol_elas,evol_noli,evol_ther),
                           fr="Resultat contenant le champ à mettre à jour",
                           ang="Result with field to be updated" ),
#
# 7.4. Le nom du champ a interpoler
#
           NOM_CHAM       = SIMP(statut='o',typ='TXM',
                           fr="Nom du champ à mettre à jour",
                           ang="Name of the field to be updated" ),
#
# 7.5. Le paramètre temporel pour le champ a interpoler
#
                           regles=(EXCLUS('NUME_ORDRE','INST'),),
#
# 7.5.1. Soit le numero d'ordre
#
           NUME_ORDRE     = SIMP(statut='f',typ='I',
                           fr="Numero d ordre du champ à mettre à jour",
                           ang="Rank of the field to be updated" ),
#
# 7.5.2. Soit l'instant
# 7.5.2.1. Sa valeur
#
           INST           = SIMP(statut='f',typ='R',
                           fr="Instant associé",
                           ang="Instant" ),
#
# 7.5.2.2. La précision du choix de l'instant
#
                           b_precision     =BLOC(condition="(INST != None)",
                             PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-3,
                             fr="Précision sur le choix de l'instant associé",
                             ang="Accuracy over instant choice" ),
                             CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU"),
                             fr="Critère de précision sur le choix de l'instant associé",
                             ang="Accuracy criterium over instant choice" ),),
         ),
#
# 8. Les options d'analyse de maillage ; par defaut, on ne fait que les nombres
# 8.1. Nombre de noeuds et éléments
#
         NOMBRE         = SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON"),
                          fr="Nombre de noeuds et éléments du maillage",
                          ang="Number of nodes and éléments in the mesh" ),
#
# 8.2. Determination de la qualité des éléments du maillage
#
         QUALITE        = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),
                          fr="Qualité du maillage",
                          ang="Mesh quality" ),
#
# 8.3. Connexite du maillage
#
         CONNEXITE      = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),
                          fr="Connexité du maillage.",
                          ang="Mesh connexity." ),
#
# 8.4. Taille des sous-domaines du maillage
#
         TAILLE         = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),
                          fr="Tailles des sous-domaines du maillage.",
                          ang="Sizes of mesh sub-domains." ),
#
# 8.5. Controle de la non-interpenetration des éléments
#
         INTERPENETRATION=SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),
                          fr="Controle de la non interpénétration des éléments.",
                          ang="Overlapping checking." ),
#
)  ;
