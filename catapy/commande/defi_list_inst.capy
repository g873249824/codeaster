#& MODIF COMMANDE  DATE 10/08/2010   AUTEUR GENIAUT S.GENIAUT 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2009  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# RESPONSABLE GENIAUT S.GENIAUT

DEFI_LIST_INST=OPER(nom="DEFI_LIST_INST",op=  28,sd_prod=list_inst,reentrant='n',
            UIinfo={"groupes":("Modélisation",)},
               fr="Définition de la gestion de la liste d'instants",


# ----------------------------------------------------------------------------------------------------------------------------------
# mot-cle pour la definition a priori de la liste d'instant
# ----------------------------------------------------------------------------------------------------------------------------------

    DEFI_LIST             =FACT(statut='o',max=1,

      METHODE  =SIMP(statut='o',typ='TXM',into=("MANUEL","AUTO",),defaut="MANUEL",max=1,position='global' ),

         b_manuel            =BLOC(condition = "METHODE == 'MANUEL' ",fr="Liste d'instants donnée par l'utilisateur",
           LIST_INST       =SIMP(statut='o',typ=listr8_sdaster),
                                  ),
                      
         b_auto              =BLOC(condition = "METHODE == 'AUTO' ",fr="a compléter",
           LIST_INST       =SIMP(statut='o',typ=listr8_sdaster),
           PAS_MINI    =SIMP(statut='o',typ='R',val_min=0.0,max=1),
           PAS_MAXI    =SIMP(statut='f',typ='R',max=1),
           NB_PAS_MAXI =SIMP(statut='f',typ='I',max=1),
                                  ),
           
#          b_cfl               =BLOC(condition = "METHODE  == 'CFL' ",fr="Liste d'instants construite sur condition CFL",
#            COEF            =SIMP(statut='f',typ='R',val_min=0.E+0,val_max=1.E+0,defaut=0.5),
#            MODELE          =SIMP(statut='o',typ=modele_sdaster),
#                                   ),

                               ),

# ----------------------------------------------------------------------------------------------------------------------------------
# mot-cle pour le comportement en cas d'echec (on doit recommencer le meme instant)
# ----------------------------------------------------------------------------------------------------------------------------------

    ECHEC  =FACT(statut='d',max='**',

      EVENEMENT     =SIMP(statut='f',typ='TXM',into=("DIVERGENCE",),defaut="DIVERGENCE",max=1 ),

      SUBD_METHODE    =SIMP(statut='f',typ='TXM',into =("AUCUNE","UNIFORME","EXTRAPOLE"),defaut="UNIFORME",max=1,
                            fr="Méthode de subdivision des pas de temps en cas de diconvergence"),

           b_subd_unif=BLOC(condition = "SUBD_METHODE == 'UNIFORME'",
             SUBD_COEF_PAS_1=SIMP(statut='f',typ='R',defaut=1.0,val_min=0.0,max=1,
                fr="Coefficient multiplicateur de la 1ère subdivision"),
             SUBD_PAS       =SIMP(statut='f',typ='I',defaut=4,val_min=2,max=1,
                fr="Nombre de subdivision d'un pas de temps"),
                
                b_subd_unif_manu  =   BLOC(condition="METHODE == 'MANUEL'",        
             regles=(AU_MOINS_UN('SUBD_NIVEAU','SUBD_PAS_MINI'),),
             SUBD_NIVEAU=SIMP(statut='f',typ='I',val_min=2,defaut=3,max=1,
                fr="Nombre maximum de niveau de subdivision d'un pas de temps"),
             SUBD_PAS_MINI=SIMP(statut='f',typ='R',defaut=0.,val_min=0.0,max=1,
                fr="Pas de temps en dessous duquel on ne subdivise plus"),
                                          ),         

                b_subd_unif_auto  =   BLOC(condition="METHODE == 'AUTO'",        
             SUBD_PAS_MINI=SIMP(statut='f',typ='R',defaut=0.,val_min=0.0,max=1,
                fr="Pas de temps en dessous duquel on ne subdivise plus"),
                                          ),         

             
                           ),

           b_subd_extr=BLOC(condition = "SUBD_METHODE == 'EXTRAPOLE'",
             SUBD_OPTION    =SIMP(statut='f',typ='TXM',
                into =("IGNORE_PREMIERES","GARDE_DERNIERES",),
                defaut="IGNORE_PREMIERES",
                fr="Technique d'extrapolation : les 1ere itérations sont ignorées ou les dernières sont gardées"),
             SUBD_ITER_IGNO =SIMP(statut='f',typ='I',defaut=3,val_min=3,max=1,
                fr="Les n premières itérations sont ignorées pour l'extrapolation"),
             SUBD_ITER_FIN  =SIMP(statut='f',typ='I',defaut=8,val_min=3,max=1,
                fr="Seules les n dernières itérations sont prises pour l'extrapolation"),
             SUBD_PAS       =SIMP(statut='f',typ='I',defaut=4,val_min=2,max=1,
                fr="Nombre de subdivision d'un pas de temps en cas divergence"),

                b_subd_unif_manu  =   BLOC(condition="METHODE == 'MANUEL'",        
             regles=(AU_MOINS_UN('SUBD_NIVEAU','SUBD_PAS_MINI'),),
             SUBD_NIVEAU=SIMP(statut='f',typ='I',val_min=2,max=1,
                fr="Nombre maximum de niveau de subdivision d'un pas de temps"),
             SUBD_PAS_MINI=SIMP(statut='f',typ='R',defaut=0.,val_min=0.0,max=1,
                fr="Pas de temps en dessous duquel on ne subdivise plus"),
                                          ),         

                b_subd_unif_auto  =   BLOC(condition="METHODE == 'AUTO'",        
             SUBD_PAS_MINI=SIMP(statut='f',typ='R',defaut=0.,val_min=0.0,max=1,
                fr="Pas de temps en dessous duquel on ne subdivise plus"),
                                          ),         

             SUBD_ITER_PLUS =SIMP(statut='f',typ='I',defaut=50,val_min=20,max=1,
                fr="% itération autorisée en plus"),
                            ),

               ),

# ----------------------------------------------------------------------------------------------------------------------------------
# mot-cle pour le comportement en cas de succes (on a bien converge)
# ----------------------------------------------------------------------------------------------------------------------------------

  b_adap  =   BLOC(condition="METHODE == 'AUTO'",

    ADAPTATION  =FACT(statut='d',max='**',

#     1) parametres de l'evenement declencheur
#     ----------------------------------------

      EVENEMENT       =SIMP(statut='f',typ='TXM',into=("SEUIL","TOUT_INST","AUCUN"),defaut="SEUIL",max=1 ),

         b_adap_seuil       =BLOC(condition = "EVENEMENT == 'SEUIL' ",fr="seuil de re-decoupe",           

#          FORMULE_SEUIL          =SIMP(statut='f',typ=formule),

#          b_adap_seuil_nf   =   BLOC(condition="FORMULE_SEUIL == None",
#              critere : si on fait NB_INCR_SEUIL fois de suite des increments verifiant le critere
               regles=(PRESENT_PRESENT('NB_INCR_SEUIL','NOM_PARA',),
                       PRESENT_PRESENT('NB_INCR_SEUIL','CRIT_COMP',),
                       PRESENT_PRESENT('NB_INCR_SEUIL','CRIT_COMP',),),
               NB_INCR_SEUIL     =SIMP(statut='f',typ='I',defaut=2),
               NOM_PARA          =SIMP(statut='f',typ='TXM',into=("NB_ITER_NEWTON",),defaut="NB_ITER_NEWTON"),
               CRIT_COMP         =SIMP(statut='f',typ='TXM',into=("LT","GT","LE","GE"),defaut="LE"),
#                   b_vale_R           =BLOC(condition = "NOM_PARA == 'DP' ",fr="valeur reelle",           
#                VALE              =SIMP(statut='o',typ='R'),
#                                           ),
                  b_vale_I           =BLOC(condition = "NOM_PARA == 'NB_ITER_NEWTON' ",fr="valeur entiere",           
               VALE_I            =SIMP(statut='f',typ='I'),
                                          ),
#                                    ),
                                ),
                           
#     2) parametre du mode de calcul de dt+
#     ----------------------------------------

      MODE_CALCUL_TPLUS =SIMP(statut='f',typ='TXM',into=("FIXE","DELTA_GRANDEUR","ITER_NEWTON","FORMULE"),defaut='FIXE',max=1 ),
         b_mfixe           =BLOC(condition = "MODE_CALCUL_TPLUS == 'FIXE' ",fr="fixe",           
#      dans le cas FIXE :(deltaT+) = (deltaT-)x(1+PCENT_AUGM/100)
      PCENT_AUGM                 =SIMP(statut='f',typ='R',defaut=100.,val_min=-100.,max=1),
                               ),
         b_mdelta           =BLOC(condition = "MODE_CALCUL_TPLUS == 'DELTA_GRANDEUR' ",fr=" ",           
#      dans le cas DELTA_GRANDEUR : (deltaT+) = (deltaT-)x(VALREF/deltaVAL) : l'acceleration est inversement proportionnelle
#                                                                             a la variation de la grandeur
      VALE_REF          =SIMP(statut='o',typ='R',max=1),
      NOM_CHAM          =SIMP(statut='o',typ='TXM',into=("DEPL","VARI_ELGA","SIEF_ELGA",),max=1),
      NOM_CMP           =SIMP(statut='o',typ='TXM',max=1),
                                  ),
         b_mitnew           =BLOC(condition = "MODE_CALCUL_TPLUS == 'ITER_NEWTON' ",fr=" ",           
#      dans le cas ITER_NEWTON : (deltaT+) = (deltaT-) x sqrt(VALREF/N) : l'acceleration est inversement proportionnelle
#                                                                        au nombre d'iter de Newton precedent
      NB_ITER_NEWTON_REF          =SIMP(statut='o',typ='I',max=1),
                                  ),
         b_mformule           =BLOC(condition = "MODE_CALCUL_TPLUS == 'FORMULE' ",fr=" ",           
#      dans le cas FORMULE
           regles=UN_PARMI('FORMULE_TPLUS','NOM_SCHEMA'),
      FORMULE_TPLUS     =SIMP(statut='f',typ=formule),
      NOM_SCHEMA        =SIMP(statut='f',typ='TXM',into=("OLIVER",)),
                                   ),

# les schemas pre-definis :
#  abaqus : 
#      EVENEMENT       ='SEUIL'
#      NB_INCR_SEUIL     = 2
#      NOM_PARA          ='NB_ITER_NEWTON'
#      CRIT_COMP         ='LE'
#      VALE_I            = 5
#      MODE_CALCUL_TPLUS ='FIXE'
#      PCENT_AUGM        = 50.
#  Zebulon 1 : 
#      EVENEMENT       ='TOUT_INST'
#      MODE_CALCUL_TPLUS ='DELTA_GRANDEUR'
#      VALE_REF          = valref
#      NOM_CHAM          ='VARI_ELGA'
#      NOM_CMP           ='V1'
#  Zebulon 2 : 
#      EVENEMENT       ='TOUT_INST'
#      MODE_CALCUL_TPLUS ='ITER_NEWTON'
#      NB_ITER_NEWTON_REF= nc
#  Tough2 : 
#      EVENEMENT       ='SEUIL'
#      NB_INCR_SEUIL     = 1
#      NOM_PARA          ='NB_ITER_NEWTON'
#      CRIT_COMP         ='LE'
#      VALE_I            = n
#      MODE_CALCUL_TPLUS ='FIXE'
#      PCENT_AUGM        = 100.
#  Oliver : 
#      EVENEMENT       ='TOUT_INST'
#      MODE_CALCUL_TPLUS ='FORMULE'
#      NOM_SCHEMA        ='OLIVER'

             ),
      ),

# ----------------------------------------------------------------------------------------------------------------------------------

    INFO                  =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),

)  ;
      
