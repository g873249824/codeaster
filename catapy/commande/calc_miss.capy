#& MODIF COMMANDE  DATE 14/11/2012   AUTEUR LADIER A.LADIER 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2012  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# RESPONSABLE COURTOIS M.COURTOIS

def calc_miss_sdprod(self, TYPE_RESU, **kwargs):
    if TYPE_RESU == 'TABLE':
        return table_sdaster
    elif TYPE_RESU == 'HARM_GENE':
        return harm_gene
    elif TYPE_RESU == 'TRAN_GENE':
        return tran_gene
    else:
        return None

from Macro.calc_miss_ops import calc_miss_ops

CALC_MISS = MACRO(nom="CALC_MISS",
                  op=calc_miss_ops,
                  sd_prod=calc_miss_sdprod,
                  fr="Préparation des données, exécution du logiciel Miss3D, et post-traitement",
                  UIinfo={"groupes":("Résolution","Outils-métier",)},

    TYPE_RESU   = SIMP(statut='o', typ='TXM', into=('HARM_GENE', 'TRAN_GENE', 'TABLE', 'FICHIER'),
                       fr="Type de résultat produit en post-traitement. FICHIER : pas de post-traitement"),
    PROJET      = SIMP(statut='f', typ='TXM', defaut='MODELE',
                       fr="Nom de l'étude Miss"),
    REPERTOIRE  = SIMP(statut='f', typ='TXM',
                       fr="Répertoire de travail de Miss"),
    VERSION     = SIMP(statut='f', typ='TXM', into=("V6.6","V6.5"), defaut="V6.6",
                       fr="Version de Miss utilisée"),

    TABLE_SOL   = SIMP(statut='o', typ=table_sdaster,
                       fr="Table des propriétés du sol"),

    # pas de post-traitement
    b_fichier   = BLOC(condition="TYPE_RESU == 'FICHIER'",
                       regles=(UN_PARMI('MACR_ELEM_DYNA', 'BASE_MODALE'),),
        MACR_ELEM_DYNA  = SIMP(statut='f', typ=macr_elem_dyna,
                               fr="Macro élément produit en amont"),
        BASE_MODALE     = SIMP(statut='f', typ=mode_meca,
                               fr="Base de modes"),
        b_base_modale = BLOC(condition="BASE_MODALE is not None",
            MATR_RIGI       = SIMP(statut='f', typ=(matr_asse_depl_r, matr_asse_depl_c),),
            MATR_MASS       = SIMP(statut='f', typ=matr_asse_depl_r ),
        ),
        AMOR_REDUIT     = SIMP(statut='f', typ='R', max='**'),
        GROUP_MA_INTERF = SIMP(statut='o', typ=grma, max='**',
                               fr="Groupe de mailles de l'interface"),

        UNITE_IMPR_ASTER = SIMP(statut='f', typ='I', defaut=25,
                                fr="Unité des résultats transmis par Code_Aster à Miss"),
        UNITE_RESU_IMPE  = SIMP(statut='f', typ='I', defaut=38,
                                fr="Unité logique des impédances écrites par Miss"),
        UNITE_RESU_FORC  = SIMP(statut='f', typ='I', defaut=28,
                                fr="Unité logique des forces sismiques écrites par Miss"),
    ),
    # si post-traitement
    b_donnees   = BLOC(condition="TYPE_RESU != 'FICHIER'",
        MACR_ELEM_DYNA  = SIMP(statut='f', typ=macr_elem_dyna,
                               fr="Macro élément produit en amont"),
        BASE_MODALE     = SIMP(statut='o', typ=mode_meca,
                               fr="Base de modes"),
        MATR_RIGI       = SIMP(statut='o', typ=(matr_asse_depl_r, matr_asse_depl_c),),
        MATR_MASS       = SIMP(statut='o', typ=matr_asse_depl_r ),
        AMOR_REDUIT     = SIMP(statut='o', typ='R', max='**'),
        GROUP_MA_INTERF = SIMP(statut='o', typ=grma, max='**',
                               fr="Groupe de mailles de l'interface"),

        UNITE_IMPR_ASTER = SIMP(statut='f', typ='I',
                                fr="Unité des résultats transmis par Code_Aster à Miss"),
        UNITE_RESU_IMPE  = SIMP(statut='f', typ='I',
                                fr="Unité logique des impédances à relire."),
        UNITE_RESU_FORC  = SIMP(statut='f', typ='I',
                                fr="Unité logique des forces sismiques à relire"),
    ),
    # Paramètres du calcul Miss
    PARAMETRE   = FACT(statut='o',
                       regles=(PRESENT_PRESENT('OFFSET_MAX', 'OFFSET_NB'),
                               PRESENT_PRESENT('FREQ_MIN', 'FREQ_MAX','FREQ_PAS'),
                               UN_PARMI('FREQ_MIN', 'LIST_FREQ'),
                               PRESENT_PRESENT('SPEC_MAX', 'SPEC_NB'),),
        FREQ_MIN       = SIMP(statut='f', typ='R'),
        FREQ_MAX       = SIMP(statut='f', typ='R'),
        FREQ_PAS       = SIMP(statut='f', typ='R'),
        LIST_FREQ      = SIMP(statut='f', typ='R', max='**'),
        Z0             = SIMP(statut='f', typ='R', defaut=0.),
        SURF           = SIMP(statut='f', typ='TXM', into=("OUI","NON",), defaut="NON"),
        RFIC           = SIMP(statut='f', typ='R', defaut=0.),

        ALGO           = SIMP(statut='f', typ='TXM', into=("DEPL","REGU")),
        DREF           = SIMP(statut='f', typ='R'),
        SPEC_MAX       = SIMP(statut='f', typ='R'),
        SPEC_NB        = SIMP(statut='f', typ='I'),
        OFFSET_MAX     = SIMP(statut='f', typ='R'),
        OFFSET_NB      = SIMP(statut='f', typ='I'),
        TYPE           = SIMP(statut='f', typ='TXM', into=("BINAIRE","ASCII",), defaut="ASCII"),
    ),
    # Post-traitement type 1 - tran_gene
    b_post_tran_gene = BLOC(condition="TYPE_RESU == 'TRAN_GENE'",
                       regles=(AU_MOINS_UN('ACCE_X', 'ACCE_Y', 'ACCE_Z'),),
        MODELE         = SIMP(statut='o', typ=(modele_sdaster),),
        ACCE_X         = SIMP(statut='f', typ=fonction_sdaster,),
        ACCE_Y         = SIMP(statut='f', typ=fonction_sdaster,),
        ACCE_Z         = SIMP(statut='f', typ=fonction_sdaster,),
        INST_FIN       = SIMP(statut='o', typ='R', fr="Instant final du calcul"),
        PAS_INST       = SIMP(statut='o', typ='R', fr="Pas de temps du calcul"),
    ),
    # Post-traitement type 1 - harm_gene
    b_post_harm_gene  = BLOC(condition="TYPE_RESU == 'HARM_GENE'",
                       regles=(AU_MOINS_UN('EXCIT_HARMO', 'ACCE_X', 'ACCE_Y', 'ACCE_Z'),
                               PRESENT_ABSENT('EXCIT_HARMO', 'ACCE_X', 'ACCE_Y', 'ACCE_Z', 'INST_FIN'),
                               ENSEMBLE('INST_FIN', 'PAS_INST'),),
        MODELE         = SIMP(statut='o', typ=(modele_sdaster),),
        ACCE_X         = SIMP(statut='f', typ=fonction_sdaster,),
        ACCE_Y         = SIMP(statut='f', typ=fonction_sdaster,),
        ACCE_Z         = SIMP(statut='f', typ=fonction_sdaster,),
        INST_FIN       = SIMP(statut='f', typ='R', fr="Instant final du calcul"),
        PAS_INST       = SIMP(statut='f', typ='R', fr="Pas de temps du calcul"),
        # identique à EXCIT de DYNA_LINE_HARM au type attendu pour VECT_ASSE près
        EXCIT_HARMO    = FACT(statut='f', max='**',
                              regles=(UN_PARMI('VECT_ASSE', 'CHARGE'),
                                      UN_PARMI('FONC_MULT', 'FONC_MULT_C', 'COEF_MULT', 'COEF_MULT_C'),),
            VECT_ASSE     = SIMP(statut='f', typ=cham_no_sdaster,),
            CHARGE        = SIMP(statut='f', typ=char_meca),
            TYPE_CHARGE   = SIMP(statut='f', typ='TXM', defaut="FIXE", into=("FIXE",),),
            FONC_MULT_C   = SIMP(statut='f', typ=(fonction_c, formule_c),),
            COEF_MULT_C   = SIMP(statut='f', typ='C'),
            FONC_MULT     = SIMP(statut='f', typ=(fonction_sdaster, nappe_sdaster, formule) ),
            COEF_MULT     = SIMP(statut='f', typ='R'),
            PHAS_DEG      = SIMP(statut='f', typ='R', defaut=0.),
            PUIS_PULS     = SIMP(statut='f', typ='I', defaut=0),
        ),
    ),
    # Post-traitement type 2
    b_post_table = BLOC(condition="TYPE_RESU == 'TABLE'",
                        regles=(AU_MOINS_UN('ACCE_X', 'ACCE_Y', 'ACCE_Z'),),
        MODELE         = SIMP(statut='o', typ=(modele_sdaster),),
        GROUP_NO       = SIMP(statut='o', typ=grno, max='**',
                              fr="Liste des groupes de noeud de post-traitement"),
        ACCE_X         = SIMP(statut='f', typ=fonction_sdaster,),
        ACCE_Y         = SIMP(statut='f', typ=fonction_sdaster,),
        ACCE_Z         = SIMP(statut='f', typ=fonction_sdaster,),
        INST_FIN       = SIMP(statut='o', typ='R', fr="Instant final du calcul"),
        PAS_INST       = SIMP(statut='o', typ='R', fr="Pas de temps du calcul"),
        NORME          = SIMP(statut='o', typ='R',
                              fr="Valeur de la norme du spectre d'oscillateur" ),
        AMOR_SPEC_OSCI      = SIMP(statut='o', typ='R', max='**',
                                   fr="Amortissement du spectre d'oscillateur"),
        LIST_FREQ_SPEC_OSCI = SIMP(statut='f', typ=listr8_sdaster,
                                   fr="Fréquences utilisées pour le calcul du spectre d'oscillateur"),
    ),

    INFO        = SIMP(statut='f', typ='I', defaut=1, into=(1,2)),
)

